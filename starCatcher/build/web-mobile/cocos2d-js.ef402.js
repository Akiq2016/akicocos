(function outer(modules, cache, entry) {
  var previousRequire = "function" == typeof require && require;
  function newRequire(name, jumped) {
    var module = cache[name];
    if (!module) {
      var moduleData = modules[name];
      if (!moduleData) {
        var currentRequire = "function" == typeof require && require;
        if (!jumped && currentRequire) return currentRequire(name, true);
        if (previousRequire) return previousRequire(name, true);
        var err = new Error("Cannot find module '" + name + "'");
        err.code = "MODULE_NOT_FOUND";
        throw err;
      }
      var exports = {};
      module = cache[name] = {
        exports: exports
      };
      moduleData[0]((function(x) {
        return newRequire(moduleData[1][x] || x);
      }), module, exports);
    }
    return module.exports;
  }
  for (var i = 0; i < entry.length; i++) newRequire(entry[i]);
  return newRequire;
})({
  1: [ (function(require, module, exports) {
    var engineVersion;
    engineVersion = "2.0.0 preview3";
    window["CocosEngine"] = cc.ENGINE_VERSION = engineVersion;
    require("./cocos2d/core/utils");
    require("./cocos2d/core/platform/CCSys");
    var _engineInitCalled = false, _engineLoadedCallback = null;
    cc._engineLoaded = false;
    function _determineRenderType(config) {
      var CONFIG_KEY = cc.game.CONFIG_KEY, userRenderMode = parseInt(config[CONFIG_KEY.renderMode]) || 0;
      (isNaN(userRenderMode) || userRenderMode > 2 || userRenderMode < 0) && (config[CONFIG_KEY.renderMode] = 0);
      cc.game.renderType = cc.game.RENDER_TYPE_CANVAS;
      var supportRender = false;
      if (0 === userRenderMode) {
        if (cc.sys.capabilities["opengl"]) {
          cc.game.renderType = cc.game.RENDER_TYPE_WEBGL;
          supportRender = true;
        } else if (cc.sys.capabilities["canvas"]) {
          cc.game.renderType = cc.game.RENDER_TYPE_CANVAS;
          supportRender = true;
        }
      } else if (1 === userRenderMode && cc.sys.capabilities["canvas"]) {
        cc.game.renderType = cc.game.RENDER_TYPE_CANVAS;
        supportRender = true;
      } else if (2 === userRenderMode && cc.sys.capabilities["opengl"]) {
        cc.game.renderType = cc.game.RENDER_TYPE_WEBGL;
        supportRender = true;
      }
      if (!supportRender) throw new Error(cc._getError(3820, userRenderMode));
    }
    function _afterEngineLoaded() {
      cc._engineLoaded = true;
      console.log("Cocos Creator v" + cc.ENGINE_VERSION);
      _engineLoadedCallback && _engineLoadedCallback();
    }
    function _windowLoaded() {
      window.removeEventListener("load", _windowLoaded, false);
      _afterEngineLoaded();
    }
    cc.initEngine = function(config, cb) {
      if (_engineInitCalled) {
        var previousCallback = _engineLoadedCallback;
        _engineLoadedCallback = function() {
          previousCallback && previousCallback();
          cb && cb();
        };
        return;
      }
      _engineLoadedCallback = cb;
      !cc.game.config && config ? cc.game.config = config : cc.game.config || cc.game._loadConfig();
      config = cc.game.config;
      _determineRenderType(config);
      document.body ? _afterEngineLoaded() : window.addEventListener("load", _windowLoaded, false);
      _engineInitCalled = true;
    };
  }), {
    "./cocos2d/core/platform/CCSys": 164,
    "./cocos2d/core/utils": 231
  } ],
  2: [ (function(require, module, exports) {
    var Enum = require("./cocos2d/core/platform/CCEnum");
    var logList;
    cc.DebugMode = Enum({
      NONE: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      INFO_FOR_WEB_PAGE: 4,
      WARN_FOR_WEB_PAGE: 5,
      ERROR_FOR_WEB_PAGE: 6
    });
    cc._initDebugSetting = function(mode) {
      cc.log = cc.warn = cc.error = cc.assert = function() {};
      if (mode === cc.DebugMode.NONE) return;
      if (mode > cc.DebugMode.ERROR) (function() {
        function logToWebPage(msg) {
          if (!cc.game.canvas) return;
          if (!logList) {
            var logDiv = document.createElement("Div");
            logDiv.setAttribute("id", "logInfoDiv");
            logDiv.setAttribute("width", "200");
            logDiv.setAttribute("height", cc.game.canvas.height);
            var logDivStyle = logDiv.style;
            logDivStyle.zIndex = "99999";
            logDivStyle.position = "absolute";
            logDivStyle.top = logDivStyle.left = "0";
            logList = document.createElement("textarea");
            logList.setAttribute("rows", "20");
            logList.setAttribute("cols", "30");
            logList.setAttribute("disabled", "true");
            var logListStyle = logList.style;
            logListStyle.backgroundColor = "transparent";
            logListStyle.borderBottom = "1px solid #cccccc";
            logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px";
            logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none";
            logListStyle.padding = "0px";
            logListStyle.margin = 0;
            logDiv.appendChild(logList);
            cc.game.canvas.parentNode.appendChild(logDiv);
          }
          logList.value = logList.value + msg + "\r\n";
          logList.scrollTop = logList.scrollHeight;
        }
        cc.error = function() {
          logToWebPage("ERROR :  " + cc.js.formatStr.apply(null, arguments));
        };
        cc.assert = function(cond, msg) {
          "use strict";
          if (!cond && msg) {
            msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments));
            logToWebPage("ASSERT: " + msg);
          }
        };
        mode !== cc.DebugMode.ERROR_FOR_WEB_PAGE && (cc.warn = function() {
          logToWebPage("WARN :  " + cc.js.formatStr.apply(null, arguments));
        });
        mode === cc.DebugMode.INFO_FOR_WEB_PAGE && (cc.log = cc.info = function() {
          logToWebPage(cc.js.formatStr.apply(null, arguments));
        });
      })(); else if (console && console.log.apply) {
        console.error || (console.error = console.log);
        console.warn || (console.warn = console.log);
        false;
        console.error.bind ? cc.error = console.error.bind(console) : cc.error = function() {
          return console.error.apply(console, arguments);
        };
        cc.assert = function(cond, msg) {
          if (!cond) {
            msg && (msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments)));
            false;
            false;
            throw new Error(msg);
          }
        };
      }
      if (mode !== cc.DebugMode.ERROR) {
        false;
        console.warn.bind ? cc.warn = console.warn.bind(console) : cc.warn = function() {
          return console.warn.apply(console, arguments);
        };
      }
      false;
      if (mode === cc.DebugMode.INFO) {
        false;
        console.log.bind ? cc.log = console.log.bind(console) : cc.log = function() {
          return console.log.apply(console, arguments);
        };
        false;
        cc.info = function() {
          (console.info || console.log).apply(console, arguments);
        };
      }
    };
    cc._throw = function(error) {
      var stack = error.stack;
      stack ? cc.error(stack) : cc.error(error);
    };
    var debugInfos = require("./DebugInfos") || {};
    var ERROR_MAP_URL = "https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md";
    function getTypedFormatter(type) {
      return function() {
        var id = arguments[0];
        var msg = debugInfos[id] || "unknown id";
        if (1 === arguments.length) return msg;
        if (2 === arguments.length) return cc.js.formatStr(msg, arguments[1]);
        var argsArray = cc.js.shiftArguments.apply(null, arguments);
        return cc.js.formatStr.apply(null, [ msg ].concat(argsArray));
      };
    }
    var logFormatter = getTypedFormatter("Log");
    cc.logID = function() {
      cc.log(logFormatter.apply(null, arguments));
    };
    var warnFormatter = getTypedFormatter("Warning");
    cc.warnID = function() {
      cc.warn(warnFormatter.apply(null, arguments));
    };
    var errorFormatter = getTypedFormatter("Error");
    cc.errorID = function() {
      cc.error(errorFormatter.apply(null, arguments));
    };
    var assertFormatter = getTypedFormatter("Assert");
    cc.assertID = function(cond) {
      "use strict";
      if (cond) return;
      cc.assert(false, assertFormatter.apply(null, cc.js.shiftArguments.apply(null, arguments)));
    };
    cc._getError = getTypedFormatter("ERROR");
    cc._initDebugSetting(cc.DebugMode.INFO);
  }), {
    "./DebugInfos": 3,
    "./cocos2d/core/platform/CCEnum": 157
  } ],
  3: [ (function(require, module, exports) {
    module.exports = {
      1001: "cocos2d: removeAction: Target not found",
      1002: "cc.ActionManager.removeActionByTag(): an invalid tag",
      1003: "cc.ActionManager.removeActionByTag(): target must be non-null",
      1004: "cc.ActionManager.getActionByTag(): an invalid tag",
      1005: "cocos2d : getActionByTag(tag = %s): Action not found",
      1006: "[Action step]. override me",
      1007: "[Action update]. override me",
      1008: "cocos2d: FiniteTimeAction#reverse: Implement me",
      1009: "cc.EaseElastic.reverse(): it should be overridden in subclass.",
      1010: "cc.IntervalAction: reverse not implemented.",
      1011: "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.",
      1012: "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.",
      1013: "The speed parameter error",
      1014: "The repeat parameter error",
      1015: "parameters should not be ending with null in Javascript",
      1016: "cc.RotateTo.reverse(): it should be overridden in subclass.",
      1019: "Failed to construct, Sequence construction needs two or more actions.",
      1020: "Failed to construct, Spawn construction needs two or more actions.",
      1021: "cc.Speed.initWithAction(): action must be non nil",
      1022: "cc.Follow.initWithAction(): followedNode must be non nil",
      1023: "cc.ActionEase.initWithAction(): action must be non nil",
      1024: "Invalid configuration. It must at least have one control point",
      1025: "cc.Sequence.initWithTwoActions(): arguments must all be non nil",
      1026: "cc.RepeatForever.initWithAction(): action must be non null",
      1027: "cc.Spawn.initWithTwoActions(): arguments must all be non null",
      1028: "cc.ReverseTime.initWithAction(): action must be non null",
      1029: "cc.ReverseTime.initWithAction(): the action was already passed in.",
      1030: "cc.Animate.initWithAnimation(): animation must be non-NULL",
      1100: "Expected 'data' dict, but not found. Config file: %s",
      1101: "Please load the resource first : %s",
      1200: "cocos2d: Director: Error in gettimeofday",
      1201: "cocos2d: Director: unrecognized projection",
      1203: "cocos2d: Director: Error in gettimeofday",
      1204: "running scene should not null",
      1205: "the scene should not null",
      1206: "loadScene: The scene index to load (%s) is out of range.",
      1207: "loadScene: Unknown name type to load: '%s'",
      1208: "loadScene: Failed to load scene '%s' because '%s' is already loading",
      1209: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      1210: "Failed to preload '%s', %s",
      1211: "loadScene: The scene index to load (%s) is out of range.",
      1212: "loadScene: Unknown name type to load: '%s'",
      1213: "loadScene: Failed to load scene '%s' because '%s' is already loading",
      1214: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      1215: "Failed to preload '%s', %s",
      1216: "Director.runSceneImmediate: scene is not valid",
      1300: "element type is wrong!",
      1400: "'%s' is deprecated, please use '%s' instead.",
      1401: "The first argument should be the destination object",
      1402: "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
      1403: "Sorry, cc.audioEngine.willPlayMusic is removed.",
      1404: "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      1405: "The '%s' will be removed in v2.0, please use '%s' instead. \ud83d\ude25",
      1406: "'%s.%s' is removed",
      1407: "cc.pool is being removed from v2.0, you are getting cc.js.Pool instead",
      1502: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
      1503: "cc.Scheduler.pauseTarget():target should be non-null",
      1504: "cc.Scheduler.resumeTarget():target should be non-null",
      1505: "cc.Scheduler.isTargetPaused():target should be non-null",
      1506: "warning: you CANNOT change update priority in scheduled function",
      1507: "CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %.4f to %.4f",
      1508: "Argument callback must not be empty",
      1509: "Argument target must be non-nullptr",
      1510: "cc.Scheduler: Illegal target which doesn't have uuid or instanceId.",
      1511: "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
      1512: "cc.Scheduler: updateFunc parameter is deprecated in scheduleUpdate function, and will be removed in v2.0",
      1513: "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do scheduler.enableForTarget(target) before all scheduler API usage on target",
      1600: "getZOrder is deprecated. Please use getLocalZOrder instead.",
      1601: "setZOrder is deprecated. Please use setLocalZOrder instead.",
      1602: "RotationX != RotationY. Don't know which one to return",
      1603: "ScaleX != ScaleY. Don't know which one to return",
      1605: "child already added. It can't be added again",
      1606: "child must be non-null",
      1607: "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
      1608: "boundingBox is deprecated. Use getBoundingBox instead",
      1609: "argument tag is an invalid tag",
      1610: "cocos2d: removeChildByTag(tag = %s): child not found!",
      1612: "cc.Node.stopActionBy(): argument tag an invalid tag",
      1613: "cc.Node.getActionByTag(): argument tag is an invalid tag",
      1614: "resumeSchedulerAndActions is deprecated, please use resume instead.",
      1615: "pauseSchedulerAndActions is deprecated, please use pause instead.",
      1617: "child must be non-null",
      1618: "cc.Node.runAction(): action must be non-null",
      1619: "callback function must be non-null",
      1620: "interval must be positive",
      1622: "_ccsg.Node._requestDirtyFlag: failed to satisfy the request, key (%s) for flag have already been taken",
      1623: "Set '%s' to normal node (not persist root node).",
      1624: "Replacing with the same sgNode",
      1625: "The replacement sgNode should not contain any child.",
      1626: "Should not set alpha via 'color', set 'opacity' please.",
      1627: "Not support for asynchronous creating node in SG",
      1628: "Renderer error: Size of the cc._RendererInSG._sgNode must be zero",
      1629: "The node '%s' has a component inherited from 'cc._RendererInSG'",
      1630: "JSB environment is not support invoke node.runAction before the 'cc._RendererInSG' component enabled.",
      1631: "Please use runAction in the method 'start' instead.",
      1632: "Node name can not include '/'.",
      1633: "Internal error, should not remove unknown node from parent.",
      1634: "addChild: The child to add must be instance of cc.Node, not %s.",
      1635: "reorderChild: this child is not in children list.",
      1636: "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
      1637: "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
      1638: "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
      1800: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      1801: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      1802: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      1803: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
      1900: "Invalid parameter.",
      2000: "Don't call this method if the event is for touch.",
      2200: "Resolution not valid",
      2201: "should set resolutionPolicy",
      2300: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      2400: "WebGL error %s",
      2602: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
      2603: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
      2604: "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
      2606: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
      2607: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
      2608: "%s is null, please check.",
      2609: "cc.Sprite.initWithFile(): filename should be non-null",
      2610: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
      2614: "cc.Sprite.addChild(): child should be non-null",
      2616: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2617: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2618: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2619: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
      2623: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
      2625: "too many tiles, only 16384 tiles will be show",
      2626: "Unrecognized fill type in bar fill",
      2627: "Can not generate quad",
      2628: "%s does not exist",
      2710: "Sprite.initWithTexture(): Argument must be non-nil",
      2712: "Invalid spriteFrameName",
      3002: "textureForKey is deprecated. Please use getTextureForKey instead.",
      3005: "cocos2d: '%s' id=%s %s x %s",
      3006: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
      3007: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
      3103: "cc.Texture.addImage(): path should be non-null",
      3112: "cc.Texture.addImage(): path should be non-null",
      3113: "NSInternalInconsistencyException",
      3116: "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures",
      3117: "Mimpap texture only works in POT textures",
      3118: "contentSize parameter is deprecated and ignored for cc.Texture2D initWithData function.",
      3119: "Lazy init texture with image element failed due to image loading failure: %s",
      3300: "Rect width exceeds maximum margin: %s",
      3400: "Rect height exceeds maximum margin: %s",
      3500: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      3501: "Invalid listener type!",
      3502: "Can't set fixed priority with scene graph based listener.",
      3503: "Invalid parameters.",
      3504: "listener must be a cc.EventListener object when adding a fixed priority listener",
      3505: "The listener has been registered, please don't register it again.",
      3506: "Unsupported listener target.",
      3507: "Invalid scene graph priority!",
      3508: "If program goes here, there should be event in dispatch.",
      3509: "_inDispatch should be 1 here.",
      3510: "%s's scene graph node not contains in the parent's children",
      3511: "event is undefined",
      3600: "cc.Class will automatically call super constructor of %s, you should not call it manually.",
      3601: "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      3602: "Unknown editor property '%s' in class '%s'.",
      3603: "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please. \ud83d\ude02",
      3604: "Can only indicate one type attribute for %s.",
      3605: "The default value of %s is not instance of %s.",
      3606: "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      3607: "The default value of %s must be an empty string.",
      3608: "The type of %s must be cc.String, not String.",
      3609: "The type of %s must be cc.Boolean, not Boolean.",
      3610: "The type of %s must be cc.Float or cc.Integer, not Number.",
      3611: "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      3612: "%s Just set the default value to 'new %s()' and it will be handled properly.",
      3613: "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
      3614: "Should not define constructor for cc.Component %s.",
      3615: "Each script can have at most one Component.",
      3616: "Should not specify class name %s for Component which defines in project.",
      3617: "Can not instantiate CCClass '%s' with arguments.",
      3618: "ctor of '%s' can not be another CCClass",
      3619: "ctor of '%s' must be function type",
      3620: "this._super declared in '%s.%s' but no super method defined",
      3621: "Unknown type of %s.%s, maybe you want is '%s'.",
      3622: "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
      3623: "Can not use 'editor' attribute, '%s' not inherits from Components.",
      3624: "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
      3625: "[isChildClassOf] superclass should be function type, not",
      3626: "Can't remove '%s' because '%s' depends on it.",
      3627: "Should not add renderer component (%s) to a Canvas node.",
      3628: "Should not add %s to a node which size is already used by its other component.",
      3629: "attribute must be type object",
      3633: "Properties function of '%s' should return an object!",
      3634: "Disallow to use '.' in property name",
      3635: "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
      3636: "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
      3637: "Can not declare %s.%s, it is already defined in the prototype of %s",
      3638: "'%s': the getter of '%s' is already defined!",
      3639: "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
      3640: "'%s': the setter of '%s' is already defined!",
      3641: "Can not construct %s because it contains object property.",
      3642: "Cannot define %s.%s because static member name can not be '%s'.",
      3643: "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
      3644: "Please define 'type' parameter of %s.%s as the actual constructor.",
      3645: "Please define 'type' parameter of %s.%s as the constructor of %s.",
      3646: "Unknown 'type' parameter of %s.%s\uff1a%s",
      3647: "The length of range array must be equal or greater than 2",
      3648: "Can not declare %s.%s method, it is already defined in the properties of %s.",
      3649: "CCClass %s have conflict between its ctor and __ctor__.",
      3651: 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
      3652: 'Failed to construct a dummy instance of the "%s" class using `new` behind the scenes. This is for getting default values declared in TypeScript. Please ensure the class will be able to construct during script\'s initialization. %s.',
      3653: 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.  \r\nDefault value must be initialized at their declaration: \ud83d\ude30\r\n \r\n// Before:\r\n@property({\r\n  type: cc.Integer\r\n  default: 0  // <--\r\n})\r\nvalue;\r\n// After:\r\n@property({\r\n  type: cc.Integer\r\n})\r\nvalue = 0;    // <--',
      3654: 'Please specifiy a default value for "%s" property at its declaration: \ud83d\ude30\r\n \r\n// Before:\r\n@property(...)\r\nvalue; \r\n// After:\r\n@property(...)\r\nvalue = 0',
      3655: 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.  \r\nPlease use:\r\n \r\n@property(...)\r\nget %s () {\r\n    ...\r\n}\r\n@property\r\nset %s (value) {\r\n    ...\r\n}',
      3656: "The default value of %s.%s must be an empty string. (changed since 1.8)",
      3657: "The value assigned to %s should be Texture2D object, not url string. Since 1.8,  \r\nyou can declare a texture object directly in properties by using:  \r\n \r\n{\r\n    default: null,\r\n    type: cc.Texture2D  // use 'type:' instead of 'url:'\r\n}",
      3658: "browser does not support getters",
      3700: "internal error: _prefab is undefined",
      3701: "Failed to load prefab asset for node '%s'",
      3800: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      3801: "The node can not be made persist because it's not under root node.",
      3802: "The node can not be made persist because it's not in current scene.",
      3803: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      3804: "getComponent: Type must be non-nil",
      3805: "Can't add component '%s' because %s already contains the same component.",
      3806: "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      3807: "addComponent: Failed to get class '%s'",
      3808: "addComponent: Should not add component ('%s') when the scripts are still loading.",
      3809: "addComponent: The component to add must be a constructor",
      3810: "addComponent: The component to add must be child class of cc.Component",
      3811: "_addComponentAt: The component to add must be a constructor",
      3812: "_addComponentAt: Index out of range",
      3813: "removeComponent: Component must be non-nil",
      3814: "Argument must be non-nil",
      3815: "Component not owned by this entity",
      3816: "Node '%s' is already activating",
      3817: "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      3818: "Failed to read or parse project.json",
      3819: "Warning: target element is not a DIV or CANVAS",
      3820: "The renderer doesn't support the renderMode %s",
      3821: "Cannot change hierarchy while activating or deactivating the parent.",
      3900: "Invalid clip to add",
      3901: "Invalid clip to remove",
      3902: "clip is defaultClip, set force to true to force remove clip and animation state",
      3903: "animation state is playing, set force to true to force stop and remove clip and animation state",
      3904: "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      3905: "sprite frames must be an Array.",
      3906: "Can't find easing type [%s]",
      3907: "animator not added or already removed",
      3908: "animation not added or already removed",
      3912: "already-playing",
      4000: "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
      4002: "_ccsg.Label._initBMFontWithString(): re-init is no longer supported",
      4003: "Label font size can't be shirnked less than 0!",
      4004: "force notify all fonts loaded!",
      4011: "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      4012: "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      4013: "Sorry, lineHeight of system font not supported on JSB.",
      4100: "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
      4200: "MaskType: IMAGE_STENCIL only support WebGL mode.",
      4201: "The alphaThreshold invalid in Canvas Mode.",
      4202: "The inverted invalid in Canvas Mode.",
      4300: "can not found the %s page.",
      4400: "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      4600: "Script attached to '%s' is missing or invalid.",
      4700: "The dom control is not created!",
      4800: "unknown asset type",
      4901: "loadRes: should not specify the extname in %s %s",
      4902: "No need to release non-cached asset.",
      4903: "Can not get class '%s'",
      4914: "Resources url '%s' does not exist.",
      4915: "Pack indices and data do not match in size",
      4916: "Failed to download package for %s",
      4920: "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
      4921: "Invalid pipe or invalid index provided!",
      4922: "The pipe to be inserted is already in the pipeline!",
      4923: "Uuid Loader: Parse asset [ %s ] failed : %s",
      4924: "JSON Loader: Input item doesn't contain string content",
      4925: "Uuid Loader: Deserialize asset [ %s ] failed : %s",
      4926: "Audio Downloader: no web audio context.",
      4927: "Audio Downloader: audio not supported on this browser!",
      4928: "Load %s failed!",
      4929: "Load Webp ( %s ) failed",
      4930: "Load image ( %s ) failed",
      4931: "Download Uuid: can not find type of raw asset[ %s ]: %s",
      4932: 'Since v1.10, for any atlas ("%s") in the "resources" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.',
      5000: "object already destroyed",
      5001: "object not yet destroyed",
      5100: "Not a plist file!",
      5200: "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      5201: "browser don't support web audio",
      5202: "This feature supports WebGL render mode only.",
      5300: "Type of target to deserialize not matched with data: target is %s, data is %s",
      5301: "Can not find script '%s'",
      5302: "Can not find class '%s'",
      5400: "'%s' is deprecated, use '%s' instead please.",
      5401: "'%s' is deprecated, use '%s' instead please.",
      5402: "cc.js.addon called on non-object:",
      5403: "cc.js.mixin: arguments must be type object:",
      5404: "The base class to extend from must be non-nil",
      5405: "The class to extend must be non-nil",
      5406: "Class should be extended before assigning any prototype members.",
      5500: "'notify' can't work with 'get/set' !",
      5501: "'notify' must work with 'default' !",
      5502: "Invalid url of %s.%s",
      5503: "The 'url' attribute of '%s.%s' is undefined when loading script.",
      5504: "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
      5505: "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
      5506: "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
      5507: "The 'default' attribute of '%s.%s' must be an array",
      5508: "Invalid type of %s.%s",
      5510: "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
      5511: "The 'type' attribute of '%s.%s' is undefined when loading script",
      5512: "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      5513: "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      5514: "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      5515: "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      5516: "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
      5517: "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
      5600: "Argument must be non-nil",
      5601: "Can not get current scene.",
      5602: "Scene is destroyed",
      5603: "reference node is destroyed",
      5700: "no %s or %s on %s",
      5800: "%s.lerp not yet implemented.",
      5801: "%s.clone not yet implemented.",
      5802: "%s.equals not yet implemented.",
      5900: "MotionStreak only support WebGL mode.",
      5901: "cc.MotionStreak.getOpacity has not been supported.",
      5902: "cc.MotionStreak.setOpacity has not been supported.",
      6000: "Custom should not be false if file is not specified.",
      6001: "The new %s must not be NaN",
      6008: "_ccsg.ParticleSystem.initWithFile(): Particles: file not found",
      6009: "_ccsg.ParticleSystem.initWithDictionary(): Invalid emitterType in config file",
      6010: "_ccsg.ParticleSystem: error decoding or ungzipping textureImageData",
      6011: "_ccsg.ParticleSystem: unknown image format with Data",
      6012: "_ccsg.ParticleSystem.initWithDictionary() : error loading the texture",
      6013: "Particle system: not enough memory",
      6015: "_ccsg.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets",
      6017: "Incomplete or corrupt PNG file",
      6018: "Invalid filter algorithm: %s",
      6019: "Invalid byte order value.",
      6020: "You forgot your towel!",
      6021: "Unknown Field Tag: %s",
      6022: "Too many bits requested",
      6023: "No bits requested",
      6024: "Cannot recover from missing StripByteCounts",
      6025: "Cannot handle sub-byte bits per sample",
      6026: "Cannot handle sub-byte bits per pixel",
      6027: "Palette image missing color map",
      6028: "Unknown Photometric Interpretation: %s",
      6029: "Unkown error",
      6200: "Canvas doesn't support mesh slot!",
      6300: "only cc.DrawNode is accepted as stencil",
      6301: "Stencil buffer is not enabled.",
      6302: "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
      6400: "asset.url is not usable in core process",
      6401: "asset.urls is not usable in core process",
      6402: "AssetLibrary has already been initialized!",
      6500: "Widget target must be one of the parent nodes of it",
      6600: "collider not added or already removed",
      6601: "Can't find testFunc for (%s, $s).",
      6700: "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
      6701: "Should not add Canvas to a node which already contains a renderer component (%s).",
      6702: "Should not add Canvas to a node which size is already used by its other component.",
      6703: "Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext",
      6704: "Polygon's point must greater than 2",
      6705: "Argument must be non-nil",
      6800: "Callback of event must be non-nil",
      6801: "The message must be provided",
      6900: "The thing you want to instantiate must be an object",
      6901: "The thing you want to instantiate is nil",
      6902: "The thing you want to instantiate is destroyed",
      6903: "The instantiate method for given asset do not implemented",
      6904: "Can not instantiate array",
      6905: "Can not instantiate DOM element",
      7000: "Failed to init asset's raw path.",
      7001: "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
      7002: "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
      7003: "Failed to init builtin asset's raw path.",
      7100: "%s already defined in Enum.",
      7101: "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
      7200: "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      7201: "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      7202: "Add component TiledLayer into node failed.",
      7203: "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      7204: "_ccsg.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      7205: "_ccsg.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      7206: "_ccsg.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      7207: "_ccsg.TMXLayer.setTileGID(): invalid gid: %s",
      7208: "_ccsg.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      7209: "_ccsg.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released",
      7210: "TMX Hexa zOrder not supported",
      7211: "TMX invalid value",
      7212: "_ccsg.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.",
      7213: "_ccsg.TMXTiledMap.initWithXML(): Map not found. Please check the filename.",
      7214: "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
      7215: "cocos2d: Warning: TMX Layer %s has no tiles",
      7216: "cocos2d: TMXFormat: Unsupported TMX version: %s",
      7217: "cocos2d: TMXFomat: Unsupported orientation: %s",
      7218: "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      7219: "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      7221: "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
      7222: "Parse %s failed.",
      7223: "_ccsg.TMXLayer.setTileGID(): pos should be non-null",
      7224: "_ccsg.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.",
      7225: "_ccsg.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.",
      7226: "_ccsg.TMXLayer.getTileAt(): pos should be non-null",
      7227: "_ccsg.TMXLayer.getTileAt(): invalid position",
      7228: "_ccsg.TMXLayer.getTileGIDAt(): pos should be non-null",
      7229: "_ccsg.TMXLayer.getTileGIDAt(): invalid position",
      7230: "_ccsg.TMXLayer.setTileGID(): pos should be non-null",
      7231: "_ccsg.TMXLayer.setTileGID(): invalid position",
      7232: "_ccsg.TMXLayer.getTileFlagsAt(): pos should be non-null",
      7233: "_ccsg.TMXLayer.getTileFlagsAt(): invalid position",
      7234: "_ccsg.TMXLayer.removeTileAt(): pos should be non-null",
      7235: "_ccsg.TMXLayer.removeTileAt(): invalid position",
      7401: "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      7402: "Failed to set _animationIndex for '%s' because the index is out of range.",
      7501: "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      7502: "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      7503: "Failed to set _animationIndex for '%s' because the index is out of range.",
      7504: "Can not render dynamic created SkeletonData",
      7505: "Invalid type of atlasFile, atlas should be registered as raw asset.",
      7506: "Failed to load spine atlas '$s'",
      7507: "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      7508: "The atlas asset of '%s' is not exists!",
      7509: "Spine: Animation not found: %s",
      7510: "Spine: Animation not found: %s",
      7600: "The context of RenderTexture is invalid.",
      7601: "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
      7602: "Could not attach texture to the framebuffer",
      7603: "clearDepth isn't supported on Cocos2d-Html5",
      7604: "saveToFile isn't supported on Cocos2d-Html5",
      7605: "newCCImage isn't supported on Cocos2d-Html5",
      7700: "On the web is always keep the aspect ratio",
      7701: "Can't know status",
      7702: "Video player's duration is not ready to get now!",
      7800: "Web does not support loading",
      7801: "Web does not support query history",
      7802: "Web does not support query history",
      7803: "The current browser does not support the GoBack",
      7804: "The current browser does not support the GoForward",
      7805: "Web does not support zoom",
      7900: "cc.math.Matrix3.assign(): current matrix equals matIn",
      7901: "cc.math.mat4Assign(): pOut equals pIn",
      7902: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      7903: "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      7904: "cc.math.Matrix4.extractPlane: Invalid plane index",
      7905: "cc.math.mat4Assign(): pOut equals pIn",
      7906: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      7907: "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      7908: "Invalid matrix mode specified",
      7909: "current quaternion is an invalid value",
      8000: "Can't handle this field type or size",
      8001: "No bytes requested",
      8002: "Too many bytes requested",
      8003: "Missing StripByteCounts!",
      8100: "cocos2d: ERROR: Failed to compile shader:\r\n %s",
      8101: "cocos2d: ERROR: Failed to compile vertex shader",
      8102: "cocos2d: ERROR: Failed to compile fragment shader",
      8103: "cc.GLProgram.link(): Cannot link invalid program",
      8104: "cocos2d: ERROR: Failed to link program: %s",
      8105: "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      8106: "Please load the resource firset : %s",
      8107: "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
      8108: "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
      8109: "modelView matrix is undefined.",
      8200: "Please set node's active instead of rigidbody's enabled.",
      8300: "Should only one camera exists, please check your project.",
      8301: "Camera does not support Canvas Mode.",
      8400: "Wrong type arguments, 'filePath' must be a String.",
      8401: "Since 1.10, `%s` accept %s instance directly, not a URL string. Please directly reference the %s object in your script, or load %s by loader first. Don't use %s's URL anymore.",
      9000: "Stencil manager does not support level bigger than %d in this device.",
      9001: "Stencil manager is already empty, cannot pop any mask",
      "0100": "%s not yet implemented."
    };
  }), {} ],
  4: [ (function(require, module, exports) {
    require("../core/platform/CCClass");
    var misc = require("../core/utils/misc");
    cc.Action = cc.Class({
      name: "cc.Action",
      ctor: function() {
        this.originalTarget = null;
        this.target = null;
        this.tag = cc.Action.TAG_INVALID;
      },
      clone: function() {
        var action = new cc.Action();
        action.originalTarget = null;
        action.target = null;
        action.tag = this.tag;
        return action;
      },
      isDone: function() {
        return true;
      },
      startWithTarget: function(target) {
        this.originalTarget = target;
        this.target = target;
      },
      stop: function() {
        this.target = null;
      },
      step: function(dt) {
        cc.logID(1006);
      },
      update: function(dt) {
        cc.logID(1007);
      },
      getTarget: function() {
        return this.target;
      },
      setTarget: function(target) {
        this.target = target;
      },
      getOriginalTarget: function() {
        return this.originalTarget;
      },
      setOriginalTarget: function(originalTarget) {
        this.originalTarget = originalTarget;
      },
      getTag: function() {
        return this.tag;
      },
      setTag: function(tag) {
        this.tag = tag;
      },
      retain: function() {},
      release: function() {}
    });
    cc.Action.TAG_INVALID = -1;
    cc.FiniteTimeAction = cc.Class({
      name: "cc.FiniteTimeAction",
      extends: cc.Action,
      ctor: function() {
        this._duration = 0;
      },
      getDuration: function() {
        return this._duration * (this._timesForRepeat || 1);
      },
      setDuration: function(duration) {
        this._duration = duration;
      },
      reverse: function() {
        cc.logID(1008);
        return null;
      },
      clone: function() {
        return new cc.FiniteTimeAction();
      }
    });
    cc.Speed = cc.Class({
      name: "cc.Speed",
      extends: cc.Action,
      ctor: function(action, speed) {
        this._speed = 0;
        this._innerAction = null;
        action && this.initWithAction(action, speed);
      },
      getSpeed: function() {
        return this._speed;
      },
      setSpeed: function(speed) {
        this._speed = speed;
      },
      initWithAction: function(action, speed) {
        if (!action) throw new Error(cc._getError(1021));
        this._innerAction = action;
        this._speed = speed;
        return true;
      },
      clone: function() {
        var action = new cc.Speed();
        action.initWithAction(this._innerAction.clone(), this._speed);
        return action;
      },
      startWithTarget: function(target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
      },
      step: function(dt) {
        this._innerAction.step(dt * this._speed);
      },
      isDone: function() {
        return this._innerAction.isDone();
      },
      reverse: function() {
        return new cc.Speed(this._innerAction.reverse(), this._speed);
      },
      setInnerAction: function(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function() {
        return this._innerAction;
      }
    });
    cc.speed = function(action, speed) {
      return new cc.Speed(action, speed);
    };
    cc.Follow = cc.Class({
      name: "cc.Follow",
      extends: cc.Action,
      ctor: function(followedNode, rect) {
        this._followedNode = null;
        this._boundarySet = false;
        this._boundaryFullyCovered = false;
        this._halfScreenSize = null;
        this._fullScreenSize = null;
        this.leftBoundary = 0;
        this.rightBoundary = 0;
        this.topBoundary = 0;
        this.bottomBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        followedNode && (rect ? this.initWithTarget(followedNode, rect) : this.initWithTarget(followedNode));
      },
      clone: function() {
        var action = new cc.Follow();
        var locRect = this._worldRect;
        var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
        action.initWithTarget(this._followedNode, rect);
        return action;
      },
      isBoundarySet: function() {
        return this._boundarySet;
      },
      setBoudarySet: function(value) {
        this._boundarySet = value;
      },
      initWithTarget: function(followedNode, rect) {
        if (!followedNode) throw new Error(cc._getError(1022));
        var _this = this;
        rect = rect || cc.rect(0, 0, 0, 0);
        _this._followedNode = followedNode;
        _this._worldRect = rect;
        _this._boundarySet = !(0 === rect.width && 0 === rect.height);
        _this._boundaryFullyCovered = false;
        var winSize = cc.director.getWinSize();
        _this._fullScreenSize = cc.v2(winSize.width, winSize.height);
        _this._halfScreenSize = _this._fullScreenSize.mul(.5);
        if (_this._boundarySet) {
          _this.leftBoundary = -(rect.x + rect.width - _this._fullScreenSize.x);
          _this.rightBoundary = -rect.x;
          _this.topBoundary = -rect.y;
          _this.bottomBoundary = -(rect.y + rect.height - _this._fullScreenSize.y);
          _this.rightBoundary < _this.leftBoundary && (_this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2);
          _this.topBoundary < _this.bottomBoundary && (_this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2);
          _this.topBoundary === _this.bottomBoundary && _this.leftBoundary === _this.rightBoundary && (_this._boundaryFullyCovered = true);
        }
        return true;
      },
      step: function(dt) {
        var targetWorldPos = this.target.convertToWorldSpaceAR(cc.Vec2.ZERO);
        var followedWorldPos = this._followedNode.convertToWorldSpaceAR(cc.Vec2.ZERO);
        var delta = targetWorldPos.sub(followedWorldPos);
        var tempPos = this.target.parent.convertToNodeSpaceAR(delta.add(this._halfScreenSize));
        if (this._boundarySet) {
          if (this._boundaryFullyCovered) return;
          this.target.setPosition(misc.clampf(tempPos.x, this.leftBoundary, this.rightBoundary), misc.clampf(tempPos.y, this.bottomBoundary, this.topBoundary));
        } else this.target.setPosition(tempPos.x, tempPos.y);
      },
      isDone: function() {
        return !this._followedNode.activeInHierarchy;
      },
      stop: function() {
        this.target = null;
        cc.Action.prototype.stop.call(this);
      }
    });
    cc.follow = function(followedNode, rect) {
      return new cc.Follow(followedNode, rect);
    };
  }), {
    "../core/platform/CCClass": 155,
    "../core/utils/misc": 233
  } ],
  5: [ (function(require, module, exports) {
    function cardinalSplineAt(p0, p1, p2, p3, tension, t) {
      var t2 = t * t;
      var t3 = t2 * t;
      var s = (1 - tension) / 2;
      var b1 = s * (2 * t2 - t3 - t);
      var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
      var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
      var b4 = s * (t3 - t2);
      var x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
      var y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
      return cc.v2(x, y);
    }
    function getControlPointAt(controlPoints, pos) {
      var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
      return controlPoints[p];
    }
    function reverseControlPoints(controlPoints) {
      var newArray = [];
      for (var i = controlPoints.length - 1; i >= 0; i--) newArray.push(cc.v2(controlPoints[i].x, controlPoints[i].y));
      return newArray;
    }
    function cloneControlPoints(controlPoints) {
      var newArray = [];
      for (var i = 0; i < controlPoints.length; i++) newArray.push(cc.v2(controlPoints[i].x, controlPoints[i].y));
      return newArray;
    }
    cc.CardinalSplineTo = cc.Class({
      name: "cc.CardinalSplineTo",
      extends: cc.ActionInterval,
      ctor: function(duration, points, tension) {
        this._points = [];
        this._deltaT = 0;
        this._tension = 0;
        this._previousPosition = null;
        this._accumulatedDiff = null;
        void 0 !== tension && cc.CardinalSplineTo.prototype.initWithDuration.call(this, duration, points, tension);
      },
      initWithDuration: function(duration, points, tension) {
        if (!points || 0 === points.length) throw new Error(cc._getError(1024));
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this.setPoints(points);
          this._tension = tension;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.CardinalSplineTo();
        action.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.v2(this.target.x, this.target.y);
        this._accumulatedDiff = cc.v2(0, 0);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        var p, lt;
        var ps = this._points;
        if (1 === dt) {
          p = ps.length - 1;
          lt = 1;
        } else {
          var locDT = this._deltaT;
          p = 0 | dt / locDT;
          lt = (dt - locDT * p) / locDT;
        }
        var newPos = cardinalSplineAt(getControlPointAt(ps, p - 1), getControlPointAt(ps, p - 0), getControlPointAt(ps, p + 1), getControlPointAt(ps, p + 2), this._tension, lt);
        if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
          var tempX, tempY;
          tempX = this.target.x - this._previousPosition.x;
          tempY = this.target.y - this._previousPosition.y;
          if (0 !== tempX || 0 !== tempY) {
            var locAccDiff = this._accumulatedDiff;
            tempX = locAccDiff.x + tempX;
            tempY = locAccDiff.y + tempY;
            locAccDiff.x = tempX;
            locAccDiff.y = tempY;
            newPos.x += tempX;
            newPos.y += tempY;
          }
        }
        this.updatePosition(newPos);
      },
      reverse: function() {
        var reversePoints = reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, reversePoints, this._tension);
      },
      updatePosition: function(newPos) {
        this.target.setPosition(newPos);
        this._previousPosition = newPos;
      },
      getPoints: function() {
        return this._points;
      },
      setPoints: function(points) {
        this._points = points;
      }
    });
    cc.cardinalSplineTo = function(duration, points, tension) {
      return new cc.CardinalSplineTo(duration, points, tension);
    };
    cc.CardinalSplineBy = cc.Class({
      name: "cc.CardinalSplineBy",
      extends: cc.CardinalSplineTo,
      ctor: function(duration, points, tension) {
        this._startPosition = cc.v2(0, 0);
        void 0 !== tension && this.initWithDuration(duration, points, tension);
      },
      startWithTarget: function(target) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
        this._startPosition.x = target.x;
        this._startPosition.y = target.y;
      },
      reverse: function() {
        var copyConfig = this._points.slice();
        var current;
        var p = copyConfig[0];
        for (var i = 1; i < copyConfig.length; ++i) {
          current = copyConfig[i];
          copyConfig[i] = current.sub(p);
          p = current;
        }
        var reverseArray = reverseControlPoints(copyConfig);
        p = reverseArray[reverseArray.length - 1];
        reverseArray.pop();
        p.x = -p.x;
        p.y = -p.y;
        reverseArray.unshift(p);
        for (var i = 1; i < reverseArray.length; ++i) {
          current = reverseArray[i];
          current.x = -current.x;
          current.y = -current.y;
          current.x += p.x;
          current.y += p.y;
          reverseArray[i] = current;
          p = current;
        }
        return cc.cardinalSplineBy(this._duration, reverseArray, this._tension);
      },
      updatePosition: function(newPos) {
        var pos = this._startPosition;
        var posX = newPos.x + pos.x;
        var posY = newPos.y + pos.y;
        this._previousPosition.x = posX;
        this._previousPosition.y = posY;
        this.target.setPosition(posX, posY);
      },
      clone: function() {
        var a = new cc.CardinalSplineBy();
        a.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
        return a;
      }
    });
    cc.cardinalSplineBy = function(duration, points, tension) {
      return new cc.CardinalSplineBy(duration, points, tension);
    };
    cc.CatmullRomTo = cc.Class({
      name: "cc.CatmullRomTo",
      extends: cc.CardinalSplineTo,
      ctor: function(dt, points) {
        points && this.initWithDuration(dt, points);
      },
      initWithDuration: function(dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
      },
      clone: function() {
        var action = new cc.CatmullRomTo();
        action.initWithDuration(this._duration, cloneControlPoints(this._points));
        return action;
      }
    });
    cc.catmullRomTo = function(dt, points) {
      return new cc.CatmullRomTo(dt, points);
    };
    cc.CatmullRomBy = cc.Class({
      name: "cc.CatmullRomBy",
      extends: cc.CardinalSplineBy,
      ctor: function(dt, points) {
        points && this.initWithDuration(dt, points);
      },
      initWithDuration: function(dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
      },
      clone: function() {
        var action = new cc.CatmullRomBy();
        action.initWithDuration(this._duration, cloneControlPoints(this._points));
        return action;
      }
    });
    cc.catmullRomBy = function(dt, points) {
      return new cc.CatmullRomBy(dt, points);
    };
  }), {} ],
  6: [ (function(require, module, exports) {
    cc.easeIn = function(rate) {
      return {
        _rate: rate,
        easing: function(dt) {
          return Math.pow(dt, this._rate);
        },
        reverse: function() {
          return cc.easeIn(1 / this._rate);
        }
      };
    };
    cc.easeOut = function(rate) {
      return {
        _rate: rate,
        easing: function(dt) {
          return Math.pow(dt, 1 / this._rate);
        },
        reverse: function() {
          return cc.easeOut(1 / this._rate);
        }
      };
    };
    cc.easeInOut = function(rate) {
      return {
        _rate: rate,
        easing: function(dt) {
          dt *= 2;
          return dt < 1 ? .5 * Math.pow(dt, this._rate) : 1 - .5 * Math.pow(2 - dt, this._rate);
        },
        reverse: function() {
          return cc.easeInOut(this._rate);
        }
      };
    };
    var _easeExponentialInObj = {
      easing: function(dt) {
        return 0 === dt ? 0 : Math.pow(2, 10 * (dt - 1));
      },
      reverse: function() {
        return _easeExponentialOutObj;
      }
    };
    cc.easeExponentialIn = function() {
      return _easeExponentialInObj;
    };
    var _easeExponentialOutObj = {
      easing: function(dt) {
        return 1 === dt ? 1 : 1 - Math.pow(2, -10 * dt);
      },
      reverse: function() {
        return _easeExponentialInObj;
      }
    };
    cc.easeExponentialOut = function() {
      return _easeExponentialOutObj;
    };
    var _easeExponentialInOutObj = {
      easing: function(dt) {
        if (1 !== dt && 0 !== dt) {
          dt *= 2;
          return dt < 1 ? .5 * Math.pow(2, 10 * (dt - 1)) : .5 * (2 - Math.pow(2, -10 * (dt - 1)));
        }
        return dt;
      },
      reverse: function() {
        return _easeExponentialInOutObj;
      }
    };
    cc.easeExponentialInOut = function() {
      return _easeExponentialInOutObj;
    };
    var _easeSineInObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
      },
      reverse: function() {
        return _easeSineOutObj;
      }
    };
    cc.easeSineIn = function() {
      return _easeSineInObj;
    };
    var _easeSineOutObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
      },
      reverse: function() {
        return _easeSineInObj;
      }
    };
    cc.easeSineOut = function() {
      return _easeSineOutObj;
    };
    var _easeSineInOutObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
      },
      reverse: function() {
        return _easeSineInOutObj;
      }
    };
    cc.easeSineInOut = function() {
      return _easeSineInOutObj;
    };
    var _easeElasticInObj = {
      easing: function(dt) {
        if (0 === dt || 1 === dt) return dt;
        dt -= 1;
        return -Math.pow(2, 10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3);
      },
      reverse: function() {
        return _easeElasticOutObj;
      }
    };
    cc.easeElasticIn = function(period) {
      if (period && .3 !== period) return {
        _period: period,
        easing: function(dt) {
          if (0 === dt || 1 === dt) return dt;
          dt -= 1;
          return -Math.pow(2, 10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period);
        },
        reverse: function() {
          return cc.easeElasticOut(this._period);
        }
      };
      return _easeElasticInObj;
    };
    var _easeElasticOutObj = {
      easing: function(dt) {
        return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3) + 1;
      },
      reverse: function() {
        return _easeElasticInObj;
      }
    };
    cc.easeElasticOut = function(period) {
      if (period && .3 !== period) return {
        _period: period,
        easing: function(dt) {
          return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period) + 1;
        },
        reverse: function() {
          return cc.easeElasticIn(this._period);
        }
      };
      return _easeElasticOutObj;
    };
    cc.easeElasticInOut = function(period) {
      period = period || .3;
      return {
        _period: period,
        easing: function(dt) {
          var newT = 0;
          var locPeriod = this._period;
          if (0 === dt || 1 === dt) newT = dt; else {
            dt *= 2;
            locPeriod || (locPeriod = this._period = .3 * 1.5);
            var s = locPeriod / 4;
            dt -= 1;
            newT = dt < 0 ? -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) : Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
          }
          return newT;
        },
        reverse: function() {
          return cc.easeElasticInOut(this._period);
        }
      };
    };
    function _bounceTime(time1) {
      if (time1 < 1 / 2.75) return 7.5625 * time1 * time1;
      if (time1 < 2 / 2.75) {
        time1 -= 1.5 / 2.75;
        return 7.5625 * time1 * time1 + .75;
      }
      if (time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + .9375;
      }
      time1 -= 2.625 / 2.75;
      return 7.5625 * time1 * time1 + .984375;
    }
    var _easeBounceInObj = {
      easing: function(dt) {
        return 1 - _bounceTime(1 - dt);
      },
      reverse: function() {
        return _easeBounceOutObj;
      }
    };
    cc.easeBounceIn = function() {
      return _easeBounceInObj;
    };
    var _easeBounceOutObj = {
      easing: function(dt) {
        return _bounceTime(dt);
      },
      reverse: function() {
        return _easeBounceInObj;
      }
    };
    cc.easeBounceOut = function() {
      return _easeBounceOutObj;
    };
    var _easeBounceInOutObj = {
      easing: function(time1) {
        var newT;
        if (time1 < .5) {
          time1 *= 2;
          newT = .5 * (1 - _bounceTime(1 - time1));
        } else newT = .5 * _bounceTime(2 * time1 - 1) + .5;
        return newT;
      },
      reverse: function() {
        return _easeBounceInOutObj;
      }
    };
    cc.easeBounceInOut = function() {
      return _easeBounceInOutObj;
    };
    var _easeBackInObj = {
      easing: function(time1) {
        var overshoot = 1.70158;
        return 0 === time1 || 1 === time1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
      },
      reverse: function() {
        return _easeBackOutObj;
      }
    };
    cc.easeBackIn = function() {
      return _easeBackInObj;
    };
    var _easeBackOutObj = {
      easing: function(time1) {
        var overshoot = 1.70158;
        time1 -= 1;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
      },
      reverse: function() {
        return _easeBackInObj;
      }
    };
    cc.easeBackOut = function() {
      return _easeBackOutObj;
    };
    var _easeBackInOutObj = {
      easing: function(time1) {
        var overshoot = 2.5949095;
        time1 *= 2;
        if (time1 < 1) return time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2;
        time1 -= 2;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1;
      },
      reverse: function() {
        return _easeBackInOutObj;
      }
    };
    cc.easeBackInOut = function() {
      return _easeBackInOutObj;
    };
    cc.easeBezierAction = function(a, b, c, d) {
      return {
        easing: function(t) {
          return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
        },
        reverse: function() {
          return cc.easeBezierAction(d, c, b, a);
        }
      };
    };
    var _easeQuadraticActionIn = {
      easing: function(time) {
        return Math.pow(time, 2);
      },
      reverse: function() {
        return _easeQuadraticActionIn;
      }
    };
    cc.easeQuadraticActionIn = function() {
      return _easeQuadraticActionIn;
    };
    var _easeQuadraticActionOut = {
      easing: function(time) {
        return -time * (time - 2);
      },
      reverse: function() {
        return _easeQuadraticActionOut;
      }
    };
    cc.easeQuadraticActionOut = function() {
      return _easeQuadraticActionOut;
    };
    var _easeQuadraticActionInOut = {
      easing: function(time) {
        var resultTime = time;
        time *= 2;
        if (time < 1) resultTime = time * time * .5; else {
          --time;
          resultTime = -.5 * (time * (time - 2) - 1);
        }
        return resultTime;
      },
      reverse: function() {
        return _easeQuadraticActionInOut;
      }
    };
    cc.easeQuadraticActionInOut = function() {
      return _easeQuadraticActionInOut;
    };
    var _easeQuarticActionIn = {
      easing: function(time) {
        return time * time * time * time;
      },
      reverse: function() {
        return _easeQuarticActionIn;
      }
    };
    cc.easeQuarticActionIn = function() {
      return _easeQuarticActionIn;
    };
    var _easeQuarticActionOut = {
      easing: function(time) {
        time -= 1;
        return -(time * time * time * time - 1);
      },
      reverse: function() {
        return _easeQuarticActionOut;
      }
    };
    cc.easeQuarticActionOut = function() {
      return _easeQuarticActionOut;
    };
    var _easeQuarticActionInOut = {
      easing: function(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time * time;
        time -= 2;
        return -.5 * (time * time * time * time - 2);
      },
      reverse: function() {
        return _easeQuarticActionInOut;
      }
    };
    cc.easeQuarticActionInOut = function() {
      return _easeQuarticActionInOut;
    };
    var _easeQuinticActionIn = {
      easing: function(time) {
        return time * time * time * time * time;
      },
      reverse: function() {
        return _easeQuinticActionIn;
      }
    };
    cc.easeQuinticActionIn = function() {
      return _easeQuinticActionIn;
    };
    var _easeQuinticActionOut = {
      easing: function(time) {
        time -= 1;
        return time * time * time * time * time + 1;
      },
      reverse: function() {
        return _easeQuinticActionOut;
      }
    };
    cc.easeQuinticActionOut = function() {
      return _easeQuinticActionOut;
    };
    var _easeQuinticActionInOut = {
      easing: function(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time * time * time;
        time -= 2;
        return .5 * (time * time * time * time * time + 2);
      },
      reverse: function() {
        return _easeQuinticActionInOut;
      }
    };
    cc.easeQuinticActionInOut = function() {
      return _easeQuinticActionInOut;
    };
    var _easeCircleActionIn = {
      easing: function(time) {
        return -1 * (Math.sqrt(1 - time * time) - 1);
      },
      reverse: function() {
        return _easeCircleActionIn;
      }
    };
    cc.easeCircleActionIn = function() {
      return _easeCircleActionIn;
    };
    var _easeCircleActionOut = {
      easing: function(time) {
        time -= 1;
        return Math.sqrt(1 - time * time);
      },
      reverse: function() {
        return _easeCircleActionOut;
      }
    };
    cc.easeCircleActionOut = function() {
      return _easeCircleActionOut;
    };
    var _easeCircleActionInOut = {
      easing: function(time) {
        time *= 2;
        if (time < 1) return -.5 * (Math.sqrt(1 - time * time) - 1);
        time -= 2;
        return .5 * (Math.sqrt(1 - time * time) + 1);
      },
      reverse: function() {
        return _easeCircleActionInOut;
      }
    };
    cc.easeCircleActionInOut = function() {
      return _easeCircleActionInOut;
    };
    var _easeCubicActionIn = {
      easing: function(time) {
        return time * time * time;
      },
      reverse: function() {
        return _easeCubicActionIn;
      }
    };
    cc.easeCubicActionIn = function() {
      return _easeCubicActionIn;
    };
    var _easeCubicActionOut = {
      easing: function(time) {
        time -= 1;
        return time * time * time + 1;
      },
      reverse: function() {
        return _easeCubicActionOut;
      }
    };
    cc.easeCubicActionOut = function() {
      return _easeCubicActionOut;
    };
    var _easeCubicActionInOut = {
      easing: function(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time;
        time -= 2;
        return .5 * (time * time * time + 2);
      },
      reverse: function() {
        return _easeCubicActionInOut;
      }
    };
    cc.easeCubicActionInOut = function() {
      return _easeCubicActionInOut;
    };
  }), {} ],
  7: [ (function(require, module, exports) {
    cc.ActionInstant = cc.Class({
      name: "cc.ActionInstant",
      extends: cc.FiniteTimeAction,
      isDone: function() {
        return true;
      },
      step: function(dt) {
        this.update(1);
      },
      update: function(dt) {},
      reverse: function() {
        return this.clone();
      },
      clone: function() {
        return new cc.ActionInstant();
      }
    });
    cc.Show = cc.Class({
      name: "cc.Show",
      extends: cc.ActionInstant,
      update: function(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc.RenderComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = true;
        }
      },
      reverse: function() {
        return new cc.Hide();
      },
      clone: function() {
        return new cc.Show();
      }
    });
    cc.show = function() {
      return new cc.Show();
    };
    cc.Hide = cc.Class({
      name: "cc.Hide",
      extends: cc.ActionInstant,
      update: function(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc.RenderComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = false;
        }
      },
      reverse: function() {
        return new cc.Show();
      },
      clone: function() {
        return new cc.Hide();
      }
    });
    cc.hide = function() {
      return new cc.Hide();
    };
    cc.ToggleVisibility = cc.Class({
      name: "cc.ToggleVisibility",
      extends: cc.ActionInstant,
      update: function(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc.RenderComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = !render.enabled;
        }
      },
      reverse: function() {
        return new cc.ToggleVisibility();
      },
      clone: function() {
        return new cc.ToggleVisibility();
      }
    });
    cc.toggleVisibility = function() {
      return new cc.ToggleVisibility();
    };
    cc.RemoveSelf = cc.Class({
      name: "cc.RemoveSelf",
      extends: cc.ActionInstant,
      ctor: function(isNeedCleanUp) {
        this._isNeedCleanUp = true;
        void 0 !== isNeedCleanUp && this.init(isNeedCleanUp);
      },
      update: function(dt) {
        this.target.removeFromParent(this._isNeedCleanUp);
      },
      init: function(isNeedCleanUp) {
        this._isNeedCleanUp = isNeedCleanUp;
        return true;
      },
      reverse: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
      },
      clone: function() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
      }
    });
    cc.removeSelf = function(isNeedCleanUp) {
      return new cc.RemoveSelf(isNeedCleanUp);
    };
    cc.FlipX = cc.Class({
      name: "cc.FlipX",
      extends: cc.ActionInstant,
      ctor: function(flip) {
        this._flippedX = false;
        void 0 !== flip && this.initWithFlipX(flip);
      },
      initWithFlipX: function(flip) {
        this._flippedX = flip;
        return true;
      },
      update: function(dt) {
        this.target.scaleX = Math.abs(this.target.scaleX) * (this._flippedX ? -1 : 1);
      },
      reverse: function() {
        return new cc.FlipX(!this._flippedX);
      },
      clone: function() {
        var action = new cc.FlipX();
        action.initWithFlipX(this._flippedX);
        return action;
      }
    });
    cc.flipX = function(flip) {
      return new cc.FlipX(flip);
    };
    cc.FlipY = cc.Class({
      name: "cc.FlipY",
      extends: cc.ActionInstant,
      ctor: function(flip) {
        this._flippedY = false;
        void 0 !== flip && this.initWithFlipY(flip);
      },
      initWithFlipY: function(flip) {
        this._flippedY = flip;
        return true;
      },
      update: function(dt) {
        this.target.scaleY = Math.abs(this.target.scaleY) * (this._flippedY ? -1 : 1);
      },
      reverse: function() {
        return new cc.FlipY(!this._flippedY);
      },
      clone: function() {
        var action = new cc.FlipY();
        action.initWithFlipY(this._flippedY);
        return action;
      }
    });
    cc.flipY = function(flip) {
      return new cc.FlipY(flip);
    };
    cc.Place = cc.Class({
      name: "cc.Place",
      extends: cc.ActionInstant,
      ctor: function(pos, y) {
        this._x = 0;
        this._y = 0;
        if (void 0 !== pos) {
          if (void 0 !== pos.x) {
            y = pos.y;
            pos = pos.x;
          }
          this.initWithPosition(pos, y);
        }
      },
      initWithPosition: function(x, y) {
        this._x = x;
        this._y = y;
        return true;
      },
      update: function(dt) {
        this.target.setPosition(this._x, this._y);
      },
      clone: function() {
        var action = new cc.Place();
        action.initWithPosition(this._x, this._y);
        return action;
      }
    });
    cc.place = function(pos, y) {
      return new cc.Place(pos, y);
    };
    cc.CallFunc = cc.Class({
      name: "cc.CallFunc",
      extends: cc.ActionInstant,
      ctor: function(selector, selectorTarget, data) {
        this._selectorTarget = null;
        this._function = null;
        this._data = null;
        this.initWithFunction(selector, selectorTarget, data);
      },
      initWithFunction: function(selector, selectorTarget, data) {
        selector && (this._function = selector);
        selectorTarget && (this._selectorTarget = selectorTarget);
        void 0 !== data && (this._data = data);
        return true;
      },
      execute: function() {
        this._function && this._function.call(this._selectorTarget, this.target, this._data);
      },
      update: function(dt) {
        this.execute();
      },
      getTargetCallback: function() {
        return this._selectorTarget;
      },
      setTargetCallback: function(sel) {
        if (sel !== this._selectorTarget) {
          this._selectorTarget && (this._selectorTarget = null);
          this._selectorTarget = sel;
        }
      },
      clone: function() {
        var action = new cc.CallFunc();
        action.initWithFunction(this._function, this._selectorTarget, this._data);
        return action;
      }
    });
    cc.callFunc = function(selector, selectorTarget, data) {
      return new cc.CallFunc(selector, selectorTarget, data);
    };
  }), {} ],
  8: [ (function(require, module, exports) {
    cc.ActionInterval = cc.Class({
      name: "cc.ActionInterval",
      extends: cc.FiniteTimeAction,
      ctor: function(d) {
        this.MAX_VALUE = 2;
        this._elapsed = 0;
        this._firstTick = false;
        this._easeList = null;
        this._speed = 1;
        this._timesForRepeat = 1;
        this._repeatForever = false;
        this._repeatMethod = false;
        this._speedMethod = false;
        void 0 !== d && cc.ActionInterval.prototype.initWithDuration.call(this, d);
      },
      getElapsed: function() {
        return this._elapsed;
      },
      initWithDuration: function(d) {
        this._duration = 0 === d ? cc.macro.FLT_EPSILON : d;
        this._elapsed = 0;
        this._firstTick = true;
        return true;
      },
      isDone: function() {
        return this._elapsed >= this._duration;
      },
      _cloneDecoration: function(action) {
        action._repeatForever = this._repeatForever;
        action._speed = this._speed;
        action._timesForRepeat = this._timesForRepeat;
        action._easeList = this._easeList;
        action._speedMethod = this._speedMethod;
        action._repeatMethod = this._repeatMethod;
      },
      _reverseEaseList: function(action) {
        if (this._easeList) {
          action._easeList = [];
          for (var i = 0; i < this._easeList.length; i++) action._easeList.push(this._easeList[i].reverse());
        }
      },
      clone: function() {
        var action = new cc.ActionInterval(this._duration);
        this._cloneDecoration(action);
        return action;
      },
      easing: function(easeObj) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);
        return this;
      },
      _computeEaseTime: function(dt) {
        var locList = this._easeList;
        if (!locList || 0 === locList.length) return dt;
        for (var i = 0, n = locList.length; i < n; i++) dt = locList[i].easing(dt);
        return dt;
      },
      step: function(dt) {
        if (this._firstTick) {
          this._firstTick = false;
          this._elapsed = 0;
        } else this._elapsed += dt;
        var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
        t = 1 > t ? t : 1;
        this.update(t > 0 ? t : 0);
        if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
          this._repeatForever || this._timesForRepeat--;
          this.startWithTarget(this.target);
          this.step(this._elapsed - this._duration);
        }
      },
      startWithTarget: function(target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._elapsed = 0;
        this._firstTick = true;
      },
      reverse: function() {
        cc.logID(1010);
        return null;
      },
      setAmplitudeRate: function(amp) {
        cc.logID(1011);
      },
      getAmplitudeRate: function() {
        cc.logID(1012);
        return 0;
      },
      speed: function(speed) {
        if (speed <= 0) {
          cc.logID(1013);
          return this;
        }
        this._speedMethod = true;
        this._speed *= speed;
        return this;
      },
      getSpeed: function() {
        return this._speed;
      },
      setSpeed: function(speed) {
        this._speed = speed;
        return this;
      },
      repeat: function(times) {
        times = Math.round(times);
        if (isNaN(times) || times < 1) {
          cc.logID(1014);
          return this;
        }
        this._repeatMethod = true;
        this._timesForRepeat *= times;
        return this;
      },
      repeatForever: function() {
        this._repeatMethod = true;
        this._timesForRepeat = this.MAX_VALUE;
        this._repeatForever = true;
        return this;
      }
    });
    cc.actionInterval = function(d) {
      return new cc.ActionInterval(d);
    };
    cc.Sequence = cc.Class({
      name: "cc.Sequence",
      extends: cc.ActionInterval,
      ctor: function(tempArray) {
        this._actions = [];
        this._split = null;
        this._last = 0;
        this._reversed = false;
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) {
          cc.errorID(1019);
          return;
        }
        var last = paramArray.length - 1;
        last >= 0 && null == paramArray[last] && cc.logID(1015);
        if (last >= 0) {
          var prev = paramArray[0], action1;
          for (var i = 1; i < last; i++) if (paramArray[i]) {
            action1 = prev;
            prev = cc.Sequence._actionOneTwo(action1, paramArray[i]);
          }
          this.initWithTwoActions(prev, paramArray[last]);
        }
      },
      initWithTwoActions: function(actionOne, actionTwo) {
        if (!actionOne || !actionTwo) throw new Error(cc._getError(1025));
        var durationOne = actionOne._duration, durationTwo = actionTwo._duration;
        durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1;
        durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1;
        var d = durationOne + durationTwo;
        this.initWithDuration(d);
        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;
        return true;
      },
      clone: function() {
        var action = new cc.Sequence();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._split = this._actions[0]._duration / this._duration;
        this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1;
        this._last = -1;
      },
      stop: function() {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function(dt) {
        var new_t, found = 0;
        var locSplit = this._split, locActions = this._actions, locLast = this._last, actionFound;
        dt = this._computeEaseTime(dt);
        if (dt < locSplit) {
          new_t = 0 !== locSplit ? dt / locSplit : 1;
          if (0 === found && 1 === locLast && this._reversed) {
            locActions[1].update(0);
            locActions[1].stop();
          }
        } else {
          found = 1;
          new_t = 1 === locSplit ? 1 : (dt - locSplit) / (1 - locSplit);
          if (-1 === locLast) {
            locActions[0].startWithTarget(this.target);
            locActions[0].update(1);
            locActions[0].stop();
          }
          if (0 === locLast) {
            locActions[0].update(1);
            locActions[0].stop();
          }
        }
        actionFound = locActions[found];
        if (locLast === found && actionFound.isDone()) return;
        locLast !== found && actionFound.startWithTarget(this.target);
        new_t *= actionFound._timesForRepeat;
        actionFound.update(new_t > 1 ? new_t % 1 : new_t);
        this._last = found;
      },
      reverse: function() {
        var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        action._reversed = true;
        return action;
      }
    });
    cc.sequence = function(tempArray) {
      var paramArray = tempArray instanceof Array ? tempArray : arguments;
      if (1 === paramArray.length) {
        cc.errorID(1019);
        return null;
      }
      var last = paramArray.length - 1;
      last >= 0 && null == paramArray[last] && cc.logID(1015);
      var result = null;
      if (last >= 0) {
        result = paramArray[0];
        for (var i = 1; i <= last; i++) paramArray[i] && (result = cc.Sequence._actionOneTwo(result, paramArray[i]));
      }
      return result;
    };
    cc.Sequence._actionOneTwo = function(actionOne, actionTwo) {
      var sequence = new cc.Sequence();
      sequence.initWithTwoActions(actionOne, actionTwo);
      return sequence;
    };
    cc.Repeat = cc.Class({
      name: "cc.Repeat",
      extends: cc.ActionInterval,
      ctor: function(action, times) {
        this._times = 0;
        this._total = 0;
        this._nextDt = 0;
        this._actionInstant = false;
        this._innerAction = null;
        void 0 !== times && this.initWithAction(action, times);
      },
      initWithAction: function(action, times) {
        var duration = action._duration * times;
        if (this.initWithDuration(duration)) {
          this._times = times;
          this._innerAction = action;
          if (action instanceof cc.ActionInstant) {
            this._actionInstant = true;
            this._times -= 1;
          }
          this._total = 0;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.Repeat();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone(), this._times);
        return action;
      },
      startWithTarget: function(target) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      stop: function() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        var locInnerAction = this._innerAction;
        var locDuration = this._duration;
        var locTimes = this._times;
        var locNextDt = this._nextDt;
        if (dt >= locNextDt) {
          while (dt > locNextDt && this._total < locTimes) {
            locInnerAction.update(1);
            this._total++;
            locInnerAction.stop();
            locInnerAction.startWithTarget(this.target);
            locNextDt += locInnerAction._duration / locDuration;
            this._nextDt = locNextDt > 1 ? 1 : locNextDt;
          }
          if (dt >= 1 && this._total < locTimes) {
            locInnerAction.update(1);
            this._total++;
          }
          this._actionInstant || (this._total === locTimes ? locInnerAction.stop() : locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration)));
        } else locInnerAction.update(dt * locTimes % 1);
      },
      isDone: function() {
        return this._total === this._times;
      },
      reverse: function() {
        var action = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      setInnerAction: function(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function() {
        return this._innerAction;
      }
    });
    cc.repeat = function(action, times) {
      return new cc.Repeat(action, times);
    };
    cc.RepeatForever = cc.Class({
      name: "cc.RepeatForever",
      extends: cc.ActionInterval,
      ctor: function(action) {
        this._innerAction = null;
        action && this.initWithAction(action);
      },
      initWithAction: function(action) {
        if (!action) throw new Error(cc._getError(1026));
        this._innerAction = action;
        return true;
      },
      clone: function() {
        var action = new cc.RepeatForever();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      step: function(dt) {
        var locInnerAction = this._innerAction;
        locInnerAction.step(dt);
        if (locInnerAction.isDone()) {
          locInnerAction.startWithTarget(this.target);
          locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
        }
      },
      isDone: function() {
        return false;
      },
      reverse: function() {
        var action = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      setInnerAction: function(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function() {
        return this._innerAction;
      }
    });
    cc.repeatForever = function(action) {
      return new cc.RepeatForever(action);
    };
    cc.Spawn = cc.Class({
      name: "cc.Spawn",
      extends: cc.ActionInterval,
      ctor: function(tempArray) {
        this._one = null;
        this._two = null;
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) {
          cc.errorID(1020);
          return;
        }
        var last = paramArray.length - 1;
        last >= 0 && null == paramArray[last] && cc.logID(1015);
        if (last >= 0) {
          var prev = paramArray[0], action1;
          for (var i = 1; i < last; i++) if (paramArray[i]) {
            action1 = prev;
            prev = cc.Spawn._actionOneTwo(action1, paramArray[i]);
          }
          this.initWithTwoActions(prev, paramArray[last]);
        }
      },
      initWithTwoActions: function(action1, action2) {
        if (!action1 || !action2) throw new Error(cc._getError(1027));
        var ret = false;
        var d1 = action1._duration;
        var d2 = action2._duration;
        if (this.initWithDuration(Math.max(d1, d2))) {
          this._one = action1;
          this._two = action2;
          d1 > d2 ? this._two = cc.Sequence._actionOneTwo(action2, cc.delayTime(d1 - d2)) : d1 < d2 && (this._one = cc.Sequence._actionOneTwo(action1, cc.delayTime(d2 - d1)));
          ret = true;
        }
        return ret;
      },
      clone: function() {
        var action = new cc.Spawn();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._one.clone(), this._two.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._one.startWithTarget(target);
        this._two.startWithTarget(target);
      },
      stop: function() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this._one && this._one.update(dt);
        this._two && this._two.update(dt);
      },
      reverse: function() {
        var action = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.spawn = function(tempArray) {
      var paramArray = tempArray instanceof Array ? tempArray : arguments;
      if (1 === paramArray.length) {
        cc.errorID(1020);
        return null;
      }
      paramArray.length > 0 && null == paramArray[paramArray.length - 1] && cc.logID(1015);
      var prev = paramArray[0];
      for (var i = 1; i < paramArray.length; i++) null != paramArray[i] && (prev = cc.Spawn._actionOneTwo(prev, paramArray[i]));
      return prev;
    };
    cc.Spawn._actionOneTwo = function(action1, action2) {
      var pSpawn = new cc.Spawn();
      pSpawn.initWithTwoActions(action1, action2);
      return pSpawn;
    };
    cc.RotateTo = cc.Class({
      name: "cc.RotateTo",
      extends: cc.ActionInterval,
      ctor: function(duration, deltaAngleX, deltaAngleY) {
        this._dstAngleX = 0;
        this._startAngleX = 0;
        this._diffAngleX = 0;
        this._dstAngleY = 0;
        this._startAngleY = 0;
        this._diffAngleY = 0;
        void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
      },
      initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._dstAngleX = deltaAngleX || 0;
          this._dstAngleY = void 0 !== deltaAngleY ? deltaAngleY : this._dstAngleX;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.RotateTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locStartAngleX = target.rotationX % 360;
        var locDiffAngleX = this._dstAngleX - locStartAngleX;
        locDiffAngleX > 180 && (locDiffAngleX -= 360);
        locDiffAngleX < -180 && (locDiffAngleX += 360);
        this._startAngleX = locStartAngleX;
        this._diffAngleX = locDiffAngleX;
        this._startAngleY = target.rotationY % 360;
        var locDiffAngleY = this._dstAngleY - this._startAngleY;
        locDiffAngleY > 180 && (locDiffAngleY -= 360);
        locDiffAngleY < -180 && (locDiffAngleY += 360);
        this._diffAngleY = locDiffAngleY;
      },
      reverse: function() {
        cc.logID(1016);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          this.target.rotationX = this._startAngleX + this._diffAngleX * dt;
          this.target.rotationY = this._startAngleY + this._diffAngleY * dt;
        }
      }
    });
    cc.rotateTo = function(duration, deltaAngleX, deltaAngleY) {
      return new cc.RotateTo(duration, deltaAngleX, deltaAngleY);
    };
    cc.RotateBy = cc.Class({
      name: "cc.RotateBy",
      extends: cc.ActionInterval,
      ctor: function(duration, deltaAngleX, deltaAngleY) {
        this._angleX = 0;
        this._startAngleX = 0;
        this._angleY = 0;
        this._startAngleY = 0;
        void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
      },
      initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._angleX = deltaAngleX || 0;
          this._angleY = void 0 !== deltaAngleY ? deltaAngleY : this._angleX;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.RotateBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._angleX, this._angleY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startAngleX = target.rotationX;
        this._startAngleY = target.rotationY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          this.target.rotationX = this._startAngleX + this._angleX * dt;
          this.target.rotationY = this._startAngleY + this._angleY * dt;
        }
      },
      reverse: function() {
        var action = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.rotateBy = function(duration, deltaAngleX, deltaAngleY) {
      return new cc.RotateBy(duration, deltaAngleX, deltaAngleY);
    };
    cc.MoveBy = cc.Class({
      name: "cc.MoveBy",
      extends: cc.ActionInterval,
      ctor: function(duration, deltaPos, deltaY) {
        this._positionDelta = cc.v2(0, 0);
        this._startPosition = cc.v2(0, 0);
        this._previousPosition = cc.v2(0, 0);
        void 0 !== deltaPos && cc.MoveBy.prototype.initWithDuration.call(this, duration, deltaPos, deltaY);
      },
      initWithDuration: function(duration, position, y) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          if (void 0 !== position.x) {
            y = position.y;
            position = position.x;
          }
          this._positionDelta.x = position;
          this._positionDelta.y = y;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.MoveBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._positionDelta);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.x;
        var locPosY = target.y;
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var x = this._positionDelta.x * dt;
          var y = this._positionDelta.y * dt;
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.x;
            var targetY = this.target.y;
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function() {
        var action = new cc.MoveBy(this._duration, cc.v2(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.moveBy = function(duration, deltaPos, deltaY) {
      return new cc.MoveBy(duration, deltaPos, deltaY);
    };
    cc.MoveTo = cc.Class({
      name: "cc.MoveTo",
      extends: cc.MoveBy,
      ctor: function(duration, position, y) {
        this._endPosition = cc.v2(0, 0);
        void 0 !== position && this.initWithDuration(duration, position, y);
      },
      initWithDuration: function(duration, position, y) {
        if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
          if (void 0 !== position.x) {
            y = position.y;
            position = position.x;
          }
          this._endPosition.x = position;
          this._endPosition.y = y;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.MoveTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition);
        return action;
      },
      startWithTarget: function(target) {
        cc.MoveBy.prototype.startWithTarget.call(this, target);
        this._positionDelta.x = this._endPosition.x - target.x;
        this._positionDelta.y = this._endPosition.y - target.y;
      }
    });
    cc.moveTo = function(duration, position, y) {
      return new cc.MoveTo(duration, position, y);
    };
    cc.SkewTo = cc.Class({
      name: "cc.SkewTo",
      extends: cc.ActionInterval,
      ctor: function(t, sx, sy) {
        this._skewX = 0;
        this._skewY = 0;
        this._startSkewX = 0;
        this._startSkewY = 0;
        this._endSkewX = 0;
        this._endSkewY = 0;
        this._deltaX = 0;
        this._deltaY = 0;
        void 0 !== sy && cc.SkewTo.prototype.initWithDuration.call(this, t, sx, sy);
      },
      initWithDuration: function(t, sx, sy) {
        var ret = false;
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._endSkewX = sx;
          this._endSkewY = sy;
          ret = true;
        }
        return ret;
      },
      clone: function() {
        var action = new cc.SkewTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startSkewX = target.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        this._deltaX > 180 && (this._deltaX -= 360);
        this._deltaX < -180 && (this._deltaX += 360);
        this._startSkewY = target.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        this._deltaY > 180 && (this._deltaY -= 360);
        this._deltaY < -180 && (this._deltaY += 360);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this.target.skewX = this._startSkewX + this._deltaX * dt;
        this.target.skewY = this._startSkewY + this._deltaY * dt;
      }
    });
    cc.skewTo = function(t, sx, sy) {
      return new cc.SkewTo(t, sx, sy);
    };
    cc.SkewBy = cc.Class({
      name: "cc.SkewBy",
      extends: cc.SkewTo,
      ctor: function(t, sx, sy) {
        void 0 !== sy && this.initWithDuration(t, sx, sy);
      },
      initWithDuration: function(t, deltaSkewX, deltaSkewY) {
        var ret = false;
        if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
          this._skewX = deltaSkewX;
          this._skewY = deltaSkewY;
          ret = true;
        }
        return ret;
      },
      clone: function() {
        var action = new cc.SkewBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._skewX, this._skewY);
        return action;
      },
      startWithTarget: function(target) {
        cc.SkewTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
      },
      reverse: function() {
        var action = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.skewBy = function(t, sx, sy) {
      return new cc.SkewBy(t, sx, sy);
    };
    cc.JumpBy = cc.Class({
      name: "cc.JumpBy",
      extends: cc.ActionInterval,
      ctor: function(duration, position, y, height, jumps) {
        this._startPosition = cc.v2(0, 0);
        this._previousPosition = cc.v2(0, 0);
        this._delta = cc.v2(0, 0);
        this._height = 0;
        this._jumps = 0;
        void 0 !== height && cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps);
      },
      initWithDuration: function(duration, position, y, height, jumps) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          if (void 0 === jumps) {
            jumps = height;
            height = y;
            y = position.y;
            position = position.x;
          }
          this._delta.x = position;
          this._delta.y = y;
          this._height = height;
          this._jumps = jumps;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.JumpBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.x;
        var locPosY = target.y;
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var frac = dt * this._jumps % 1;
          var y = 4 * this._height * frac * (1 - frac);
          y += this._delta.y * dt;
          var x = this._delta.x * dt;
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.x;
            var targetY = this.target.y;
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function() {
        var action = new cc.JumpBy(this._duration, cc.v2(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.jumpBy = function(duration, position, y, height, jumps) {
      return new cc.JumpBy(duration, position, y, height, jumps);
    };
    cc.JumpTo = cc.Class({
      name: "cc.JumpTo",
      extends: cc.JumpBy,
      ctor: function(duration, position, y, height, jumps) {
        this._endPosition = cc.v2(0, 0);
        void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
      },
      initWithDuration: function(duration, position, y, height, jumps) {
        if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
          if (void 0 === jumps) {
            y = position.y;
            position = position.x;
          }
          this._endPosition.x = position;
          this._endPosition.y = y;
          return true;
        }
        return false;
      },
      startWithTarget: function(target) {
        cc.JumpBy.prototype.startWithTarget.call(this, target);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y = this._endPosition.y - this._startPosition.y;
      },
      clone: function() {
        var action = new cc.JumpTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return action;
      }
    });
    cc.jumpTo = function(duration, position, y, height, jumps) {
      return new cc.JumpTo(duration, position, y, height, jumps);
    };
    function bezierAt(a, b, c, d, t) {
      return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
    }
    cc.BezierBy = cc.Class({
      name: "cc.BezierBy",
      extends: cc.ActionInterval,
      ctor: function(t, c) {
        this._config = [];
        this._startPosition = cc.v2(0, 0);
        this._previousPosition = cc.v2(0, 0);
        c && cc.BezierBy.prototype.initWithDuration.call(this, t, c);
      },
      initWithDuration: function(t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._config = c;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.BezierBy();
        this._cloneDecoration(action);
        var newConfigs = [];
        for (var i = 0; i < this._config.length; i++) {
          var selConf = this._config[i];
          newConfigs.push(cc.v2(selConf.x, selConf.y));
        }
        action.initWithDuration(this._duration, newConfigs);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.x;
        var locPosY = target.y;
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var locConfig = this._config;
          var xa = 0;
          var xb = locConfig[0].x;
          var xc = locConfig[1].x;
          var xd = locConfig[2].x;
          var ya = 0;
          var yb = locConfig[0].y;
          var yc = locConfig[1].y;
          var yd = locConfig[2].y;
          var x = bezierAt(xa, xb, xc, xd, dt);
          var y = bezierAt(ya, yb, yc, yd, dt);
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.x;
            var targetY = this.target.y;
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function() {
        var locConfig = this._config;
        var x0 = locConfig[0].x, y0 = locConfig[0].y;
        var x1 = locConfig[1].x, y1 = locConfig[1].y;
        var x2 = locConfig[2].x, y2 = locConfig[2].y;
        var r = [ cc.v2(x1 - x2, y1 - y2), cc.v2(x0 - x2, y0 - y2), cc.v2(-x2, -y2) ];
        var action = new cc.BezierBy(this._duration, r);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.bezierBy = function(t, c) {
      return new cc.BezierBy(t, c);
    };
    cc.BezierTo = cc.Class({
      name: "cc.BezierTo",
      extends: cc.BezierBy,
      ctor: function(t, c) {
        this._toConfig = [];
        c && this.initWithDuration(t, c);
      },
      initWithDuration: function(t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._toConfig = c;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.BezierTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toConfig);
        return action;
      },
      startWithTarget: function(target) {
        cc.BezierBy.prototype.startWithTarget.call(this, target);
        var locStartPos = this._startPosition;
        var locToConfig = this._toConfig;
        var locConfig = this._config;
        locConfig[0] = locToConfig[0].sub(locStartPos);
        locConfig[1] = locToConfig[1].sub(locStartPos);
        locConfig[2] = locToConfig[2].sub(locStartPos);
      }
    });
    cc.bezierTo = function(t, c) {
      return new cc.BezierTo(t, c);
    };
    cc.ScaleTo = cc.Class({
      name: "cc.ScaleTo",
      extends: cc.ActionInterval,
      ctor: function(duration, sx, sy) {
        this._scaleX = 1;
        this._scaleY = 1;
        this._startScaleX = 1;
        this._startScaleY = 1;
        this._endScaleX = 0;
        this._endScaleY = 0;
        this._deltaX = 0;
        this._deltaY = 0;
        void 0 !== sx && cc.ScaleTo.prototype.initWithDuration.call(this, duration, sx, sy);
      },
      initWithDuration: function(duration, sx, sy) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._endScaleX = sx;
          this._endScaleY = null != sy ? sy : sx;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.ScaleTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startScaleX = target.scaleX;
        this._startScaleY = target.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          this.target.scaleX = this._startScaleX + this._deltaX * dt;
          this.target.scaleY = this._startScaleY + this._deltaY * dt;
        }
      }
    });
    cc.scaleTo = function(duration, sx, sy) {
      return new cc.ScaleTo(duration, sx, sy);
    };
    cc.ScaleBy = cc.Class({
      name: "cc.ScaleBy",
      extends: cc.ScaleTo,
      startWithTarget: function(target) {
        cc.ScaleTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
      },
      reverse: function() {
        var action = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.ScaleBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
      }
    });
    cc.scaleBy = function(duration, sx, sy) {
      return new cc.ScaleBy(duration, sx, sy);
    };
    cc.Blink = cc.Class({
      name: "cc.Blink",
      extends: cc.ActionInterval,
      ctor: function(duration, blinks) {
        this._times = 0;
        this._originalState = false;
        void 0 !== blinks && this.initWithDuration(duration, blinks);
      },
      initWithDuration: function(duration, blinks) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._times = blinks;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.Blink();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._times);
        return action;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target && !this.isDone()) {
          var slice = 1 / this._times;
          var m = dt % slice;
          this.target.opacity = m > slice / 2 ? 255 : 0;
        }
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._originalState = target.opacity;
      },
      stop: function() {
        this.target.opacity = this._originalState;
        cc.ActionInterval.prototype.stop.call(this);
      },
      reverse: function() {
        var action = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.blink = function(duration, blinks) {
      return new cc.Blink(duration, blinks);
    };
    cc.FadeTo = cc.Class({
      name: "cc.FadeTo",
      extends: cc.ActionInterval,
      ctor: function(duration, opacity) {
        this._toOpacity = 0;
        this._fromOpacity = 0;
        void 0 !== opacity && cc.FadeTo.prototype.initWithDuration.call(this, duration, opacity);
      },
      initWithDuration: function(duration, opacity) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._toOpacity = opacity;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.FadeTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      },
      update: function(time) {
        time = this._computeEaseTime(time);
        var fromOpacity = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
        this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._fromOpacity = target.opacity;
      }
    });
    cc.fadeTo = function(duration, opacity) {
      return new cc.FadeTo(duration, opacity);
    };
    cc.FadeIn = cc.Class({
      name: "cc.FadeIn",
      extends: cc.FadeTo,
      ctor: function(duration) {
        null == duration && (duration = 0);
        this._reverseAction = null;
        this.initWithDuration(duration, 255);
      },
      reverse: function() {
        var action = new cc.FadeOut();
        action.initWithDuration(this._duration, 0);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.FadeIn();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      },
      startWithTarget: function(target) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, target);
      }
    });
    cc.fadeIn = function(duration) {
      return new cc.FadeIn(duration);
    };
    cc.FadeOut = cc.Class({
      name: "cc.FadeOut",
      extends: cc.FadeTo,
      ctor: function(duration) {
        null == duration && (duration = 0);
        this._reverseAction = null;
        this.initWithDuration(duration, 0);
      },
      reverse: function() {
        var action = new cc.FadeIn();
        action._reverseAction = this;
        action.initWithDuration(this._duration, 255);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.FadeOut();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      }
    });
    cc.fadeOut = function(d) {
      return new cc.FadeOut(d);
    };
    cc.TintTo = cc.Class({
      name: "cc.TintTo",
      extends: cc.ActionInterval,
      ctor: function(duration, red, green, blue) {
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        if (red instanceof cc.Color) {
          blue = red.b;
          green = red.g;
          red = red.r;
        }
        void 0 !== blue && this.initWithDuration(duration, red, green, blue);
      },
      initWithDuration: function(duration, red, green, blue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._to = cc.color(red, green, blue);
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.TintTo();
        this._cloneDecoration(action);
        var locTo = this._to;
        action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._from = this.target.color;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        var locFrom = this._from, locTo = this._to;
        locFrom && (this.target.color = cc.color(locFrom.r + (locTo.r - locFrom.r) * dt, locFrom.g + (locTo.g - locFrom.g) * dt, locFrom.b + (locTo.b - locFrom.b) * dt));
      }
    });
    cc.tintTo = function(duration, red, green, blue) {
      return new cc.TintTo(duration, red, green, blue);
    };
    cc.TintBy = cc.Class({
      name: "cc.TintBy",
      extends: cc.ActionInterval,
      ctor: function(duration, deltaRed, deltaGreen, deltaBlue) {
        this._deltaR = 0;
        this._deltaG = 0;
        this._deltaB = 0;
        this._fromR = 0;
        this._fromG = 0;
        this._fromB = 0;
        void 0 !== deltaBlue && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
      },
      initWithDuration: function(duration, deltaRed, deltaGreen, deltaBlue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._deltaR = deltaRed;
          this._deltaG = deltaGreen;
          this._deltaB = deltaBlue;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.TintBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var color = target.color;
        this._fromR = color.r;
        this._fromG = color.g;
        this._fromB = color.b;
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this.target.color = cc.color(this._fromR + this._deltaR * dt, this._fromG + this._deltaG * dt, this._fromB + this._deltaB * dt);
      },
      reverse: function() {
        var action = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.tintBy = function(duration, deltaRed, deltaGreen, deltaBlue) {
      return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue);
    };
    cc.DelayTime = cc.Class({
      name: "cc.DelayTime",
      extends: cc.ActionInterval,
      update: function(dt) {},
      reverse: function() {
        var action = new cc.DelayTime(this._duration);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function() {
        var action = new cc.DelayTime();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration);
        return action;
      }
    });
    cc.delayTime = function(d) {
      return new cc.DelayTime(d);
    };
    cc.ReverseTime = cc.Class({
      name: "cc.ReverseTime",
      extends: cc.ActionInterval,
      ctor: function(action) {
        this._other = null;
        action && this.initWithAction(action);
      },
      initWithAction: function(action) {
        if (!action) throw new Error(cc._getError(1028));
        if (action === this._other) throw new Error(cc._getError(1029));
        if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
          this._other = action;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.ReverseTime();
        this._cloneDecoration(action);
        action.initWithAction(this._other.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._other.startWithTarget(target);
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this._other && this._other.update(1 - dt);
      },
      reverse: function() {
        return this._other.clone();
      },
      stop: function() {
        this._other.stop();
        cc.Action.prototype.stop.call(this);
      }
    });
    cc.reverseTime = function(action) {
      return new cc.ReverseTime(action);
    };
    cc.TargetedAction = cc.Class({
      name: "cc.TargetedAction",
      extends: cc.ActionInterval,
      ctor: function(target, action) {
        this._action = null;
        this._forcedTarget = null;
        action && this.initWithTarget(target, action);
      },
      initWithTarget: function(target, action) {
        if (this.initWithDuration(action._duration)) {
          this._forcedTarget = target;
          this._action = action;
          return true;
        }
        return false;
      },
      clone: function() {
        var action = new cc.TargetedAction();
        this._cloneDecoration(action);
        action.initWithTarget(this._forcedTarget, this._action.clone());
        return action;
      },
      startWithTarget: function(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._action.startWithTarget(this._forcedTarget);
      },
      stop: function() {
        this._action.stop();
      },
      update: function(dt) {
        dt = this._computeEaseTime(dt);
        this._action.update(dt);
      },
      getForcedTarget: function() {
        return this._forcedTarget;
      },
      setForcedTarget: function(forcedTarget) {
        this._forcedTarget !== forcedTarget && (this._forcedTarget = forcedTarget);
      }
    });
    cc.targetedAction = function(target, action) {
      return new cc.TargetedAction(target, action);
    };
  }), {} ],
  9: [ (function(require, module, exports) {
    require("../core/platform/CCClass");
    var js = require("../core/platform/js");
    var HashElement = function() {
      this.actions = [];
      this.target = null;
      this.actionIndex = 0;
      this.currentAction = null;
      this.paused = false;
      this.lock = false;
    };
    cc.ActionManager = function() {
      this._hashTargets = js.createMap(true);
      this._arrayTargets = [];
      this._currentTarget = null;
      cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
    };
    cc.ActionManager.prototype = {
      constructor: cc.ActionManager,
      _elementPool: [],
      _searchElementByTarget: function(arr, target) {
        for (var k = 0; k < arr.length; k++) if (target === arr[k].target) return arr[k];
        return null;
      },
      _getElement: function(target, paused) {
        var element = this._elementPool.pop();
        element || (element = new HashElement());
        element.target = target;
        element.paused = !!paused;
        return element;
      },
      _putElement: function(element) {
        element.actions.length = 0;
        element.actionIndex = 0;
        element.currentAction = null;
        element.paused = false;
        element.target = null;
        element.lock = false;
        this._elementPool.push(element);
      },
      addAction: function(action, target, paused) {
        if (!action) throw new Error(cc._getError(1e3));
        if (!target) throw new Error(cc._getError(1e3));
        var element = this._hashTargets[target._id];
        if (element) element.actions || (element.actions = []); else {
          element = this._getElement(target, paused);
          this._hashTargets[target._id] = element;
          this._arrayTargets.push(element);
        }
        element.actions.push(action);
        action.startWithTarget(target);
      },
      removeAllActions: function() {
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];
          element && this.removeAllActionsFromTarget(element.target, true);
        }
      },
      removeAllActionsFromTarget: function(target, forceDelete) {
        if (null == target) return;
        var element = this._hashTargets[target._id];
        if (element) {
          element.actions.length = 0;
          this._deleteHashElement(element);
        }
      },
      removeAction: function(action) {
        if (null == action) return;
        var target = action.getOriginalTarget();
        var element = this._hashTargets[target._id];
        if (element) {
          for (var i = 0; i < element.actions.length; i++) if (element.actions[i] === action) {
            element.actions.splice(i, 1);
            element.actionIndex >= i && element.actionIndex--;
            break;
          }
        } else cc.logID(1001);
      },
      removeActionByTag: function(tag, target) {
        tag === cc.Action.TAG_INVALID && cc.logID(1002);
        cc.assertID(target, 1003);
        var element = this._hashTargets[target._id];
        if (element) {
          var limit = element.actions.length;
          for (var i = 0; i < limit; ++i) {
            var action = element.actions[i];
            if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
              this._removeActionAtIndex(i, element);
              break;
            }
          }
        }
      },
      getActionByTag: function(tag, target) {
        tag === cc.Action.TAG_INVALID && cc.logID(1004);
        var element = this._hashTargets[target._id];
        if (element) {
          if (null != element.actions) for (var i = 0; i < element.actions.length; ++i) {
            var action = element.actions[i];
            if (action && action.getTag() === tag) return action;
          }
          cc.logID(1005, tag);
        }
        return null;
      },
      getNumberOfRunningActionsInTarget: function(target) {
        var element = this._hashTargets[target._id];
        if (element) return element.actions ? element.actions.length : 0;
        return 0;
      },
      pauseTarget: function(target) {
        var element = this._hashTargets[target._id];
        element && (element.paused = true);
      },
      resumeTarget: function(target) {
        var element = this._hashTargets[target._id];
        element && (element.paused = false);
      },
      pauseAllRunningActions: function() {
        var idsWithActions = [];
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];
          if (element && !element.paused) {
            element.paused = true;
            idsWithActions.push(element.target);
          }
        }
        return idsWithActions;
      },
      resumeTargets: function(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) targetsToResume[i] && this.resumeTarget(targetsToResume[i]);
      },
      pauseTargets: function(targetsToPause) {
        if (!targetsToPause) return;
        for (var i = 0; i < targetsToPause.length; i++) targetsToPause[i] && this.pauseTarget(targetsToPause[i]);
      },
      purgeSharedManager: function() {
        cc.director.getScheduler().unscheduleUpdate(this);
      },
      _removeActionAtIndex: function(index, element) {
        var action = element.actions[index];
        element.actions.splice(index, 1);
        element.actionIndex >= index && element.actionIndex--;
        0 === element.actions.length && this._deleteHashElement(element);
      },
      _deleteHashElement: function(element) {
        var ret = false;
        if (element && !element.lock && this._hashTargets[element.target._id]) {
          delete this._hashTargets[element.target._id];
          var targets = this._arrayTargets;
          for (var i = 0, l = targets.length; i < l; i++) if (targets[i] === element) {
            targets.splice(i, 1);
            break;
          }
          this._putElement(element);
          ret = true;
        }
        return ret;
      },
      update: function(dt) {
        var locTargets = this._arrayTargets, locCurrTarget;
        for (var elt = 0; elt < locTargets.length; elt++) {
          this._currentTarget = locTargets[elt];
          locCurrTarget = this._currentTarget;
          if (!locCurrTarget.paused && locCurrTarget.actions) {
            locCurrTarget.lock = true;
            for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
              locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
              if (!locCurrTarget.currentAction) continue;
              locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));
              if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                locCurrTarget.currentAction.stop();
                var action = locCurrTarget.currentAction;
                locCurrTarget.currentAction = null;
                this.removeAction(action);
              }
              locCurrTarget.currentAction = null;
            }
            locCurrTarget.lock = false;
          }
          0 === locCurrTarget.actions.length && this._deleteHashElement(locCurrTarget) && elt--;
        }
      }
    };
    false;
  }), {
    "../core/platform/CCClass": 155,
    "../core/platform/js": 175
  } ],
  10: [ (function(require, module, exports) {
    require("./CCActionManager");
    require("./CCAction");
    require("./CCActionInterval");
    require("./CCActionInstant");
    require("./CCActionEase");
    require("./CCActionCatmullRom");
  }), {
    "./CCAction": 4,
    "./CCActionCatmullRom": 5,
    "./CCActionEase": 6,
    "./CCActionInstant": 7,
    "./CCActionInterval": 8,
    "./CCActionManager": 9
  } ],
  11: [ (function(require, module, exports) {
    var js = cc.js;
    var Playable = require("./playable");
    var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
    var quickFindIndex = require("./animation-curves").quickFindIndex;
    var sampleMotionPaths = require("./motion-path-helper").sampleMotionPaths;
    var EventAnimCurve = require("./animation-curves").EventAnimCurve;
    var EventInfo = require("./animation-curves").EventInfo;
    var WrapModeMask = require("./types").WrapModeMask;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    function AnimationAnimator(target, animation) {
      Playable.call(this);
      this.target = target;
      this.animation = animation;
      this._anims = new js.array.MutableForwardIterator([]);
    }
    js.extend(AnimationAnimator, Playable);
    var p = AnimationAnimator.prototype;
    p.playState = function(state, startTime) {
      if (!state.clip) return;
      state.curveLoaded || initClipData(this.target, state);
      state.animator = this;
      state.play();
      "number" === typeof startTime && state.setTime(startTime);
      this.play();
    };
    p.stopStatesExcept = function(state) {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        if (anim === state) continue;
        this.stopState(anim);
      }
    };
    p.addAnimation = function(anim) {
      var index = this._anims.array.indexOf(anim);
      -1 === index && this._anims.push(anim);
      anim._setListeners(this.animation);
    };
    p.removeAnimation = function(anim) {
      var index = this._anims.array.indexOf(anim);
      if (index >= 0) {
        this._anims.fastRemoveAt(index);
        0 === this._anims.array.length && this.stop();
      } else cc.errorID(3908);
      anim.animator = null;
    };
    p.sample = function() {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        anim.sample();
      }
    };
    p.stopState = function(state) {
      state && state.stop();
    };
    p.pauseState = function(state) {
      state && state.pause();
    };
    p.resumeState = function(state) {
      state && state.resume();
      this.isPaused && this.resume();
    };
    p.setStateTime = function(state, time) {
      if (void 0 !== time) {
        if (state) {
          state.setTime(time);
          state.sample();
        }
      } else {
        time = state;
        var array = this._anims.array;
        for (var i = 0; i < array.length; ++i) {
          var anim = array[i];
          anim.setTime(time);
          anim.sample();
        }
      }
    };
    p.onStop = function() {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        anim.stop();
      }
    };
    p.onPause = function() {
      var array = this._anims.array;
      for (var i = 0; i < array.length; ++i) {
        var anim = array[i];
        anim.pause();
        anim.animator = null;
      }
    };
    p.onResume = function() {
      var array = this._anims.array;
      for (var i = 0; i < array.length; ++i) {
        var anim = array[i];
        anim.animator = this;
        anim.resume();
      }
    };
    p._reloadClip = function(state) {
      initClipData(this.target, state);
    };
    function createBatchedProperty(propPath, firstDotIndex, mainValue, animValue) {
      mainValue = mainValue.clone();
      var nextValue = mainValue;
      var leftIndex = firstDotIndex + 1;
      var rightIndex = propPath.indexOf(".", leftIndex);
      while (-1 !== rightIndex) {
        var nextName = propPath.slice(leftIndex, rightIndex);
        nextValue = nextValue[nextName];
        leftIndex = rightIndex + 1;
        rightIndex = propPath.indexOf(".", leftIndex);
      }
      var lastPropName = propPath.slice(leftIndex);
      nextValue[lastPropName] = animValue;
      return mainValue;
    }
    false;
    function splitPropPath(propPath) {
      var array = propPath.split(".");
      array.shift();
      return array.length > 0 ? array : null;
    }
    function initClipData(root, state) {
      var clip = state.clip;
      var curves = state.curves;
      curves.length = 0;
      state.duration = clip.duration;
      state.speed = clip.speed;
      state.wrapMode = clip.wrapMode;
      state.frameRate = clip.sample;
      (state.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? state.repeatCount = Infinity : state.repeatCount = 1;
      function checkMotionPath(motionPath) {
        if (!Array.isArray(motionPath)) return false;
        for (var i = 0, l = motionPath.length; i < l; i++) {
          var controls = motionPath[i];
          if (!Array.isArray(controls) || 6 !== controls.length) return false;
        }
        return true;
      }
      function createPropCurve(target, propPath, keyframes) {
        var isMotionPathProp = target instanceof cc.Node && "position" === propPath;
        var motionPaths = [];
        var curve = new DynamicAnimCurve();
        curve.target = target;
        var propName, propValue;
        var dotIndex = propPath.indexOf(".");
        var hasSubProp = -1 !== dotIndex;
        if (hasSubProp) {
          propName = propPath.slice(0, dotIndex);
          propValue = target[propName];
        } else propName = propPath;
        curve.prop = propName;
        curve.subProps = splitPropPath(propPath);
        for (var i = 0, l = keyframes.length; i < l; i++) {
          var keyframe = keyframes[i];
          var ratio = keyframe.frame / state.duration;
          curve.ratios.push(ratio);
          if (isMotionPathProp) {
            var motionPath = keyframe.motionPath;
            if (motionPath && !checkMotionPath(motionPath)) {
              cc.errorID(3904, target.name, propPath, i);
              motionPath = null;
            }
            motionPaths.push(motionPath);
          }
          var curveValue = keyframe.value;
          curve.values.push(curveValue);
          var curveTypes = keyframe.curve;
          if (curveTypes) {
            if ("string" === typeof curveTypes) {
              curve.types.push(curveTypes);
              continue;
            }
            if (Array.isArray(curveTypes)) {
              curveTypes[0] === curveTypes[1] && curveTypes[2] === curveTypes[3] ? curve.types.push(DynamicAnimCurve.Linear) : curve.types.push(DynamicAnimCurve.Bezier(curveTypes));
              continue;
            }
          }
          curve.types.push(DynamicAnimCurve.Linear);
        }
        isMotionPathProp && sampleMotionPaths(motionPaths, curve, clip.duration, clip.sample);
        var ratios = curve.ratios;
        var currRatioDif, lastRatioDif;
        var canOptimize = true;
        var EPSILON = 1e-6;
        for (var _i = 1, _l = ratios.length; _i < _l; _i++) {
          currRatioDif = ratios[_i] - ratios[_i - 1];
          if (1 === _i) lastRatioDif = currRatioDif; else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
            canOptimize = false;
            break;
          }
        }
        curve._findFrameIndex = canOptimize ? quickFindIndex : binarySearch;
        return curve;
      }
      function createTargetCurves(target, curveData) {
        var propsData = curveData.props;
        var compsData = curveData.comps;
        if (propsData) for (var propPath in propsData) {
          var data = propsData[propPath];
          var curve = createPropCurve(target, propPath, data);
          curves.push(curve);
        }
        if (compsData) for (var compName in compsData) {
          var comp = target.getComponent(compName);
          if (!comp) continue;
          var compData = compsData[compName];
          for (var propPath in compData) {
            var data = compData[propPath];
            var curve = createPropCurve(comp, propPath, data);
            curves.push(curve);
          }
        }
      }
      var curveData = clip.curveData;
      var childrenCurveDatas = curveData.paths;
      createTargetCurves(root, curveData);
      for (var namePath in childrenCurveDatas) {
        var target = cc.find(namePath, root);
        if (!target) continue;
        var childCurveDatas = childrenCurveDatas[namePath];
        createTargetCurves(target, childCurveDatas);
      }
      var events = clip.events;
      if (true, events) {
        var curve;
        for (var i = 0, l = events.length; i < l; i++) {
          if (!curve) {
            curve = new EventAnimCurve();
            curve.target = root;
            curves.push(curve);
          }
          var eventData = events[i];
          var ratio = eventData.frame / state.duration;
          var eventInfo;
          var index = binarySearch(curve.ratios, ratio);
          if (index >= 0) eventInfo = curve.events[index]; else {
            eventInfo = new EventInfo();
            curve.ratios.push(ratio);
            curve.events.push(eventInfo);
          }
          eventInfo.add(eventData.func, eventData.params);
        }
      }
    }
    false;
    module.exports = AnimationAnimator;
  }), {
    "../core/utils/binary-search": 227,
    "./animation-curves": 13,
    "./motion-path-helper": 19,
    "./playable": 20,
    "./types": 21
  } ],
  12: [ (function(require, module, exports) {
    var AnimationClip = cc.Class({
      name: "cc.AnimationClip",
      extends: cc.Asset,
      properties: {
        _duration: {
          default: 0,
          type: "Float"
        },
        duration: {
          get: function() {
            return this._duration;
          }
        },
        sample: {
          default: 60
        },
        speed: {
          default: 1
        },
        wrapMode: {
          default: cc.WrapMode.Normal
        },
        curveData: {
          default: {},
          visible: false
        },
        events: {
          default: [],
          visible: false
        }
      },
      statics: {
        createWithSpriteFrames: function(spriteFrames, sample) {
          if (!Array.isArray(spriteFrames)) {
            cc.errorID(3905);
            return null;
          }
          var clip = new AnimationClip();
          clip.sample = sample || clip.sample;
          clip._duration = spriteFrames.length / clip.sample;
          var frames = [];
          var step = 1 / clip.sample;
          for (var i = 0, l = spriteFrames.length; i < l; i++) frames[i] = {
            frame: i * step,
            value: spriteFrames[i]
          };
          clip.curveData = {
            comps: {
              "cc.Sprite": {
                spriteFrame: frames
              }
            }
          };
          return clip;
        }
      }
    });
    cc.AnimationClip = module.exports = AnimationClip;
  }), {} ],
  13: [ (function(require, module, exports) {
    var bezierByTime = require("./bezier").bezierByTime;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    var WrapModeMask = require("./types").WrapModeMask;
    var WrappedInfo = require("./types").WrappedInfo;
    function computeRatioByType(ratio, type) {
      if ("string" === typeof type) {
        var func = cc.Easing[type];
        func ? ratio = func(ratio) : cc.errorID(3906, type);
      } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
      return ratio;
    }
    var AnimCurve = cc.Class({
      name: "cc.AnimCurve",
      sample: function(time, ratio, state) {},
      onTimeChangedManually: void 0
    });
    function quickFindIndex(ratios, ratio) {
      var length = ratios.length - 1;
      if (0 === length) return 0;
      var start = ratios[0];
      if (ratio < start) return 0;
      var end = ratios[length];
      if (ratio > end) return length;
      ratio = (ratio - start) / (end - start);
      var eachLength = 1 / length;
      var index = ratio / eachLength;
      var floorIndex = 0 | index;
      var EPSILON = 1e-6;
      if (index - floorIndex < EPSILON) return floorIndex;
      return ~(floorIndex + 1);
    }
    var DynamicAnimCurve = cc.Class({
      name: "cc.DynamicAnimCurve",
      extends: AnimCurve,
      properties: {
        target: null,
        prop: "",
        values: [],
        ratios: [],
        types: [],
        subProps: null
      },
      _findFrameIndex: binarySearch,
      sample: function(time, ratio, state) {
        var values = this.values;
        var ratios = this.ratios;
        var frameCount = ratios.length;
        if (0 === frameCount) return;
        var value;
        var index = this._findFrameIndex(ratios, ratio);
        if (index < 0) {
          index = ~index;
          if (index <= 0) value = values[0]; else if (index >= frameCount) value = values[frameCount - 1]; else {
            var fromVal = values[index - 1];
            var isNumber = "number" === typeof fromVal;
            var canLerp = fromVal && fromVal.lerp;
            if (isNumber || canLerp) {
              var fromRatio = ratios[index - 1];
              var toRatio = ratios[index];
              var type = this.types[index - 1];
              var ratioBetweenFrames = (ratio - fromRatio) / (toRatio - fromRatio);
              type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type));
              var toVal = values[index];
              isNumber ? value = fromVal + (toVal - fromVal) * ratioBetweenFrames : canLerp && (value = fromVal.lerp(toVal, ratioBetweenFrames));
            } else value = fromVal;
          }
        } else value = values[index];
        var subProps = this.subProps;
        if (subProps) {
          var mainProp = this.target[this.prop];
          var subProp = mainProp;
          for (var i = 0; i < subProps.length - 1; i++) {
            var subPropName = subProps[i];
            if (!subProp) return;
            subProp = subProp[subPropName];
          }
          var propName = subProps[subProps.length - 1];
          if (!subProp) return;
          subProp[propName] = value;
          value = mainProp;
        }
        this.target[this.prop] = value;
      }
    });
    DynamicAnimCurve.Linear = null;
    DynamicAnimCurve.Bezier = function(controlPoints) {
      return controlPoints;
    };
    var EventInfo = function() {
      this.events = [];
    };
    EventInfo.prototype.add = function(func, params) {
      this.events.push({
        func: func || "",
        params: params || []
      });
    };
    var EventAnimCurve = cc.Class({
      name: "cc.EventAnimCurve",
      extends: AnimCurve,
      properties: {
        target: null,
        ratios: [],
        events: [],
        _wrappedInfo: {
          default: function() {
            return new WrappedInfo();
          }
        },
        _lastWrappedInfo: null,
        _ignoreIndex: NaN
      },
      _wrapIterations: function(iterations) {
        iterations - (0 | iterations) === 0 && (iterations -= 1);
        return 0 | iterations;
      },
      sample: function(time, ratio, state) {
        var length = this.ratios.length;
        var currentWrappedInfo = state.getWrappedInfo(state.time, this._wrappedInfo);
        var direction = currentWrappedInfo.direction;
        var currentIndex = binarySearch(this.ratios, currentWrappedInfo.ratio);
        if (currentIndex < 0) {
          currentIndex = ~currentIndex - 1;
          direction < 0 && (currentIndex += 1);
        }
        this._ignoreIndex !== currentIndex && (this._ignoreIndex = NaN);
        currentWrappedInfo.frameIndex = currentIndex;
        if (!this._lastWrappedInfo) {
          this._fireEvent(currentIndex);
          this._lastWrappedInfo = new WrappedInfo(currentWrappedInfo);
          return;
        }
        var wrapMode = state.wrapMode;
        var currentIterations = this._wrapIterations(currentWrappedInfo.iterations);
        var lastWrappedInfo = this._lastWrappedInfo;
        var lastIterations = this._wrapIterations(lastWrappedInfo.iterations);
        var lastIndex = lastWrappedInfo.frameIndex;
        var lastDirection = lastWrappedInfo.direction;
        var interationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
        if (lastIndex === currentIndex && interationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== currentIndex || interationsChanged) {
          direction = lastDirection;
          do {
            if (lastIndex !== currentIndex) {
              if (-1 === direction && 0 === lastIndex && currentIndex > 0) {
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length;
                lastIterations++;
              } else if (1 === direction && lastIndex === length - 1 && currentIndex < length - 1) {
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1;
                lastIterations++;
              }
              if (lastIndex === currentIndex) break;
              if (lastIterations > currentIterations) break;
            }
            lastIndex += direction;
            cc.director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
          } while (lastIndex !== currentIndex && lastIndex > -1 && lastIndex < length);
        }
        this._lastWrappedInfo.set(currentWrappedInfo);
      },
      _fireEvent: function(index) {
        if (index < 0 || index >= this.events.length || this._ignoreIndex === index) return;
        var eventInfo = this.events[index];
        var events = eventInfo.events;
        if (!this.target.isValid) return;
        var components = this.target._components;
        for (var i = 0; i < events.length; i++) {
          var event = events[i];
          var funcName = event.func;
          for (var j = 0; j < components.length; j++) {
            var component = components[j];
            var func = component[funcName];
            func && func.apply(component, event.params);
          }
        }
      },
      onTimeChangedManually: function(time, state) {
        this._lastWrappedInfo = null;
        this._ignoreIndex = NaN;
        var info = state.getWrappedInfo(time, this._wrappedInfo);
        var direction = info.direction;
        var frameIndex = binarySearch(this.ratios, info.ratio);
        if (frameIndex < 0) {
          frameIndex = ~frameIndex - 1;
          direction < 0 && (frameIndex += 1);
          this._ignoreIndex = frameIndex;
        }
      }
    });
    false;
    module.exports = {
      AnimCurve: AnimCurve,
      DynamicAnimCurve: DynamicAnimCurve,
      EventAnimCurve: EventAnimCurve,
      EventInfo: EventInfo,
      computeRatioByType: computeRatioByType,
      quickFindIndex: quickFindIndex
    };
  }), {
    "../core/utils/binary-search": 227,
    "./bezier": 16,
    "./types": 21
  } ],
  14: [ (function(require, module, exports) {
    var js = cc.js;
    var AnimationManager = cc.Class({
      ctor: function() {
        this._anims = new js.array.MutableForwardIterator([]);
        this._delayEvents = [];
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
      },
      update: function(dt) {
        var iterator = this._anims;
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var anim = array[iterator.i];
          anim._isPlaying && !anim._isPaused && anim.update(dt);
        }
        var events = this._delayEvents;
        for (var i = 0, l = events.length; i < l; i++) {
          var event = events[i];
          event.target[event.func].apply(event.target, event.args);
        }
        events.length = 0;
      },
      destruct: function() {},
      addAnimation: function(anim) {
        var index = this._anims.array.indexOf(anim);
        -1 === index && this._anims.push(anim);
      },
      removeAnimation: function(anim) {
        var index = this._anims.array.indexOf(anim);
        index >= 0 ? this._anims.fastRemoveAt(index) : cc.errorID(3907);
      },
      pushDelayEvent: function(target, func, args) {
        this._delayEvents.push({
          target: target,
          func: func,
          args: args
        });
      }
    });
    cc.AnimationManager = module.exports = AnimationManager;
  }), {} ],
  15: [ (function(require, module, exports) {
    var js = cc.js;
    var Playable = require("./playable");
    var Types = require("./types");
    var WrappedInfo = Types.WrappedInfo;
    var WrapMode = Types.WrapMode;
    var WrapModeMask = Types.WrapModeMask;
    function AnimationState(clip, name) {
      Playable.call(this);
      this._currentFramePlayed = false;
      this._delay = 0;
      this._delayTime = 0;
      this._wrappedInfo = new WrappedInfo();
      this._lastWrappedInfo = null;
      this._process = process;
      this._clip = clip;
      this._name = name || clip && clip.name;
      this.animator = null;
      this.curves = [];
      this.delay = 0;
      this.repeatCount = 1;
      this.duration = 1;
      this.speed = 1;
      this.wrapMode = WrapMode.Normal;
      this.time = 0;
      this._target = null;
      this._lastframeEventOn = false;
      this.emit = function() {
        var args = new Array(arguments.length);
        for (var i = 0, l = args.length; i < l; i++) args[i] = arguments[i];
        cc.director.getAnimationManager().pushDelayEvent(this, "_emit", args);
      };
    }
    js.extend(AnimationState, Playable);
    var proto = AnimationState.prototype;
    proto._emit = function(type, detail) {
      this._target && this._target.isValid && this._target.emit(type, detail);
    };
    proto.on = function(type, callback, target) {
      if (this._target && this._target.isValid) {
        "lastframe" === type && (this._lastframeEventOn = true);
        return this._target.on(type, callback, target);
      }
      return null;
    };
    proto.once = function(type, callback, target) {
      var _this = this;
      if (!this._target || !this._target.isValid) return null;
      var _ret = (function() {
        "lastframe" === type && (_this._lastframeEventOn = true);
        var self = _this;
        return {
          v: _this._target.once(type, (function(event) {
            callback.call(target, event);
            self._lastframeEventOn = false;
          }))
        };
      })();
      if ("object" === typeof _ret) return _ret.v;
    };
    proto.off = function(type, callback, target) {
      if (this._target && this._target.isValid) {
        "lastframe" === type && (this._target.hasEventListener(type) || (this._lastframeEventOn = false));
        this._target.off(type, callback, target);
      }
    };
    proto._setListeners = function(target) {
      this._target = target;
    };
    proto.onPlay = function() {
      this.setTime(0);
      this._delayTime = this._delay;
      cc.director.getAnimationManager().addAnimation(this);
      this.animator && this.animator.addAnimation(this);
      this.emit("play", this);
    };
    proto.onStop = function() {
      this.isPaused || cc.director.getAnimationManager().removeAnimation(this);
      this.animator && this.animator.removeAnimation(this);
      this.emit("stop", this);
    };
    proto.onResume = function() {
      cc.director.getAnimationManager().addAnimation(this);
      this.emit("resume", this);
    };
    proto.onPause = function() {
      cc.director.getAnimationManager().removeAnimation(this);
      this.emit("pause", this);
    };
    proto.setTime = function(time) {
      this._currentFramePlayed = false;
      this.time = time || 0;
      var curves = this.curves;
      for (var i = 0, l = curves.length; i < l; i++) {
        var curve = curves[i];
        curve.onTimeChangedManually && curve.onTimeChangedManually(time, this);
      }
    };
    function process() {
      var info = this.sample();
      if (this._lastframeEventOn) {
        var lastInfo;
        lastInfo = this._lastWrappedInfo ? this._lastWrappedInfo : this._lastWrappedInfo = new WrappedInfo(info);
        this.repeatCount > 1 && (0 | info.iterations) > (0 | lastInfo.iterations) && this.emit("lastframe", this);
        lastInfo.set(info);
      }
      if (info.stopped) {
        this.stop();
        this.emit("finished", this);
      }
    }
    function simpleProcess() {
      var time = this.time;
      var duration = this.duration;
      if (time > duration) {
        time %= duration;
        0 === time && (time = duration);
      } else if (time < 0) {
        time %= duration;
        0 !== time && (time += duration);
      }
      var ratio = time / duration;
      var curves = this.curves;
      for (var i = 0, len = curves.length; i < len; i++) {
        var curve = curves[i];
        curve.sample(time, ratio, this);
      }
      if (this._lastframeEventOn) {
        void 0 === this._lastIterations && (this._lastIterations = ratio);
        (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) && this.emit("lastframe", this);
        this._lastIterations = ratio;
      }
    }
    proto.update = function(delta) {
      if (this._delayTime > 0) {
        this._delayTime -= delta;
        if (this._delayTime > 0) return;
      }
      this._currentFramePlayed ? this.time += delta * this.speed : this._currentFramePlayed = true;
      this._process();
    };
    proto._needRevers = function(currentIterations) {
      var wrapMode = this.wrapMode;
      var needRevers = false;
      if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
        var isEnd = currentIterations - (0 | currentIterations) === 0;
        isEnd && currentIterations > 0 && (currentIterations -= 1);
        var isOddIteration = 1 & currentIterations;
        isOddIteration && (needRevers = !needRevers);
      }
      (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needRevers = !needRevers);
      return needRevers;
    };
    proto.getWrappedInfo = function(time, info) {
      info = info || new WrappedInfo();
      var stopped = false;
      var duration = this.duration;
      var repeatCount = this.repeatCount;
      var currentIterations = time > 0 ? time / duration : -time / duration;
      if (currentIterations >= repeatCount) {
        currentIterations = repeatCount;
        stopped = true;
        var tempRatio = repeatCount - (0 | repeatCount);
        0 === tempRatio && (tempRatio = 1);
        time = tempRatio * duration * (time > 0 ? 1 : -1);
      }
      if (time > duration) {
        var tempTime = time % duration;
        time = 0 === tempTime ? duration : tempTime;
      } else if (time < 0) {
        time %= duration;
        0 !== time && (time += duration);
      }
      var needRevers = false;
      var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
      shouldWrap && (needRevers = this._needRevers(currentIterations));
      var direction = needRevers ? -1 : 1;
      this.speed < 0 && (direction *= -1);
      shouldWrap && needRevers && (time = duration - time);
      info.ratio = time / duration;
      info.time = time;
      info.direction = direction;
      info.stopped = stopped;
      info.iterations = currentIterations;
      return info;
    };
    proto.sample = function() {
      var info = this.getWrappedInfo(this.time, this._wrappedInfo);
      var curves = this.curves;
      for (var i = 0, len = curves.length; i < len; i++) {
        var curve = curves[i];
        curve.sample(info.time, info.ratio, this);
      }
      return info;
    };
    js.get(proto, "clip", (function() {
      return this._clip;
    }));
    js.get(proto, "name", (function() {
      return this._name;
    }));
    js.obsolete(proto, "AnimationState.length", "duration");
    js.getset(proto, "curveLoaded", (function() {
      return this.curves.length > 0;
    }), (function() {
      this.curves.length = 0;
    }));
    js.getset(proto, "wrapMode", (function() {
      return this._wrapMode;
    }), (function(value) {
      this._wrapMode = value;
      false;
      this.time = 0;
      value & WrapModeMask.Loop ? this.repeatCount = Infinity : this.repeatCount = 1;
    }));
    js.getset(proto, "repeatCount", (function() {
      return this._repeatCount;
    }), (function(value) {
      this._repeatCount = value;
      var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
      var reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
      this._process = Infinity !== value || shouldWrap || reverse ? process : simpleProcess;
    }));
    js.getset(proto, "delay", (function() {
      return this._delay;
    }), (function(value) {
      this._delayTime = this._delay = value;
    }));
    cc.AnimationState = module.exports = AnimationState;
  }), {
    "./playable": 20,
    "./types": 21
  } ],
  16: [ (function(require, module, exports) {
    function bezier(C1, C2, C3, C4, t) {
      var t1 = 1 - t;
      return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
    }
    var cos = Math.cos, acos = Math.acos, max = Math.max, pi = Math.PI, tau = 2 * pi, sqrt = Math.sqrt;
    function crt(v) {
      return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
    }
    function cardano(curve, x) {
      var pa = x - 0;
      var pb = x - curve[0];
      var pc = x - curve[2];
      var pd = x - 1;
      var pa3 = 3 * pa;
      var pb3 = 3 * pb;
      var pc3 = 3 * pc;
      var d = -pa + pb3 - pc3 + pd, rd = 1 / d, r3 = 1 / 3, a = (pa3 - 6 * pb + pc3) * rd, a3 = a * r3, b = (-pa3 + pb3) * rd, c = pa * rd, p = (3 * b - a * a) * r3, p3 = p * r3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3, u1, v1, x1, x2, x3;
      if (discriminant < 0) {
        var mp3 = -p * r3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t = -q / (2 * r), cosphi = t < -1 ? -1 : t > 1 ? 1 : t, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
        x1 = t1 * cos(phi * r3) - a3;
        x2 = t1 * cos((phi + tau) * r3) - a3;
        x3 = t1 * cos((phi + 2 * tau) * r3) - a3;
        return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x1, x2, x3) : max(x1, x2) : 0 <= x3 && x3 <= 1 ? max(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x2, x3) : x2 : x3;
      }
      if (0 === discriminant) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2 * u1 - a3;
        x2 = -u1 - a3;
        return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max(x1, x2) : x1 : x2;
      }
      var sd = sqrt(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      x1 = u1 - v1 - a3;
      return x1;
    }
    function bezierByTime(controlPoints, x) {
      var percent = cardano(controlPoints, x);
      var p0y = 0;
      var p1y = controlPoints[1];
      var p2y = controlPoints[3];
      var p3y = 1;
      var t1 = 1 - percent;
      return p0y * t1 * t1 * t1 + 3 * p1y * percent * t1 * t1 + 3 * p2y * percent * percent * t1 + p3y * percent * percent * percent;
    }
    false;
    module.exports = {
      bezier: bezier,
      bezierByTime: bezierByTime
    };
  }), {} ],
  17: [ (function(require, module, exports) {
    var Easing = {
      constant: function() {
        return 0;
      },
      linear: function(k) {
        return k;
      },
      quadIn: function(k) {
        return k * k;
      },
      quadOut: function(k) {
        return k * (2 - k);
      },
      quadInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k;
        return -.5 * (--k * (k - 2) - 1);
      },
      cubicIn: function(k) {
        return k * k * k;
      },
      cubicOut: function(k) {
        return --k * k * k + 1;
      },
      cubicInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k * k;
        return .5 * ((k -= 2) * k * k + 2);
      },
      quartIn: function(k) {
        return k * k * k * k;
      },
      quartOut: function(k) {
        return 1 - --k * k * k * k;
      },
      quartInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k * k * k;
        return -.5 * ((k -= 2) * k * k * k - 2);
      },
      quintIn: function(k) {
        return k * k * k * k * k;
      },
      quintOut: function(k) {
        return --k * k * k * k * k + 1;
      },
      quintInOut: function(k) {
        if ((k *= 2) < 1) return .5 * k * k * k * k * k;
        return .5 * ((k -= 2) * k * k * k * k + 2);
      },
      sineIn: function(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      sineOut: function(k) {
        return Math.sin(k * Math.PI / 2);
      },
      sineInOut: function(k) {
        return .5 * (1 - Math.cos(Math.PI * k));
      },
      expoIn: function(k) {
        return 0 === k ? 0 : Math.pow(1024, k - 1);
      },
      expoOut: function(k) {
        return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
      },
      expoInOut: function(k) {
        if (0 === k) return 0;
        if (1 === k) return 1;
        if ((k *= 2) < 1) return .5 * Math.pow(1024, k - 1);
        return .5 * (2 - Math.pow(2, -10 * (k - 1)));
      },
      circIn: function(k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      circOut: function(k) {
        return Math.sqrt(1 - --k * k);
      },
      circInOut: function(k) {
        if ((k *= 2) < 1) return -.5 * (Math.sqrt(1 - k * k) - 1);
        return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      },
      elasticIn: function(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p);
      },
      elasticOut: function(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      },
      elasticInOut: function(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        if ((k *= 2) < 1) return a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * -.5;
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1;
      },
      backIn: function(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      backOut: function(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      backInOut: function(k) {
        var s = 2.5949095;
        if ((k *= 2) < 1) return k * k * ((s + 1) * k - s) * .5;
        return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      },
      bounceOut: function(k) {
        return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
      },
      smooth: function(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * (3 - 2 * t);
      },
      fade: function(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * t * (t * (6 * t - 15) + 10);
      }
    };
    function _makeOutIn(fnIn, fnOut) {
      return function(k) {
        if (k < .5) return fnOut(2 * k) / 2;
        return fnIn(2 * k - 1) / 2 + .5;
      };
    }
    Easing.quadOutIn = _makeOutIn(Easing.quadIn, Easing.quadOut);
    Easing.cubicOutIn = _makeOutIn(Easing.cubicIn, Easing.cubicOut);
    Easing.quartOutIn = _makeOutIn(Easing.quartIn, Easing.quartOut);
    Easing.quintOutIn = _makeOutIn(Easing.quintIn, Easing.quintOut);
    Easing.sineOutIn = _makeOutIn(Easing.sineIn, Easing.sineOut);
    Easing.expoOutIn = _makeOutIn(Easing.expoIn, Easing.expoOut);
    Easing.circOutIn = _makeOutIn(Easing.circIn, Easing.circOut);
    Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
    Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
    Easing.bounceIn = function(k) {
      return 1 - Easing.bounceOut(1 - k);
    };
    Easing.bounceInOut = function(k) {
      if (k < .5) return .5 * Easing.bounceIn(2 * k);
      return .5 * Easing.bounceOut(2 * k - 1) + .5;
    };
    Easing.bounceOutIn = _makeOutIn(Easing.bounceIn, Easing.bounceOut);
    cc.Easing = module.exports = Easing;
  }), {} ],
  18: [ (function(require, module, exports) {
    require("./bezier");
    require("./easing");
    require("./types");
    require("./motion-path-helper");
    require("./animation-curves");
    require("./animation-clip");
    require("./animation-manager");
    require("./animation-state");
    require("./animation-animator");
  }), {
    "./animation-animator": 11,
    "./animation-clip": 12,
    "./animation-curves": 13,
    "./animation-manager": 14,
    "./animation-state": 15,
    "./bezier": 16,
    "./easing": 17,
    "./motion-path-helper": 19,
    "./types": 21
  } ],
  19: [ (function(require, module, exports) {
    var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
    var computeRatioByType = require("./animation-curves").computeRatioByType;
    var bezier = require("./bezier").bezier;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    var v2 = cc.v2;
    function Curve(points) {
      this.points = points || [];
      this.beziers = [];
      this.ratios = [];
      this.progresses = [];
      this.length = 0;
      this.computeBeziers();
    }
    Curve.prototype.computeBeziers = function() {
      this.beziers.length = 0;
      this.ratios.length = 0;
      this.progresses.length = 0;
      this.length = 0;
      var bezier;
      for (var i = 1; i < this.points.length; i++) {
        var startPoint = this.points[i - 1];
        var endPoint = this.points[i];
        bezier = new Bezier();
        bezier.start = startPoint.pos;
        bezier.startCtrlPoint = startPoint.out;
        bezier.end = endPoint.pos;
        bezier.endCtrlPoint = endPoint.in;
        this.beziers.push(bezier);
        this.length += bezier.getLength();
      }
      var current = 0;
      for (var i = 0; i < this.beziers.length; i++) {
        bezier = this.beziers[i];
        this.ratios[i] = bezier.getLength() / this.length;
        this.progresses[i] = current += this.ratios[i];
      }
      return this.beziers;
    };
    function Bezier() {
      this.start = v2();
      this.end = v2();
      this.startCtrlPoint = v2();
      this.endCtrlPoint = v2();
    }
    Bezier.prototype.getPointAt = function(u) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t);
    };
    Bezier.prototype.getPoint = function(t) {
      var x = bezier(this.start.x, this.startCtrlPoint.x, this.endCtrlPoint.x, this.end.x, t);
      var y = bezier(this.start.y, this.startCtrlPoint.y, this.endCtrlPoint.y, this.end.y, t);
      return new v2(x, y);
    };
    Bezier.prototype.getLength = function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    };
    Bezier.prototype.getLengths = function(divisions) {
      divisions || (divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1) return this.cacheArcLengths;
      var cache = [];
      var current, last = this.getPoint(0), vector = v2();
      var p, sum = 0;
      cache.push(0);
      for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        vector.x = last.x - current.x;
        vector.y = last.y - current.y;
        sum += vector.mag();
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    };
    Bezier.prototype.getUtoTmapping = function(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0, il = arcLengths.length;
      var targetArcLength;
      targetArcLength = distance || u * arcLengths[il - 1];
      var low = 0, high = il - 1, comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
          continue;
        }
        if (comparison > 0) {
          high = i - 1;
          continue;
        }
        high = i;
        break;
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        var t = i / (il - 1);
        return t;
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    };
    function sampleMotionPaths(motionPaths, data, duration, fps) {
      function createControlPoints(array) {
        if (array instanceof cc.Vec2) return {
          in: array,
          pos: array,
          out: array
        };
        if (Array.isArray(array) && 6 === array.length) return {
          in: v2(array[2], array[3]),
          pos: v2(array[0], array[1]),
          out: v2(array[4], array[5])
        };
        return {
          in: cc.Vec2.ZERO,
          pos: cc.Vec2.ZERO,
          out: cc.Vec2.ZERO
        };
      }
      var values = data.values;
      if (0 === motionPaths.length || 0 === values.length) return;
      values = values.map((function(value) {
        return v2(value[0], value[1]);
      }));
      if (1 === values.length) {
        data.values = values;
        return;
      }
      var types = data.types;
      var ratios = data.ratios;
      var newValues = data.values = [];
      var newTypes = data.types = [];
      var newRatios = data.ratios = [];
      function addNewDatas(value, type, ratio) {
        newValues.push(value);
        newTypes.push(type);
        newRatios.push(ratio);
      }
      var startRatioOffset = 0;
      var EPSILON = 1e-6;
      var newType = DynamicAnimCurve.Linear;
      for (var i = 0, l = motionPaths.length; i < l - 1; i++) {
        var motionPath = motionPaths[i];
        var ratio = ratios[i];
        var nextRatio = ratios[i + 1];
        var betweenRatio = nextRatio - ratio;
        var value = values[i];
        var nextValue = values[i + 1];
        var type = types[i];
        var results = [];
        var progress = startRatioOffset / betweenRatio;
        var speed = 1 / (betweenRatio * duration * fps);
        var finalProgress;
        if (motionPath && motionPath.length > 0) {
          var points = [];
          points.push(createControlPoints(value));
          for (var j = 0, l2 = motionPath.length; j < l2; j++) {
            var controlPoints = createControlPoints(motionPath[j]);
            points.push(controlPoints);
          }
          points.push(createControlPoints(nextValue));
          var curve = new Curve(points);
          curve.computeBeziers();
          var progresses = curve.progresses;
          while (1 - progress > EPSILON) {
            finalProgress = progress;
            finalProgress = computeRatioByType(finalProgress, type);
            var pos, bezier, normal, length;
            if (finalProgress < 0) {
              bezier = curve.beziers[0];
              length = (0 - finalProgress) * bezier.getLength();
              normal = bezier.start.sub(bezier.endCtrlPoint).normalize();
              pos = bezier.start.add(normal.mul(length));
            } else if (finalProgress > 1) {
              bezier = curve.beziers[curve.beziers.length - 1];
              length = (finalProgress - 1) * bezier.getLength();
              normal = bezier.end.sub(bezier.startCtrlPoint).normalize();
              pos = bezier.end.add(normal.mul(length));
            } else {
              var bezierIndex = binarySearch(progresses, finalProgress);
              bezierIndex < 0 && (bezierIndex = ~bezierIndex);
              finalProgress -= bezierIndex > 0 ? progresses[bezierIndex - 1] : 0;
              finalProgress /= curve.ratios[bezierIndex];
              pos = curve.beziers[bezierIndex].getPointAt(finalProgress);
            }
            results.push(pos);
            progress += speed;
          }
        } else while (1 - progress > EPSILON) {
          finalProgress = progress;
          finalProgress = computeRatioByType(finalProgress, type);
          results.push(value.lerp(nextValue, finalProgress));
          progress += speed;
        }
        newType = "constant" === type ? type : DynamicAnimCurve.Linear;
        for (var j = 0, l2 = results.length; j < l2; j++) {
          var newRatio = ratio + startRatioOffset + speed * j * betweenRatio;
          addNewDatas(results[j], newType, newRatio);
        }
        startRatioOffset = Math.abs(progress - 1) > EPSILON ? (progress - 1) * betweenRatio : 0;
      }
      ratios[ratios.length - 1] !== newRatios[newRatios.length - 1] && addNewDatas(values[values.length - 1], newType, ratios[ratios.length - 1]);
    }
    false;
    module.exports = {
      sampleMotionPaths: sampleMotionPaths,
      Curve: Curve,
      Bezier: Bezier
    };
  }), {
    "../core/utils/binary-search": 227,
    "./animation-curves": 13,
    "./bezier": 16
  } ],
  20: [ (function(require, module, exports) {
    var js = cc.js;
    function Playable() {
      this._isPlaying = false;
      this._isPaused = false;
      this._stepOnce = false;
    }
    var prototype = Playable.prototype;
    js.get(prototype, "isPlaying", (function() {
      return this._isPlaying;
    }), true);
    js.get(prototype, "isPaused", (function() {
      return this._isPaused;
    }), true);
    var virtual = function() {};
    prototype.onPlay = virtual;
    prototype.onPause = virtual;
    prototype.onResume = virtual;
    prototype.onStop = virtual;
    prototype.onError = virtual;
    prototype.play = function() {
      if (this._isPlaying) if (this._isPaused) {
        this._isPaused = false;
        this.onResume();
      } else this.onError(cc._getError(3912)); else {
        this._isPlaying = true;
        this.onPlay();
      }
    };
    prototype.stop = function() {
      if (this._isPlaying) {
        this._isPlaying = false;
        this.onStop();
        this._isPaused = false;
      }
    };
    prototype.pause = function() {
      if (this._isPlaying && !this._isPaused) {
        this._isPaused = true;
        this.onPause();
      }
    };
    prototype.resume = function() {
      if (this._isPlaying && this._isPaused) {
        this._isPaused = false;
        this.onResume();
      }
    };
    prototype.step = function() {
      this.pause();
      this._stepOnce = true;
      this._isPlaying || this.play();
    };
    module.exports = Playable;
  }), {} ],
  21: [ (function(require, module, exports) {
    var JS = cc.js;
    var WrapModeMask = {
      Loop: 2,
      ShouldWrap: 4,
      PingPong: 22,
      Reverse: 36
    };
    var WrapMode = cc.Enum({
      Default: 0,
      Normal: 1,
      Reverse: WrapModeMask.Reverse,
      Loop: WrapModeMask.Loop,
      LoopReverse: WrapModeMask.Loop | WrapModeMask.Reverse,
      PingPong: WrapModeMask.PingPong,
      PingPongReverse: WrapModeMask.PingPong | WrapModeMask.Reverse
    });
    cc.WrapMode = WrapMode;
    function WrappedInfo(info) {
      if (info) {
        this.set(info);
        return;
      }
      this.ratio = 0;
      this.time = 0;
      this.direction = 1;
      this.stopped = true;
      this.iterations = 0;
      this.frameIndex = void 0;
    }
    WrappedInfo.prototype.set = function(info) {
      this.ratio = info.ratio;
      this.time = info.time;
      this.direction = info.direction;
      this.stopped = info.stopped;
      this.iterations = info.iterations;
      this.frameIndex = info.frameIndex;
    };
    module.exports = {
      WrapModeMask: WrapModeMask,
      WrapMode: WrapMode,
      WrappedInfo: WrappedInfo
    };
  }), {} ],
  22: [ (function(require, module, exports) {
    var EventTarget = require("../core/event/event-target");
    var sys = require("../core/platform/CCSys");
    var LoadMode = require("../core/assets/CCAudioClip").LoadMode;
    var touchBinded = false;
    var touchPlayList = [];
    var Audio = function(src) {
      EventTarget.call(this);
      this._src = src;
      this._element = null;
      this.id = 0;
      this._volume = 1;
      this._loop = false;
      this._nextTime = 0;
      this._state = Audio.State.INITIALZING;
      this._onended = function() {
        this.emit("ended");
      }.bind(this);
    };
    cc.js.extend(Audio, EventTarget);
    Audio.State = {
      ERROR: -1,
      INITIALZING: 0,
      PLAYING: 1,
      PAUSED: 2
    };
    (function(proto) {
      proto._bindEnded = function(callback) {
        callback = callback || this._onended;
        this._src && this._src.loadMode === LoadMode.DOM_AUDIO ? this._element.addEventListener("ended", callback) : this._element.onended = callback;
      };
      proto._unbindEnded = function() {
        this._src && this._src.loadMode === LoadMode.DOM_AUDIO ? this._element.removeEventListener("ended", this._onended) : this._element.onended = null;
      };
      proto._onLoaded = function() {
        var elem = this._src._nativeAsset;
        if (this._src.loadMode === LoadMode.DOM_AUDIO || false) {
          this._element = document.createElement("audio");
          this._element.src = elem.src;
        } else this._element = new WebAudioElement(elem, this);
        this.setVolume(this._volume);
        this.setLoop(this._loop);
        0 !== this._nextTime && this.setCurrentTime(this._nextTime);
        this._state === Audio.State.PLAYING ? this.play() : this._state = Audio.State.INITIALZING;
      };
      proto.play = function() {
        this._state = Audio.State.PLAYING;
        if (!this._element) return;
        this._bindEnded();
        this._element.play();
        !(false, false) && this._src && this._src.loadMode === LoadMode.DOM_AUDIO && this._element.paused && touchPlayList.push({
          instance: this,
          offset: 0,
          audio: this._element
        });
        if (touchBinded) return;
        touchBinded = true;
        cc.game.canvas.addEventListener("touchstart", (function() {
          var item = void 0;
          while (item = touchPlayList.pop()) item.audio.play(item.offset);
        }));
      };
      proto.destroy = function() {
        false;
      };
      proto.pause = function() {
        if (!this._element) return;
        this._unbindEnded();
        this._element.pause();
        this._state = Audio.State.PAUSED;
      };
      proto.resume = function() {
        if (!this._element || this._state === Audio.State.PLAYING) return;
        this._bindEnded();
        this._element.play();
        this._state = Audio.State.PLAYING;
      };
      proto.stop = function() {
        if (!this._element) return;
        try {
          this._element.currentTime = 0;
        } catch (error) {}
        this._element.pause();
        for (var i = 0; i < touchPlayList.length; i++) if (touchPlayList[i].instance === this) {
          touchPlayList.splice(i, 1);
          break;
        }
        this._unbindEnded();
        this.emit("stop");
        this._state = Audio.State.PAUSED;
      };
      proto.setLoop = function(loop) {
        this._loop = loop;
        this._element && (this._element.loop = loop);
      };
      proto.getLoop = function() {
        return this._loop;
      };
      proto.setVolume = function(num) {
        this._volume = num;
        this._element && (this._element.volume = num);
      };
      proto.getVolume = function() {
        return this._volume;
      };
      proto.setCurrentTime = function(num) {
        var _this = this;
        if (!this._element) {
          this._nextTime = num;
          return;
        }
        this._nextTime = 0;
        this._unbindEnded();
        (false, false) || this._bindEnded(function() {
          this._bindEnded();
        }.bind(this));
        try {
          this._element.currentTime = num;
        } catch (err) {
          (function() {
            var _element = _this._element;
            _element.addEventListener && (function() {
              var func = function() {
                _element.removeEventListener("loadedmetadata", func);
                _element.currentTime = num;
              };
              _element.addEventListener("loadedmetadata", func);
            })();
          })();
        }
      };
      proto.getCurrentTime = function() {
        return this._element ? this._element.currentTime : 0;
      };
      proto.getDuration = function() {
        return this._element ? this._element.duration : 0;
      };
      proto.getState = function() {
        true;
        var elem = this._element;
        elem && Audio.State.PLAYING === this._state && elem.paused && (this._state = Audio.State.PAUSED);
        return this._state;
      };
      proto.__defineGetter__("src", (function() {
        return this._src;
      }));
      proto.__defineSetter__("src", (function(clip) {
        var _this2 = this;
        if (clip) {
          this._src = clip;
          clip.loaded ? this._onLoaded() : (function() {
            var self = _this2;
            clip.once("load", (function() {
              clip === self._src && self._onLoaded();
            }));
          })();
        } else {
          this._src = null;
          this._element = null;
          this._state = Audio.State.INITIALZING;
        }
        return clip;
      }));
      proto.__defineGetter__("paused", (function() {
        return !this._element || this._element.paused;
      }));
    })(Audio.prototype);
    var WebAudioElement = function(buffer, audio) {
      this._audio = audio;
      this._context = sys.__audioSupport.context;
      this._buffer = buffer;
      this._gainObj = this._context["createGain"]();
      this._volume = 1;
      this._gainObj["gain"].setTargetAtTime ? this._gainObj["gain"].setTargetAtTime(this._volume, this._context.currentTime, .01) : this._gainObj["gain"].value = 1;
      this._gainObj["connect"](this._context["destination"]);
      this._loop = false;
      this._startTime = -1;
      this._currentSource = null;
      this.playedLength = 0;
      this._currextTimer = null;
      this._endCallback = function() {
        this.onended && this.onended(this);
      }.bind(this);
    };
    (function(proto) {
      proto.play = function(offset) {
        var _this3 = this;
        if (this._currentSource && !this.paused) {
          this._currentSource.onended = null;
          this._currentSource.stop(0);
          this.playedLength = 0;
        }
        var audio = this._context["createBufferSource"]();
        audio.buffer = this._buffer;
        audio["connect"](this._gainObj);
        audio.loop = this._loop;
        this._startTime = this._context.currentTime;
        offset = offset || this.playedLength;
        offset && (this._startTime -= offset);
        var duration = this._buffer.duration;
        var startTime = offset;
        var endTime = void 0;
        if (this._loop) audio.start ? audio.start(0, startTime) : audio["notoGrainOn"] ? audio["noteGrainOn"](0, startTime) : audio["noteOn"](0, startTime); else {
          endTime = duration - offset;
          audio.start ? audio.start(0, startTime, endTime) : audio["notoGrainOn"] ? audio["noteGrainOn"](0, startTime, endTime) : audio["noteOn"](0, startTime, endTime);
        }
        this._currentSource = audio;
        audio.onended = this._endCallback;
        audio.context.state && "suspended" !== audio.context.state || 0 !== this._context.currentTime || (function() {
          var self = _this3;
          clearTimeout(_this3._currextTimer);
          _this3._currextTimer = setTimeout((function() {
            (false, false) || 0 !== self._context.currentTime || touchPlayList.push({
              instance: self._audio,
              offset: offset,
              audio: self
            });
          }), 10);
        })();
      };
      proto.pause = function() {
        clearTimeout(this._currextTimer);
        if (this.paused) return;
        this.playedLength = this._context.currentTime - this._startTime;
        this.playedLength %= this._buffer.duration;
        var audio = this._currentSource;
        this._currentSource = null;
        this._startTime = -1;
        audio && audio.stop(0);
      };
      proto.__defineGetter__("paused", (function() {
        if (this._currentSource && this._currentSource.loop) return false;
        if (-1 === this._startTime) return true;
        return this._context.currentTime - this._startTime > this._buffer.duration;
      }));
      proto.__defineGetter__("loop", (function() {
        return this._loop;
      }));
      proto.__defineSetter__("loop", (function(bool) {
        this._currentSource && (this._currentSource.loop = bool);
        return this._loop = bool;
      }));
      proto.__defineGetter__("volume", (function() {
        return this._volume;
      }));
      proto.__defineSetter__("volume", (function(num) {
        this._volume = num;
        this._gainObj["gain"].setTargetAtTime ? this._gainObj["gain"].setTargetAtTime(this._volume, this._context.currentTime, .01) : this._volume["gain"].value = num;
        if (sys.os === sys.OS_IOS && !this.paused && this._currentSource) {
          this._currentSource.onended = null;
          this.pause();
          this.play();
        }
        return num;
      }));
      proto.__defineGetter__("currentTime", (function() {
        if (this.paused) return this.playedLength;
        this.playedLength = this._context.currentTime - this._startTime;
        this.playedLength %= this._buffer.duration;
        return this.playedLength;
      }));
      proto.__defineSetter__("currentTime", (function(num) {
        if (this.paused) this.playedLength = num; else {
          this.pause();
          this.playedLength = num;
          this.play();
        }
        return num;
      }));
      proto.__defineGetter__("duration", (function() {
        return this._buffer.duration;
      }));
    })(WebAudioElement.prototype);
    module.exports = cc.Audio = Audio;
  }), {
    "../core/assets/CCAudioClip": 35,
    "../core/event/event-target": 100,
    "../core/platform/CCSys": 164
  } ],
  23: [ (function(require, module, exports) {
    var Audio = require("./CCAudio");
    var AudioClip = require("../core/assets/CCAudioClip");
    var js = cc.js;
    var instanceId = 0;
    var id2audio = js.createMap(true);
    var url2id = {};
    var getAudioFromPath = function(path) {
      var id = instanceId++;
      var list = url2id[path];
      list || (list = url2id[path] = []);
      if (audioEngine._maxAudioInstance <= list.length) {
        var oldId = list.shift();
        var oldAudio = id2audio[oldId];
        oldAudio.stop();
        oldAudio.destroy();
      }
      var audio = new Audio();
      var callback = function() {
        delete id2audio[this.id];
        var index = list.indexOf(this.id);
        cc.js.array.fastRemoveAt(list, index);
      };
      audio.on("ended", callback);
      audio.on("stop", callback);
      id2audio[id] = audio;
      audio.id = id;
      list.push(id);
      return audio;
    };
    var getAudioFromId = function(id) {
      return id2audio[id];
    };
    var audioEngine = {
      AudioState: Audio.State,
      _maxWebAudioSize: 2097152,
      _maxAudioInstance: 24,
      _id2audio: id2audio,
      play: function(clip, loop, volume) {
        var path = clip;
        var audio;
        if ("string" === typeof clip) {
          cc.warnID(8401, "cc.audioEngine", "cc.AudioClip", "AudioClip", "cc.AudioClip", "audio");
          path = clip;
          audio = getAudioFromPath(path);
          AudioClip._loadByUrl(path, (function(err, clip) {
            clip && (audio.src = clip);
          }));
        } else {
          if (!clip) return;
          path = clip.nativeUrl;
          audio = getAudioFromPath(path);
          audio.src = clip;
        }
        audio.setLoop(loop || false);
        "number" !== typeof volume && (volume = 1);
        audio.setVolume(volume);
        audio.play();
        return audio.id;
      },
      setLoop: function(audioID, loop) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.setLoop) return;
        audio.setLoop(loop);
      },
      isLoop: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.isLoop) return false;
        return audio.isLoop();
      },
      setVolume: function(audioID, volume) {
        var audio = getAudioFromId(audioID);
        audio && audio.setVolume(volume);
      },
      getVolume: function(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getVolume() : 1;
      },
      setCurrentTime: function(audioID, sec) {
        var audio = getAudioFromId(audioID);
        if (audio) {
          audio.setCurrentTime(sec);
          return true;
        }
        return false;
      },
      getCurrentTime: function(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getCurrentTime() : 0;
      },
      getDuration: function(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getDuration() : 0;
      },
      getState: function(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getState() : this.AudioState.ERROR;
      },
      setFinishCallback: function(audioID, callback) {
        var audio = getAudioFromId(audioID);
        if (!audio) return;
        audio.off("ended", audio._finishCallback);
        audio._finishCallback = callback;
        audio.on("ended", audio._finishCallback);
      },
      pause: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (audio) {
          audio.pause();
          return true;
        }
        return false;
      },
      _pauseIDCache: [],
      pauseAll: function() {
        for (var id in id2audio) {
          var audio = id2audio[id];
          var state = audio.getState();
          if (state === Audio.State.PLAYING) {
            this._pauseIDCache.push(id);
            audio.pause();
          }
        }
      },
      resume: function(audioID) {
        var audio = getAudioFromId(audioID);
        audio && audio.resume();
      },
      resumeAll: function() {
        for (var i = 0; i < this._pauseIDCache.length; ++i) {
          var id = this._pauseIDCache[i];
          var audio = getAudioFromId(id);
          audio && audio.resume();
        }
        this._pauseIDCache.length = 0;
      },
      stop: function(audioID) {
        var audio = getAudioFromId(audioID);
        if (audio) {
          audio.stop();
          audio.destroy();
          return true;
        }
        return false;
      },
      stopAll: function() {
        for (var id in id2audio) {
          var audio = id2audio[id];
          if (audio) {
            audio.stop();
            audio.destroy();
          }
        }
      },
      setMaxAudioInstance: function(num) {
        return this._maxAudioInstance = num;
      },
      getMaxAudioInstance: function() {
        return this._maxAudioInstance;
      },
      uncache: function(clip) {
        var filePath = clip;
        if ("string" === typeof clip) {
          cc.warnID(8401, "cc.audioEngine", "cc.AudioClip", "AudioClip", "cc.AudioClip", "audio");
          filePath = clip;
        } else {
          if (!clip) return;
          filePath = clip.nativeUrl;
        }
        var list = url2id[filePath];
        if (!list) return;
        while (list.length > 0) {
          var id = list.pop();
          var audio = id2audio[id];
          if (audio) {
            audio.stop();
            audio.destroy();
            delete id2audio[id];
          }
        }
      },
      uncacheAll: function() {
        this.stopAll();
        for (var id in id2audio) {
          var audio = id2audio[id];
          audio && audio.destroy();
        }
        id2audio = js.createMap(true);
        url2id = {};
      },
      getProfile: function(profileName) {},
      preload: function(filePath, callback) {
        true;
        cc.warn("`cc.audioEngine.preload` is deprecated, use `cc.loader.loadRes(url, cc.AudioClip)` instead please.");
        cc.loader.load(filePath, callback && function(error) {
          error || callback();
        });
      },
      setMaxWebAudioSize: function(kb) {
        this._maxWebAudioSize = 1024 * kb;
      },
      _breakCache: null,
      _break: function() {
        this._breakCache = [];
        for (var id in id2audio) {
          var audio = id2audio[id];
          var state = audio.getState();
          if (state === Audio.State.PLAYING) {
            this._breakCache.push(id);
            audio.pause();
          }
        }
      },
      _restore: function() {
        if (!this._breakCache) return;
        while (this._breakCache.length > 0) {
          var id = this._breakCache.pop();
          var audio = getAudioFromId(id);
          audio && audio.resume && audio.resume();
        }
        this._breakCache = null;
      },
      _music: {
        id: -1,
        loop: false,
        volume: 1
      },
      _effect: {
        volume: 1,
        pauseCache: []
      },
      playMusic: function(clip, loop) {
        var music = this._music;
        this.stop(music.id);
        music.id = this.play(clip, loop, music.volume);
        music.loop = loop;
        return music.id;
      },
      stopMusic: function() {
        this.stop(this._music.id);
      },
      pauseMusic: function() {
        this.pause(this._music.id);
        return this._music.id;
      },
      resumeMusic: function() {
        this.resume(this._music.id);
        return this._music.id;
      },
      getMusicVolume: function() {
        return this._music.volume;
      },
      setMusicVolume: function(volume) {
        var music = this._music;
        music.volume = volume;
        this.setVolume(music.id, music.volume);
        return music.volume;
      },
      isMusicPlaying: function() {
        return this.getState(this._music.id) === this.AudioState.PLAYING;
      },
      playEffect: function(clip, loop) {
        return this.play(clip, loop || false, this._effect.volume);
      },
      setEffectsVolume: function(volume) {
        var musicId = this._music.id;
        this._effect.volume = volume;
        for (var id in id2audio) {
          if (id === musicId) continue;
          audioEngine.setVolume(id, volume);
        }
      },
      getEffectsVolume: function() {
        return this._effect.volume;
      },
      pauseEffect: function(audioID) {
        return this.pause(audioID);
      },
      pauseAllEffects: function() {
        var musicId = this._music.id;
        var effect = this._effect;
        effect.pauseCache.length = 0;
        for (var id in id2audio) {
          if (id === musicId) continue;
          var audio = id2audio[id];
          var state = audio.getState();
          if (state === this.AudioState.PLAYING) {
            effect.pauseCache.push(id);
            audio.pause();
          }
        }
      },
      resumeEffect: function(id) {
        this.resume(id);
      },
      resumeAllEffects: function() {
        var pauseIDCache = this._effect.pauseCache;
        for (var i = 0; i < pauseIDCache.length; ++i) {
          var id = pauseIDCache[i];
          var audio = id2audio[id];
          audio && audio.resume();
        }
      },
      stopEffect: function(audioID) {
        return this.stop(audioID);
      },
      stopAllEffects: function() {
        var musicId = this._music.id;
        for (var id in id2audio) {
          if (id === musicId) continue;
          var audio = id2audio[id];
          var state = audio.getState();
          state === audioEngine.AudioState.PLAYING && audio.stop();
        }
      }
    };
    module.exports = cc.audioEngine = audioEngine;
  }), {
    "../core/assets/CCAudioClip": 35,
    "./CCAudio": 22
  } ],
  24: [ (function(require, module, exports) {
    var codec = {
      name: "Jacob__Codec"
    };
    codec.Base64 = require("./base64");
    codec.GZip = require("./gzip");
    codec.unzip = function() {
      return codec.GZip.gunzip.apply(codec.GZip, arguments);
    };
    codec.unzipBase64 = function() {
      var buffer = codec.Base64.decode.apply(codec.Base64, arguments);
      try {
        return codec.GZip.gunzip.call(codec.GZip, buffer);
      } catch (e) {
        return buffer.slice(7);
      }
    };
    codec.unzipBase64AsArray = function(input, bytes) {
      bytes = bytes || 1;
      var dec = this.unzipBase64(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    codec.unzipAsArray = function(input, bytes) {
      bytes = bytes || 1;
      var dec = this.unzip(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    cc.codec = module.exports = codec;
  }), {
    "./base64": 25,
    "./gzip": 26
  } ],
  25: [ (function(require, module, exports) {
    var misc = require("../core/utils/misc");
    var strValue = misc.BASE64_VALUES;
    var Base64 = {
      name: "Jacob__Codec__Base64"
    };
    Base64.decode = function Jacob__Codec__Base64__decode(input) {
      var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      while (i < input.length) {
        enc1 = strValue[input.charCodeAt(i++)];
        enc2 = strValue[input.charCodeAt(i++)];
        enc3 = strValue[input.charCodeAt(i++)];
        enc4 = strValue[input.charCodeAt(i++)];
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (15 & enc2) << 4 | enc3 >> 2;
        chr3 = (3 & enc3) << 6 | enc4;
        output.push(String.fromCharCode(chr1));
        64 !== enc3 && output.push(String.fromCharCode(chr2));
        64 !== enc4 && output.push(String.fromCharCode(chr3));
      }
      output = output.join("");
      return output;
    };
    Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
      var dec = this.decode(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    module.exports = Base64;
  }), {
    "../core/utils/misc": 233
  } ],
  26: [ (function(require, module, exports) {
    var GZip = function Jacob__GZip(data) {
      this.data = data;
      this.debug = false;
      this.gpflags = void 0;
      this.files = 0;
      this.unzipped = [];
      this.buf32k = new Array(32768);
      this.bIdx = 0;
      this.modeZIP = false;
      this.bytepos = 0;
      this.bb = 1;
      this.bits = 0;
      this.nameBuf = [];
      this.fileout = void 0;
      this.literalTree = new Array(GZip.LITERALS);
      this.distanceTree = new Array(32);
      this.treepos = 0;
      this.Places = null;
      this.len = 0;
      this.fpos = new Array(17);
      this.fpos[0] = 0;
      this.flens = void 0;
      this.fmax = void 0;
    };
    GZip.gunzip = function(string) {
      string.constructor === Array || string.constructor === String;
      var gzip = new GZip(string);
      return gzip.gunzip()[0][0];
    };
    GZip.HufNode = function() {
      this.b0 = 0;
      this.b1 = 0;
      this.jump = null;
      this.jumppos = -1;
    };
    GZip.LITERALS = 288;
    GZip.NAMEMAX = 256;
    GZip.bitReverse = [ 0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255 ];
    GZip.cplens = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
    GZip.cplext = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 ];
    GZip.cpdist = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
    GZip.cpdext = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
    GZip.border = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
    GZip.prototype.gunzip = function() {
      this.outputArr = [];
      this.nextFile();
      return this.unzipped;
    };
    GZip.prototype.readByte = function() {
      this.bits += 8;
      return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1;
    };
    GZip.prototype.byteAlign = function() {
      this.bb = 1;
    };
    GZip.prototype.readBit = function() {
      var carry;
      this.bits++;
      carry = 1 & this.bb;
      this.bb >>= 1;
      if (0 === this.bb) {
        this.bb = this.readByte();
        carry = 1 & this.bb;
        this.bb = this.bb >> 1 | 128;
      }
      return carry;
    };
    GZip.prototype.readBits = function(a) {
      var res = 0, i = a;
      while (i--) res = res << 1 | this.readBit();
      a && (res = GZip.bitReverse[res] >> 8 - a);
      return res;
    };
    GZip.prototype.flushBuffer = function() {
      this.bIdx = 0;
    };
    GZip.prototype.addBuffer = function(a) {
      this.buf32k[this.bIdx++] = a;
      this.outputArr.push(String.fromCharCode(a));
      32768 === this.bIdx && (this.bIdx = 0);
    };
    GZip.prototype.IsPat = function() {
      while (1) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++;
      }
    };
    GZip.prototype.Rec = function() {
      var curplace = this.Places[this.treepos];
      var tmp;
      if (17 === this.len) return -1;
      this.treepos++;
      this.len++;
      tmp = this.IsPat();
      if (tmp >= 0) curplace.b0 = tmp; else {
        curplace.b0 = 32768;
        if (this.Rec()) return -1;
      }
      tmp = this.IsPat();
      if (tmp >= 0) {
        curplace.b1 = tmp;
        curplace.jump = null;
      } else {
        curplace.b1 = 32768;
        curplace.jump = this.Places[this.treepos];
        curplace.jumppos = this.treepos;
        if (this.Rec()) return -1;
      }
      this.len--;
      return 0;
    };
    GZip.prototype.CreateTree = function(currentTree, numval, lengths, show) {
      var i;
      this.Places = currentTree;
      this.treepos = 0;
      this.flens = lengths;
      this.fmax = numval;
      for (i = 0; i < 17; i++) this.fpos[i] = 0;
      this.len = 0;
      if (this.Rec()) return -1;
      return 0;
    };
    GZip.prototype.DecodeValue = function(currentTree) {
      var len, i, xtreepos = 0, X = currentTree[xtreepos], b;
      while (1) {
        b = this.readBit();
        if (b) {
          if (!(32768 & X.b1)) return X.b1;
          X = X.jump;
          len = currentTree.length;
          for (i = 0; i < len; i++) if (currentTree[i] === X) {
            xtreepos = i;
            break;
          }
        } else {
          if (!(32768 & X.b0)) return X.b0;
          xtreepos++;
          X = currentTree[xtreepos];
        }
      }
      return -1;
    };
    GZip.prototype.DeflateLoop = function() {
      var last, c, type, i, len;
      do {
        last = this.readBit();
        type = this.readBits(2);
        if (0 === type) {
          var blockLen, cSum;
          this.byteAlign();
          blockLen = this.readByte();
          blockLen |= this.readByte() << 8;
          cSum = this.readByte();
          cSum |= this.readByte() << 8;
          65535 & (blockLen ^ ~cSum) && document.write("BlockLen checksum mismatch\n");
          while (blockLen--) {
            c = this.readByte();
            this.addBuffer(c);
          }
        } else if (1 === type) {
          var j;
          while (1) {
            j = GZip.bitReverse[this.readBits(7)] >> 1;
            if (j > 23) {
              j = j << 1 | this.readBit();
              if (j > 199) {
                j -= 128;
                j = j << 1 | this.readBit();
              } else {
                j -= 48;
                j > 143 && (j += 136);
              }
            } else j += 256;
            if (j < 256) this.addBuffer(j); else {
              if (256 === j) break;
              var len, dist;
              j -= 257;
              len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
              j = GZip.bitReverse[this.readBits(5)] >> 3;
              if (GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
              } else dist = this.readBits(GZip.cpdext[j]);
              dist += GZip.cpdist[j];
              for (j = 0; j < len; j++) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c);
              }
            }
          }
        } else if (2 === type) {
          var j, n, literalCodes, distCodes, lenCodes;
          var ll = new Array(320);
          literalCodes = 257 + this.readBits(5);
          distCodes = 1 + this.readBits(5);
          lenCodes = 4 + this.readBits(4);
          for (j = 0; j < 19; j++) ll[j] = 0;
          for (j = 0; j < lenCodes; j++) ll[GZip.border[j]] = this.readBits(3);
          len = this.distanceTree.length;
          for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
          if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
            this.flushBuffer();
            return 1;
          }
          n = literalCodes + distCodes;
          i = 0;
          var z = -1;
          while (i < n) {
            z++;
            j = this.DecodeValue(this.distanceTree);
            if (j < 16) ll[i++] = j; else if (16 === j) {
              var l;
              j = 3 + this.readBits(2);
              if (i + j > n) {
                this.flushBuffer();
                return 1;
              }
              l = i ? ll[i - 1] : 0;
              while (j--) ll[i++] = l;
            } else {
              j = 17 === j ? 3 + this.readBits(3) : 11 + this.readBits(7);
              if (i + j > n) {
                this.flushBuffer();
                return 1;
              }
              while (j--) ll[i++] = 0;
            }
          }
          len = this.literalTree.length;
          for (i = 0; i < len; i++) this.literalTree[i] = new GZip.HufNode();
          if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
            this.flushBuffer();
            return 1;
          }
          len = this.literalTree.length;
          for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
          var ll2 = new Array();
          for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];
          if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
            this.flushBuffer();
            return 1;
          }
          while (1) {
            j = this.DecodeValue(this.literalTree);
            if (j >= 256) {
              var len, dist;
              j -= 256;
              if (0 === j) break;
              j--;
              len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
              j = this.DecodeValue(this.distanceTree);
              if (GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
              } else dist = this.readBits(GZip.cpdext[j]);
              dist += GZip.cpdist[j];
              while (len--) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c);
              }
            } else this.addBuffer(j);
          }
        }
      } while (!last);
      this.flushBuffer();
      this.byteAlign();
      return 0;
    };
    GZip.prototype.unzipFile = function(name) {
      var i;
      this.gunzip();
      for (i = 0; i < this.unzipped.length; i++) if (this.unzipped[i][1] === name) return this.unzipped[i][0];
    };
    GZip.prototype.nextFile = function() {
      this.outputArr = [];
      this.modeZIP = false;
      var tmp = [];
      tmp[0] = this.readByte();
      tmp[1] = this.readByte();
      if (120 === tmp[0] && 218 === tmp[1]) {
        this.DeflateLoop();
        this.unzipped[this.files] = [ this.outputArr.join(""), "geonext.gxt" ];
        this.files++;
      }
      if (31 === tmp[0] && 139 === tmp[1]) {
        this.skipdir();
        this.unzipped[this.files] = [ this.outputArr.join(""), "file" ];
        this.files++;
      }
      if (80 === tmp[0] && 75 === tmp[1]) {
        this.modeZIP = true;
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        if (3 === tmp[2] && 4 === tmp[3]) {
          tmp[0] = this.readByte();
          tmp[1] = this.readByte();
          this.gpflags = this.readByte();
          this.gpflags |= this.readByte() << 8;
          var method = this.readByte();
          method |= this.readByte() << 8;
          this.readByte();
          this.readByte();
          this.readByte();
          this.readByte();
          var compSize = this.readByte();
          compSize |= this.readByte() << 8;
          compSize |= this.readByte() << 16;
          compSize |= this.readByte() << 24;
          var size = this.readByte();
          size |= this.readByte() << 8;
          size |= this.readByte() << 16;
          size |= this.readByte() << 24;
          var filelen = this.readByte();
          filelen |= this.readByte() << 8;
          var extralen = this.readByte();
          extralen |= this.readByte() << 8;
          i = 0;
          this.nameBuf = [];
          while (filelen--) {
            var c = this.readByte();
            "/" === c | ":" === c ? i = 0 : i < GZip.NAMEMAX - 1 && (this.nameBuf[i++] = String.fromCharCode(c));
          }
          this.fileout || (this.fileout = this.nameBuf);
          var i = 0;
          while (i < extralen) {
            c = this.readByte();
            i++;
          }
          if (8 === method) {
            this.DeflateLoop();
            this.unzipped[this.files] = [ this.outputArr.join(""), this.nameBuf.join("") ];
            this.files++;
          }
          this.skipdir();
        }
      }
    };
    GZip.prototype.skipdir = function() {
      var tmp = [];
      var compSize, size, os, i, c;
      if (8 & this.gpflags) {
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        compSize = this.readByte();
        compSize |= this.readByte() << 8;
        compSize |= this.readByte() << 16;
        compSize |= this.readByte() << 24;
        size = this.readByte();
        size |= this.readByte() << 8;
        size |= this.readByte() << 16;
        size |= this.readByte() << 24;
      }
      this.modeZIP && this.nextFile();
      tmp[0] = this.readByte();
      if (8 !== tmp[0]) return 0;
      this.gpflags = this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      os = this.readByte();
      if (4 & this.gpflags) {
        tmp[0] = this.readByte();
        tmp[2] = this.readByte();
        this.len = tmp[0] + 256 * tmp[1];
        for (i = 0; i < this.len; i++) this.readByte();
      }
      if (8 & this.gpflags) {
        i = 0;
        this.nameBuf = [];
        while (c = this.readByte()) {
          "7" !== c && ":" !== c || (i = 0);
          i < GZip.NAMEMAX - 1 && (this.nameBuf[i++] = c);
        }
      }
      if (16 & this.gpflags) while (c = this.readByte()) ;
      if (2 & this.gpflags) {
        this.readByte();
        this.readByte();
      }
      this.DeflateLoop();
      size = this.readByte();
      size |= this.readByte() << 8;
      size |= this.readByte() << 16;
      size |= this.readByte() << 24;
      this.modeZIP && this.nextFile();
    };
    module.exports = GZip;
  }), {} ],
  27: [ (function(require, module, exports) {
    (function() {
      "use strict";
      function i(a) {
        throw a;
      }
      var r = void 0, v = !0, aa = this;
      function y(a, c) {
        var b = a.split("."), e = aa;
        !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);
        for (var f; b.length && (f = b.shift()); ) b.length || c === r ? e = e[f] ? e[f] : e[f] = {} : e[f] = c;
      }
      var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
      function ba(a) {
        if ("string" === typeof a) {
          var c = a.split(""), b, e;
          b = 0;
          for (e = c.length; b < e; b++) c[b] = (255 & c[b].charCodeAt(0)) >>> 0;
          a = c;
        }
        for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g; ) {
          h = 1024 < g ? 1024 : g;
          g -= h;
          do {
            f += a[m++], d += f;
          } while (--h);
          f %= 65521;
          d %= 65521;
        }
        return (d << 16 | f) >>> 0;
      }
      function J(a, c) {
        this.index = "number" === typeof c ? c : 0;
        this.i = 0;
        this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && i(Error("invalid index"));
        this.buffer.length <= this.index && this.f();
      }
      J.prototype.f = function() {
        var a = this.buffer, c, b = a.length, e = new (H ? Uint8Array : Array)(b << 1);
        if (H) e.set(a); else for (c = 0; c < b; ++c) e[c] = a[c];
        return this.buffer = e;
      };
      J.prototype.d = function(a, c, b) {
        var e = this.buffer, f = this.index, d = this.i, g = e[f], h;
        b && 1 < c && (a = 8 < c ? (N[255 & a] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
        if (8 > c + d) g = g << c | a, d += c; else for (h = 0; h < c; ++h) g = g << 1 | a >> c - h - 1 & 1, 
        8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
        e[f] = g;
        this.buffer = e;
        this.i = d;
        this.index = f;
      };
      J.prototype.finish = function() {
        var a = this.buffer, c = this.index, b;
        0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
        H ? b = a.subarray(0, c) : (a.length = c, b = a);
        return b;
      };
      var ca = new (H ? Uint8Array : Array)(256), ha;
      for (ha = 0; 256 > ha; ++ha) {
        for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) ia <<= 1, ia |= 1 & R, 
        --ja;
        ca[ha] = (ia << ja & 255) >>> 0;
      }
      var N = ca;
      var ka = [ 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117 ];
      H && new Uint32Array(ka);
      function la(a) {
        this.buffer = new (H ? Uint16Array : Array)(2 * a);
        this.length = 0;
      }
      la.prototype.getParent = function(a) {
        return 2 * ((a - 2) / 4 | 0);
      };
      la.prototype.push = function(a, c) {
        var b, e, f = this.buffer, d;
        b = this.length;
        f[this.length++] = c;
        for (f[this.length++] = a; 0 < b; ) {
          if (e = this.getParent(b), !(f[b] > f[e])) break;
          d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, 
          b = e;
        }
        return this.length;
      };
      la.prototype.pop = function() {
        var a, c, b = this.buffer, e, f, d;
        c = b[0];
        a = b[1];
        this.length -= 2;
        b[0] = b[this.length];
        b[1] = b[this.length + 1];
        for (d = 0; ;) {
          f = 2 * d + 2;
          if (f >= this.length) break;
          f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
          if (!(b[f] > b[d])) break;
          e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;
          d = f;
        }
        return {
          index: a,
          value: c,
          length: this.length
        };
      };
      function S(a) {
        var c = a.length, b = 0, e = Number.POSITIVE_INFINITY, f, d, g, h, m, j, s, n, l;
        for (n = 0; n < c; ++n) a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
        f = 1 << b;
        d = new (H ? Uint32Array : Array)(f);
        g = 1;
        h = 0;
        for (m = 2; g <= b; ) {
          for (n = 0; n < c; ++n) if (a[n] === g) {
            j = 0;
            s = h;
            for (l = 0; l < g; ++l) j = j << 1 | 1 & s, s >>= 1;
            for (l = j; l < f; l += m) d[l] = g << 16 | n;
            ++h;
          }
          ++g;
          h <<= 1;
          m <<= 1;
        }
        return [ d, b, e ];
      }
      function ma(a, c) {
        this.h = pa;
        this.w = 0;
        this.input = a;
        this.b = 0;
        c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), 
        c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), 
        "number" === typeof c.outputIndex && (this.b = c.outputIndex));
        this.a || (this.a = new (H ? Uint8Array : Array)(32768));
      }
      var pa = 2, qa = {
        NONE: 0,
        r: 1,
        j: pa,
        N: 3
      }, ra = [], T;
      for (T = 0; 288 > T; T++) switch (v) {
       case 143 >= T:
        ra.push([ T + 48, 8 ]);
        break;

       case 255 >= T:
        ra.push([ T - 144 + 400, 9 ]);
        break;

       case 279 >= T:
        ra.push([ T - 256 + 0, 7 ]);
        break;

       case 287 >= T:
        ra.push([ T - 280 + 192, 8 ]);
        break;

       default:
        i("invalid literal: " + T);
      }
      ma.prototype.n = function() {
        var a, c, b, e, f = this.input;
        switch (this.h) {
         case 0:
          b = 0;
          for (e = f.length; b < e; ) {
            c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
            b += c.length;
            var d = c, g = b === e, h = r, m = r, j = r, s = r, n = r, l = this.a, q = this.b;
            if (H) {
              for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5; ) l = new Uint8Array(l.length << 1);
              l.set(this.a);
            }
            h = g ? 1 : 0;
            l[q++] = 0 | h;
            m = d.length;
            j = 65536 + ~m & 65535;
            l[q++] = 255 & m;
            l[q++] = m >>> 8 & 255;
            l[q++] = 255 & j;
            l[q++] = j >>> 8 & 255;
            if (H) l.set(d, q), q += d.length, l = l.subarray(0, q); else {
              s = 0;
              for (n = d.length; s < n; ++s) l[q++] = d[s];
              l.length = q;
            }
            this.b = q;
            this.a = l;
          }
          break;

         case 1:
          var E = new J(new Uint8Array(this.a.buffer), this.b);
          E.d(1, 1, v);
          E.d(1, 2, v);
          var t = sa(this, f), z, K, A;
          z = 0;
          for (K = t.length; z < K; z++) if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) E.d(t[++z], t[++z], v), 
          E.d(t[++z], 5), E.d(t[++z], t[++z], v); else if (256 === A) break;
          this.a = E.finish();
          this.b = this.a.length;
          break;

         case pa:
          var x = new J(new Uint8Array(this.a), this.b), B, k, p, D, C, da = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], W, Ma, ea, Na, na, va = Array(19), Oa, $, oa, F, Pa;
          B = pa;
          x.d(1, 1, v);
          x.d(B, 2, v);
          k = sa(this, f);
          W = ta(this.L, 15);
          Ma = ua(W);
          ea = ta(this.K, 7);
          Na = ua(ea);
          for (p = 286; 257 < p && 0 === W[p - 1]; p--) ;
          for (D = 30; 1 < D && 0 === ea[D - 1]; D--) ;
          var Qa = p, Ra = D, M = new (H ? Uint32Array : Array)(Qa + Ra), u, O, w, fa, L = new (H ? Uint32Array : Array)(316), I, G, P = new (H ? Uint8Array : Array)(19);
          for (u = O = 0; u < Qa; u++) M[O++] = W[u];
          for (u = 0; u < Ra; u++) M[O++] = ea[u];
          if (!H) {
            u = 0;
            for (fa = P.length; u < fa; ++u) P[u] = 0;
          }
          u = I = 0;
          for (fa = M.length; u < fa; u += O) {
            for (O = 1; u + O < fa && M[u + O] === M[u]; ++O) ;
            w = O;
            if (0 === M[u]) if (3 > w) for (;0 < w--; ) L[I++] = 0, P[0]++; else for (;0 < w; ) G = 138 > w ? w : 138, 
            G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, 
            L[I++] = G - 11, P[18]++), w -= G; else if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) for (;0 < w--; ) L[I++] = M[u], 
            P[M[u]]++; else for (;0 < w; ) G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), 
            L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G;
          }
          a = H ? L.subarray(0, I) : L.slice(0, I);
          na = ta(P, 7);
          for (F = 0; 19 > F; F++) va[F] = na[da[F]];
          for (C = 19; 4 < C && 0 === va[C - 1]; C--) ;
          Oa = ua(na);
          x.d(p - 257, 5, v);
          x.d(D - 1, 5, v);
          x.d(C - 4, 4, v);
          for (F = 0; F < C; F++) x.d(va[F], 3, v);
          F = 0;
          for (Pa = a.length; F < Pa; F++) if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
            F++;
            switch ($) {
             case 16:
              oa = 2;
              break;

             case 17:
              oa = 3;
              break;

             case 18:
              oa = 7;
              break;

             default:
              i("invalid code: " + $);
            }
            x.d(a[F], oa, v);
          }
          var Sa = [ Ma, W ], Ta = [ Na, ea ], Q, Ua, ga, ya, Va, Wa, Xa, Ya;
          Va = Sa[0];
          Wa = Sa[1];
          Xa = Ta[0];
          Ya = Ta[1];
          Q = 0;
          for (Ua = k.length; Q < Ua; ++Q) if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) x.d(k[++Q], k[++Q], v), 
          ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v); else if (256 === ga) break;
          this.a = x.finish();
          this.b = this.a.length;
          break;

         default:
          i("invalid compression type");
        }
        return this.a;
      };
      function wa(a, c) {
        this.length = a;
        this.G = c;
      }
      function xa() {
        var a = za;
        switch (v) {
         case 3 === a:
          return [ 257, a - 3, 0 ];

         case 4 === a:
          return [ 258, a - 4, 0 ];

         case 5 === a:
          return [ 259, a - 5, 0 ];

         case 6 === a:
          return [ 260, a - 6, 0 ];

         case 7 === a:
          return [ 261, a - 7, 0 ];

         case 8 === a:
          return [ 262, a - 8, 0 ];

         case 9 === a:
          return [ 263, a - 9, 0 ];

         case 10 === a:
          return [ 264, a - 10, 0 ];

         case 12 >= a:
          return [ 265, a - 11, 1 ];

         case 14 >= a:
          return [ 266, a - 13, 1 ];

         case 16 >= a:
          return [ 267, a - 15, 1 ];

         case 18 >= a:
          return [ 268, a - 17, 1 ];

         case 22 >= a:
          return [ 269, a - 19, 2 ];

         case 26 >= a:
          return [ 270, a - 23, 2 ];

         case 30 >= a:
          return [ 271, a - 27, 2 ];

         case 34 >= a:
          return [ 272, a - 31, 2 ];

         case 42 >= a:
          return [ 273, a - 35, 3 ];

         case 50 >= a:
          return [ 274, a - 43, 3 ];

         case 58 >= a:
          return [ 275, a - 51, 3 ];

         case 66 >= a:
          return [ 276, a - 59, 3 ];

         case 82 >= a:
          return [ 277, a - 67, 4 ];

         case 98 >= a:
          return [ 278, a - 83, 4 ];

         case 114 >= a:
          return [ 279, a - 99, 4 ];

         case 130 >= a:
          return [ 280, a - 115, 4 ];

         case 162 >= a:
          return [ 281, a - 131, 5 ];

         case 194 >= a:
          return [ 282, a - 163, 5 ];

         case 226 >= a:
          return [ 283, a - 195, 5 ];

         case 257 >= a:
          return [ 284, a - 227, 5 ];

         case 258 === a:
          return [ 285, a - 258, 0 ];

         default:
          i("invalid length: " + a);
        }
      }
      var Aa = [], za, Ba;
      for (za = 3; 258 >= za; za++) Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];
      var Ca = H ? new Uint32Array(Aa) : Aa;
      function sa(a, c) {
        function b(a, c) {
          var b = a.G, d = [], e = 0, f;
          f = Ca[a.length];
          d[e++] = 65535 & f;
          d[e++] = f >> 16 & 255;
          d[e++] = f >> 24;
          var g;
          switch (v) {
           case 1 === b:
            g = [ 0, b - 1, 0 ];
            break;

           case 2 === b:
            g = [ 1, b - 2, 0 ];
            break;

           case 3 === b:
            g = [ 2, b - 3, 0 ];
            break;

           case 4 === b:
            g = [ 3, b - 4, 0 ];
            break;

           case 6 >= b:
            g = [ 4, b - 5, 1 ];
            break;

           case 8 >= b:
            g = [ 5, b - 7, 1 ];
            break;

           case 12 >= b:
            g = [ 6, b - 9, 2 ];
            break;

           case 16 >= b:
            g = [ 7, b - 13, 2 ];
            break;

           case 24 >= b:
            g = [ 8, b - 17, 3 ];
            break;

           case 32 >= b:
            g = [ 9, b - 25, 3 ];
            break;

           case 48 >= b:
            g = [ 10, b - 33, 4 ];
            break;

           case 64 >= b:
            g = [ 11, b - 49, 4 ];
            break;

           case 96 >= b:
            g = [ 12, b - 65, 5 ];
            break;

           case 128 >= b:
            g = [ 13, b - 97, 5 ];
            break;

           case 192 >= b:
            g = [ 14, b - 129, 6 ];
            break;

           case 256 >= b:
            g = [ 15, b - 193, 6 ];
            break;

           case 384 >= b:
            g = [ 16, b - 257, 7 ];
            break;

           case 512 >= b:
            g = [ 17, b - 385, 7 ];
            break;

           case 768 >= b:
            g = [ 18, b - 513, 8 ];
            break;

           case 1024 >= b:
            g = [ 19, b - 769, 8 ];
            break;

           case 1536 >= b:
            g = [ 20, b - 1025, 9 ];
            break;

           case 2048 >= b:
            g = [ 21, b - 1537, 9 ];
            break;

           case 3072 >= b:
            g = [ 22, b - 2049, 10 ];
            break;

           case 4096 >= b:
            g = [ 23, b - 3073, 10 ];
            break;

           case 6144 >= b:
            g = [ 24, b - 4097, 11 ];
            break;

           case 8192 >= b:
            g = [ 25, b - 6145, 11 ];
            break;

           case 12288 >= b:
            g = [ 26, b - 8193, 12 ];
            break;

           case 16384 >= b:
            g = [ 27, b - 12289, 12 ];
            break;

           case 24576 >= b:
            g = [ 28, b - 16385, 13 ];
            break;

           case 32768 >= b:
            g = [ 29, b - 24577, 13 ];
            break;

           default:
            i("invalid distance");
          }
          f = g;
          d[e++] = f[0];
          d[e++] = f[1];
          d[e++] = f[2];
          var h, j;
          h = 0;
          for (j = d.length; h < j; ++h) l[q++] = d[h];
          t[d[0]]++;
          z[d[3]]++;
          E = a.length + c - 1;
          n = null;
        }
        var e, f, d, g, h, m = {}, j, s, n, l = H ? new Uint16Array(2 * c.length) : [], q = 0, E = 0, t = new (H ? Uint32Array : Array)(286), z = new (H ? Uint32Array : Array)(30), K = a.w, A;
        if (!H) {
          for (d = 0; 285 >= d; ) t[d++] = 0;
          for (d = 0; 29 >= d; ) z[d++] = 0;
        }
        t[256] = 1;
        e = 0;
        for (f = c.length; e < f; ++e) {
          d = h = 0;
          for (g = 3; d < g && e + d !== f; ++d) h = h << 8 | c[e + d];
          m[h] === r && (m[h] = []);
          j = m[h];
          if (!(0 < E--)) {
            for (;0 < j.length && 32768 < e - j[0]; ) j.shift();
            if (e + 3 >= f) {
              n && b(n, -1);
              d = 0;
              for (g = f - e; d < g; ++d) A = c[e + d], l[q++] = A, ++t[A];
              break;
            }
            if (0 < j.length) {
              var x = r, B = r, k = 0, p = r, D = r, C = r, da = r, W = c.length, D = 0, da = j.length;
              a: for (;D < da; D++) {
                x = j[da - D - 1];
                p = 3;
                if (3 < k) {
                  for (C = k; 3 < C; C--) if (c[x + C - 1] !== c[e + C - 1]) continue a;
                  p = k;
                }
                for (;258 > p && e + p < W && c[x + p] === c[e + p]; ) ++p;
                p > k && (B = x, k = p);
                if (258 === p) break;
              }
              s = new wa(k, e - B);
              n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
            } else n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
          }
          j.push(e);
        }
        l[q++] = 256;
        t[256]++;
        a.L = t;
        a.K = z;
        return H ? l.subarray(0, q) : l;
      }
      function ta(a, c) {
        function b(a) {
          var c = z[a][K[a]];
          c === n ? (b(a + 1), b(a + 1)) : --E[c];
          ++K[a];
        }
        var e = a.length, f = new la(572), d = new (H ? Uint8Array : Array)(e), g, h, m, j, s;
        if (!H) for (j = 0; j < e; j++) d[j] = 0;
        for (j = 0; j < e; ++j) 0 < a[j] && f.push(j, a[j]);
        g = Array(f.length / 2);
        h = new (H ? Uint32Array : Array)(f.length / 2);
        if (1 === g.length) return d[f.pop().index] = 1, d;
        j = 0;
        for (s = f.length / 2; j < s; ++j) g[j] = f.pop(), h[j] = g[j].value;
        var n = h.length, l = new (H ? Uint16Array : Array)(c), q = new (H ? Uint8Array : Array)(c), E = new (H ? Uint8Array : Array)(n), t = Array(c), z = Array(c), K = Array(c), A = (1 << c) - n, x = 1 << c - 1, B, k, p, D, C;
        l[c - 1] = n;
        for (k = 0; k < c; ++k) A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
        l[0] = q[0];
        t[0] = Array(l[0]);
        z[0] = Array(l[0]);
        for (k = 1; k < c; ++k) l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), 
        t[k] = Array(l[k]), z[k] = Array(l[k]);
        for (B = 0; B < n; ++B) E[B] = c;
        for (p = 0; p < l[c - 1]; ++p) t[c - 1][p] = h[p], z[c - 1][p] = p;
        for (B = 0; B < c; ++B) K[B] = 0;
        1 === q[c - 1] && (--E[0], ++K[c - 1]);
        for (k = c - 2; 0 <= k; --k) {
          D = B = 0;
          C = K[k + 1];
          for (p = 0; p < l[k]; p++) D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, 
          z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B);
          K[k] = 0;
          1 === q[k] && b(k);
        }
        m = E;
        j = 0;
        for (s = g.length; j < s; ++j) d[g[j].index] = m[j];
        return d;
      }
      function ua(a) {
        var c = new (H ? Uint16Array : Array)(a.length), b = [], e = [], f = 0, d, g, h, m;
        d = 0;
        for (g = a.length; d < g; d++) b[a[d]] = 1 + (0 | b[a[d]]);
        d = 1;
        for (g = 16; d <= g; d++) e[d] = f, f += 0 | b[d], f > 1 << d && i("overcommitted"), 
        f <<= 1;
        65536 > f && i("undercommitted");
        d = 0;
        for (g = a.length; d < g; d++) {
          f = e[a[d]];
          e[a[d]] += 1;
          h = c[d] = 0;
          for (m = a[d]; h < m; h++) c[d] = c[d] << 1 | 1 & f, f >>>= 1;
        }
        return c;
      }
      function Da(a, c) {
        this.input = a;
        this.a = new (H ? Uint8Array : Array)(32768);
        this.h = U.j;
        var b = {}, e;
        !c && (c = {}) || "number" !== typeof c.compressionType || (this.h = c.compressionType);
        for (e in c) b[e] = c[e];
        b.outputBuffer = this.a;
        this.z = new ma(this.input, b);
      }
      var U = qa;
      Da.prototype.n = function() {
        var a, c, b, e, f, d, g, h = 0;
        g = this.a;
        a = Ea;
        switch (a) {
         case Ea:
          c = Math.LOG2E * Math.log(32768) - 8;
          break;

         default:
          i(Error("invalid compression method"));
        }
        b = c << 4 | a;
        g[h++] = b;
        switch (a) {
         case Ea:
          switch (this.h) {
           case U.NONE:
            f = 0;
            break;

           case U.r:
            f = 1;
            break;

           case U.j:
            f = 2;
            break;

           default:
            i(Error("unsupported compression type"));
          }
          break;

         default:
          i(Error("invalid compression method"));
        }
        e = f << 6 | 0;
        g[h++] = e | 31 - (256 * b + e) % 31;
        d = ba(this.input);
        this.z.b = h;
        g = this.z.n();
        h = g.length;
        H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), 
        this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
        g[h++] = d >> 24 & 255;
        g[h++] = d >> 16 & 255;
        g[h++] = d >> 8 & 255;
        g[h++] = 255 & d;
        return g;
      };
      y("Zlib.Deflate", Da);
      y("Zlib.Deflate.compress", (function(a, c) {
        return new Da(a, c).n();
      }));
      y("Zlib.Deflate.CompressionType", U);
      y("Zlib.Deflate.CompressionType.NONE", U.NONE);
      y("Zlib.Deflate.CompressionType.FIXED", U.r);
      y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
      function V(a, c) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = H ? new Uint8Array(a) : a;
        this.s = !1;
        this.m = Fa;
        this.B = !1;
        !c && (c = {}) || (c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), 
        c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize));
        switch (this.m) {
         case Ga:
          this.b = 32768;
          this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
          break;

         case Fa:
          this.b = 0;
          this.a = new (H ? Uint8Array : Array)(this.l);
          this.f = this.J;
          this.t = this.H;
          this.o = this.I;
          break;

         default:
          i(Error("invalid inflate mode"));
        }
      }
      var Ga = 0, Fa = 1, Ha = {
        D: Ga,
        C: Fa
      };
      V.prototype.p = function() {
        for (;!this.s; ) {
          var a = X(this, 3);
          1 & a && (this.s = v);
          a >>>= 1;
          switch (a) {
           case 0:
            var c = this.input, b = this.c, e = this.a, f = this.b, d = r, g = r, h = r, m = e.length, j = r;
            this.e = this.g = 0;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
            g = d;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
            g |= d << 8;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
            h = d;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
            h |= d << 8;
            g === ~h && i(Error("invalid uncompressed block header: length verify"));
            b + g > c.length && i(Error("input buffer is broken"));
            switch (this.m) {
             case Ga:
              for (;f + g > e.length; ) {
                j = m - f;
                g -= j;
                if (H) e.set(c.subarray(b, b + j), f), f += j, b += j; else for (;j--; ) e[f++] = c[b++];
                this.b = f;
                e = this.f();
                f = this.b;
              }
              break;

             case Fa:
              for (;f + g > e.length; ) e = this.f({
                v: 2
              });
              break;

             default:
              i(Error("invalid inflate mode"));
            }
            if (H) e.set(c.subarray(b, b + g), f), f += g, b += g; else for (;g--; ) e[f++] = c[b++];
            this.c = b;
            this.b = f;
            this.a = e;
            break;

           case 1:
            this.o(Ia, Ja);
            break;

           case 2:
            Ka(this);
            break;

           default:
            i(Error("unknown BTYPE: " + a));
          }
        }
        return this.t();
      };
      var La = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], Za = H ? new Uint16Array(La) : La, $a = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ], ab = H ? new Uint16Array($a) : $a, bb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ], cb = H ? new Uint8Array(bb) : bb, db = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ], eb = H ? new Uint16Array(db) : db, fb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], gb = H ? new Uint8Array(fb) : fb, hb = new (H ? Uint8Array : Array)(288), Y, ib;
      Y = 0;
      for (ib = hb.length; Y < ib; ++Y) hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
      var Ia = S(hb), jb = new (H ? Uint8Array : Array)(30), kb, lb;
      kb = 0;
      for (lb = jb.length; kb < lb; ++kb) jb[kb] = 5;
      var Ja = S(jb);
      function X(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c; ) g = f[d++], g === r && i(Error("input buffer is broken")), 
        b |= g << e, e += 8;
        g = b & (1 << c) - 1;
        a.g = b >>> c;
        a.e = e - c;
        a.c = d;
        return g;
      }
      function mb(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h; ) m = f[d++], 
        m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
        j = g[b & (1 << h) - 1];
        s = j >>> 16;
        a.g = b >> s;
        a.e = e - s;
        a.c = d;
        return 65535 & j;
      }
      function Ka(a) {
        function c(a, b, c) {
          var d, e, f, g;
          for (g = 0; g < a; ) switch (d = mb(this, b), d) {
           case 16:
            for (f = 3 + X(this, 2); f--; ) c[g++] = e;
            break;

           case 17:
            for (f = 3 + X(this, 3); f--; ) c[g++] = 0;
            e = 0;
            break;

           case 18:
            for (f = 11 + X(this, 7); f--; ) c[g++] = 0;
            e = 0;
            break;

           default:
            e = c[g++] = d;
          }
          return c;
        }
        var b = X(a, 5) + 257, e = X(a, 5) + 1, f = X(a, 4) + 4, d = new (H ? Uint8Array : Array)(Za.length), g, h, m, j;
        for (j = 0; j < f; ++j) d[Za[j]] = X(a, 3);
        g = S(d);
        h = new (H ? Uint8Array : Array)(b);
        m = new (H ? Uint8Array : Array)(e);
        a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
      }
      V.prototype.o = function(a, c) {
        var b = this.a, e = this.b;
        this.u = a;
        for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a)); ) if (256 > d) e >= f && (this.b = e, 
        b = this.f(), e = this.b), b[e++] = d; else {
          g = d - 257;
          m = ab[g];
          0 < cb[g] && (m += X(this, cb[g]));
          d = mb(this, c);
          h = eb[d];
          0 < gb[d] && (h += X(this, gb[d]));
          e >= f && (this.b = e, b = this.f(), e = this.b);
          for (;m--; ) b[e] = b[e++ - h];
        }
        for (;8 <= this.e; ) this.e -= 8, this.c--;
        this.b = e;
      };
      V.prototype.I = function(a, c) {
        var b = this.a, e = this.b;
        this.u = a;
        for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a)); ) if (256 > d) e >= f && (b = this.f(), 
        f = b.length), b[e++] = d; else {
          g = d - 257;
          m = ab[g];
          0 < cb[g] && (m += X(this, cb[g]));
          d = mb(this, c);
          h = eb[d];
          0 < gb[d] && (h += X(this, gb[d]));
          e + m > f && (b = this.f(), f = b.length);
          for (;m--; ) b[e] = b[e++ - h];
        }
        for (;8 <= this.e; ) this.e -= 8, this.c--;
        this.b = e;
      };
      V.prototype.f = function() {
        var a = new (H ? Uint8Array : Array)(this.b - 32768), c = this.b - 32768, b, e, f = this.a;
        if (H) a.set(f.subarray(32768, a.length)); else {
          b = 0;
          for (e = a.length; b < e; ++b) a[b] = f[b + 32768];
        }
        this.k.push(a);
        this.q += a.length;
        if (H) f.set(f.subarray(c, c + 32768)); else for (b = 0; 32768 > b; ++b) f[b] = f[c + b];
        this.b = 32768;
        return f;
      };
      V.prototype.J = function(a) {
        var c, b = this.input.length / this.c + 1 | 0, e, f, d, g = this.input, h = this.a;
        a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
        2 > b ? (e = (g.length - this.c) / this.u[2], d = e / 2 * 258 | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
        H ? (c = new Uint8Array(f), c.set(h)) : c = h;
        return this.a = c;
      };
      V.prototype.t = function() {
        var a = 0, c = this.a, b = this.k, e, f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)), d, g, h, m;
        if (0 === b.length) return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        d = 0;
        for (g = b.length; d < g; ++d) {
          e = b[d];
          h = 0;
          for (m = e.length; h < m; ++h) f[a++] = e[h];
        }
        d = 32768;
        for (g = this.b; d < g; ++d) f[a++] = c[d];
        this.k = [];
        return this.buffer = f;
      };
      V.prototype.H = function() {
        var a, c = this.b;
        H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), 
        a = this.a);
        return this.buffer = a;
      };
      function nb(a, c) {
        var b, e;
        this.input = a;
        this.c = 0;
        !c && (c = {}) || (c.index && (this.c = c.index), c.verify && (this.M = c.verify));
        b = a[this.c++];
        e = a[this.c++];
        switch (15 & b) {
         case Ea:
          this.method = Ea;
          break;

         default:
          i(Error("unsupported compression method"));
        }
        0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
        32 & e && i(Error("fdict flag is not supported"));
        this.A = new V(a, {
          index: this.c,
          bufferSize: c.bufferSize,
          bufferType: c.bufferType,
          resize: c.resize
        });
      }
      nb.prototype.p = function() {
        var a = this.input, c, b;
        c = this.A.p();
        this.c = this.A.c;
        this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, 
        b !== ba(c) && i(Error("invalid adler-32 checksum")));
        return c;
      };
      y("Zlib.Inflate", nb);
      y("Zlib.Inflate.BufferType", Ha);
      Ha.ADAPTIVE = Ha.C;
      Ha.BLOCK = Ha.D;
      y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
      var ob = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
      H && new Uint16Array(ob);
      var pb = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ];
      H && new Uint16Array(pb);
      var qb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ];
      H && new Uint8Array(qb);
      var rb = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
      H && new Uint16Array(rb);
      var sb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
      H && new Uint8Array(sb);
      var tb = new (H ? Uint8Array : Array)(288), Z, ub;
      Z = 0;
      for (ub = tb.length; Z < ub; ++Z) tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
      S(tb);
      var vb = new (H ? Uint8Array : Array)(30), wb, xb;
      wb = 0;
      for (xb = vb.length; wb < xb; ++wb) vb[wb] = 5;
      S(vb);
      var Ea = 8;
    }).call(window);
    var _p = window.Zlib;
    _p.Deflate = _p["Deflate"];
    _p.Deflate.compress = _p.Deflate["compress"];
    _p.Inflate = _p["Inflate"];
    _p.Inflate.BufferType = _p.Inflate["BufferType"];
    _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];
    module.exports = _p;
  }), {} ],
  28: [ (function(require, module, exports) {
    var EventTarget = require("./event/event-target");
    var AutoReleaseUtils = require("./load-pipeline/auto-release-utils");
    var ComponentScheduler = require("./component-scheduler");
    var NodeActivator = require("./node-activator");
    var EventListeners = require("./event/event-listeners");
    var Obj = require("./platform/CCObject");
    var renderer = require("./renderer");
    var eventManager = require("./event-manager");
    cc.Director = function() {
      EventTarget.call(this);
      this.invalid = false;
      this._paused = false;
      this._purgeDirectorInNextLoop = false;
      this._winSizeInPoints = null;
      this._loadingScene = "";
      this._scene = null;
      this._totalFrames = 0;
      this._lastUpdate = performance.now();
      this._deltaTime = 0;
      this._scheduler = null;
      this._compScheduler = null;
      this._nodeActivator = null;
      this._actionManager = null;
      var self = this;
      cc.game.on(cc.game.EVENT_SHOW, (function() {
        self._lastUpdate = performance.now();
      }));
    };
    cc.Director.prototype = {
      constructor: cc.Director,
      init: function() {
        this._totalFrames = 0;
        this._lastUpdate = performance.now();
        this._paused = false;
        this._purgeDirectorInNextLoop = false;
        this._winSizeInPoints = cc.size(0, 0);
        this._scheduler = new cc.Scheduler();
        if (cc.ActionManager) {
          this._actionManager = new cc.ActionManager();
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._actionManager = null;
        cc.game.renderType === cc.game.RENDER_TYPE_WEBGL && (cc.dynamicAtlasManager.enabled = true);
        this.sharedInit();
        return true;
      },
      sharedInit: function() {
        this._compScheduler = new ComponentScheduler();
        this._nodeActivator = new NodeActivator();
        eventManager && eventManager.setEnabled(true);
        if (cc.AnimationManager) {
          this._animationManager = new cc.AnimationManager();
          this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._animationManager = null;
        if (cc.CollisionManager) {
          this._collisionManager = new cc.CollisionManager();
          this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._collisionManager = null;
        if (cc.PhysicsManager) {
          this._physicsManager = new cc.PhysicsManager();
          this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        } else this._physicsManager = null;
        cc._widgetManager && cc._widgetManager.init(this);
        cc.loader.init(this);
      },
      calculateDeltaTime: function() {
        var now = performance.now();
        this._deltaTime = (now - this._lastUpdate) / 1e3;
        cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > 1 && (this._deltaTime = 1 / 60);
        this._lastUpdate = now;
      },
      convertToGL: function(uiPoint) {
        var container = cc.game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var x = view._devicePixelRatio * (uiPoint.x - left);
        var y = view._devicePixelRatio * (top + box.height - uiPoint.y);
        return view._isRotated ? {
          x: view._viewportRect.width - y,
          y: x
        } : {
          x: x,
          y: y
        };
      },
      convertToUI: function(glPoint) {
        var container = cc.game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var uiPoint = {
          x: 0,
          y: 0
        };
        if (view._isRotated) {
          uiPoint.x = left + glPoint.y / view._devicePixelRatio;
          uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio;
        } else {
          uiPoint.x = left + glPoint.x * view._devicePixelRatio;
          uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio;
        }
        return uiPoint;
      },
      end: function() {
        this._purgeDirectorInNextLoop = true;
      },
      getWinSize: function() {
        return cc.size(this._winSizeInPoints);
      },
      getWinSizeInPixels: function() {
        return cc.size(this._winSizeInPoints.width, this._winSizeInPoints.height);
      },
      pause: function() {
        if (this._paused) return;
        this._paused = true;
      },
      purgeCachedData: function() {
        cc.loader.releaseAll();
      },
      purgeDirector: function() {
        this._scheduler.unscheduleAll();
        this._compScheduler.unscheduleAll();
        this._nodeActivator.reset();
        eventManager && eventManager.setEnabled(false);
        cc.renderer.clear();
        true;
        cc.isValid(this._scene) && this._scene.destroy();
        this._scene = null;
        this.stopAnimation();
        cc.loader.releaseAll();
      },
      reset: function() {
        this.purgeDirector();
        eventManager && eventManager.setEnabled(true);
        this._actionManager && this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._collisionManager && this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._physicsManager && this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this.startAnimation();
      },
      runSceneImmediate: function(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene instanceof cc.Scene, 1216);
        (true, true) && console.time("InitScene");
        scene._load();
        (true, true) && console.timeEnd("InitScene");
        var game = cc.game;
        var persistNodeList = Object.keys(game._persistRootNodes).map((function(x) {
          return game._persistRootNodes[x];
        }));
        for (var i = 0; i < persistNodeList.length; i++) {
          var node = persistNodeList[i];
          game._ignoreRemovePersistNode = node;
          node.parent = null;
          game._ignoreRemovePersistNode = null;
        }
        var oldScene = this._scene;
        true;
        (true, true) && console.time("AutoRelease");
        var autoReleaseAssets = oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets;
        AutoReleaseUtils.autoRelease(autoReleaseAssets, scene.dependAssets, persistNodeList);
        (true, true) && console.timeEnd("AutoRelease");
        (true, true) && console.time("Destroy");
        cc.isValid(oldScene) && oldScene.destroy();
        this._scene = null;
        Obj._deferredDestroy();
        (true, true) && console.timeEnd("Destroy");
        onBeforeLoadScene && onBeforeLoadScene();
        this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
        this._scene = scene;
        (true, true) && console.time("AttachPersist");
        for (var _i = 0; _i < persistNodeList.length; _i++) {
          var _node = persistNodeList[_i];
          var existNode = scene.getChildByUuid(_node.uuid);
          if (existNode) {
            var index = existNode.getSiblingIndex();
            existNode._destroyImmediate();
            scene.insertChild(_node, index);
          } else _node.parent = scene;
        }
        (true, true) && console.timeEnd("AttachPersist");
        (true, true) && console.time("Activate");
        scene._activate();
        (true, true) && console.timeEnd("Activate");
        this.startAnimation();
        onLaunched && onLaunched(null, scene);
        this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
      },
      runScene: function(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene, 1205);
        cc.assertID(scene instanceof cc.Scene, 1216);
        scene._load();
        this.once(cc.Director.EVENT_AFTER_UPDATE, (function() {
          this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
        }));
      },
      _getSceneUuid: function(key) {
        var scenes = cc.game._sceneInfos;
        if ("string" === typeof key) {
          key.endsWith(".fire") || (key += ".fire");
          "/" === key[0] || key.startsWith("db://assets/") || (key = "/" + key);
          for (var i = 0; i < scenes.length; i++) {
            var info = scenes[i];
            if (info.url.endsWith(key)) return info;
          }
        } else if ("number" === typeof key) {
          if (0 <= key && key < scenes.length) return scenes[key];
          cc.errorID(1206, key);
        } else cc.errorID(1207, key);
        return null;
      },
      loadScene: function(sceneName, onLaunched, _onUnloaded) {
        if (this._loadingScene) {
          cc.errorID(1208, sceneName, this._loadingScene);
          return false;
        }
        var info = this._getSceneUuid(sceneName);
        if (info) {
          var uuid = info.uuid;
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          this._loadingScene = sceneName;
          this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
          return true;
        }
        cc.errorID(1209, sceneName);
        return false;
      },
      preloadScene: function(sceneName, onLoaded) {
        var info = this._getSceneUuid(sceneName);
        if (info) {
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          cc.loader.load({
            uuid: info.uuid,
            type: "uuid"
          }, (function(error, asset) {
            error && cc.errorID(1210, sceneName, error.message);
            onLoaded && onLoaded(error, asset);
          }));
        } else {
          var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
          onLoaded(new Error(error));
          cc.error("preloadScene: " + error);
        }
      },
      _loadSceneByUuid: function(uuid, onLaunched, onUnloaded, dontRunScene) {
        false;
        console.time("LoadScene " + uuid);
        cc.AssetLibrary.loadAsset(uuid, (function(error, sceneAsset) {
          console.timeEnd("LoadScene " + uuid);
          var self = cc.director;
          self._loadingScene = "";
          if (error) {
            error = "Failed to load scene: " + error;
            cc.error(error);
          } else {
            if (sceneAsset instanceof cc.SceneAsset) {
              var scene = sceneAsset.scene;
              scene._id = sceneAsset._uuid;
              scene._name = sceneAsset._name;
              false;
              self.runSceneImmediate(scene, onUnloaded, onLaunched);
              return;
            }
            error = "The asset " + uuid + " is not a scene";
            cc.error(error);
          }
          onLaunched && onLaunched(error);
        }));
      },
      resume: function() {
        if (!this._paused) return;
        this._lastUpdate = performance.now();
        this._lastUpdate || cc.logID(1200);
        this._paused = false;
        this._deltaTime = 0;
      },
      setDepthTest: function(value) {
        if (!cc.Camera.main) return;
        cc.Camera.main.depth = !!value;
      },
      setClearColor: function(clearColor) {
        if (!cc.Camera.main) return;
        cc.Camera.main.backgroundColor = clearColor;
      },
      getRunningScene: function() {
        return this._scene;
      },
      getScene: function() {
        return this._scene;
      },
      getAnimationInterval: function() {
        return 1e3 / cc.game.getFrameRate();
      },
      setAnimationInterval: function(value) {
        cc.game.setFrameRate(Math.round(1e3 / value));
      },
      getDeltaTime: function() {
        return this._deltaTime;
      },
      getTotalFrames: function() {
        return this._totalFrames;
      },
      isDisplayStats: function() {
        return !!cc.profiler && cc.profiler.isShowingStats();
      },
      setDisplayStats: function(displayStats) {
        if (cc.profiler) {
          displayStats ? cc.profiler.showStats() : cc.profiler.hideStats();
          cc.game.config[cc.game.CONFIG_KEY.showFPS] = !!displayStats;
        }
      },
      isPaused: function() {
        return this._paused;
      },
      getScheduler: function() {
        return this._scheduler;
      },
      setScheduler: function(scheduler) {
        this._scheduler !== scheduler && (this._scheduler = scheduler);
      },
      getActionManager: function() {
        return this._actionManager;
      },
      setActionManager: function(actionManager) {
        if (this._actionManager !== actionManager) {
          this._actionManager && this._scheduler.unscheduleUpdate(this._actionManager);
          this._actionManager = actionManager;
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        }
      },
      getAnimationManager: function() {
        return this._animationManager;
      },
      getCollisionManager: function() {
        return this._collisionManager;
      },
      getPhysicsManager: function() {
        return this._physicsManager;
      },
      startAnimation: function() {
        this.invalid = false;
        this._lastUpdate = performance.now();
      },
      stopAnimation: function() {
        this.invalid = true;
      },
      mainLoop: function() {
        if (this._purgeDirectorInNextLoop) {
          this._purgeDirectorInNextLoop = false;
          this.purgeDirector();
        } else if (!this.invalid) {
          this.calculateDeltaTime();
          if (!this._paused) {
            this.emit(cc.Director.EVENT_BEFORE_UPDATE);
            this._compScheduler.startPhase();
            this._compScheduler.updatePhase(this._deltaTime);
            this._scheduler.update(this._deltaTime);
            this._compScheduler.lateUpdatePhase(this._deltaTime);
            this.emit(cc.Director.EVENT_AFTER_UPDATE);
            Obj._deferredDestroy();
          }
          this.emit(cc.Director.EVENT_BEFORE_DRAW);
          renderer.render(this._scene);
          this.emit(cc.Director.EVENT_AFTER_DRAW);
          eventManager.frameUpdateListeners();
          this._totalFrames++;
        }
      },
      __fastOn: function(type, callback, target) {
        this.add(type, callback, target);
      },
      __fastOff: function(type, callback, target) {
        this.remove(type, callback, target);
      }
    };
    cc.js.addon(cc.Director.prototype, EventTarget.prototype);
    cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
    cc.Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
    cc.Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
    cc.Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
    cc.Director.EVENT_BEFORE_UPDATE = "director_before_update";
    cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
    cc.Director.EVENT_BEFORE_VISIT = "director_before_draw";
    cc.Director.EVENT_AFTER_VISIT = "director_before_draw";
    cc.Director.EVENT_BEFORE_DRAW = "director_before_draw";
    cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
    cc.Director.PROJECTION_2D = 0;
    cc.Director.PROJECTION_3D = 1;
    cc.Director.PROJECTION_CUSTOM = 3;
    cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_2D;
  }), {
    "./component-scheduler": 61,
    "./event-manager": 98,
    "./event/event-listeners": 99,
    "./event/event-target": 100,
    "./load-pipeline/auto-release-utils": 113,
    "./node-activator": 127,
    "./platform/CCObject": 161,
    "./renderer": 196
  } ],
  29: [ (function(require, module, exports) {
    var EventTarget = require("./event/event-target");
    var View;
    true;
    View = require("./platform/CCView");
    require("../audio/CCAudioEngine");
    var renderer = require("./renderer/index.js");
    var inputManager = require("./platform/CCInputManager");
    var game = {
      EVENT_HIDE: "game_on_hide",
      EVENT_SHOW: "game_on_show",
      EVENT_GAME_INITED: "game_inited",
      EVENT_RENDERER_INITED: "renderer_inited",
      RENDER_TYPE_CANVAS: 0,
      RENDER_TYPE_WEBGL: 1,
      RENDER_TYPE_OPENGL: 2,
      _persistRootNodes: {},
      _ignoreRemovePersistNode: null,
      CONFIG_KEY: {
        width: "width",
        height: "height",
        debugMode: "debugMode",
        exposeClassName: "exposeClassName",
        showFPS: "showFPS",
        frameRate: "frameRate",
        id: "id",
        renderMode: "renderMode",
        registerSystemEvent: "registerSystemEvent",
        jsList: "jsList",
        scenes: "scenes"
      },
      _paused: true,
      _configLoaded: false,
      _isCloning: false,
      _prepareCalled: false,
      _prepared: false,
      _rendererInitialized: false,
      _renderContext: null,
      _intervalId: null,
      _lastTime: null,
      _frameTime: null,
      _sceneInfos: [],
      frame: null,
      container: null,
      canvas: null,
      renderType: -1,
      config: null,
      onStart: null,
      setFrameRate: function(frameRate) {
        var config = this.config, CONFIG_KEY = this.CONFIG_KEY;
        config[CONFIG_KEY.frameRate] = frameRate;
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
        this._paused = true;
        this._setAnimFrame();
        this._runMainLoop();
      },
      getFrameRate: function() {
        return this.config[this.CONFIG_KEY.frameRate];
      },
      step: function() {
        cc.director.mainLoop();
      },
      pause: function() {
        if (this._paused) return;
        this._paused = true;
        cc.audioEngine && cc.audioEngine._break();
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
      },
      resume: function() {
        if (!this._paused) return;
        this._paused = false;
        cc.audioEngine && cc.audioEngine._restore();
        this._runMainLoop();
      },
      isPaused: function() {
        return this._paused;
      },
      restart: function() {
        cc.director.once(cc.Director.EVENT_AFTER_DRAW, (function() {
          for (var id in game._persistRootNodes) game.removePersistRootNode(game._persistRootNodes[id]);
          cc.director.getScene().destroy();
          cc.Object._deferredDestroy();
          cc.director.purgeDirector();
          cc.audioEngine && cc.audioEngine.uncacheAll();
          cc.director.reset();
          game.onStart();
        }));
      },
      end: function() {
        close();
      },
      prepare: function(cb) {
        var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
        if (!this._configLoaded) {
          this._loadConfig((function() {
            self.prepare(cb);
          }));
          return;
        }
        if (this._prepared) {
          cb && cb();
          return;
        }
        if (this._prepareCalled) return;
        if (cc._engineLoaded) {
          this._prepareCalled = true;
          cc.director = new cc.Director();
          this._initRenderer(config[CONFIG_KEY.width], config[CONFIG_KEY.height]);
          cc.view = View ? View._getInstance() : null;
          cc.director.init();
          cc.winSize = cc.director.getWinSize();
          true;
          this._initEvents();
          this._setAnimFrame();
          this._runMainLoop();
          var jsList = config[CONFIG_KEY.jsList];
          if (jsList && jsList.length > 0) cc.loader.load(jsList, (function(err) {
            if (err) throw new Error(JSON.stringify(err));
            self._prepared = true;
            cb && cb();
            self.emit(self.EVENT_GAME_INITED);
          })); else {
            cb && cb();
            self.emit(self.EVENT_GAME_INITED);
          }
          return;
        }
        cc.initEngine(this.config, (function() {
          self.prepare(cb);
        }));
      },
      run: function(config, onStart) {
        if ("function" === typeof config) game.onStart = config; else {
          config && (game.config = config);
          "function" === typeof onStart && (game.onStart = onStart);
        }
        this.prepare(game.onStart && game.onStart.bind(game));
      },
      addPersistRootNode: function(node) {
        if (!cc.Node.isNode(node) || !node.uuid) {
          cc.warnID(3800);
          return;
        }
        var id = node.uuid;
        if (!this._persistRootNodes[id]) {
          var scene = cc.director._scene;
          if (cc.isValid(scene)) if (node.parent) {
            if (!(node.parent instanceof cc.Scene)) {
              cc.warnID(3801);
              return;
            }
            if (node.parent !== scene) {
              cc.warnID(3802);
              return;
            }
          } else node.parent = scene;
          this._persistRootNodes[id] = node;
          node._persistNode = true;
        }
      },
      removePersistRootNode: function(node) {
        if (node !== this._ignoreRemovePersistNode) {
          var id = node.uuid || "";
          if (node === this._persistRootNodes[id]) {
            delete this._persistRootNodes[id];
            node._persistNode = false;
          }
        }
      },
      isPersistRootNode: function(node) {
        return node._persistNode;
      },
      _setAnimFrame: function() {
        this._lastTime = new Date();
        var frameRate = game.config[game.CONFIG_KEY.frameRate];
        this._frameTime = 1e3 / frameRate;
        false;
        if (60 !== frameRate && 30 !== frameRate) {
          window.requestAnimFrame = this._stTime;
          window.cancelAnimFrame = this._ctTime;
        } else {
          window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime;
          window.cancelAnimFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime;
        }
      },
      _stTime: function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
        var id = window.setTimeout((function() {
          callback();
        }), timeToCall);
        game._lastTime = currTime + timeToCall;
        return id;
      },
      _ctTime: function(id) {
        window.clearTimeout(id);
      },
      _runMainLoop: function() {
        var self = this, callback, config = self.config, CONFIG_KEY = self.CONFIG_KEY, director = cc.director, skip = true, frameRate = config[CONFIG_KEY.frameRate];
        director.setDisplayStats(config[CONFIG_KEY.showFPS]);
        callback = function() {
          if (!self._paused) {
            self._intervalId = window.requestAnimFrame(callback);
            if ((true, 30 === frameRate) && (skip = !skip)) return;
            director.mainLoop();
          }
        };
        self._intervalId = window.requestAnimFrame(callback);
        self._paused = false;
      },
      _loadConfig: function(cb) {
        if (this.config) {
          this._initConfig(this.config);
          cb && cb();
          return;
        }
        if (document["ccConfig"]) {
          this._initConfig(document["ccConfig"]);
          cb && cb();
          return;
        }
        var self = this;
        cc.loader.load("project.json", (function(err, data) {
          err && cc.logID(3818);
          self._initConfig(data || {});
          cb && cb();
        }));
      },
      _initConfig: function(config) {
        var CONFIG_KEY = this.CONFIG_KEY;
        "number" !== typeof config[CONFIG_KEY.debugMode] && (config[CONFIG_KEY.debugMode] = 0);
        config[CONFIG_KEY.exposeClassName] = !!config[CONFIG_KEY.exposeClassName];
        "number" !== typeof config[CONFIG_KEY.frameRate] && (config[CONFIG_KEY.frameRate] = 60);
        "number" !== typeof config[CONFIG_KEY.renderMode] && (config[CONFIG_KEY.renderMode] = 0);
        "boolean" !== typeof config[CONFIG_KEY.registerSystemEvent] && (config[CONFIG_KEY.registerSystemEvent] = true);
        config[CONFIG_KEY.showFPS] = !(CONFIG_KEY.showFPS in config) || !!config[CONFIG_KEY.showFPS];
        this._sceneInfos = config[CONFIG_KEY.scenes] || [];
        this.collisionMatrix = config.collisionMatrix || [];
        this.groupList = config.groupList || [];
        cc._initDebugSetting(config[CONFIG_KEY.debugMode]);
        this.config = config;
        this._configLoaded = true;
      },
      _initRenderer: function(width, height) {
        if (this._rendererInitialized) return;
        var el = this.config[game.CONFIG_KEY.id], win = window, localCanvas, localContainer, isWeChatGame = cc.sys.platform === cc.sys.WECHAT_GAME, isQQPlay = cc.sys.platform === cc.sys.QQ_PLAY;
        if (isWeChatGame || false) {
          this.container = localContainer = document.createElement("DIV");
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) localCanvas = wx.getSharedCanvas(); else {
            false;
            localCanvas = canvas;
          }
          this.canvas = localCanvas;
        } else if (isQQPlay) {
          this.container = cc.container = document.createElement("DIV");
          this.frame = document.documentElement;
          this.canvas = localCanvas = canvas;
        } else {
          var element = el instanceof HTMLElement ? el : document.querySelector(el) || document.querySelector("#" + el);
          if ("CANVAS" === element.tagName) {
            width = width || element.width;
            height = height || element.height;
            this.canvas = localCanvas = element;
            this.container = localContainer = document.createElement("DIV");
            localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas);
          } else {
            "DIV" !== element.tagName && cc.warnID(3819);
            width = width || element.clientWidth;
            height = height || element.clientHeight;
            this.canvas = localCanvas = document.createElement("CANVAS");
            this.container = localContainer = document.createElement("DIV");
            element.appendChild(localContainer);
          }
          localContainer.setAttribute("id", "Cocos2dGameContainer");
          localContainer.appendChild(localCanvas);
          this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
          function addClass(element, name) {
            var hasClass = (" " + element.className + " ").indexOf(" " + name + " ") > -1;
            if (!hasClass) {
              element.className && (element.className += " ");
              element.className += name;
            }
          }
          addClass(localCanvas, "gameCanvas");
          localCanvas.setAttribute("width", width || 480);
          localCanvas.setAttribute("height", height || 320);
          localCanvas.setAttribute("tabindex", 99);
        }
        if (game.renderType === game.RENDER_TYPE_WEBGL) {
          var opts = {
            stencil: true,
            antialias: cc.macro.ENABLE_WEBGL_ANTIALIAS,
            alpha: cc.macro.ENABLE_TRANSPARENT_CANVAS
          };
          isWeChatGame && (opts["preserveDrawingBuffer"] = true);
          renderer.initWebGL(localCanvas, opts);
          this._renderContext = renderer.device._gl;
        }
        if (!this._renderContext) {
          game.renderType = game.RENDER_TYPE_CANVAS;
          renderer.initCanvas(localCanvas);
          this._renderContext = renderer.device._ctx;
        }
        cc.renderer = renderer;
        game.canvas.oncontextmenu = function() {
          if (!cc._isContextMenuEnable) return false;
        };
        this.emit(this.EVENT_RENDERER_INITED, true);
        this._rendererInitialized = true;
      },
      _initEvents: function() {
        var win = window, hiddenPropName;
        this.config[this.CONFIG_KEY.registerSystemEvent] && inputManager.registerSystemEvent(this.canvas);
        "undefined" !== typeof document.hidden ? hiddenPropName = "hidden" : "undefined" !== typeof document.mozHidden ? hiddenPropName = "mozHidden" : "undefined" !== typeof document.msHidden ? hiddenPropName = "msHidden" : "undefined" !== typeof document.webkitHidden && (hiddenPropName = "webkitHidden");
        var hidden = false;
        function onHidden() {
          if (!hidden) {
            hidden = true;
            game.emit(game.EVENT_HIDE, game);
          }
        }
        function onShown() {
          if (hidden) {
            hidden = false;
            game.emit(game.EVENT_SHOW, game);
          }
        }
        if (hiddenPropName) {
          var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ];
          for (var i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], (function(event) {
            var visible = document[hiddenPropName];
            visible = visible || event["hidden"];
            visible ? onHidden() : onShown();
          }));
        } else {
          win.addEventListener("blur", onHidden);
          win.addEventListener("focus", onShown);
        }
        navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = onShown);
        false;
        if ("onpageshow" in window && "onpagehide" in window) {
          win.addEventListener("pagehide", onHidden);
          win.addEventListener("pageshow", onShown);
          document.addEventListener("pagehide", onHidden);
          document.addEventListener("pageshow", onShown);
        }
        this.on(game.EVENT_HIDE, (function() {
          game.pause();
        }));
        this.on(game.EVENT_SHOW, (function() {
          game.resume();
        }));
      }
    };
    EventTarget.call(game);
    cc.js.addon(game, EventTarget.prototype);
    cc.game = module.exports = game;
  }), {
    "../audio/CCAudioEngine": 23,
    "./event/event-target": 100,
    "./platform/BKInputManager": 153,
    "./platform/CCInputManager": 159,
    "./platform/CCView": 165,
    "./renderer/index.js": 196
  } ],
  30: [ (function(require, module, exports) {
    "use strict";
    var BaseNode = require("./utils/base-node");
    var PrefabHelper = require("./utils/prefab-helper");
    var mathPools = require("./utils/math-pools");
    var renderEngine = require("./renderer/render-engine");
    var AffineTrans = require("./utils/affine-transform");
    var math = renderEngine.math;
    var eventManager = require("./event-manager");
    var macro = require("./platform/CCMacro");
    var misc = require("./utils/misc");
    var js = require("./platform/js");
    var Event = require("./event/event");
    var EventTarget = require("./event/event-target");
    var RenderFlow = require("./renderer/render-flow");
    var Flags = cc.Object.Flags;
    var Destroying = Flags.Destroying;
    var ERR_INVALID_NUMBER = false;
    var ONE_DEGREE = Math.PI / 180;
    var ActionManagerExist = !!cc.ActionManager;
    var emptyFunc = function() {};
    var _mat4_temp = math.mat4.create();
    var _vec3_temp = math.vec3.create();
    var _quat_temp = math.quat.create();
    var _globalOrderOfArrival = 1;
    var _cachedArray = new Array(16);
    _cachedArray.length = 0;
    var POSITION_ON = 1;
    var SCALE_ON = 2;
    var ROTATION_ON = 4;
    var SIZE_ON = 8;
    var ANCHOR_ON = 16;
    var LocalDirtyFlag = cc.Enum({
      POSITION: 1,
      SCALE: 2,
      ROTATION: 4,
      SKEW: 8,
      RT: 7,
      ALL: 65535
    });
    var EventType = cc.Enum({
      TOUCH_START: "touchstart",
      TOUCH_MOVE: "touchmove",
      TOUCH_END: "touchend",
      TOUCH_CANCEL: "touchcancel",
      MOUSE_DOWN: "mousedown",
      MOUSE_MOVE: "mousemove",
      MOUSE_ENTER: "mouseenter",
      MOUSE_LEAVE: "mouseleave",
      MOUSE_UP: "mouseup",
      MOUSE_WHEEL: "mousewheel",
      POSITION_CHANGED: "position-changed",
      ROTATION_CHANGED: "rotation-changed",
      SCALE_CHANGED: "scale-changed",
      SIZE_CHANGED: "size-changed",
      ANCHOR_CHANGED: "anchor-changed",
      CHILD_ADDED: "child-added",
      CHILD_REMOVED: "child-removed",
      CHILD_REORDER: "child-reorder",
      GROUP_CHANGED: "group-changed"
    });
    var _touchEvents = [ EventType.TOUCH_START, EventType.TOUCH_MOVE, EventType.TOUCH_END, EventType.TOUCH_CANCEL ];
    var _mouseEvents = [ EventType.MOUSE_DOWN, EventType.MOUSE_ENTER, EventType.MOUSE_MOVE, EventType.MOUSE_LEAVE, EventType.MOUSE_UP, EventType.MOUSE_WHEEL ];
    var _currentHovered = null;
    var _touchStartHandler = function(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.TOUCH_START;
        event.touch = touch;
        event.bubbles = true;
        node.dispatchEvent(event);
        return true;
      }
      return false;
    };
    var _touchMoveHandler = function(touch, event) {
      var node = this.owner;
      event.type = EventType.TOUCH_MOVE;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _touchEndHandler = function(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      node._hitTest(pos, this) ? event.type = EventType.TOUCH_END : event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _touchCancelHandler = function(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _mouseDownHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_DOWN;
        event.bubbles = true;
        node.dispatchEvent(event);
      }
    };
    var _mouseMoveHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      var hit = node._hitTest(pos, this);
      if (hit) {
        if (!this._previousIn) {
          if (_currentHovered && _currentHovered._mouseListener) {
            event.type = EventType.MOUSE_LEAVE;
            _currentHovered.dispatchEvent(event);
            _currentHovered._mouseListener._previousIn = false;
          }
          _currentHovered = this.owner;
          event.type = EventType.MOUSE_ENTER;
          node.dispatchEvent(event);
          this._previousIn = true;
        }
        event.type = EventType.MOUSE_MOVE;
        event.bubbles = true;
        node.dispatchEvent(event);
      } else {
        if (!this._previousIn) return;
        event.type = EventType.MOUSE_LEAVE;
        node.dispatchEvent(event);
        this._previousIn = false;
        _currentHovered = null;
      }
      event.stopPropagation();
    };
    var _mouseUpHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_UP;
        event.bubbles = true;
        node.dispatchEvent(event);
        event.stopPropagation();
      }
    };
    var _mouseWheelHandler = function(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_WHEEL;
        event.bubbles = true;
        node.dispatchEvent(event);
        event.stopPropagation();
      }
    };
    function _searchMaskInParent(node) {
      var Mask = cc.Mask;
      if (Mask) {
        var index = 0;
        for (var curr = node; curr && cc.Node.isNode(curr); curr = curr._parent, ++index) if (curr.getComponent(Mask)) return {
          index: index,
          node: curr
        };
      }
      return null;
    }
    function _checkListeners(node, events) {
      if (!(node._objFlags & Destroying)) {
        var i = 0;
        if (node._bubblingListeners) for (;i < events.length; ++i) if (node._bubblingListeners.hasEventListener(events[i])) return true;
        if (node._capturingListeners) for (;i < events.length; ++i) if (node._capturingListeners.hasEventListener(events[i])) return true;
        return false;
      }
      return true;
    }
    function _doDispatchEvent(owner, event) {
      var target, i;
      event.target = owner;
      _cachedArray.length = 0;
      owner._getCapturingTargets(event.type, _cachedArray);
      event.eventPhase = 1;
      for (i = _cachedArray.length - 1; i >= 0; --i) {
        target = _cachedArray[i];
        if (target._capturingListeners) {
          event.currentTarget = target;
          target._capturingListeners.invoke(event, _cachedArray);
          if (event._propagationStopped) {
            _cachedArray.length = 0;
            return;
          }
        }
      }
      _cachedArray.length = 0;
      event.eventPhase = 2;
      event.currentTarget = owner;
      owner._capturingListeners && owner._capturingListeners.invoke(event);
      !event._propagationImmediateStopped && owner._bubblingListeners && owner._bubblingListeners.invoke(event);
      if (!event._propagationStopped && event.bubbles) {
        owner._getBubblingTargets(event.type, _cachedArray);
        event.eventPhase = 3;
        for (i = 0; i < _cachedArray.length; ++i) {
          target = _cachedArray[i];
          if (target._bubblingListeners) {
            event.currentTarget = target;
            target._bubblingListeners.invoke(event);
            if (event._propagationStopped) {
              _cachedArray.length = 0;
              return;
            }
          }
        }
      }
      _cachedArray.length = 0;
    }
    var Node = cc.Class({
      name: "cc.Node",
      extends: BaseNode,
      properties: {
        _opacity: 255,
        _color: cc.Color.WHITE,
        _contentSize: cc.Size,
        _anchorPoint: cc.v2(.5, .5),
        _position: cc.Vec3,
        _scaleX: {
          default: void 0,
          type: cc.Float
        },
        _scaleY: {
          default: void 0,
          type: cc.Float
        },
        _scale: cc.Vec3,
        _rotationX: 0,
        _rotationY: 0,
        _quat: cc.Quat,
        _skewX: 0,
        _skewY: 0,
        _localZOrder: 0,
        groupIndex: {
          default: 0,
          type: cc.Integer
        },
        group: {
          get: function() {
            return cc.game.groupList[this.groupIndex] || "";
          },
          set: function(value) {
            this.groupIndex = cc.game.groupList.indexOf(value);
            this.emit(EventType.GROUP_CHANGED);
          }
        },
        x: {
          get: function() {
            return this._position.x;
          },
          set: function(value) {
            var localPosition = this._position;
            if (value !== localPosition.x) {
              true;
              var oldValue;
              false;
              localPosition.x = value;
              this.setLocalDirty(LocalDirtyFlag.POSITION);
              this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
              if (this._eventMask & POSITION_ON) {
                false;
                this.emit(EventType.POSITION_CHANGED);
              }
            }
          }
        },
        y: {
          get: function() {
            return this._position.y;
          },
          set: function(value) {
            var localPosition = this._position;
            if (value !== localPosition.y) {
              true;
              var oldValue;
              false;
              localPosition.y = value;
              this.setLocalDirty(LocalDirtyFlag.POSITION);
              this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
              if (this._eventMask & POSITION_ON) {
                false;
                this.emit(EventType.POSITION_CHANGED);
              }
            }
          }
        },
        z: {
          get: function() {
            return this._position.z;
          },
          set: function(value) {
            var localPosition = this._position;
            if (value !== localPosition.z) {
              true;
              localPosition.z = value;
              this.setLocalDirty(LocalDirtyFlag.POSITION);
              this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
              this._eventMask & POSITION_ON && this.emit(EventType.POSITION_CHANGED);
            }
          }
        },
        rotation: {
          get: function() {
            this._rotationX !== this._rotationY && cc.logID(1602);
            return this._rotationX;
          },
          set: function(value) {
            if (this._rotationX !== value || this._rotationY !== value) {
              this._rotationX = this._rotationY = value;
              math.quat.fromEuler(this._quat, 0, 0, -value);
              this.setLocalDirty(LocalDirtyFlag.ROTATION);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            }
          }
        },
        rotationX: {
          get: function() {
            return this._rotationX;
          },
          set: function(value) {
            if (this._rotationX !== value) {
              this._rotationX = value;
              this._rotationX === this._rotationY ? math.quat.fromEuler(this._quat, 0, 0, -value) : math.quat.fromEuler(this._quat, value, this._rotationY, 0);
              this.setLocalDirty(LocalDirtyFlag.ROTATION);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            }
          }
        },
        rotationY: {
          get: function() {
            return this._rotationY;
          },
          set: function(value) {
            if (this._rotationY !== value) {
              this._rotationY = value;
              this._rotationX === this._rotationY ? math.quat.fromEuler(this._quat, 0, 0, -value) : math.quat.fromEuler(this._quat, this._rotationX, value, 0);
              this.setLocalDirty(LocalDirtyFlag.ROTATION);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            }
          }
        },
        scaleX: {
          get: function() {
            return this._scale.x;
          },
          set: function(value) {
            if (this._scale.x !== value) {
              this._scale.x = value;
              this.setLocalDirty(LocalDirtyFlag.SCALE);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
            }
          }
        },
        scaleY: {
          get: function() {
            return this._scale.y;
          },
          set: function(value) {
            if (this._scale.y !== value) {
              this._scale.y = value;
              this.setLocalDirty(LocalDirtyFlag.SCALE);
              this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
              this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
            }
          }
        },
        skewX: {
          get: function() {
            return this._skewX;
          },
          set: function(value) {
            this._skewX = value;
            this.setLocalDirty(LocalDirtyFlag.SKEW);
            this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
          }
        },
        skewY: {
          get: function() {
            return this._skewY;
          },
          set: function(value) {
            this._skewY = value;
            this.setLocalDirty(LocalDirtyFlag.SKEW);
            this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
          }
        },
        opacity: {
          get: function() {
            return this._opacity;
          },
          set: function(value) {
            if (this._opacity !== value) {
              this._opacity = value;
              this._renderFlag |= RenderFlow.FLAG_COLOR;
            }
          },
          range: [ 0, 255 ]
        },
        color: {
          get: function() {
            return this._color.clone();
          },
          set: function(value) {
            if (!this._color.equals(value)) {
              this._color.fromColor(value);
              false;
              this._renderComponent && (this._renderFlag |= RenderFlow.FLAG_COLOR);
            }
          }
        },
        anchorX: {
          get: function() {
            return this._anchorPoint.x;
          },
          set: function(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.x !== value) {
              anchorPoint.x = value;
              this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
            }
          }
        },
        anchorY: {
          get: function() {
            return this._anchorPoint.y;
          },
          set: function(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.y !== value) {
              anchorPoint.y = value;
              this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
            }
          }
        },
        width: {
          get: function() {
            return this._contentSize.width;
          },
          set: function(value) {
            if (value !== this._contentSize.width) {
              var clone;
              false;
              this._contentSize.width = value;
              if (this._eventMask & SIZE_ON) {
                false;
                this.emit(EventType.SIZE_CHANGED);
              }
            }
          }
        },
        height: {
          get: function() {
            return this._contentSize.height;
          },
          set: function(value) {
            if (value !== this._contentSize.height) {
              var clone;
              false;
              this._contentSize.height = value;
              if (this._eventMask & SIZE_ON) {
                false;
                this.emit(EventType.SIZE_CHANGED);
              }
            }
          }
        },
        zIndex: {
          get: function() {
            return (4294901760 & this._localZOrder) >> 16;
          },
          set: function(value) {
            if (value > macro.MAX_ZINDEX) {
              cc.warnID(1636);
              value = macro.MAX_ZINDEX;
            } else if (value < macro.MIN_ZINDEX) {
              cc.warnID(1637);
              value = macro.MIN_ZINDEX;
            }
            var zIndex = (4294901760 & this._localZOrder) >> 16;
            if (zIndex !== value) {
              this._localZOrder = 65535 & this._localZOrder | value << 16;
              this._parent && this._parent._delaySort();
            }
          }
        }
      },
      ctor: function(name) {
        this._reorderChildDirty = false;
        this._widget = null;
        this._renderComponent = null;
        this._capturingListeners = null;
        this._bubblingListeners = null;
        this._touchListener = null;
        this._mouseListener = null;
        this._scale.x = 1;
        this._scale.y = 1;
        this._scale.z = 1;
        this._matrix = mathPools.mat4.get();
        this._worldMatrix = mathPools.mat4.get();
        this._localMatDirty = LocalDirtyFlag.ALL;
        this._worldMatDirty = true;
        this._eventMask = 0;
        this._cullingMask = 1 << this.groupIndex;
      },
      statics: {
        EventType: EventType,
        _LocalDirtyFlag: LocalDirtyFlag,
        isNode: function(obj) {
          return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
        }
      },
      _onSiblingIndexChanged: function(index) {
        var parent = this._parent;
        var siblings = parent._children;
        var i = 0, len = siblings.length, sibling;
        for (;i < len; i++) {
          sibling = siblings[i];
          sibling._updateOrderOfArrival();
          eventManager._setDirtyForNode(sibling);
        }
        parent._delaySort();
      },
      _onPreDestroy: function() {
        var destroyByParent = this._onPreDestroyBase();
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        _currentHovered === this && (_currentHovered = null);
        if (this._touchListener || this._mouseListener) {
          eventManager.removeListeners(this);
          if (this._touchListener) {
            this._touchListener.owner = null;
            this._touchListener.mask = null;
            this._touchListener = null;
          }
          if (this._mouseListener) {
            this._mouseListener.owner = null;
            this._mouseListener.mask = null;
            this._mouseListener = null;
          }
        }
        mathPools.mat4.put(this._matrix);
        mathPools.mat4.put(this._worldMatrix);
        this._matrix = this._worldMatrix = null;
        this._reorderChildDirty && cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        destroyByParent || false;
      },
      _onPostActivated: function(active) {
        var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
        if (active) {
          this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
          actionManager && actionManager.resumeTarget(this);
          eventManager.resumeTarget(this);
          if (this._touchListener) {
            var mask = this._touchListener.mask = _searchMaskInParent(this);
            this._mouseListener && (this._mouseListener.mask = mask);
          } else this._mouseListener && (this._mouseListener.mask = _searchMaskInParent(this));
        } else {
          actionManager && actionManager.pauseTarget(this);
          eventManager.pauseTarget(this);
        }
      },
      _onHierarchyChanged: function(oldParent) {
        this._updateOrderOfArrival();
        this._parent && this._parent._delaySort();
        this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
        this._onHierarchyChangedBase(oldParent);
        cc._widgetManager._nodesOrderDirty = true;
      },
      _upgrade_1x_to_2x: function() {
        if (void 0 !== this._scaleX) {
          this._scale.x = this._scaleX;
          this._scaleX = void 0;
        }
        if (void 0 !== this._scaleY) {
          this._scale.y = this._scaleY;
          this._scaleY = void 0;
        }
        if (0 !== this._rotationX || 0 !== this._rotationY) this._rotationX === this._rotationY ? math.quat.fromEuler(this._quat, 0, 0, -this._rotationX) : math.quat.fromEuler(this._quat, this._rotationX, this._rotationY, 0); else {
          var rotx = this._quat.getRoll();
          var roty = this._quat.getPitch();
          if (0 === rotx && 0 === roty) this._rotationX = this._rotationY = -this._quat.getYaw(); else {
            this._rotationX = rotx;
            this._rotationY = roty;
          }
        }
      },
      _onBatchCreated: function() {
        this._upgrade_1x_to_2x();
        this._updateOrderOfArrival();
        var prefabInfo = this._prefab;
        if (prefabInfo && prefabInfo.sync && prefabInfo.root === this) {
          false;
          PrefabHelper.syncWithPrefab(this);
        }
        if (!this._activeInHierarchy) {
          ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
          eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchCreated();
        children.length > 0 && (this._renderFlag |= RenderFlow.FLAG_CHILDREN);
      },
      _onBatchRestored: function() {
        this._upgrade_1x_to_2x();
        if (!this._activeInHierarchy) {
          ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
          eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) children[i]._onBatchRestored();
        children.length > 0 && (this._renderFlag |= RenderFlow.FLAG_CHILDREN);
      },
      on: function(type, callback, target, useCapture) {
        var newAdded = false;
        var forDispatch = false;
        if (-1 !== _touchEvents.indexOf(type)) {
          if (!this._touchListener) {
            this._touchListener = cc.EventListener.create({
              event: cc.EventListener.TOUCH_ONE_BY_ONE,
              swallowTouches: true,
              owner: this,
              mask: _searchMaskInParent(this),
              onTouchBegan: _touchStartHandler,
              onTouchMoved: _touchMoveHandler,
              onTouchEnded: _touchEndHandler,
              onTouchCancelled: _touchCancelHandler
            });
            eventManager.addListener(this._touchListener, this);
            newAdded = true;
          }
          forDispatch = true;
        } else if (-1 !== _mouseEvents.indexOf(type)) {
          if (!this._mouseListener) {
            this._mouseListener = cc.EventListener.create({
              event: cc.EventListener.MOUSE,
              _previousIn: false,
              owner: this,
              mask: _searchMaskInParent(this),
              onMouseDown: _mouseDownHandler,
              onMouseMove: _mouseMoveHandler,
              onMouseUp: _mouseUpHandler,
              onMouseScroll: _mouseWheelHandler
            });
            eventManager.addListener(this._mouseListener, this);
            newAdded = true;
          }
          forDispatch = true;
        }
        newAdded && !this._activeInHierarchy && cc.director.getScheduler().schedule((function() {
          this._activeInHierarchy || eventManager.pauseTarget(this);
        }), this, 0, 0, 0, false);
        if (forDispatch) return this._onDispatch(type, callback, target, useCapture);
        switch (type) {
         case EventType.POSITION_CHANGED:
          this._eventMask |= POSITION_ON;
          break;

         case EventType.SCALE_CHANGED:
          this._eventMask |= SCALE_ON;
          break;

         case EventType.ROTATION_CHANGED:
          this._eventMask |= ROTATION_ON;
          break;

         case EventType.SIZE_CHANGED:
          this._eventMask |= SIZE_ON;
          break;

         case EventType.ANCHOR_CHANGED:
          this._eventMask |= ANCHOR_ON;
        }
        this._bubblingListeners || (this._bubblingListeners = new EventTarget());
        return this._bubblingListeners.on(type, callback, target);
      },
      _onDispatch: function(type, callback, target, useCapture) {
        if ("boolean" === typeof target) {
          useCapture = target;
          target = void 0;
        } else useCapture = !!useCapture;
        if (!callback) {
          cc.errorID(6800);
          return;
        }
        var listeners = null;
        listeners = useCapture ? this._capturingListeners = this._capturingListeners || new EventTarget() : this._bubblingListeners = this._bubblingListeners || new EventTarget();
        if (!listeners.hasEventListener(type, callback, target)) {
          listeners.add(type, callback, target);
          target && target.__eventTargets && target.__eventTargets.push(this);
        }
        return callback;
      },
      _onceDispatch: function(type, callback, target, useCapture) {
        var eventType_hasOnceListener = "__ONCE_FLAG:" + type;
        var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
        var hasOnceListener = listeners && listeners.hasEventListener(eventType_hasOnceListener, callback, target);
        if (!hasOnceListener) {
          var self = this;
          var onceWrapper = function(event) {
            self._offDispatch(type, onceWrapper, target, useCapture);
            listeners.remove(eventType_hasOnceListener, callback, target);
            callback.call(this, event);
          };
          this._onDispatch(type, onceWrapper, target, useCapture);
          listeners || (listeners = useCapture ? this._capturingListeners : this._bubblingListeners);
          listeners.add(eventType_hasOnceListener, callback, target);
        }
      },
      off: function(type, callback, target, useCapture) {
        var touchEvent = -1 !== _touchEvents.indexOf(type);
        var mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
        if (touchEvent || mouseEvent) {
          this._offDispatch(type, callback, target, useCapture);
          if (touchEvent) {
            if (this._touchListener && !_checkListeners(this, _touchEvents)) {
              eventManager.removeListener(this._touchListener);
              this._touchListener = null;
            }
          } else if (mouseEvent && this._mouseListener && !_checkListeners(this, _mouseEvents)) {
            eventManager.removeListener(this._mouseListener);
            this._mouseListener = null;
          }
        } else if (this._bubblingListeners) {
          this._bubblingListeners.off(type, callback, target);
          var hasListeners = this._bubblingListeners.hasEventListener(type);
          if (!hasListeners) switch (type) {
           case EventType.POSITION_CHANGED:
            this._eventMask &= ~POSITION_ON;
            break;

           case EventType.SCALE_CHANGED:
            this._eventMask &= ~SCALE_ON;
            break;

           case EventType.ROTATION_CHANGED:
            this._eventMask &= ~ROTATION_ON;
            break;

           case EventType.SIZE_CHANGED:
            this._eventMask &= ~SIZE_ON;
            break;

           case EventType.ANCHOR_CHANGED:
            this._eventMask &= ~ANCHOR_ON;
          }
        }
      },
      _offDispatch: function(type, callback, target, useCapture) {
        if ("boolean" === typeof target) {
          useCapture = target;
          target = void 0;
        } else useCapture = !!useCapture;
        if (callback) {
          var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
          if (listeners) {
            listeners.remove(type, callback, target);
            target && target.__eventTargets && js.array.fastRemove(target.__eventTargets, this);
          }
        } else {
          this._capturingListeners && this._capturingListeners.removeAll(type);
          this._bubblingListeners && this._bubblingListeners.removeAll(type);
        }
      },
      targetOff: function(target) {
        var listeners = this._bubblingListeners;
        if (listeners) {
          listeners.targetOff(target);
          this._eventMask & POSITION_ON && !listeners.hasEventListener(EventType.POSITION_CHANGED) && (this._eventMask &= ~POSITION_ON);
          this._eventMask & SCALE_ON && !listeners.hasEventListener(EventType.SCALE_CHANGED) && (this._eventMask &= ~SCALE_ON);
          this._eventMask & ROTATION_ON && !listeners.hasEventListener(EventType.ROTATION_CHANGED) && (this._eventMask &= ~ROTATION_ON);
          this._eventMask & SIZE_ON && !listeners.hasEventListener(EventType.SIZE_CHANGED) && (this._eventMask &= ~SIZE_ON);
          this._eventMask & ANCHOR_ON && !listeners.hasEventListener(EventType.ANCHOR_CHANGED) && (this._eventMask &= ~ANCHOR_ON);
        }
        this._capturingListeners && this._capturingListeners.targetOff(target);
        if (this._touchListener && !_checkListeners(this, _touchEvents)) {
          eventManager.removeListener(this._touchListener);
          this._touchListener = null;
        }
        if (this._mouseListener && !_checkListeners(this, _mouseEvents)) {
          eventManager.removeListener(this._mouseListener);
          this._mouseListener = null;
        }
      },
      hasEventListener: function(type) {
        var has = false;
        this._bubblingListeners && (has = this._bubblingListeners.hasEventListener(type));
        !has && this._capturingListeners && (has = this._capturingListeners.hasEventListener(type));
        return has;
      },
      emit: function(type, detail) {
        this._bubblingListeners && this._bubblingListeners.emit(type, detail, this);
      },
      dispatchEvent: function(event) {
        _doDispatchEvent(this, event);
        _cachedArray.length = 0;
      },
      pauseSystemEvents: function(recursive) {
        eventManager.pauseTarget(this, recursive);
      },
      resumeSystemEvents: function(recursive) {
        eventManager.resumeTarget(this, recursive);
      },
      _hitTest: function(point, listener) {
        var w = this.width, h = this.height;
        var testPt;
        var camera = cc.Camera.findCamera(this);
        testPt = camera ? camera.getCameraToWorldPoint(point) : cc.v2(point);
        this._updateWorldMatrix();
        math.mat4.invert(_mat4_temp, this._worldMatrix);
        math.vec2.transformMat4(testPt, testPt, _mat4_temp);
        testPt.x += this._anchorPoint.x * this._contentSize.width;
        testPt.y += this._anchorPoint.y * this._contentSize.height;
        if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
          if (listener && listener.mask) {
            var mask = listener.mask;
            var parent = this;
            for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) ;
            if (parent === mask.node) {
              var comp = parent.getComponent(cc.Mask);
              return !comp || !comp.enabledInHierarchy || comp._hitTest(point);
            }
            listener.mask = null;
            return true;
          }
          return true;
        }
        return false;
      },
      _getCapturingTargets: function(type, array) {
        var parent = this.parent;
        while (parent) {
          parent._capturingListeners && parent._capturingListeners.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      _getBubblingTargets: function(type, array) {
        var parent = this.parent;
        while (parent) {
          parent._bubblingListeners && parent._bubblingListeners.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      runAction: ActionManagerExist ? function(action) {
        if (!this.active) return;
        cc.assertID(action, 1618);
        cc.director.getActionManager().addAction(action, this, false);
        return action;
      } : emptyFunc,
      pauseAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().pauseTarget(this);
      } : emptyFunc,
      resumeAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().resumeTarget(this);
      } : emptyFunc,
      stopAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().removeAllActionsFromTarget(this);
      } : emptyFunc,
      stopAction: ActionManagerExist ? function(action) {
        cc.director.getActionManager().removeAction(action);
      } : emptyFunc,
      stopActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1612);
          return;
        }
        cc.director.getActionManager().removeActionByTag(tag, this);
      } : emptyFunc,
      getActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1613);
          return null;
        }
        return cc.director.getActionManager().getActionByTag(tag, this);
      } : function() {
        return null;
      },
      getNumberOfRunningActions: ActionManagerExist ? function() {
        return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
      } : function() {
        return 0;
      },
      getPosition: function() {
        return new cc.Vec2(this._position);
      },
      setPosition: function(newPosOrX, y) {
        var x;
        if (void 0 === y) {
          x = newPosOrX.x;
          y = newPosOrX.y;
        } else x = newPosOrX;
        var locPosition = this._position;
        if (locPosition.x === x && locPosition.y === y) return;
        var oldPosition;
        false;
        true;
        locPosition.x = x;
        true;
        locPosition.y = y;
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
        if (this._eventMask & POSITION_ON) {
          false;
          this.emit(EventType.POSITION_CHANGED);
        }
      },
      getScale: function() {
        this._scale.x !== this._scale.y && cc.logID(1603);
        return this._scale.x;
      },
      setScale: function(x, y) {
        if (x && "number" !== typeof x) {
          y = x.y;
          x = x.x;
        } else void 0 === y && (y = x);
        if (this._scale.x !== x || this._scale.y !== y) {
          this._scale.x = x;
          this._scale.y = y;
          this.setLocalDirty(LocalDirtyFlag.SCALE);
          this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
          this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
        }
      },
      getContentSize: function() {
        return cc.size(this._contentSize.width, this._contentSize.height);
      },
      setContentSize: function(size, height) {
        var locContentSize = this._contentSize;
        var clone;
        if (void 0 === height) {
          if (size.width === locContentSize.width && size.height === locContentSize.height) return;
          false;
          locContentSize.width = size.width;
          locContentSize.height = size.height;
        } else {
          if (size === locContentSize.width && height === locContentSize.height) return;
          false;
          locContentSize.width = size;
          locContentSize.height = height;
        }
        if (this._eventMask & SIZE_ON) {
          false;
          this.emit(EventType.SIZE_CHANGED);
        }
      },
      getAnchorPoint: function() {
        return cc.v2(this._anchorPoint);
      },
      setAnchorPoint: function(point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (void 0 === y) {
          if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
          locAnchorPoint.x = point.x;
          locAnchorPoint.y = point.y;
        } else {
          if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
          locAnchorPoint.x = point;
          locAnchorPoint.y = y;
        }
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
      },
      _invTransformPoint: function(out, pos) {
        this._parent ? this._parent._invTransformPoint(out, pos) : math.vec3.copy(out, pos);
        math.vec3.sub(out, out, this._position);
        math.quat.conjugate(_quat_temp, this._quat);
        math.vec3.transformQuat(out, out, _quat_temp);
        math.vec3.inverseSafe(_vec3_temp, this._scale);
        math.vec3.mul(out, out, _vec3_temp);
        return out;
      },
      getWorldPos: function(out) {
        math.vec3.copy(out, this._position);
        var curr = this._parent;
        while (curr) {
          math.vec3.mul(out, out, curr._scale);
          math.vec3.transformQuat(out, out, curr._quat);
          math.vec3.add(out, out, curr._position);
          curr = curr._parent;
        }
        return out;
      },
      setWorldPos: function(pos) {
        this._parent ? this._parent._invTransformPoint(this._position, pos) : math.vec3.copy(this._position, pos);
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        if (this._eventMask & POSITION_ON) {
          false;
          this.emit(EventType.POSITION_CHANGED);
        }
      },
      getWorldRot: function(out) {
        math.quat.copy(out, this._quat);
        var curr = this._parent;
        while (curr) {
          math.quat.mul(out, curr._quat, out);
          curr = curr._parent;
        }
        return out;
      },
      setWorldRot: function(quat) {
        if (this._parent) {
          this._parent.getWorldRot(this._quat);
          math.quat.conjugate(this._quat, this._quat);
          math.quat.mul(this._quat, this._quat, quat);
        } else math.quat.copy(this._quat, quat);
        this.setLocalDirty(LocalDirtyFlag.ROTATION);
      },
      getWorldRT: function(out) {
        var opos = _vec3_temp;
        var orot = _quat_temp;
        math.vec3.copy(opos, this._position);
        math.quat.copy(orot, this._quat);
        var curr = this._parent;
        while (curr) {
          math.vec3.mul(opos, opos, curr._scale);
          math.vec3.transformQuat(opos, opos, curr._quat);
          math.vec3.add(opos, opos, curr._position);
          math.quat.mul(orot, curr._quat, orot);
          curr = curr._parent;
        }
        math.mat4.fromRT(out, orot, opos);
        return out;
      },
      lookAt: function(pos, up) {
        this.getWorldPos(_vec3_temp);
        math.vec3.sub(_vec3_temp, _vec3_temp, pos);
        math.vec3.normalize(_vec3_temp, _vec3_temp);
        math.quat.fromViewUp(_quat_temp, _vec3_temp, up);
        this.setWorldRot(_quat_temp);
      },
      _updateLocalMatrix: function() {
        var dirtyFlag = this._localMatDirty;
        if (!dirtyFlag) return;
        var t = this._matrix;
        if (dirtyFlag & LocalDirtyFlag.RT) {
          var hasRotation = this._rotationX || this._rotationY;
          var hasSkew = this._skewX || this._skewY;
          var sx = this._scale.x, sy = this._scale.y;
          if (hasRotation || hasSkew) {
            var a = 1, b = 0, c = 0, d = 1;
            if (hasRotation) {
              var rotationRadiansX = this._rotationX * ONE_DEGREE;
              c = Math.sin(rotationRadiansX);
              d = Math.cos(rotationRadiansX);
              if (this._rotationY === this._rotationX) {
                a = d;
                b = -c;
              } else {
                var rotationRadiansY = this._rotationY * ONE_DEGREE;
                a = Math.cos(rotationRadiansY);
                b = -Math.sin(rotationRadiansY);
              }
            }
            t.m00 = a *= sx;
            t.m01 = b *= sx;
            t.m04 = c *= sy;
            t.m05 = d *= sy;
            if (hasSkew) {
              var _a = t.m00, _b = t.m01, _c = t.m04, _d = t.m05;
              var skx = Math.tan(this._skewX * ONE_DEGREE);
              var sky = Math.tan(this._skewY * ONE_DEGREE);
              Infinity === skx && (skx = 99999999);
              Infinity === sky && (sky = 99999999);
              t.m00 = _a + _c * sky;
              t.m01 = _b + _d * sky;
              t.m04 = _c + _a * skx;
              t.m05 = _d + _b * skx;
            }
          } else {
            t.m00 = sx;
            t.m01 = 0;
            t.m04 = 0;
            t.m05 = sy;
          }
        }
        t.m12 = this._position.x;
        t.m13 = this._position.y;
        this._localMatDirty = 0;
        this._worldMatDirty = true;
      },
      _calculWorldMatrix: function() {
        this._localMatDirty && this._updateLocalMatrix();
        var parent = this._parent;
        if (parent) {
          var pt = parent._worldMatrix;
          var t = this._matrix;
          var wt = this._worldMatrix;
          var aa = t.m00, ab = t.m01, ac = t.m04, ad = t.m05, atx = t.m12, aty = t.m13;
          var ba = pt.m00, bb = pt.m01, bc = pt.m04, bd = pt.m05, btx = pt.m12, bty = pt.m13;
          if (0 !== bb || 0 !== bc) {
            wt.m00 = aa * ba + ab * bc;
            wt.m01 = aa * bb + ab * bd;
            wt.m04 = ac * ba + ad * bc;
            wt.m05 = ac * bb + ad * bd;
            wt.m12 = ba * atx + bc * aty + btx;
            wt.m13 = bb * atx + bd * aty + bty;
          } else {
            wt.m00 = aa * ba;
            wt.m01 = ab * bd;
            wt.m04 = ac * ba;
            wt.m05 = ad * bd;
            wt.m12 = ba * atx + btx;
            wt.m13 = bd * aty + bty;
          }
        } else math.mat4.copy(this._worldMatrix, this._matrix);
        this._worldMatDirty = false;
      },
      _updateWorldMatrix: function() {
        this._parent && this._parent._updateWorldMatrix();
        if (this._worldMatDirty) {
          this._calculWorldMatrix();
          var children = this._children;
          for (var i = 0, l = children.length; i < l; i++) children[i]._worldMatDirty = true;
        }
      },
      setLocalDirty: function(flag) {
        this._localMatDirty = this._localMatDirty | flag;
        this._worldMatDirty = true;
      },
      setWorldDirty: function() {
        this._worldMatDirty = true;
      },
      getLocalMatrix: function(out) {
        this._updateLocalMatrix();
        return math.mat4.copy(out, this._matrix);
      },
      getWorldMatrix: function(out) {
        this._updateWorldMatrix();
        return math.mat4.copy(out, this._worldMatrix);
      },
      convertToNodeSpace: function(worldPoint) {
        this._updateWorldMatrix();
        math.mat4.invert(_mat4_temp, this._worldMatrix);
        var out = new cc.Vec2();
        math.vec2.transformMat4(out, worldPoint, _mat4_temp);
        out.x += this._anchorPoint.x * this._contentSize.width;
        out.y += this._anchorPoint.y * this._contentSize.height;
        return out;
      },
      convertToWorldSpace: function(nodePoint) {
        this._updateWorldMatrix();
        var out = new cc.Vec2(nodePoint.x - this._anchorPoint.x * this._contentSize.width, nodePoint.y - this._anchorPoint.y * this._contentSize.height);
        return math.vec2.transformMat4(out, out, this._worldMatrix);
      },
      convertToNodeSpaceAR: function(worldPoint) {
        this._updateWorldMatrix();
        math.mat4.invert(_mat4_temp, this._worldMatrix);
        var out = new cc.Vec2();
        return math.vec2.transformMat4(out, worldPoint, _mat4_temp);
      },
      convertToWorldSpaceAR: function(nodePoint) {
        this._updateWorldMatrix();
        var out = new cc.Vec2();
        return math.vec2.transformMat4(out, nodePoint, this._worldMatrix);
      },
      getNodeToParentTransform: function(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        var contentSize = this._contentSize;
        _vec3_temp.x = -this._anchorPoint.x * contentSize.width;
        _vec3_temp.y = -this._anchorPoint.y * contentSize.height;
        math.mat4.copy(_mat4_temp, this._matrix);
        math.mat4.translate(_mat4_temp, _mat4_temp, _vec3_temp);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getNodeToParentTransformAR: function(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        return AffineTrans.fromMat4(out, this._matrix);
      },
      getNodeToWorldTransform: function(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        var contentSize = this._contentSize;
        _vec3_temp.x = -this._anchorPoint.x * contentSize.width;
        _vec3_temp.y = -this._anchorPoint.y * contentSize.height;
        math.mat4.copy(_mat4_temp, this._worldMatrix);
        math.mat4.translate(_mat4_temp, _mat4_temp, _vec3_temp);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getNodeToWorldTransformAR: function(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        return AffineTrans.fromMat4(out, this._worldMatrix);
      },
      getParentToNodeTransform: function(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        math.mat4.invert(_mat4_temp, this._matrix);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getWorldToNodeTransform: function(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        math.mat4.invert(_mat4_temp, this._worldMatrix);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      convertTouchToNodeSpace: function(touch) {
        return this.convertToNodeSpace(touch.getLocation());
      },
      convertTouchToNodeSpaceAR: function(touch) {
        return this.convertToNodeSpaceAR(touch.getLocation());
      },
      getBoundingBox: function() {
        this._updateLocalMatrix();
        var width = this._contentSize.width;
        var height = this._contentSize.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        return rect.transformMat4(rect, this._matrix);
      },
      getBoundingBoxToWorld: function() {
        if (this._parent) {
          this._parent._updateWorldMatrix();
          return this._getBoundingBoxTo(this._parent._worldMatrix);
        }
        return this.getBoundingBox();
      },
      _getBoundingBoxTo: function(parentMat) {
        this._updateLocalMatrix();
        var width = this._contentSize.width;
        var height = this._contentSize.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        var parentMat = math.mat4.mul(this._worldMatrix, parentMat, this._matrix);
        rect.transformMat4(rect, parentMat);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child.active) {
            var childRect = child._getBoundingBoxTo(parentMat);
            childRect && rect.union(rect, childRect);
          }
        }
        return rect;
      },
      _updateOrderOfArrival: function() {
        var arrivalOrder = ++_globalOrderOfArrival;
        this._localZOrder = 4294901760 & this._localZOrder | arrivalOrder;
      },
      addChild: function(child, zIndex, name) {
        false;
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.parent = this;
        void 0 !== zIndex && (child.zIndex = zIndex);
        void 0 !== name && (child.name = name);
      },
      cleanup: function() {
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        eventManager.removeListeners(this);
        var i, len = this._children.length, node;
        for (i = 0; i < len; ++i) {
          node = this._children[i];
          node && node.cleanup();
        }
      },
      sortAllChildren: function() {
        if (this._reorderChildDirty) {
          this._reorderChildDirty = false;
          var _children = this._children;
          if (_children.length > 1) {
            var len = _children.length, i, j, child;
            for (i = 1; i < len; i++) {
              child = _children[i];
              j = i - 1;
              while (j >= 0) {
                if (!(child._localZOrder < _children[j]._localZOrder)) break;
                _children[j + 1] = _children[j];
                j--;
              }
              _children[j + 1] = child;
            }
            this.emit(EventType.CHILD_REORDER);
          }
          cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _delaySort: function() {
        if (!this._reorderChildDirty) {
          this._reorderChildDirty = true;
          cc.director.__fastOn(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _restoreProperties: function() {
        this._matrix || (this._matrix = mathPools.mat4.get());
        this._worldMatrix || (this._worldMatrix = mathPools.mat4.get());
        this._localMatDirty = this._worldMatDirty = true;
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
        if (this._renderComponent) {
          this._renderFlag |= RenderFlow.FLAG_COLOR;
          this._renderComponent.markForUpdateRenderData(true);
        }
      },
      onRestore: false
    });
    var SameNameGetSets = [ "parent", "position", "scale", "rotation" ];
    misc.propertyDefine(Node, SameNameGetSets);
    cc.Node = module.exports = Node;
  }), {
    "./event-manager": 98,
    "./event/event": 101,
    "./event/event-target": 100,
    "./platform/CCMacro": 160,
    "./platform/js": 175,
    "./renderer/render-engine": 197,
    "./renderer/render-flow": 198,
    "./utils/affine-transform": 225,
    "./utils/base-node": 226,
    "./utils/math-pools": 232,
    "./utils/misc": 233,
    "./utils/prefab-helper": 236
  } ],
  31: [ (function(require, module, exports) {
    "use strict";
    var Node = require("./CCNode");
    var RenderFlow = require("./renderer/render-flow");
    var renderEngine = require("./renderer/render-engine");
    var math = renderEngine.math;
    var LocalDirtyFlag = Node._LocalDirtyFlag;
    var POSITION_ON = 1;
    var _vec3_temp = math.vec3.create();
    var PrivateNode = cc.Class({
      name: "cc.PrivateNode",
      extends: Node,
      properties: {
        x: {
          get: function() {
            return this._originPos.x;
          },
          set: function(value) {
            var localPosition = this._originPos;
            if (value !== localPosition.x) {
              localPosition.x = value;
              this._posDirty(true);
            }
          },
          override: true
        },
        y: {
          get: function() {
            return this._originPos.y;
          },
          set: function(value) {
            var localPosition = this._originPos;
            if (value !== localPosition.y) {
              localPosition.y = value;
              this._posDirty(true);
            }
          },
          override: true
        },
        zIndex: {
          get: function() {
            return cc.macro.MIN_ZINDEX;
          },
          set: function() {
            cc.warnID(1638);
          },
          override: true
        }
      },
      ctor: function(name) {
        this._localZOrder = cc.macro.MIN_ZINDEX << 16;
        this._originPos = cc.v2();
      },
      _posDirty: function(sendEvent) {
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        this._renderFlag |= RenderFlow.FLAG_LOCAL_TRANSFORM;
        true === sendEvent && this._eventMask & POSITION_ON && this.emit(Node.EventType.POSITION_CHANGED);
      },
      _updateLocalMatrix: function() {
        if (!this._localMatDirty) return;
        this._position.x = this._originPos.x - (this.parent._anchorPoint.x - .5) * this.parent._contentSize.width;
        this._position.y = this._originPos.y - (this.parent._anchorPoint.y - .5) * this.parent._contentSize.height;
        this._super();
      },
      getPosition: function() {
        return new cc.Vec2(this._originPos);
      },
      setPosition: function(x, y) {
        if (void 0 === y) {
          x = x.x;
          y = x.y;
        }
        var pos = this._originPos;
        if (pos.x === x && pos.y === y) return;
        pos.x = x;
        pos.y = y;
        this._posDirty(true);
      },
      setParent: function(value) {
        var oldParent = this._parent;
        this._super(value);
        if (oldParent !== value) {
          oldParent && oldParent.off(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
          value && value.on(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
        }
      },
      _updateOrderOfArrival: function() {}
    });
    cc.js.getset(PrivateNode.prototype, "parent", PrivateNode.prototype.getParent, PrivateNode.prototype.setParent);
    cc.js.getset(PrivateNode.prototype, "position", PrivateNode.prototype.getPosition, PrivateNode.prototype.setPosition);
    cc.PrivateNode = module.exports = PrivateNode;
  }), {
    "./CCNode": 30,
    "./renderer/render-engine": 197,
    "./renderer/render-flow": 198
  } ],
  32: [ (function(require, module, exports) {
    var NIL = function() {};
    cc.Scene = cc.Class({
      name: "cc.Scene",
      extends: require("./CCNode"),
      properties: {
        autoReleaseAssets: {
          default: void 0,
          type: cc.Boolean
        }
      },
      ctor: function() {
        this._anchorPoint.x = 0;
        this._anchorPoint.y = 0;
        this._activeInHierarchy = false;
        this._inited = !cc.game._isCloning;
        false;
        this.dependAssets = null;
      },
      destroy: function() {
        this._super();
        this._activeInHierarchy = false;
      },
      _onHierarchyChanged: NIL,
      _instantiate: null,
      _load: function() {
        if (!this._inited) {
          false;
          false;
          this._onBatchCreated();
          this._inited = true;
        }
      },
      _activate: function(active) {
        active = false !== active;
        false, false;
        cc.director._nodeActivator.activateNode(this, active);
      }
    });
    module.exports = cc.Scene;
  }), {
    "./CCNode": 30
  } ],
  33: [ (function(require, module, exports) {
    var js = require("./platform/js");
    var IdGenerater = require("./platform/id-generater");
    var MAX_POOL_SIZE = 20;
    var idGenerater = new IdGenerater("Scheduler");
    var ListEntry = function(target, priority, paused, markedForDeletion) {
      this.target = target;
      this.priority = priority;
      this.paused = paused;
      this.markedForDeletion = markedForDeletion;
    };
    var _listEntries = [];
    ListEntry.get = function(target, priority, paused, markedForDeletion) {
      var result = _listEntries.pop();
      if (result) {
        result.target = target;
        result.priority = priority;
        result.paused = paused;
        result.markedForDeletion = markedForDeletion;
      } else result = new ListEntry(target, priority, paused, markedForDeletion);
      return result;
    };
    ListEntry.put = function(entry) {
      if (_listEntries.length < MAX_POOL_SIZE) {
        entry.target = null;
        _listEntries.push(entry);
      }
    };
    var HashUpdateEntry = function(list, entry, target, callback) {
      this.list = list;
      this.entry = entry;
      this.target = target;
      this.callback = callback;
    };
    var _hashUpdateEntries = [];
    HashUpdateEntry.get = function(list, entry, target, callback) {
      var result = _hashUpdateEntries.pop();
      if (result) {
        result.list = list;
        result.entry = entry;
        result.target = target;
        result.callback = callback;
      } else result = new HashUpdateEntry(list, entry, target, callback);
      return result;
    };
    HashUpdateEntry.put = function(entry) {
      if (_hashUpdateEntries.length < MAX_POOL_SIZE) {
        entry.list = entry.entry = entry.target = entry.callback = null;
        _hashUpdateEntries.push(entry);
      }
    };
    var HashTimerEntry = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var _t = this;
      _t.timers = timers;
      _t.target = target;
      _t.timerIndex = timerIndex;
      _t.currentTimer = currentTimer;
      _t.currentTimerSalvaged = currentTimerSalvaged;
      _t.paused = paused;
    };
    var _hashTimerEntries = [];
    HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var result = _hashTimerEntries.pop();
      if (result) {
        result.timers = timers;
        result.target = target;
        result.timerIndex = timerIndex;
        result.currentTimer = currentTimer;
        result.currentTimerSalvaged = currentTimerSalvaged;
        result.paused = paused;
      } else result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
      return result;
    };
    HashTimerEntry.put = function(entry) {
      if (_hashTimerEntries.length < MAX_POOL_SIZE) {
        entry.timers = entry.target = entry.currentTimer = null;
        _hashTimerEntries.push(entry);
      }
    };
    function CallbackTimer() {
      this._lock = false;
      this._scheduler = null;
      this._elapsed = -1;
      this._runForever = false;
      this._useDelay = false;
      this._timesExecuted = 0;
      this._repeat = 0;
      this._delay = 0;
      this._interval = 0;
      this._target = null;
      this._callback = null;
    }
    var proto = CallbackTimer.prototype;
    proto.initWithCallback = function(scheduler, callback, target, seconds, repeat, delay) {
      this._lock = false;
      this._scheduler = scheduler;
      this._target = target;
      this._callback = callback;
      this._elapsed = -1;
      this._interval = seconds;
      this._delay = delay;
      this._useDelay = this._delay > 0;
      this._repeat = repeat;
      this._runForever = this._repeat === cc.macro.REPEAT_FOREVER;
      return true;
    };
    proto.getInterval = function() {
      return this._interval;
    };
    proto.setInterval = function(interval) {
      this._interval = interval;
    };
    proto.update = function(dt) {
      if (-1 === this._elapsed) {
        this._elapsed = 0;
        this._timesExecuted = 0;
      } else {
        this._elapsed += dt;
        if (this._runForever && !this._useDelay) {
          if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
          }
        } else {
          if (this._useDelay) {
            if (this._elapsed >= this._delay) {
              this.trigger();
              this._elapsed -= this._delay;
              this._timesExecuted += 1;
              this._useDelay = false;
            }
          } else if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
            this._timesExecuted += 1;
          }
          this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel();
        }
      }
    };
    proto.getCallback = function() {
      return this._callback;
    };
    proto.trigger = function() {
      if (this._target && this._callback) {
        this._lock = true;
        this._callback.call(this._target, this._elapsed);
        this._lock = false;
      }
    };
    proto.cancel = function() {
      this._scheduler.unschedule(this._callback, this._target);
    };
    var _timers = [];
    CallbackTimer.get = function() {
      return _timers.pop() || new CallbackTimer();
    };
    CallbackTimer.put = function(timer) {
      if (_timers.length < MAX_POOL_SIZE && !timer._lock) {
        timer._scheduler = timer._target = timer._callback = null;
        _timers.push(timer);
      }
    };
    cc.Scheduler = function() {
      this._timeScale = 1;
      this._updatesNegList = [];
      this._updates0List = [];
      this._updatesPosList = [];
      this._hashForUpdates = js.createMap(true);
      this._hashForTimers = js.createMap(true);
      this._currentTarget = null;
      this._currentTargetSalvaged = false;
      this._updateHashLocked = false;
      this._arrayForTimers = [];
    };
    cc.Scheduler.prototype = {
      constructor: cc.Scheduler,
      _removeHashElement: function(element) {
        delete this._hashForTimers[element.target._id];
        var arr = this._arrayForTimers;
        for (var i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
          arr.splice(i, 1);
          break;
        }
        HashTimerEntry.put(element);
      },
      _removeUpdateFromHash: function(entry) {
        var targetId = entry.target._id;
        var self = this, element = self._hashForUpdates[targetId];
        if (element) {
          var list = element.list, listEntry = element.entry;
          for (var i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
            list.splice(i, 1);
            break;
          }
          delete self._hashForUpdates[targetId];
          ListEntry.put(listEntry);
          HashUpdateEntry.put(element);
        }
      },
      _priorityIn: function(ppList, listElement, priority) {
        for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) {
          ppList.splice(i, 0, listElement);
          return;
        }
        ppList.push(listElement);
      },
      _appendIn: function(ppList, listElement) {
        ppList.push(listElement);
      },
      enableForTarget: function(target) {
        target._id || (target.__instanceId ? cc.warnID(1513) : target._id = idGenerater.getNewId());
      },
      setTimeScale: function(timeScale) {
        this._timeScale = timeScale;
      },
      getTimeScale: function() {
        return this._timeScale;
      },
      update: function(dt) {
        this._updateHashLocked = true;
        1 !== this._timeScale && (dt *= this._timeScale);
        var i, list, len, entry;
        for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        var elt, arr = this._arrayForTimers;
        for (i = 0; i < arr.length; i++) {
          elt = arr[i];
          this._currentTarget = elt;
          this._currentTargetSalvaged = false;
          if (!elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
            elt.currentTimer = elt.timers[elt.timerIndex];
            elt.currentTimerSalvaged = false;
            elt.currentTimer.update(dt);
            elt.currentTimer = null;
          }
          if (this._currentTargetSalvaged && 0 === this._currentTarget.timers.length) {
            this._removeHashElement(this._currentTarget);
            --i;
          }
        }
        for (i = 0, list = this._updatesNegList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updates0List; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updatesPosList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        this._updateHashLocked = false;
        this._currentTarget = null;
      },
      schedule: function(callback, target, interval, repeat, delay, paused) {
        "use strict";
        if ("function" !== typeof callback) {
          var tmp = callback;
          callback = target;
          target = tmp;
        }
        if (4 === arguments.length || 5 === arguments.length) {
          paused = !!repeat;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }
        cc.assertID(target, 1502);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) element.paused !== paused && cc.warnID(1511); else {
          element = HashTimerEntry.get(null, target, 0, null, null, paused);
          this._arrayForTimers.push(element);
          this._hashForTimers[targetId] = element;
        }
        var timer, i;
        if (null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) {
          timer = element.timers[i];
          if (timer && callback === timer._callback) {
            cc.logID(1507, timer.getInterval(), interval);
            timer._interval = interval;
            return;
          }
        }
        timer = CallbackTimer.get();
        timer.initWithCallback(this, callback, target, interval, repeat, delay);
        element.timers.push(timer);
        this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = false);
      },
      scheduleUpdate: function(target, priority, paused) {
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var hashElement = this._hashForUpdates[targetId];
        if (hashElement && hashElement.entry) {
          if (hashElement.entry.priority === priority) {
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          if (this._updateHashLocked) {
            cc.logID(1506);
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          this.unscheduleUpdate(target);
        }
        var listElement = ListEntry.get(target, priority, paused, false);
        var ppList;
        if (0 === priority) {
          ppList = this._updates0List;
          this._appendIn(ppList, listElement);
        } else {
          ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
          this._priorityIn(ppList, listElement, priority);
        }
        this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
      },
      unschedule: function(callback, target) {
        if (!target || !callback) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          for (var i = 0, li = timers.length; i < li; i++) {
            var timer = timers[i];
            if (callback === timer._callback) {
              timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = true);
              timers.splice(i, 1);
              CallbackTimer.put(timer);
              element.timerIndex >= i && element.timerIndex--;
              0 === timers.length && (self._currentTarget === element ? self._currentTargetSalvaged = true : self._removeHashElement(element));
              return;
            }
          }
        }
      },
      unscheduleUpdate: function(target) {
        if (!target) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForUpdates[targetId];
        element && (this._updateHashLocked ? element.entry.markedForDeletion = true : this._removeUpdateFromHash(element.entry));
      },
      unscheduleAllForTarget: function(target) {
        if (!target) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = true);
          for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
          timers.length = 0;
          this._currentTarget === element ? this._currentTargetSalvaged = true : this._removeHashElement(element);
        }
        this.unscheduleUpdate(target);
      },
      unscheduleAll: function() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      unscheduleAllWithMinPriority: function(minPriority) {
        var i, element, arr = this._arrayForTimers;
        for (i = arr.length - 1; i >= 0; i--) {
          element = arr[i];
          this.unscheduleAllForTarget(element.target);
        }
        var entry;
        var temp_length = 0;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) {
          temp_length = this._updatesNegList.length;
          entry = this._updatesNegList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesNegList.length && i++;
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) {
          temp_length = this._updates0List.length;
          entry = this._updates0List[i];
          entry && this.unscheduleUpdate(entry.target);
          temp_length == this._updates0List.length && i++;
        }
        for (i = 0; i < this._updatesPosList.length; ) {
          temp_length = this._updatesPosList.length;
          entry = this._updatesPosList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesPosList.length && i++;
        }
      },
      isScheduled: function(callback, target) {
        cc.assertID(callback, 1508);
        cc.assertID(target, 1509);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (!element) return false;
        if (null == element.timers) return false;
        var timers = element.timers;
        for (var i = 0; i < timers.length; ++i) {
          var timer = timers[i];
          if (callback === timer._callback) return true;
        }
        return false;
      },
      pauseAllTargets: function() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      pauseAllTargetsWithMinPriority: function(minPriority) {
        var idsWithSelectors = [];
        var self = this, element, locArrayForTimers = self._arrayForTimers;
        var i, li;
        for (i = 0, li = locArrayForTimers.length; i < li; i++) {
          element = locArrayForTimers[i];
          if (element) {
            element.paused = true;
            idsWithSelectors.push(element.target);
          }
        }
        var entry;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) {
          entry = this._updatesNegList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) {
          entry = this._updates0List[i];
          if (entry) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        for (i = 0; i < this._updatesPosList.length; i++) {
          entry = this._updatesPosList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        return idsWithSelectors;
      },
      resumeTargets: function(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
      },
      pauseTarget: function(target) {
        cc.assertID(target, 1503);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = true);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = true);
      },
      resumeTarget: function(target) {
        cc.assertID(target, 1504);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = false);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = false);
      },
      isTargetPaused: function(target) {
        cc.assertID(target, 1505);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) return element.paused;
        var elementUpdate = this._hashForUpdates[targetId];
        if (elementUpdate) return elementUpdate.entry.paused;
        return false;
      }
    };
    cc.Scheduler.PRIORITY_SYSTEM = 1 << 31;
    cc.Scheduler.PRIORITY_NON_SYSTEM = cc.Scheduler.PRIORITY_SYSTEM + 1;
  }), {
    "./platform/id-generater": 171,
    "./platform/js": 175
  } ],
  34: [ (function(require, module, exports) {
    var RawAsset = require("./CCRawAsset");
    var js = cc.js;
    cc.Asset = cc.Class({
      name: "cc.Asset",
      extends: RawAsset,
      ctor: function() {
        this.loaded = true;
      },
      properties: {
        nativeUrl: {
          get: function() {
            if (this._native) {
              var name = this._native;
              if (47 === name.charCodeAt(0)) return name.slice(1);
              if (cc.AssetLibrary) {
                var base = cc.AssetLibrary.getLibUrlNoExt(this._uuid);
                return 46 === name.charCodeAt(0) ? base + name : base + "/" + name;
              }
              cc.errorID(6400);
            }
            return "";
          },
          visible: false
        },
        _native: "",
        _nativeAsset: {
          get: function() {},
          set: function(obj) {}
        }
      },
      statics: {
        deserialize: false,
        preventDeferredLoadDependents: false,
        preventPreloadNativeObject: false
      },
      toString: function() {
        return this.nativeUrl;
      },
      serialize: false,
      createNode: null,
      _setRawAsset: function(filename, inLibrary) {
        this._native = false !== inLibrary ? filename || void 0 : "/" + filename;
      }
    });
    module.exports = cc.Asset;
  }), {
    "./CCRawAsset": 41
  } ],
  35: [ (function(require, module, exports) {
    var Asset = require("./CCAsset");
    var EventTarget = require("../event/event-target");
    var LoadMode = cc.Enum({
      WEB_AUDIO: 0,
      DOM_AUDIO: 1
    });
    var AudioClip = cc.Class({
      name: "cc.AudioClip",
      extends: Asset,
      mixins: [ EventTarget ],
      ctor: function() {
        this.loaded = false;
        this._audio = null;
      },
      properties: {
        loadMode: {
          default: LoadMode.WEB_AUDIO,
          type: LoadMode
        },
        _nativeAsset: {
          get: function() {
            return this._audio;
          },
          set: function(value) {
            this._audio = value;
            if (value) {
              this.loaded = true;
              this.emit("load");
            }
          },
          override: true
        }
      },
      statics: {
        LoadMode: LoadMode,
        _loadByUrl: function(url, callback) {
          var item = cc.loader.getItem(url) || cc.loader.getItem(url + "?useDom=1");
          item && item.complete ? item._owner instanceof AudioClip ? callback(null, item._owner) : callback(null, item.content) : cc.loader.load(url, (function(error, downloadUrl) {
            if (error) return callback(error);
            item = cc.loader.getItem(url) || cc.loader.getItem(url + "?useDom=1");
            callback(null, item.content);
          }));
        }
      },
      destroy: function() {
        cc.audioEngine.uncache(this);
        this._super();
      }
    });
    cc.AudioClip = AudioClip;
    module.exports = AudioClip;
  }), {
    "../event/event-target": 100,
    "./CCAsset": 34
  } ],
  36: [ (function(require, module, exports) {
    var BitmapFont = cc.Class({
      name: "cc.BitmapFont",
      extends: cc.Font,
      properties: {
        fntDataStr: {
          default: ""
        },
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        fontSize: {
          default: -1
        },
        _fntConfig: null
      }
    });
    cc.BitmapFont = BitmapFont;
    module.exports = BitmapFont;
  }), {} ],
  37: [ (function(require, module, exports) {
    var Font = cc.Class({
      name: "cc.Font",
      extends: cc.Asset
    });
    cc.Font = module.exports = Font;
  }), {} ],
  38: [ (function(require, module, exports) {
    var JsonAsset = cc.Class({
      name: "cc.JsonAsset",
      extends: cc.Asset,
      properties: {
        json: null
      }
    });
    module.exports = cc.JsonAsset = JsonAsset;
  }), {} ],
  39: [ (function(require, module, exports) {
    var LabelAtlas = cc.Class({
      name: "cc.LabelAtlas",
      extends: cc.BitmapFont
    });
    cc.LabelAtlas = LabelAtlas;
    module.exports = LabelAtlas;
  }), {} ],
  40: [ (function(require, module, exports) {
    var OptimizationPolicy = cc.Enum({
      AUTO: 0,
      SINGLE_INSTANCE: 1,
      MULTI_INSTANCE: 2
    });
    var Prefab = cc.Class({
      name: "cc.Prefab",
      extends: cc.Asset,
      ctor: function() {
        this._createFunction = null;
        this._instantiatedTimes = 0;
      },
      properties: {
        data: null,
        optimizationPolicy: OptimizationPolicy.AUTO,
        asyncLoadAssets: false
      },
      statics: {
        OptimizationPolicy: OptimizationPolicy,
        OptimizationPolicyThreshold: 3
      },
      createNode: false,
      compileCreateFunction: function() {
        var jit = require("../platform/instantiate-jit");
        this._createFunction = jit.compile(this.data);
      },
      _doInstantiate: function(rootToRedirect) {
        this.data._prefab ? this.data._prefab._synced = true : cc.warnID(3700);
        this._createFunction || this.compileCreateFunction();
        return this._createFunction(rootToRedirect);
      },
      _instantiate: function() {
        var node, useJit = false;
        true;
        useJit = this.optimizationPolicy !== OptimizationPolicy.SINGLE_INSTANCE && (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE || this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold);
        if (useJit) {
          node = this._doInstantiate();
          this.data._instantiate(node);
        } else {
          this.data._prefab._synced = true;
          node = this.data._instantiate();
        }
        ++this._instantiatedTimes;
        false, false;
        return node;
      }
    });
    cc.Prefab = module.exports = Prefab;
    cc.js.obsolete(cc, "cc._Prefab", "Prefab");
  }), {
    "../platform/instantiate-jit": 173
  } ],
  41: [ (function(require, module, exports) {
    var CCObject = require("../platform/CCObject");
    var js = require("../platform/js");
    cc.RawAsset = cc.Class({
      name: "cc.RawAsset",
      extends: CCObject,
      ctor: function() {
        Object.defineProperty(this, "_uuid", {
          value: "",
          writable: true
        });
      }
    });
    js.value(cc.RawAsset, "isRawAssetType", (function(ctor) {
      return js.isChildClassOf(ctor, cc.RawAsset) && !js.isChildClassOf(ctor, cc.Asset);
    }));
    js.value(cc.RawAsset, "wasRawAssetType", (function(ctor) {
      return ctor === cc.Texture2D || ctor === cc.AudioClip || ctor === cc.ParticleAsset || ctor === cc.Asset;
    }));
    module.exports = cc.RawAsset;
  }), {
    "../platform/CCObject": 161,
    "../platform/js": 175
  } ],
  42: [ (function(require, module, exports) {
    var renderer = require("../renderer");
    var renderEngine = require("../renderer/render-engine");
    var Texture2D = require("./CCTexture2D");
    var RenderTexture = cc.Class({
      name: "cc.RenderTexture",
      extends: Texture2D,
      ctor: function() {
        this._framebuffer = null;
      },
      initWithSize: function(width, height) {
        this.width = Math.floor(width || cc.visibleRect.width);
        this.height = Math.floor(height || cc.visibleRect.height);
        var opts = {};
        opts.format = this._format;
        opts.width = width;
        opts.height = height;
        opts.images = void 0;
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
        opts = {
          colors: [ this._texture ]
        };
        this._framebuffer && this._framebuffer.destroy();
        this._framebuffer = new renderEngine.gfx.FrameBuffer(renderer.device, width, height, opts);
        this.loaded = true;
        this.emit("load");
      },
      drawTextureAt: function(texture, x, y) {
        if (!texture._image) return;
        this._texture.updateSubImage({
          x: x,
          y: y,
          image: texture._image,
          width: texture.width,
          height: texture.height,
          level: 0,
          flipY: false
        });
      },
      readPixels: function(data, x, y, w, h) {
        if (!this._framebuffer || !this._texture) return data;
        x = x || 0;
        y = y || 0;
        var width = w || this.width;
        var height = h || this.height;
        data = data || new Uint8Array(width * height * 4);
        var gl = renderer._forward._device._gl;
        var oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer._glID);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._texture._glID, 0);
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.bindFramebuffer(gl.FRAMEBUFFER, oldFBO);
        return data;
      },
      destroy: function() {
        this._super();
        this._framebuffer && this._framebuffer.destroy();
      }
    });
    cc.RenderTexture = module.exports = RenderTexture;
  }), {
    "../renderer": 196,
    "../renderer/render-engine": 197,
    "./CCTexture2D": 49
  } ],
  43: [ (function(require, module, exports) {
    var Scene = cc.Class({
      name: "cc.SceneAsset",
      extends: cc.Asset,
      properties: {
        scene: null,
        asyncLoadAssets: void 0
      }
    });
    cc.SceneAsset = Scene;
    module.exports = Scene;
  }), {} ],
  44: [ (function(require, module, exports) {
    var Script = cc.Class({
      name: "cc.Script",
      extends: cc.Asset
    });
    cc._Script = Script;
    var JavaScript = cc.Class({
      name: "cc.JavaScript",
      extends: Script
    });
    cc._JavaScript = JavaScript;
    var CoffeeScript = cc.Class({
      name: "cc.CoffeeScript",
      extends: Script
    });
    cc._CoffeeScript = CoffeeScript;
    var TypeScript = cc.Class({
      name: "cc.TypeScript",
      extends: Script
    });
    cc._TypeScript = TypeScript;
  }), {} ],
  45: [ (function(require, module, exports) {
    var SpriteAtlas = cc.Class({
      name: "cc.SpriteAtlas",
      extends: cc.Asset,
      properties: {
        _spriteFrames: {
          default: {}
        }
      },
      getTexture: function() {
        var keys = Object.keys(this._spriteFrames);
        if (keys.length > 0) {
          var spriteFrame = this._spriteFrames[keys[0]];
          return spriteFrame ? spriteFrame.getTexture() : null;
        }
        return null;
      },
      getSpriteFrame: function(key) {
        return this._spriteFrames[key];
      },
      getSpriteFrames: function() {
        var frames = [];
        var spriteFrames = this._spriteFrames;
        for (var key in spriteFrames) frames.push(spriteFrames[key]);
        return frames;
      }
    });
    cc.SpriteAtlas = SpriteAtlas;
    module.exports = SpriteAtlas;
  }), {} ],
  46: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    var textureUtil = require("../utils/texture-util");
    var temp_uvs = [ {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    } ];
    var SpriteFrame = cc.Class({
      name: "cc.SpriteFrame",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      properties: {
        _textureSetter: {
          set: function(texture) {
            if (texture) {
              false;
              this._texture !== texture && this._refreshTexture(texture);
              this._textureFilename = texture.url;
            }
          }
        }
      },
      ctor: function() {
        var filename = arguments[0];
        var rect = arguments[1];
        var rotated = arguments[2];
        var offset = arguments[3];
        var originalSize = arguments[4];
        this._rect = null;
        this._offset = null;
        this._originalSize = null;
        this._rotated = false;
        this.insetTop = 0;
        this.insetBottom = 0;
        this.insetLeft = 0;
        this.insetRight = 0;
        this.vertices = null;
        this.uv = [];
        this.uvSliced = [];
        this._texture = null;
        this._textureFilename = "";
        this._original = null;
        false;
        void 0 !== filename && this.initWithTexture(filename, rect, rotated, offset, originalSize);
      },
      textureLoaded: function() {
        return this._texture && this._texture.loaded;
      },
      isRotated: function() {
        return this._rotated;
      },
      setRotated: function(bRotated) {
        this._rotated = bRotated;
      },
      getRect: function() {
        return cc.rect(this._rect);
      },
      setRect: function(rect) {
        this._rect = rect;
      },
      getOriginalSize: function() {
        return cc.size(this._originalSize);
      },
      setOriginalSize: function(size) {
        if (this._originalSize) {
          this._originalSize.width = size.width;
          this._originalSize.height = size.height;
        } else this._originalSize = cc.size(size);
      },
      getTexture: function() {
        return this._texture;
      },
      _textureLoadedCallback: function() {
        var self = this;
        var texture = this._texture;
        if (!texture) return;
        var w = texture.width, h = texture.height;
        if (self._rotated && cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          self._rotated = false;
          w = self._texture.width;
          h = self._texture.height;
          self.setRect(cc.rect(0, 0, w, h));
        }
        self._rect ? self._checkRect(self._texture) : self.setRect(cc.rect(0, 0, w, h));
        self._originalSize || self.setOriginalSize(cc.size(w, h));
        self._offset || self.setOffset(cc.v2(0, 0));
        self._calculateUV();
        self.emit("load");
      },
      _refreshTexture: function(texture) {
        this._texture = texture;
        texture.loaded ? this._textureLoadedCallback() : texture.once("load", this._textureLoadedCallback, this);
      },
      getOffset: function() {
        return cc.v2(this._offset);
      },
      setOffset: function(offsets) {
        this._offset = cc.v2(offsets);
      },
      clone: function() {
        return new SpriteFrame(this._texture || this._textureFilename, this._rect, this._rotated, this._offset, this._originalSize);
      },
      setTexture: function(textureOrTextureFile, rect, rotated, offset, originalSize) {
        rect ? this.setRect(rect) : this._rect = null;
        offset ? this.setOffset(offset) : this._offset = null;
        originalSize ? this.setOriginalSize(originalSize) : this._originalSize = null;
        this._rotated = rotated || false;
        var texture = textureOrTextureFile;
        if ("string" === typeof texture && texture) {
          this._textureFilename = texture;
          this._loadTexture();
        }
        texture instanceof cc.Texture2D && this._texture !== texture && this._refreshTexture(texture);
        return true;
      },
      _loadTexture: function() {
        if (this._textureFilename) {
          var texture = textureUtil.loadImage(this._textureFilename);
          this._refreshTexture(texture);
        }
      },
      ensureLoadTexture: function() {
        if (this._texture) {
          if (!this._texture.loaded) {
            this._refreshTexture(this._texture);
            textureUtil.postLoadTexture(this._texture);
          }
        } else this._textureFilename && this._loadTexture();
      },
      clearTexture: function() {
        this._texture = null;
      },
      _checkRect: function(texture) {
        var rect = this._rect;
        var maxX = rect.x, maxY = rect.y;
        if (this._rotated) {
          maxX += rect.height;
          maxY += rect.width;
        } else {
          maxX += rect.width;
          maxY += rect.height;
        }
        maxX > texture.width && cc.errorID(3300, texture.url + "/" + this.name, maxX, texture.width);
        maxY > texture.height && cc.errorID(3400, texture.url + "/" + this.name, maxY, texture.height);
      },
      _calculateSlicedUV: function() {
        var rect = this._rect;
        var atlasWidth = this._texture.width;
        var atlasHeight = this._texture.height;
        var leftWidth = this.insetLeft;
        var rightWidth = this.insetRight;
        var centerWidth = rect.width - leftWidth - rightWidth;
        var topHeight = this.insetTop;
        var bottomHeight = this.insetBottom;
        var centerHeight = rect.height - topHeight - bottomHeight;
        var uvSliced = this.uvSliced;
        uvSliced.length = 0;
        if (this._rotated) {
          temp_uvs[0].u = rect.x / atlasWidth;
          temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
          temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
          temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
          temp_uvs[3].v = rect.y / atlasHeight;
          temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
          temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
          temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
          for (var row = 0; row < 4; ++row) {
            var rowD = temp_uvs[row];
            for (var col = 0; col < 4; ++col) {
              var colD = temp_uvs[3 - col];
              uvSliced.push({
                u: rowD.u,
                v: colD.v
              });
            }
          }
        } else {
          temp_uvs[0].u = rect.x / atlasWidth;
          temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
          temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
          temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
          temp_uvs[3].v = rect.y / atlasHeight;
          temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
          temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
          temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
          for (var _row = 0; _row < 4; ++_row) {
            var _rowD = temp_uvs[_row];
            for (var _col = 0; _col < 4; ++_col) {
              var _colD = temp_uvs[_col];
              uvSliced.push({
                u: _colD.u,
                v: _rowD.v
              });
            }
          }
        }
      },
      _calculateUV: function() {
        var rect = this._rect, texture = this._texture, uv = this.uv, texw = texture.width, texh = texture.height;
        if (this._rotated) {
          var l = 0 === texw ? 0 : rect.x / texw;
          var r = 0 === texw ? 0 : (rect.x + rect.height) / texw;
          var b = 0 === texh ? 0 : (rect.y + rect.width) / texh;
          var t = 0 === texh ? 0 : rect.y / texh;
          uv[0] = l;
          uv[1] = t;
          uv[2] = l;
          uv[3] = b;
          uv[4] = r;
          uv[5] = t;
          uv[6] = r;
          uv[7] = b;
        } else {
          var _l = 0 === texw ? 0 : rect.x / texw;
          var _r = 0 === texw ? 0 : (rect.x + rect.width) / texw;
          var _b = 0 === texh ? 0 : (rect.y + rect.height) / texh;
          var _t = 0 === texh ? 0 : rect.y / texh;
          uv[0] = _l;
          uv[1] = _b;
          uv[2] = _r;
          uv[3] = _b;
          uv[4] = _l;
          uv[5] = _t;
          uv[6] = _r;
          uv[7] = _t;
        }
        var vertices = this.vertices;
        if (vertices) {
          vertices.nu.length = 0;
          vertices.nv.length = 0;
          for (var i = 0; i < vertices.u.length; i++) {
            vertices.nu[i] = vertices.u[i] / texw;
            vertices.nv[i] = vertices.v[i] / texh;
          }
        }
        this._calculateSlicedUV();
      },
      _serialize: false,
      _deserialize: function(data, handle) {
        var rect = data.rect;
        rect && this.setRect(new cc.Rect(rect[0], rect[1], rect[2], rect[3]));
        data.offset && this.setOffset(new cc.Vec2(data.offset[0], data.offset[1]));
        data.originalSize && this.setOriginalSize(new cc.Size(data.originalSize[0], data.originalSize[1]));
        this._rotated = 1 === data.rotated;
        this._name = data.name;
        var capInsets = data.capInsets;
        if (capInsets) {
          this.insetLeft = capInsets[0];
          this.insetTop = capInsets[1];
          this.insetRight = capInsets[2];
          this.insetBottom = capInsets[3];
        }
        false;
        this.vertices = data.vertices;
        if (this.vertices) {
          this.vertices.nu = [];
          this.vertices.nv = [];
        }
        var textureUuid = data.texture;
        textureUuid && handle.result.push(this, "_textureSetter", textureUuid);
      }
    });
    var proto = SpriteFrame.prototype;
    proto.copyWithZone = proto.clone;
    proto.copy = proto.clone;
    proto.initWithTexture = proto.setTexture;
    cc.SpriteFrame = SpriteFrame;
    module.exports = SpriteFrame;
  }), {
    "../assets/CCAsset": 34,
    "../event/event-target": 100,
    "../utils/texture-util": 241
  } ],
  47: [ (function(require, module, exports) {
    var TTFFont = cc.Class({
      name: "cc.TTFFont",
      extends: cc.Font,
      statics: {
        preventPreloadNativeObject: true
      }
    });
    cc.TTFFont = module.exports = TTFFont;
  }), {} ],
  48: [ (function(require, module, exports) {
    var TextAsset = cc.Class({
      name: "cc.TextAsset",
      extends: cc.Asset,
      properties: {
        text: ""
      },
      toString: function() {
        return this.text;
      }
    });
    module.exports = cc.TextAsset = TextAsset;
  }), {} ],
  49: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    var sys = require("../platform/CCSys");
    var JS = require("../platform/js");
    var misc = require("../utils/misc");
    var game = require("../CCGame");
    var renderEngine = require("../renderer/render-engine");
    var renderer = require("../renderer");
    require("../platform/CCClass");
    var TextureAsset = renderEngine.TextureAsset;
    var gfx = renderEngine.gfx;
    var GL_NEAREST = 9728;
    var GL_LINEAR = 9729;
    var GL_REPEAT = 10497;
    var GL_CLAMP_TO_EDGE = 33071;
    var GL_MIRRORED_REPEAT = 33648;
    var CHAR_CODE_0 = 48;
    var CHAR_CODE_1 = 49;
    var idGenerater = new (require("../platform/id-generater"))("Tex");
    var PixelFormat = cc.Enum({
      RGB565: gfx.TEXTURE_FMT_R5_G6_B5,
      RGB5A1: gfx.TEXTURE_FMT_R5_G5_B5_A1,
      RGBA4444: gfx.TEXTURE_FMT_R4_G4_B4_A4,
      RGB888: gfx.TEXTURE_FMT_RGB8,
      RGBA8888: gfx.TEXTURE_FMT_RGBA8,
      A8: gfx.TEXTURE_FMT_A8,
      I8: gfx.TEXTURE_FMT_L8,
      AI8: gfx.TEXTURE_FMT_L8_A8
    });
    var WrapMode = cc.Enum({
      REPEAT: GL_REPEAT,
      CLAMP_TO_EDGE: GL_CLAMP_TO_EDGE,
      MIRRORED_REPEAT: GL_MIRRORED_REPEAT
    });
    var Filter = cc.Enum({
      LINEAR: GL_LINEAR,
      NEAREST: GL_NEAREST
    });
    var FilterIndex = {
      9728: 0,
      9729: 1
    };
    var _emptyOpts = {};
    var _images = [];
    var _sharedOpts = {
      width: void 0,
      height: void 0,
      minFilter: void 0,
      magFilter: void 0,
      wrapS: void 0,
      wrapT: void 0,
      format: void 0,
      mipmap: void 0,
      images: void 0,
      image: void 0,
      flipY: void 0,
      premultiplyAlpha: void 0
    };
    function _getSharedOptions() {
      for (var key in _sharedOpts) _sharedOpts[key] = void 0;
      _images.length = 0;
      _sharedOpts.images = _images;
      _sharedOpts.flipY = false;
      return _sharedOpts;
    }
    var Texture2D = cc.Class({
      name: "cc.Texture2D",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      properties: {
        _nativeAsset: {
          get: function() {
            return this._image;
          },
          set: function(image) {
            this.initWithElement(image);
          },
          override: true
        },
        _hasMipmap: false,
        _format: PixelFormat.RGBA8888,
        _premultiplyAlpha: false,
        _flipY: false,
        _minFilter: Filter.LINEAR,
        _magFilter: Filter.LINEAR,
        _wrapS: WrapMode.CLAMP_TO_EDGE,
        _wrapT: WrapMode.CLAMP_TO_EDGE
      },
      statics: {
        PixelFormat: PixelFormat,
        WrapMode: WrapMode,
        Filter: Filter,
        extnames: [ ".png", ".jpg", ".jpeg", ".bmp", ".webp" ]
      },
      ctor: function() {
        this._id = idGenerater.getNewId();
        this.url = "";
        this.loaded = false;
        this.width = 0;
        this.height = 0;
        this._texture = null;
      },
      getImpl: function() {
        return this._texture;
      },
      getId: function() {
        return this._id;
      },
      toString: function() {
        return this.url || "";
      },
      update: function(options) {
        if (options) {
          var updateImg = false;
          void 0 !== options.width && (this.width = options.width);
          void 0 !== options.height && (this.height = options.height);
          if (void 0 !== options.minFilter) {
            this._minFilter = options.minFilter;
            options.minFilter = FilterIndex[options.minFilter];
          }
          if (void 0 !== options.magFilter) {
            this._magFilter = options.magFilter;
            options.magFilter = FilterIndex[options.magFilter];
          }
          void 0 !== options.wrapS && (this._wrapS = options.wrapS);
          void 0 !== options.wrapT && (this._wrapT = options.wrapT);
          void 0 !== options.format && (this._format = options.format);
          if (void 0 !== options.flipY) {
            this._flipY = options.flipY;
            updateImg = true;
          }
          if (void 0 !== options.premultiplyAlpha) {
            this._premultiplyAlpha = options.premultiplyAlpha;
            updateImg = true;
          }
          void 0 !== options.mipmap && (this._hasMipmap = options.mipmap);
          updateImg && this._image && (options.image = this._image);
          if (options.images && options.images.length > 0) this._image = options.images[0]; else if (void 0 !== options.image) {
            this._image = options.image;
            if (!options.images) {
              _images.length = 0;
              options.images = _images;
            }
            options.images.push(options.image);
          }
          options.images && options.images.length > 0 && this._texture.update(options);
        }
      },
      initWithElement: function(element) {
        if (!element) return;
        this._image = element;
        if ((false, false) || element.complete || element instanceof HTMLCanvasElement) this.handleLoadedTexture(); else {
          var self = this;
          element.addEventListener("load", (function() {
            self.handleLoadedTexture();
          }));
          element.addEventListener("error", (function(err) {
            cc.warnID(3119, err.message);
          }));
        }
      },
      initWithData: function(data, pixelFormat, pixelsWidth, pixelsHeight) {
        var opts = _getSharedOptions();
        opts.image = data;
        opts.format = pixelFormat;
        opts.width = pixelsWidth;
        opts.height = pixelsHeight;
        this.update(opts);
        this.width = pixelsWidth;
        this.height = pixelsHeight;
        this.loaded = true;
        this.emit("load");
        return true;
      },
      getHtmlElementObj: function() {
        return this._image;
      },
      destroy: function() {
        this._image = null;
        this._texture && this._texture.destroy();
        this._super();
      },
      getPixelFormat: function() {
        return this._format;
      },
      hasPremultipliedAlpha: function() {
        return this._premultiplyAlpha || false;
      },
      hasMipmap: function() {
        return this._hasMipmap || false;
      },
      handleLoadedTexture: function() {
        if (!this._image || !this._image.width || !this._image.height) return;
        this.width = this._image.width;
        this.height = this._image.height;
        var opts = _getSharedOptions();
        opts.image = this._image;
        opts.images = [ opts.image ];
        opts.width = this.width;
        opts.height = this.height;
        opts.hasMipmap = this._hasMipmap;
        opts.format = this._format;
        opts.premultiplyAlpha = this._premultiplyAlpha;
        opts.flipY = this._flipY;
        opts.minFilter = FilterIndex[this._minFilter];
        opts.magFilter = FilterIndex[this._magFilter];
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
        this.loaded = true;
        this.emit("load");
      },
      description: function() {
        return "<cc.Texture2D | Name = " + this.url + " | Dimensions = " + this.width + " x " + this.height + ">";
      },
      releaseTexture: function() {
        this._image = null;
        this._texture && this._texture.destroy();
      },
      setWrapMode: function(wrapS, wrapT) {
        if (this._wrapS !== wrapS || this._wrapT !== wrapT) {
          var opts = _getSharedOptions();
          opts.wrapS = wrapS;
          opts.wrapT = wrapT;
          this.update(opts);
        }
      },
      setFilters: function(minFilter, magFilter) {
        if (this._minFilter !== minFilter || this._magFilter !== magFilter) {
          var opts = _getSharedOptions();
          opts.minFilter = minFilter;
          opts.magFilter = magFilter;
          this.update(opts);
        }
      },
      setFlipY: function(flipY) {
        if (this._flipY !== flipY) {
          var opts = _getSharedOptions();
          opts.flipY = flipY;
          this.update(opts);
        }
      },
      setPremultiplyAlpha: function(premultiply) {
        if (this._premultiplyAlpha !== premultiply) {
          var opts = _getSharedOptions();
          opts.premultiplyAlpha = premultiply;
          this.update(opts);
        }
      },
      setMipmap: function(mipmap) {
        if (this._hasMipmap !== mipmap) {
          var opts = _getSharedOptions();
          opts.hasMipmap = mipmap;
          this.update(opts);
        }
      },
      _serialize: (false, false) && function() {
        var extId = "";
        if (this._native) {
          var ext = cc.path.extname(this._native);
          if (ext) {
            extId = Texture2D.extnames.indexOf(ext);
            extId < 0 && (extId = ext);
          }
        }
        var asset = extId + "," + this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0);
        return asset;
      },
      _deserialize: function(data, handle) {
        var fields = data.split(",");
        var extIdStr = fields[0];
        if (extIdStr) {
          var extId = extIdStr.charCodeAt(0) - CHAR_CODE_0;
          var ext = Texture2D.extnames[extId];
          this._setRawAsset(ext || extIdStr);
          var loadingItem = handle.customEnv;
          var uuid = loadingItem && loadingItem.uuid;
          if (uuid) {
            this._uuid = uuid;
            var url = this.nativeUrl;
            this.url = url;
          }
        }
        if (6 === fields.length) {
          this._minFilter = parseInt(fields[1]);
          this._magFilter = parseInt(fields[2]);
          this._wrapS = parseInt(fields[3]);
          this._wrapT = parseInt(fields[4]);
          this._premultiplyAlpha = fields[5].charCodeAt(0) === CHAR_CODE_1;
        }
      }
    });
    cc.Texture2D = module.exports = Texture2D;
  }), {
    "../CCGame": 29,
    "../assets/CCAsset": 34,
    "../event/event-target": 100,
    "../platform/CCClass": 155,
    "../platform/CCSys": 164,
    "../platform/id-generater": 171,
    "../platform/js": 175,
    "../renderer": 196,
    "../renderer/render-engine": 197,
    "../utils/misc": 233
  } ],
  50: [ (function(require, module, exports) {
    require("./CCRawAsset");
    require("./CCAsset");
    require("./CCFont");
    require("./CCPrefab");
    require("./CCAudioClip");
    require("./CCScripts");
    require("./CCSceneAsset");
    require("./CCSpriteFrame");
    require("./CCTexture2D");
    require("./CCRenderTexture");
    require("./CCTTFFont");
    require("./CCSpriteAtlas");
    require("./CCBitmapFont");
    require("./CCLabelAtlas");
    require("./CCTextAsset");
    require("./CCJsonAsset");
  }), {
    "./CCAsset": 34,
    "./CCAudioClip": 35,
    "./CCBitmapFont": 36,
    "./CCFont": 37,
    "./CCJsonAsset": 38,
    "./CCLabelAtlas": 39,
    "./CCPrefab": 40,
    "./CCRawAsset": 41,
    "./CCRenderTexture": 42,
    "./CCSceneAsset": 43,
    "./CCScripts": 44,
    "./CCSpriteAtlas": 45,
    "./CCSpriteFrame": 46,
    "./CCTTFFont": 47,
    "./CCTextAsset": 48,
    "./CCTexture2D": 49
  } ],
  51: [ (function(require, module, exports) {
    var eventManager = require("../event-manager");
    var Event = require("../CCNode").EventType;
    var TOP = 1;
    var MID = 2;
    var BOT = 4;
    var LEFT = 8;
    var CENTER = 16;
    var RIGHT = 32;
    var HORIZONTAL = LEFT | CENTER | RIGHT;
    var VERTICAL = TOP | MID | BOT;
    var AlignMode = cc.Enum({
      ONCE: 0,
      ON_WINDOW_RESIZE: 1,
      ALWAYS: 2
    });
    function getReadonlyNodeSize(parent) {
      return parent instanceof cc.Scene ? cc.visibleRect : parent._contentSize;
    }
    function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
      var scaleX = widgetNode._parent._scale.x;
      var scaleY = widgetNode._parent._scale.y;
      var translateX = 0;
      var translateY = 0;
      for (var node = widgetNode._parent; ;) {
        var pos = node._position;
        translateX += pos.x;
        translateY += pos.y;
        node = node._parent;
        if (!node) {
          out_inverseTranslate.x = out_inverseTranslate.y = 0;
          out_inverseScale.x = out_inverseScale.y = 1;
          return;
        }
        if (node === target) break;
        var sx = node._scale.x;
        var sy = node._scale.y;
        translateX *= sx;
        translateY *= sy;
        scaleX *= sx;
        scaleY *= sy;
      }
      out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1;
      out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1;
      out_inverseTranslate.x = -translateX;
      out_inverseTranslate.y = -translateY;
    }
    var tInverseTranslate = cc.Vec2.ZERO;
    var tInverseScale = cc.Vec2.ONE;
    function align(node, widget) {
      var hasTarget = widget._target;
      var target;
      var inverseTranslate, inverseScale;
      if (hasTarget) {
        target = hasTarget;
        inverseTranslate = tInverseTranslate;
        inverseScale = tInverseScale;
        computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
      } else target = node._parent;
      var targetSize = getReadonlyNodeSize(target);
      var targetAnchor = target._anchorPoint;
      var isRoot = (true, target instanceof cc.Scene);
      var x = node._position.x, y = node._position.y;
      var anchor = node._anchorPoint;
      if (widget._alignFlags & HORIZONTAL) {
        var localLeft, localRight, targetWidth = targetSize.width;
        if (isRoot) {
          localLeft = cc.visibleRect.left.x;
          localRight = cc.visibleRect.right.x;
        } else {
          localLeft = -targetAnchor.x * targetWidth;
          localRight = localLeft + targetWidth;
        }
        localLeft += widget._isAbsLeft ? widget._left : widget._left * targetWidth;
        localRight -= widget._isAbsRight ? widget._right : widget._right * targetWidth;
        if (hasTarget) {
          localLeft += inverseTranslate.x;
          localLeft *= inverseScale.x;
          localRight += inverseTranslate.x;
          localRight *= inverseScale.x;
        }
        var width, anchorX = anchor.x, scaleX = node._scale.x;
        if (scaleX < 0) {
          anchorX = 1 - anchorX;
          scaleX = -scaleX;
        }
        if (widget.isStretchWidth) {
          width = localRight - localLeft;
          0 !== scaleX && (node.width = width / scaleX);
          x = localLeft + anchorX * width;
        } else {
          width = node.width * scaleX;
          if (widget.isAlignHorizontalCenter) {
            var localHorizontalCenter = widget._isAbsHorizontalCenter ? widget._horizontalCenter : widget._horizontalCenter * targetWidth;
            var targetCenter = (.5 - targetAnchor.x) * targetSize.width;
            if (hasTarget) {
              localHorizontalCenter *= inverseScale.x;
              targetCenter += inverseTranslate.x;
              targetCenter *= inverseScale.x;
            }
            x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
          } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
        }
      }
      if (widget._alignFlags & VERTICAL) {
        var localTop, localBottom, targetHeight = targetSize.height;
        if (isRoot) {
          localBottom = cc.visibleRect.bottom.y;
          localTop = cc.visibleRect.top.y;
        } else {
          localBottom = -targetAnchor.y * targetHeight;
          localTop = localBottom + targetHeight;
        }
        localBottom += widget._isAbsBottom ? widget._bottom : widget._bottom * targetHeight;
        localTop -= widget._isAbsTop ? widget._top : widget._top * targetHeight;
        if (hasTarget) {
          localBottom += inverseTranslate.y;
          localBottom *= inverseScale.y;
          localTop += inverseTranslate.y;
          localTop *= inverseScale.y;
        }
        var height, anchorY = anchor.y, scaleY = node._scale.y;
        if (scaleY < 0) {
          anchorY = 1 - anchorY;
          scaleY = -scaleY;
        }
        if (widget.isStretchHeight) {
          height = localTop - localBottom;
          0 !== scaleY && (node.height = height / scaleY);
          y = localBottom + anchorY * height;
        } else {
          height = node.height * scaleY;
          if (widget.isAlignVerticalCenter) {
            var localVerticalCenter = widget._isAbsVerticalCenter ? widget._verticalCenter : widget._verticalCenter * targetHeight;
            var targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
            if (hasTarget) {
              localVerticalCenter *= inverseScale.y;
              targetMiddle += inverseTranslate.y;
              targetMiddle *= inverseScale.y;
            }
            y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
          } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
        }
      }
      node.setPosition(x, y);
    }
    function visitNode(node) {
      var widget = node._widget;
      if (widget) {
        var target;
        var isParent;
        false;
        align(node, widget);
        true, widget.alignMode !== AlignMode.ALWAYS ? widget.enabled = false : activeWidgets.push(widget);
      }
      var children = node._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        child._active && visitNode(child);
      }
    }
    var animationState;
    false;
    function refreshScene() {
      var nowPreviewing;
      false;
      var scene = cc.director.getScene();
      if (scene) {
        widgetManager.isAligning = true;
        if (widgetManager._nodesOrderDirty) {
          activeWidgets.length = 0;
          visitNode(scene);
          widgetManager._nodesOrderDirty = false;
        } else {
          var i, widget, iterator = widgetManager._activeWidgetsIterator;
          var editingNode;
          var node;
          false;
          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];
            align(widget.node, widget);
          }
        }
        widgetManager.isAligning = false;
      }
      false;
    }
    var adjustWidgetToAllowMovingInEditor = false;
    var adjustWidgetToAllowResizingInEditor = false;
    var activeWidgets = [];
    function updateAlignment(node) {
      var parent = node._parent;
      cc.Node.isNode(parent) && updateAlignment(parent);
      var widget = node._widget || node.getComponent(cc.Widget);
      widget && align(node, widget);
    }
    var widgetManager = cc._widgetManager = module.exports = {
      _AlignFlags: {
        TOP: TOP,
        MID: MID,
        BOT: BOT,
        LEFT: LEFT,
        CENTER: CENTER,
        RIGHT: RIGHT
      },
      isAligning: false,
      _nodesOrderDirty: false,
      _activeWidgetsIterator: new cc.js.array.MutableForwardIterator(activeWidgets),
      init: function(director) {
        director.on(cc.Director.EVENT_AFTER_UPDATE, refreshScene);
        false;
        true;
        cc.sys.isMobile ? window.addEventListener("resize", this.onResized.bind(this)) : eventManager.addCustomListener("canvas-resize", this.onResized.bind(this));
      },
      add: function(widget) {
        widget.node._widget = widget;
        this._nodesOrderDirty = true;
        false;
      },
      remove: function(widget) {
        widget.node._widget = null;
        this._activeWidgetsIterator.remove(widget);
        false;
      },
      onResized: function() {
        var scene = cc.director.getScene();
        scene && this.refreshWidgetOnResized(scene);
      },
      refreshWidgetOnResized: function(node) {
        var widget = cc.Node.isNode(node) && node.getComponent(cc.Widget);
        widget && widget.alignMode === AlignMode.ON_WINDOW_RESIZE && (widget.enabled = true);
        var children = node._children;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          this.refreshWidgetOnResized(child);
        }
      },
      updateAlignment: updateAlignment,
      AlignMode: AlignMode
    };
    false;
  }), {
    "../CCNode": 30,
    "../event-manager": 98
  } ],
  52: [ (function(require, module, exports) {
    var AffineTrans = require("../utils/affine-transform");
    var renderEngine = require("../renderer/render-engine");
    var renderer = require("../renderer/index");
    var game = require("../CCGame");
    var mat4 = cc.vmath.mat4;
    var vec2 = cc.vmath.vec2;
    var vec3 = cc.vmath.vec3;
    var _mat4_temp_1 = mat4.create();
    var _mat4_temp_2 = mat4.create();
    var _vec3_temp_1 = vec3.create();
    var _vec3_temp_2 = vec3.create();
    var _cameras = [];
    var ClearFlags = cc.Enum({
      COLOR: 1,
      DEPTH: 2,
      STENCIL: 4
    });
    var Camera = cc.Class({
      name: "cc.Camera",
      extends: cc.Component,
      ctor: function() {
        var camera = new renderEngine.Camera();
        camera.setStages([ "transparent" ]);
        this._fov = 60 * Math.PI / 180;
        camera.setFov(this._fov);
        camera.setNear(.1);
        camera.setFar(4096);
        var view = new renderEngine.View();
        camera.view = view;
        camera.dirty = true;
        this._matrixDirty = true;
        this._inited = false;
        this._camera = camera;
      },
      editor: false,
      properties: {
        _cullingMask: 4294967295,
        _clearFlags: 0,
        _backgroundColor: cc.color(0, 0, 0, 255),
        _depth: 0,
        _zoomRatio: 1,
        _targetTexture: null,
        zoomRatio: {
          get: function() {
            return this._zoomRatio;
          },
          set: function(value) {
            this._zoomRatio = value;
            this._matrixDirty = true;
          }
        },
        cullingMask: {
          get: function() {
            return this._cullingMask;
          },
          set: function(value) {
            this._cullingMask = value;
            this._updateCameraMask();
          }
        },
        clearFlags: {
          get: function() {
            return this._clearFlags;
          },
          set: function(value) {
            this._clearFlags = value;
            this._camera.setClearFlags(value);
          }
        },
        backgroundColor: {
          get: function() {
            return this._backgroundColor;
          },
          set: function(value) {
            this._backgroundColor = value;
            this._updateBackgroundColor();
          }
        },
        depth: {
          get: function() {
            return this._depth;
          },
          set: function(value) {
            this._depth = value;
            this._camera.setDepth(value);
          }
        },
        targetTexture: {
          get: function() {
            return this._targetTexture;
          },
          set: function(value) {
            this._targetTexture = value;
            this._updateTargetTexture();
          }
        }
      },
      statics: {
        main: null,
        cameras: _cameras,
        ClearFlags: ClearFlags,
        findCamera: function(node) {
          for (var i = 0, l = _cameras.length; i < l; i++) {
            var camera = _cameras[i];
            if (camera.containsNode(node)) return camera;
          }
          return null;
        }
      },
      _updateCameraMask: function() {
        this._camera._cullingMask = this._cullingMask;
        this._camera.view._cullingMask = this._cullingMask;
      },
      _updateBackgroundColor: function() {
        var color = this._backgroundColor;
        this._camera.setColor(color.r / 255, color.g / 255, color.b / 255, color.a / 255);
      },
      _updateTargetTexture: function() {
        var texture = this._targetTexture;
        this._camera._framebuffer = texture ? texture._framebuffer : null;
      },
      _onMatrixDirty: function() {
        this._matrixDirty = true;
      },
      _init: function() {
        if (this._inited) return;
        this._inited = true;
        this._camera.setNode(this.node);
        this._camera.setClearFlags(this._clearFlags);
        this._camera.setDepth(this._depth);
        this._updateBackgroundColor();
        this._updateCameraMask();
        this._updateTargetTexture();
      },
      onLoad: function() {
        this._init();
      },
      onEnable: function() {
        this._matrixDirty = true;
        cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
        game.renderType === game.RENDER_TYPE_WEBGL && renderer.scene.addCamera(this._camera);
        _cameras.push(this);
      },
      onDisable: function() {
        cc.director.off(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
        game.renderType === game.RENDER_TYPE_WEBGL && renderer.scene.removeCamera(this._camera);
        cc.js.array.remove(_cameras, this);
      },
      getNodeToCameraTransform: function(node) {
        var out = AffineTrans.identity();
        node.getWorldMatrix(_mat4_temp_2);
        if (this.containsNode(node)) {
          this.getWorldToCameraMatrix(_mat4_temp_1);
          mat4.mul(_mat4_temp_2, _mat4_temp_2, _mat4_temp_1);
        }
        AffineTrans.fromMat4(out, _mat4_temp_2);
        return out;
      },
      getCameraToWorldPoint: function(point, out) {
        out = out || cc.v2();
        this.getCameraToWorldMatrix(_mat4_temp_1);
        vec2.transformMat4(out, point, _mat4_temp_1);
        return out;
      },
      getWorldToCameraPoint: function(point, out) {
        out = out || cc.v2();
        this.getWorldToCameraMatrix(_mat4_temp_1);
        vec2.transformMat4(out, point, _mat4_temp_1);
        return out;
      },
      getCameraToWorldMatrix: function(out) {
        this.getWorldToCameraMatrix(out);
        mat4.invert(out, out);
        return out;
      },
      getWorldToCameraMatrix: function(out) {
        this.node.getWorldRT(_mat4_temp_1);
        var zoomRatio = this.zoomRatio;
        _mat4_temp_1.m00 *= zoomRatio;
        _mat4_temp_1.m01 *= zoomRatio;
        _mat4_temp_1.m04 *= zoomRatio;
        _mat4_temp_1.m05 *= zoomRatio;
        var m12 = _mat4_temp_1.m12;
        var m13 = _mat4_temp_1.m13;
        var center = cc.visibleRect.center;
        _mat4_temp_1.m12 = center.x - (_mat4_temp_1.m00 * m12 + _mat4_temp_1.m04 * m13);
        _mat4_temp_1.m13 = center.y - (_mat4_temp_1.m01 * m12 + _mat4_temp_1.m05 * m13);
        out !== _mat4_temp_1 && mat4.copy(out, _mat4_temp_1);
        return out;
      },
      containsNode: function(node) {
        return node._cullingMask & this.cullingMask;
      },
      render: function(root) {
        root = root || cc.director.getScene();
        if (!root) return null;
        this.node.getWorldMatrix(_mat4_temp_1);
        this.beforeDraw();
        renderer._walker.visit(root);
        renderer._forward.renderCamera(this._camera, renderer.scene);
      },
      beforeDraw: (true, function() {
        var node = this.node;
        if (!this._matrixDirty && !node._worldMatDirty) return;
        var camera = this._camera;
        var fov = 2 * Math.atan(Math.tan(this._fov / 2) / this.zoomRatio);
        camera.setFov(fov);
        var height = cc.visibleRect.height;
        var targetTexture = this._targetTexture;
        targetTexture && (height = targetTexture.height);
        node._updateWorldMatrix();
        _vec3_temp_1.x = node._worldMatrix.m12;
        _vec3_temp_1.y = node._worldMatrix.m13;
        _vec3_temp_1.z = 0;
        node.z = height / 1.1566;
        node.lookAt(_vec3_temp_1);
        this._matrixDirty = false;
        camera.dirty = true;
      })
    });
    module.exports = cc.Camera = Camera;
  }), {
    "../CCGame": 29,
    "../renderer/index": 196,
    "../renderer/render-engine": 197,
    "../utils/affine-transform": 225
  } ],
  53: [ (function(require, module, exports) {
    cc.Collider.Box = cc.Class({
      properties: {
        _offset: cc.v2(0, 0),
        _size: cc.size(100, 100),
        offset: {
          tooltip: false,
          get: function() {
            return this._offset;
          },
          set: function(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        size: {
          tooltip: false,
          get: function() {
            return this._size;
          },
          set: function(value) {
            this._size.width = value.width < 0 ? 0 : value.width;
            this._size.height = value.height < 0 ? 0 : value.height;
          },
          type: cc.Size
        }
      },
      resetInEditor: false
    });
    var BoxCollider = cc.Class({
      name: "cc.BoxCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Box ],
      editor: false
    });
    cc.BoxCollider = module.exports = BoxCollider;
  }), {} ],
  54: [ (function(require, module, exports) {
    cc.Collider.Circle = cc.Class({
      properties: {
        _offset: cc.v2(0, 0),
        _radius: 50,
        offset: {
          get: function() {
            return this._offset;
          },
          set: function(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        radius: {
          tooltip: false,
          get: function() {
            return this._radius;
          },
          set: function(value) {
            this._radius = value < 0 ? 0 : value;
          }
        }
      },
      resetInEditor: false
    });
    var CircleCollider = cc.Class({
      name: "cc.CircleCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Circle ],
      editor: false
    });
    cc.CircleCollider = module.exports = CircleCollider;
  }), {} ],
  55: [ (function(require, module, exports) {
    var Collider = cc.Class({
      name: "cc.Collider",
      extends: cc.Component,
      properties: {
        editing: {
          default: false,
          serializable: false,
          tooltip: false
        },
        tag: {
          tooltip: false,
          default: 0,
          range: [ 0, 1e7 ],
          type: cc.Integer
        }
      },
      onDisable: function() {
        cc.director.getCollisionManager().removeCollider(this);
      },
      onEnable: function() {
        cc.director.getCollisionManager().addCollider(this);
      }
    });
    cc.Collider = module.exports = Collider;
  }), {} ],
  56: [ (function(require, module, exports) {
    var Contact = require("./CCContact");
    var CollisionType = Contact.CollisionType;
    var NodeEvent = require("../CCNode").EventType;
    var math = cc.vmath;
    var _vec2 = cc.v2();
    function obbApplyMatrix(rect, mat4, out_bl, out_tl, out_tr, out_br) {
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var m00 = mat4.m00, m01 = mat4.m01, m04 = mat4.m04, m05 = mat4.m05;
      var m12 = mat4.m12, m13 = mat4.m13;
      var tx = m00 * x + m04 * y + m12;
      var ty = m01 * x + m05 * y + m13;
      var xa = m00 * width;
      var xb = m01 * width;
      var yc = m04 * height;
      var yd = m05 * height;
      out_tl.x = tx;
      out_tl.y = ty;
      out_tr.x = xa + tx;
      out_tr.y = xb + ty;
      out_bl.x = yc + tx;
      out_bl.y = yd + ty;
      out_br.x = xa + yc + tx;
      out_br.y = xb + yd + ty;
    }
    var CollisionManager = cc.Class({
      mixins: [ cc.EventTarget ],
      properties: {
        enabled: false,
        enabledDrawBoundingBox: false
      },
      ctor: function() {
        this._contacts = [];
        this._colliders = [];
        this._debugDrawer = null;
        this._enabledDebugDraw = false;
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
      },
      update: function(dt) {
        if (!this.enabled) return;
        var i = void 0, l = void 0;
        var colliders = this._colliders;
        for (i = 0, l = colliders.length; i < l; i++) this.updateCollider(colliders[i]);
        var contacts = this._contacts;
        var results = [];
        for (i = 0, l = contacts.length; i < l; i++) {
          var collisionType = contacts[i].updateState();
          if (collisionType === CollisionType.None) continue;
          results.push([ collisionType, contacts[i] ]);
        }
        for (i = 0, l = results.length; i < l; i++) {
          var result = results[i];
          this._doCollide(result[0], result[1]);
        }
        this.drawColliders();
      },
      _doCollide: function(collisionType, contact) {
        var contactFunc = void 0;
        switch (collisionType) {
         case CollisionType.CollisionEnter:
          contactFunc = "onCollisionEnter";
          break;

         case CollisionType.CollisionStay:
          contactFunc = "onCollisionStay";
          break;

         case CollisionType.CollisionExit:
          contactFunc = "onCollisionExit";
        }
        var collider1 = contact.collider1;
        var collider2 = contact.collider2;
        var comps1 = collider1.node._components;
        var comps2 = collider2.node._components;
        var i = void 0, l = void 0, comp = void 0;
        for (i = 0, l = comps1.length; i < l; i++) {
          comp = comps1[i];
          comp[contactFunc] && comp[contactFunc](collider2, collider1);
        }
        for (i = 0, l = comps2.length; i < l; i++) {
          comp = comps2[i];
          comp[contactFunc] && comp[contactFunc](collider1, collider2);
        }
      },
      shouldCollide: function(c1, c2) {
        var node1 = c1.node, node2 = c2.node;
        var collisionMatrix = cc.game.collisionMatrix;
        return node1 !== node2 && collisionMatrix[node1.groupIndex][node2.groupIndex];
      },
      initCollider: function(collider) {
        if (!collider.world) {
          var world = collider.world = {};
          world.aabb = cc.rect();
          world.preAabb = cc.rect();
          world.matrix = math.mat4.create();
          world.radius = 0;
          if (collider instanceof cc.BoxCollider) {
            world.position = null;
            world.points = [ cc.v2(), cc.v2(), cc.v2(), cc.v2() ];
          } else if (collider instanceof cc.PolygonCollider) {
            world.position = null;
            world.points = collider.points.map((function(p) {
              return cc.v2(p.x, p.y);
            }));
          } else if (collider instanceof cc.CircleCollider) {
            world.position = cc.v2();
            world.points = null;
          }
        }
      },
      updateCollider: function(collider) {
        var offset = collider.offset;
        var world = collider.world;
        var aabb = world.aabb;
        var m = world.matrix;
        collider.node.getWorldMatrix(m);
        var preAabb = world.preAabb;
        preAabb.x = aabb.x;
        preAabb.y = aabb.y;
        preAabb.width = aabb.width;
        preAabb.height = aabb.height;
        if (collider instanceof cc.BoxCollider) {
          var size = collider.size;
          aabb.x = offset.x - size.width / 2;
          aabb.y = offset.y - size.height / 2;
          aabb.width = size.width;
          aabb.height = size.height;
          var wps = world.points;
          var wp0 = wps[0], wp1 = wps[1], wp2 = wps[2], wp3 = wps[3];
          obbApplyMatrix(aabb, m, wp0, wp1, wp2, wp3);
          var minx = Math.min(wp0.x, wp1.x, wp2.x, wp3.x);
          var miny = Math.min(wp0.y, wp1.y, wp2.y, wp3.y);
          var maxx = Math.max(wp0.x, wp1.x, wp2.x, wp3.x);
          var maxy = Math.max(wp0.y, wp1.y, wp2.y, wp3.y);
          aabb.x = minx;
          aabb.y = miny;
          aabb.width = maxx - minx;
          aabb.height = maxy - miny;
        } else if (collider instanceof cc.CircleCollider) {
          math.vec2.transformMat4(_vec2, collider.offset, m);
          world.position.x = _vec2.x;
          world.position.y = _vec2.y;
          var tempx = m.m12, tempy = m.m13;
          m.m12 = m.m13 = 0;
          _vec2.x = collider.radius;
          _vec2.y = 0;
          math.vec2.transformMat4(_vec2, _vec2, m);
          var d = Math.sqrt(_vec2.x * _vec2.x + _vec2.y * _vec2.y);
          world.radius = d;
          aabb.x = world.position.x - d;
          aabb.y = world.position.y - d;
          aabb.width = 2 * d;
          aabb.height = 2 * d;
          m.m12 = tempx;
          m.m13 = tempy;
        } else if (collider instanceof cc.PolygonCollider) {
          var points = collider.points;
          var worldPoints = world.points;
          worldPoints.length = points.length;
          var _minx = 1e6, _miny = 1e6, _maxx = -1e6, _maxy = -1e6;
          for (var i = 0, l = points.length; i < l; i++) {
            worldPoints[i] || (worldPoints[i] = cc.v2());
            _vec2.x = points[i].x + offset.x;
            _vec2.y = points[i].y + offset.y;
            math.vec2.transformMat4(_vec2, _vec2, m);
            var x = _vec2.x;
            var y = _vec2.y;
            worldPoints[i].x = x;
            worldPoints[i].y = y;
            x > _maxx && (_maxx = x);
            x < _minx && (_minx = x);
            y > _maxy && (_maxy = y);
            y < _miny && (_miny = y);
          }
          aabb.x = _minx;
          aabb.y = _miny;
          aabb.width = _maxx - _minx;
          aabb.height = _maxy - _miny;
        }
      },
      addCollider: function(collider) {
        var colliders = this._colliders;
        var index = colliders.indexOf(collider);
        if (-1 === index) {
          for (var i = 0, l = colliders.length; i < l; i++) {
            var other = colliders[i];
            if (this.shouldCollide(collider, other)) {
              var contact = new Contact(collider, other);
              this._contacts.push(contact);
            }
          }
          colliders.push(collider);
          this.initCollider(collider);
        }
        collider.node.on(NodeEvent.GROUP_CHANGED, this.onNodeGroupChanged, this);
      },
      removeCollider: function(collider) {
        var colliders = this._colliders;
        var index = colliders.indexOf(collider);
        if (index >= 0) {
          colliders.splice(index, 1);
          var contacts = this._contacts;
          for (var i = contacts.length - 1; i >= 0; i--) {
            var contact = contacts[i];
            if (contact.collider1 === collider || contact.collider2 === collider) {
              contact.touching && this._doCollide(CollisionType.CollisionExit, contact);
              contacts.splice(i, 1);
            }
          }
          collider.node.off(NodeEvent.GROUP_CHANGED, this.onNodeGroupChanged, this);
        } else cc.errorID(6600);
      },
      onNodeGroupChanged: function(event) {
        var node = event.currentTarget;
        var colliders = node.getComponents(cc.Collider);
        for (var i = 0, l = colliders.length; i < l; i++) {
          this.removeCollider(colliders[i]);
          this.addCollider(colliders[i]);
        }
      },
      drawColliders: function() {
        if (!this._enabledDebugDraw) return;
        this._checkDebugDrawValid();
        var debugDrawer = this._debugDrawer;
        debugDrawer.clear();
        var colliders = this._colliders;
        for (var i = 0, l = colliders.length; i < l; i++) {
          var collider = colliders[i];
          debugDrawer.strokeColor = cc.Color.WHITE;
          if (collider instanceof cc.BoxCollider || collider instanceof cc.PolygonCollider) {
            var ps = collider.world.points;
            if (ps.length > 0) {
              debugDrawer.moveTo(ps[0].x, ps[0].y);
              for (var j = 1; j < ps.length; j++) debugDrawer.lineTo(ps[j].x, ps[j].y);
              debugDrawer.close();
              debugDrawer.stroke();
            }
          } else if (collider instanceof cc.CircleCollider) {
            debugDrawer.circle(collider.world.position.x, collider.world.position.y, collider.world.radius);
            debugDrawer.stroke();
          }
          if (this.enabledDrawBoundingBox) {
            var aabb = collider.world.aabb;
            debugDrawer.strokeColor = cc.Color.BLUE;
            debugDrawer.moveTo(aabb.xMin, aabb.yMin);
            debugDrawer.lineTo(aabb.xMin, aabb.yMax);
            debugDrawer.lineTo(aabb.xMax, aabb.yMax);
            debugDrawer.lineTo(aabb.xMax, aabb.yMin);
            debugDrawer.close();
            debugDrawer.stroke();
          }
        }
      },
      _checkDebugDrawValid: function() {
        if (!this._debugDrawer || !this._debugDrawer.isValid) {
          var node = new cc.Node("COLLISION_MANAGER_DEBUG_DRAW");
          node.zIndex = cc.macro.MAX_ZINDEX;
          cc.game.addPersistRootNode(node);
          this._debugDrawer = node.addComponent(cc.Graphics);
        }
      }
    });
    cc.js.getset(CollisionManager.prototype, "enabledDebugDraw", (function() {
      return this._enabledDebugDraw;
    }), (function(value) {
      if (value && !this._enabledDebugDraw) {
        this._checkDebugDrawValid();
        this._debugDrawer.node.active = true;
      } else if (!value && this._enabledDebugDraw) {
        this._debugDrawer.clear(true);
        this._debugDrawer.node.active = false;
      }
      this._enabledDebugDraw = value;
    }));
    cc.CollisionManager = module.exports = CollisionManager;
  }), {
    "../CCNode": 30,
    "./CCContact": 57
  } ],
  57: [ (function(require, module, exports) {
    var Intersection = require("./CCIntersection");
    var CollisionType = cc.Enum({
      None: 0,
      CollisionEnter: 1,
      CollisionStay: 2,
      CollisionExit: 3
    });
    function Contact(collider1, collider2) {
      this.collider1 = collider1;
      this.collider2 = collider2;
      this.touching = false;
      var isCollider1Polygon = collider1 instanceof cc.BoxCollider || collider1 instanceof cc.PolygonCollider;
      var isCollider2Polygon = collider2 instanceof cc.BoxCollider || collider2 instanceof cc.PolygonCollider;
      var isCollider1Circle = collider1 instanceof cc.CircleCollider;
      var isCollider2Circle = collider2 instanceof cc.CircleCollider;
      if (isCollider1Polygon && isCollider2Polygon) this.testFunc = Intersection.polygonPolygon; else if (isCollider1Circle && isCollider2Circle) this.testFunc = Intersection.circleCircle; else if (isCollider1Polygon && isCollider2Circle) this.testFunc = Intersection.polygonCircle; else if (isCollider1Circle && isCollider2Polygon) {
        this.testFunc = Intersection.polygonCircle;
        this.collider1 = collider2;
        this.collider2 = collider1;
      } else cc.errorID(6601, cc.js.getClassName(collider1), cc.js.getClassName(collider2));
    }
    Contact.prototype.test = function() {
      var world1 = this.collider1.world;
      var world2 = this.collider2.world;
      if (!world1.aabb.intersects(world2.aabb)) return false;
      if (this.testFunc === Intersection.polygonPolygon) return this.testFunc(world1.points, world2.points);
      if (this.testFunc === Intersection.circleCircle) return this.testFunc(world1, world2);
      if (this.testFunc === Intersection.polygonCircle) return this.testFunc(world1.points, world2);
      return false;
    };
    Contact.prototype.updateState = function() {
      var result = this.test();
      var type = CollisionType.None;
      if (result && !this.touching) {
        this.touching = true;
        type = CollisionType.CollisionEnter;
      } else if (result && this.touching) type = CollisionType.CollisionStay; else if (!result && this.touching) {
        this.touching = false;
        type = CollisionType.CollisionExit;
      }
      return type;
    };
    Contact.CollisionType = CollisionType;
    module.exports = Contact;
  }), {
    "./CCIntersection": 58
  } ],
  58: [ (function(require, module, exports) {
    var Intersection = {};
    function lineLine(a1, a2, b1, b2) {
      var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
      var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
      var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
      if (0 !== u_b) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) return true;
      }
      return false;
    }
    Intersection.lineLine = lineLine;
    function lineRect(a1, a2, b) {
      var r0 = new cc.Vec2(b.x, b.y);
      var r1 = new cc.Vec2(b.x, b.yMax);
      var r2 = new cc.Vec2(b.xMax, b.yMax);
      var r3 = new cc.Vec2(b.xMax, b.y);
      if (lineLine(a1, a2, r0, r1)) return true;
      if (lineLine(a1, a2, r1, r2)) return true;
      if (lineLine(a1, a2, r2, r3)) return true;
      if (lineLine(a1, a2, r3, r0)) return true;
      return false;
    }
    Intersection.lineRect = lineRect;
    function linePolygon(a1, a2, b) {
      var length = b.length;
      for (var i = 0; i < length; ++i) {
        var b1 = b[i];
        var b2 = b[(i + 1) % length];
        if (lineLine(a1, a2, b1, b2)) return true;
      }
      return false;
    }
    Intersection.linePolygon = linePolygon;
    function rectRect(a, b) {
      var a_min_x = a.x;
      var a_min_y = a.y;
      var a_max_x = a.x + a.width;
      var a_max_y = a.y + a.height;
      var b_min_x = b.x;
      var b_min_y = b.y;
      var b_max_x = b.x + b.width;
      var b_max_y = b.y + b.height;
      return a_min_x <= b_max_x && a_max_x >= b_min_x && a_min_y <= b_max_y && a_max_y >= b_min_y;
    }
    Intersection.rectRect = rectRect;
    function rectPolygon(a, b) {
      var i, l;
      var r0 = new cc.Vec2(a.x, a.y);
      var r1 = new cc.Vec2(a.x, a.yMax);
      var r2 = new cc.Vec2(a.xMax, a.yMax);
      var r3 = new cc.Vec2(a.xMax, a.y);
      if (linePolygon(r0, r1, b)) return true;
      if (linePolygon(r1, r2, b)) return true;
      if (linePolygon(r2, r3, b)) return true;
      if (linePolygon(r3, r0, b)) return true;
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      if (pointInPolygon(r0, b)) return true;
      if (pointInPolygon(r1, b)) return true;
      if (pointInPolygon(r2, b)) return true;
      if (pointInPolygon(r3, b)) return true;
      return false;
    }
    Intersection.rectPolygon = rectPolygon;
    function polygonPolygon(a, b) {
      var i, l;
      for (i = 0, l = a.length; i < l; ++i) {
        var a1 = a[i];
        var a2 = a[(i + 1) % l];
        if (linePolygon(a1, a2, b)) return true;
      }
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      for (i = 0, l = a.length; i < l; ++i) if (pointInPolygon(a[i], b)) return true;
      return false;
    }
    Intersection.polygonPolygon = polygonPolygon;
    function circleCircle(a, b) {
      var distance = a.position.sub(b.position).mag();
      return distance < a.radius + b.radius;
    }
    Intersection.circleCircle = circleCircle;
    function polygonCircle(polygon, circle) {
      var position = circle.position;
      if (pointInPolygon(position, polygon)) return true;
      for (var i = 0, l = polygon.length; i < l; i++) {
        var start = 0 === i ? polygon[polygon.length - 1] : polygon[i - 1];
        var end = polygon[i];
        if (pointLineDistance(position, start, end, true) < circle.radius) return true;
      }
      return false;
    }
    Intersection.polygonCircle = polygonCircle;
    function pointInPolygon(point, polygon) {
      var inside = false;
      var x = point.x;
      var y = point.y;
      var length = polygon.length;
      for (var i = 0, j = length - 1; i < length; j = i++) {
        var xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y, intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        intersect && (inside = !inside);
      }
      return inside;
    }
    Intersection.pointInPolygon = pointInPolygon;
    function pointLineDistance(point, start, end, isSegment) {
      var dx = end.x - start.x;
      var dy = end.y - start.y;
      var d = dx * dx + dy * dy;
      var t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;
      var p;
      p = isSegment ? d ? t < 0 ? start : t > 1 ? end : cc.v2(start.x + t * dx, start.y + t * dy) : start : cc.v2(start.x + t * dx, start.y + t * dy);
      dx = point.x - p.x;
      dy = point.y - p.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    Intersection.pointLineDistance = pointLineDistance;
    cc.Intersection = module.exports = Intersection;
  }), {} ],
  59: [ (function(require, module, exports) {
    cc.Collider.Polygon = cc.Class({
      properties: {
        threshold: {
          default: 1,
          serializable: false,
          visible: false
        },
        _offset: cc.v2(0, 0),
        offset: {
          get: function() {
            return this._offset;
          },
          set: function(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        points: {
          tooltip: false,
          default: function() {
            return [ cc.v2(-50, -50), cc.v2(50, -50), cc.v2(50, 50), cc.v2(-50, 50) ];
          },
          type: [ cc.Vec2 ]
        }
      },
      resetPointsByContour: false
    });
    var PolygonCollider = cc.Class({
      name: "cc.PolygonCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Polygon ],
      editor: false
    });
    cc.PolygonCollider = module.exports = PolygonCollider;
  }), {} ],
  60: [ (function(require, module, exports) {
    require("./CCCollisionManager");
    require("./CCCollider");
    require("./CCBoxCollider");
    require("./CCCircleCollider");
    require("./CCPolygonCollider");
  }), {
    "./CCBoxCollider": 53,
    "./CCCircleCollider": 54,
    "./CCCollider": 55,
    "./CCCollisionManager": 56,
    "./CCPolygonCollider": 59
  } ],
  61: [ (function(require, module, exports) {
    require("./platform/CCClass");
    var Flags = require("./platform/CCObject").Flags;
    var jsArray = require("./platform/js").array;
    var IsStartCalled = Flags.IsStartCalled;
    var IsOnEnableCalled = Flags.IsOnEnableCalled;
    var IsEditorOnEnableCalled = Flags.IsEditorOnEnableCalled;
    var callerFunctor = false;
    var callOnEnableInTryCatch = false;
    var callStartInTryCatch = false;
    var callUpdateInTryCatch = false;
    var callLateUpdateInTryCatch = false;
    var callOnDisableInTryCatch = false;
    var callStart = "c.start();c._objFlags|=" + IsStartCalled;
    var callUpdate = "c.update(dt)";
    var callLateUpdate = "c.lateUpdate(dt)";
    function sortedIndex(array, comp) {
      var order = comp.constructor._executionOrder;
      var id = comp._id;
      for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m];
        var testOrder = test.constructor._executionOrder;
        if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
          var testId = test._id;
          if (testId > id) h = m - 1; else {
            if (!(testId < id)) return m;
            l = m + 1;
          }
        }
      }
      return ~l;
    }
    function stableRemoveInactive(iterator, flagToClear) {
      var array = iterator.array;
      var next = iterator.i + 1;
      while (next < array.length) {
        var comp = array[next];
        if (comp._enabled && comp.node._activeInHierarchy) ++next; else {
          iterator.removeAt(next);
          flagToClear && (comp._objFlags &= ~flagToClear);
        }
      }
    }
    var LifeCycleInvoker = cc.Class({
      __ctor__: function(invokeFunc) {
        var Iterator = jsArray.MutableForwardIterator;
        this._zero = new Iterator([]);
        this._neg = new Iterator([]);
        this._pos = new Iterator([]);
        false;
        this._invoke = invokeFunc;
      },
      statics: {
        stableRemoveInactive: stableRemoveInactive
      },
      add: null,
      remove: null,
      invoke: null
    });
    function compareOrder(a, b) {
      return a.constructor._executionOrder - b.constructor._executionOrder;
    }
    var OneOffInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
      },
      remove: function(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
      },
      cancelInactive: function(flagToClear) {
        stableRemoveInactive(this._zero, flagToClear);
        stableRemoveInactive(this._neg, flagToClear);
        stableRemoveInactive(this._pos, flagToClear);
      },
      invoke: function() {
        var compsNeg = this._neg;
        if (compsNeg.array.length > 0) {
          compsNeg.array.sort(compareOrder);
          this._invoke(compsNeg);
          compsNeg.array.length = 0;
        }
        this._invoke(this._zero);
        this._zero.array.length = 0;
        var compsPos = this._pos;
        if (compsPos.array.length > 0) {
          compsPos.array.sort(compareOrder);
          this._invoke(compsPos);
          compsPos.array.length = 0;
        }
      }
    });
    var ReusableInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.array.push(comp); else {
          var array = order < 0 ? this._neg.array : this._pos.array;
          var i = sortedIndex(array, comp);
          i < 0 && array.splice(~i, 0, comp);
        }
      },
      remove: function(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.fastRemove(comp); else {
          var iterator = order < 0 ? this._neg : this._pos;
          var i = sortedIndex(iterator.array, comp);
          i >= 0 && iterator.removeAt(i);
        }
      },
      invoke: function(dt) {
        this._neg.array.length > 0 && this._invoke(this._neg, dt);
        this._invoke(this._zero, dt);
        this._pos.array.length > 0 && this._invoke(this._pos, dt);
      }
    });
    function enableInEditor(comp) {
      if (!(comp._objFlags & IsEditorOnEnableCalled)) {
        cc.engine.emit("component-enabled", comp.uuid);
        comp._objFlags |= IsEditorOnEnableCalled;
      }
    }
    function createInvokeImpl(funcOrCode, useDt) {
      if ("function" === typeof funcOrCode) return useDt ? function(iterator, dt) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp, dt);
        }
      } : function(iterator) {
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var comp = array[iterator.i];
          funcOrCode(comp);
        }
      };
      var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + funcOrCode + "}";
      return useDt ? Function("it", "dt", body) : Function("it", body);
    }
    function ctor() {
      this.startInvoker = new OneOffInvoker(createInvokeImpl(callStart));
      this.updateInvoker = new ReusableInvoker(createInvokeImpl(callUpdate, true));
      this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl(callLateUpdate, true));
      this.scheduleInNextFrame = [];
      this._updating = false;
    }
    var ComponentScheduler = cc.Class({
      ctor: ctor,
      unscheduleAll: ctor,
      statics: {
        LifeCycleInvoker: LifeCycleInvoker,
        OneOffInvoker: OneOffInvoker,
        createInvokeImpl: createInvokeImpl,
        invokeOnEnable: function(iterator) {
          var compScheduler = cc.director._compScheduler;
          var array = iterator.array;
          for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            if (comp._enabled) {
              comp.onEnable();
              var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
              deactivatedDuringOnEnable || compScheduler._onEnabled(comp);
            }
          }
        }
      },
      _onEnabled: function(comp) {
        cc.director.getScheduler().resumeTarget(comp);
        comp._objFlags |= IsOnEnableCalled;
        this._updating ? this.scheduleInNextFrame.push(comp) : this._scheduleImmediate(comp);
      },
      _onDisabled: function(comp) {
        cc.director.getScheduler().pauseTarget(comp);
        comp._objFlags &= ~IsOnEnableCalled;
        var index = this.scheduleInNextFrame.indexOf(comp);
        if (index >= 0) {
          jsArray.fastRemoveAt(this.scheduleInNextFrame, index);
          return;
        }
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.remove(comp);
        comp.update && this.updateInvoker.remove(comp);
        comp.lateUpdate && this.lateUpdateInvoker.remove(comp);
      },
      enableComp: function(comp, invoker) {
        if (!(comp._objFlags & IsOnEnableCalled)) {
          if (comp.onEnable) {
            if (invoker) {
              invoker.add(comp);
              return;
            }
            comp.onEnable();
            var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
            if (deactivatedDuringOnEnable) return;
          }
          this._onEnabled(comp);
        }
      },
      disableComp: function(comp) {
        if (comp._objFlags & IsOnEnableCalled) {
          comp.onDisable && comp.onDisable();
          this._onDisabled(comp);
        }
      },
      _scheduleImmediate: function(comp) {
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.add(comp);
        comp.update && this.updateInvoker.add(comp);
        comp.lateUpdate && this.lateUpdateInvoker.add(comp);
      },
      _deferredSchedule: function() {
        var comps = this.scheduleInNextFrame;
        for (var i = 0, len = comps.length; i < len; i++) {
          var comp = comps[i];
          this._scheduleImmediate(comp);
        }
        comps.length = 0;
      },
      startPhase: function() {
        this._updating = true;
        this.scheduleInNextFrame.length > 0 && this._deferredSchedule();
        this.startInvoker.invoke();
      },
      updatePhase: function(dt) {
        this.updateInvoker.invoke(dt);
      },
      lateUpdatePhase: function(dt) {
        this.lateUpdateInvoker.invoke(dt);
        this._updating = false;
      }
    });
    module.exports = ComponentScheduler;
  }), {
    "./platform/CCClass": 155,
    "./platform/CCObject": 161,
    "./platform/js": 175,
    "./utils/misc": 233
  } ],
  62: [ (function(require, module, exports) {
    var AnimationAnimator = require("../../animation/animation-animator");
    var AnimationClip = require("../../animation/animation-clip");
    var js = require("../platform/js");
    function equalClips(clip1, clip2) {
      if (clip1 === clip2) return true;
      return clip1 && clip2 && (clip1.name === clip2.name || clip1._uuid === clip2._uuid);
    }
    var Animation = cc.Class({
      name: "cc.Animation",
      extends: require("./CCComponent"),
      mixins: [ cc.EventTarget ],
      editor: false,
      ctor: function() {
        cc.EventTarget.call(this);
        this._animator = null;
        this._nameToState = js.createMap(true);
        this._didInit = false;
        this._currentClip = null;
      },
      properties: {
        _defaultClip: {
          default: null,
          type: AnimationClip
        },
        defaultClip: {
          type: AnimationClip,
          get: function() {
            return this._defaultClip;
          },
          set: function(value) {
            true;
            return;
            var clips;
            var i, l;
          },
          tooltip: false
        },
        currentClip: {
          get: function() {
            return this._currentClip;
          },
          set: function(value) {
            this._currentClip = value;
          },
          type: AnimationClip,
          visible: false
        },
        _clips: {
          default: [],
          type: [ AnimationClip ],
          tooltip: false,
          visible: true
        },
        playOnLoad: {
          default: false,
          tooltip: false
        }
      },
      start: function() {
        if ((true, this.playOnLoad) && this._defaultClip) {
          var isPlaying = this._animator && this._animator.isPlaying;
          if (!isPlaying) {
            var state = this.getAnimationState(this._defaultClip.name);
            this._animator.playState(state);
          }
        }
      },
      onEnable: function() {
        this._animator && this._animator.resume();
      },
      onDisable: function() {
        this._animator && this._animator.pause();
      },
      onDestroy: function() {
        this.stop();
      },
      getClips: function() {
        return this._clips;
      },
      play: function(name, startTime) {
        var state = this.playAdditive(name, startTime);
        this._animator.stopStatesExcept(state);
        return state;
      },
      playAdditive: function(name, startTime) {
        this._init();
        var state = this.getAnimationState(name || this._defaultClip && this._defaultClip.name);
        if (state) {
          this.enabled = true;
          var animator = this._animator;
          if (animator.isPlaying && state.isPlaying) if (state.isPaused) animator.resumeState(state); else {
            animator.stopState(state);
            animator.playState(state, startTime);
          } else animator.playState(state, startTime);
          this.enabledInHierarchy || animator.pause();
          this.currentClip = state.clip;
        }
        return state;
      },
      stop: function(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.stopState(state);
        } else this._animator.stop();
      },
      pause: function(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.pauseState(state);
        } else this.enabled = false;
      },
      resume: function(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.resumeState(state);
        } else this.enabled = true;
      },
      setCurrentTime: function(time, name) {
        this._init();
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.setStateTime(state, time);
        } else this._animator.setStateTime(time);
      },
      getAnimationState: function(name) {
        this._init();
        var state = this._nameToState[name];
        false;
        state && !state.curveLoaded && this._animator._reloadClip(state);
        return state || null;
      },
      addClip: function(clip, newName) {
        if (!clip) {
          cc.warnID(3900);
          return;
        }
        this._init();
        cc.js.array.contains(this._clips, clip) || this._clips.push(clip);
        newName = newName || clip.name;
        var oldState = this._nameToState[newName];
        if (oldState) {
          if (oldState.clip === clip) return oldState;
          var index = this._clips.indexOf(oldState.clip);
          -1 !== index && this._clips.splice(index, 1);
        }
        var newState = new cc.AnimationState(clip, newName);
        this._nameToState[newName] = newState;
        return newState;
      },
      removeClip: function(clip, force) {
        if (!clip) {
          cc.warnID(3901);
          return;
        }
        this._init();
        var state;
        for (var name in this._nameToState) {
          state = this._nameToState[name];
          var stateClip = state.clip;
          if (stateClip === clip) break;
        }
        if (clip === this._defaultClip) {
          if (!force) {
            true;
            cc.warnID(3902);
            return;
          }
          this._defaultClip = null;
        }
        if (state && state.isPlaying) {
          if (!force) {
            true;
            cc.warnID(3903);
            return;
          }
          this.stop(state.name);
        }
        this._clips = this._clips.filter((function(item) {
          return item !== clip;
        }));
        state && delete this._nameToState[state.name];
      },
      sample: function(name) {
        this._init();
        if (name) {
          var state = this._nameToState[name];
          state && state.sample();
        } else this._animator.sample();
      },
      on: function(type, callback, target, useCapture) {
        this._init();
        var ret = this._EventTargetOn(type, callback, target, useCapture);
        var array = this._animator._anims.array;
        for (var i = 0; i < array.length; ++i) array[i]._setListeners(this);
        return ret;
      },
      off: function(type, callback, target, useCapture) {
        this._init();
        this._EventTargetOff(type, callback, target, useCapture);
        var nameToState = this._nameToState;
        for (var name in nameToState) {
          var state = nameToState[name];
          state._setListeners(null);
        }
      },
      _init: function() {
        if (this._didInit) return;
        this._didInit = true;
        this._animator = new AnimationAnimator(this.node, this);
        this._createStates();
      },
      _createStates: function() {
        this._nameToState = js.createMap(true);
        var state = null;
        var defaultClipState = false;
        for (var i = 0; i < this._clips.length; ++i) {
          var clip = this._clips[i];
          if (clip) {
            state = new cc.AnimationState(clip);
            false;
            this._nameToState[state.name] = state;
            equalClips(this._defaultClip, clip) && (defaultClipState = state);
          }
        }
        if (this._defaultClip && !defaultClipState) {
          state = new cc.AnimationState(this._defaultClip);
          false;
          this._nameToState[state.name] = state;
        }
      }
    });
    cc.Animation = module.exports = Animation;
  }), {
    "../../animation/animation-animator": 11,
    "../../animation/animation-clip": 12,
    "../platform/js": 175,
    "./CCComponent": 67
  } ],
  63: [ (function(require, module, exports) {
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var Audio = require("../../audio/CCAudio");
    var AudioClip = require("../assets/CCAudioClip");
    var AudioSource = cc.Class({
      name: "cc.AudioSource",
      extends: Component,
      editor: false,
      ctor: function() {
        this.audio = new Audio();
      },
      properties: {
        _clip: {
          default: null,
          type: AudioClip
        },
        _volume: 1,
        _mute: false,
        _loop: false,
        _pausedFlag: {
          default: false,
          serializable: false
        },
        isPlaying: {
          get: function() {
            var state = this.audio.getState();
            return state === cc.Audio.State.PLAYING;
          },
          visible: false
        },
        clip: {
          get: function() {
            return this._clip;
          },
          set: function(value) {
            var _this = this;
            if ("string" === typeof value) {
              var _ret = (function() {
                cc.warnID(8401, "cc.AudioSource", "cc.AudioClip", "AudioClip", "cc.AudioClip", "audio");
                var self = _this;
                AudioClip._loadByUrl(value, (function(err, clip) {
                  clip && (self.clip = clip);
                }));
                return {
                  v: void 0
                };
              })();
              if ("object" === typeof _ret) return _ret.v;
            }
            if (value === this._clip) return;
            this._clip = value;
            this.audio.stop();
            this.preload && (this.audio.src = this._clip);
          },
          type: AudioClip,
          tooltip: false,
          animatable: false
        },
        volume: {
          get: function() {
            return this._volume;
          },
          set: function(value) {
            value = misc.clamp01(value);
            this._volume = value;
            this._mute || this.audio.setVolume(value);
            return value;
          },
          tooltip: false
        },
        mute: {
          get: function() {
            return this._mute;
          },
          set: function(value) {
            this._mute = value;
            this.audio.setVolume(value ? 0 : this._volume);
            return value;
          },
          animatable: false,
          tooltip: false
        },
        loop: {
          get: function() {
            return this._loop;
          },
          set: function(value) {
            this._loop = value;
            this.audio.setLoop(value);
            return value;
          },
          animatable: false,
          tooltip: false
        },
        playOnLoad: {
          default: false,
          tooltip: false,
          animatable: false
        },
        preload: {
          default: false,
          animatable: false
        }
      },
      _ensureDataLoaded: function() {
        this.audio.src !== this._clip && (this.audio.src = this._clip);
      },
      _pausedCallback: function() {
        var audio = this.audio;
        if (audio.paused) return;
        this.audio.pause();
        this._pausedFlag = true;
      },
      _restoreCallback: function() {
        this._pausedFlag && this.audio.resume();
        this._pausedFlag = false;
      },
      onLoad: function() {
        this.audio.setVolume(this._mute ? 0 : this._volume);
        this.audio.setLoop(this._loop);
      },
      onEnable: function() {
        this.preload && (this.audio.src = this._clip);
        this.playOnLoad && this.play();
        cc.game.on(cc.game.EVENT_HIDE, this._pausedCallback, this);
        cc.game.on(cc.game.EVENT_SHOW, this._restoreCallback, this);
      },
      onDisable: function() {
        this.stop();
        cc.game.off(cc.game.EVENT_HIDE, this._pausedCallback, this);
        cc.game.off(cc.game.EVENT_SHOW, this._restoreCallback, this);
      },
      onDestroy: function() {
        this.stop();
        this.audio.destroy();
        cc.audioEngine.uncache(this._clip);
      },
      play: function() {
        if (!this._clip) return;
        var audio = this.audio;
        this._clip.loaded && audio.stop();
        this._ensureDataLoaded();
        audio.setCurrentTime(0);
        audio.play();
      },
      stop: function() {
        this.audio.stop();
      },
      pause: function() {
        this.audio.pause();
      },
      resume: function() {
        this._ensureDataLoaded();
        this.audio.resume();
      },
      rewind: function() {
        this.audio.setCurrentTime(0);
      },
      getCurrentTime: function() {
        return this.audio.getCurrentTime();
      },
      setCurrentTime: function(time) {
        this.audio.setCurrentTime(time);
        return time;
      },
      getDuration: function() {
        return this.audio.getDuration();
      }
    });
    cc.AudioSource = module.exports = AudioSource;
  }), {
    "../../audio/CCAudio": 22,
    "../assets/CCAudioClip": 35,
    "../utils/misc": 233,
    "./CCComponent": 67
  } ],
  64: [ (function(require, module, exports) {
    var BlockEvents = [ "touchstart", "touchmove", "touchend", "mousedown", "mousemove", "mouseup", "mouseenter", "mouseleave", "mousewheel" ];
    function stopPropagation(event) {
      event.stopPropagation();
    }
    var BlockInputEvents = cc.Class({
      name: "cc.BlockInputEvents",
      extends: require("./CCComponent"),
      editor: {
        menu: "i18n:MAIN_MENU.component.ui/Block Input Events",
        inspector: "packages://inspector/inspectors/comps/block-input-events.js",
        help: "i18n:COMPONENT.help_url.block-input-events"
      },
      onEnable: function() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
      },
      onDisable: function() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
      }
    });
    cc.BlockInputEvents = module.exports = BlockInputEvents;
  }), {
    "./CCComponent": 67
  } ],
  65: [ (function(require, module, exports) {
    var Component = require("./CCComponent");
    var misc = require("../utils/misc");
    var Transition = cc.Enum({
      NONE: 0,
      COLOR: 1,
      SPRITE: 2,
      SCALE: 3
    });
    var Button = cc.Class({
      name: "cc.Button",
      extends: Component,
      ctor: function() {
        this._resetState();
        this._fromColor = null;
        this._toColor = null;
        this._time = 0;
        this._transitionFinished = true;
        this._fromScale = 1;
        this._toScale = 1;
        this._originalScale = 1;
        this._sprite = null;
        false;
      },
      _resetState: function() {
        this._pressed = false;
        this._hovered = false;
      },
      editor: false,
      properties: {
        interactable: {
          default: true,
          tooltip: false,
          notify: function(oldValue) {
            false;
            this._updateState();
            this.interactable || this._resetState();
          },
          animatable: false
        },
        _resizeToTarget: {
          animatable: false,
          set: function(value) {
            value && this._resizeNodeToTargetNode();
          }
        },
        enableAutoGrayEffect: {
          default: false,
          tooltip: false,
          notify: function() {
            this._updateDisabledState();
          }
        },
        transition: {
          default: Transition.NONE,
          tooltip: false,
          type: Transition,
          animatable: false
        },
        normalColor: {
          default: cc.color(214, 214, 214),
          displayName: "Normal",
          tooltip: false,
          notify: function() {
            this._updateState();
          }
        },
        pressedColor: {
          default: cc.color(211, 211, 211),
          displayName: "Pressed",
          tooltip: false
        },
        hoverColor: {
          default: cc.Color.WHITE,
          displayName: "Hover",
          tooltip: false
        },
        disabledColor: {
          default: cc.color(124, 124, 124),
          displayName: "Disabled",
          tooltip: false,
          notify: function() {
            this._updateState();
          }
        },
        duration: {
          default: .1,
          range: [ 0, 10 ],
          tooltip: false
        },
        zoomScale: {
          default: 1.2,
          tooltip: false
        },
        normalSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Normal",
          tooltip: false,
          notify: function() {
            this._updateState();
          }
        },
        pressedSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Pressed",
          tooltip: false,
          formerlySerializedAs: "pressedSprite",
          notify: function() {
            this._updateState();
          }
        },
        hoverSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Hover",
          tooltip: false,
          formerlySerializedAs: "hoverSprite",
          notify: function() {
            this._updateState();
          }
        },
        disabledSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Disabled",
          tooltip: false,
          notify: function() {
            this._updateState();
          }
        },
        target: {
          default: null,
          type: cc.Node,
          tooltip: false,
          notify: function() {
            this._applyTarget();
          }
        },
        clickEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        }
      },
      statics: {
        Transition: Transition
      },
      __preload: function() {
        this.target || (this.target = this.node);
        this._applyTarget();
        this._updateState();
      },
      onEnable: function() {
        this.normalSprite && this.normalSprite.ensureLoadTexture();
        this.hoverSprite && this.hoverSprite.ensureLoadTexture();
        this.pressedSprite && this.pressedSprite.ensureLoadTexture();
        this.disabledSprite && this.disabledSprite.ensureLoadTexture();
        true;
        this._registerEvent();
      },
      update: function(dt) {
        var target = this.target;
        if (this._transitionFinished) return;
        if (this.transition !== Transition.COLOR && this.transition !== Transition.SCALE) return;
        this.time += dt;
        var ratio = 1;
        this.duration > 0 && (ratio = this.time / this.duration);
        if (ratio >= 1) {
          ratio = 1;
          this._transitionFinished = true;
        }
        this.transition === Transition.COLOR ? target.color = this._fromColor.lerp(this._toColor, ratio) : this.transition === Transition.SCALE && (target.scale = misc.lerp(this._fromScale, this._toScale, ratio));
      },
      _registerEvent: function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.on(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _getTargetSprite: function(target) {
        var sprite = null;
        target && (sprite = target.getComponent(cc.Sprite));
        return sprite;
      },
      _applyTarget: function() {
        this._sprite = this._getTargetSprite(this.target);
        this.target && (this._originalScale = this.target.scale);
      },
      _onTouchBegan: function(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = true;
        this._updateState();
        event.stopPropagation();
      },
      _onTouchMove: function(event) {
        if (!this.interactable || !this.enabledInHierarchy || !this._pressed) return;
        var touch = event.touch;
        var hit = this.node._hitTest(touch.getLocation());
        if (this.transition === Transition.SCALE && this.target) if (hit) {
          this._fromScale = this._originalScale;
          this._toScale = this._originalScale * this.zoomScale;
          this._transitionFinished = false;
        } else {
          this.time = 0;
          this._transitionFinished = true;
          this.target.scale = this._originalScale;
        } else {
          var state;
          state = hit ? "pressed" : "normal";
          this._applyTransition(state);
        }
        event.stopPropagation();
      },
      _onTouchEnded: function(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        if (this._pressed) {
          cc.Component.EventHandler.emitEvents(this.clickEvents, event);
          this.node.emit("click", this);
        }
        this._pressed = false;
        this._updateState();
        event.stopPropagation();
      },
      _zoomUp: function() {
        this._fromScale = this._originalScale;
        this._toScale = this._originalScale * this.zoomScale;
        this.time = 0;
        this._transitionFinished = false;
      },
      _zoomBack: function() {
        this._fromScale = this.target.scale;
        this._toScale = this._originalScale;
        this.time = 0;
        this._transitionFinished = false;
      },
      _onTouchCancel: function() {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = false;
        this._updateState();
      },
      _onMouseMoveIn: function() {
        if (this._pressed || !this.interactable || !this.enabledInHierarchy) return;
        if (this.transition === Transition.SPRITE && !this.hoverSprite) return;
        if (!this._hovered) {
          this._hovered = true;
          this._updateState();
        }
      },
      _onMouseMoveOut: function() {
        if (this._hovered) {
          this._hovered = false;
          this._updateState();
        }
      },
      _updateState: function() {
        var state = this._getButtonState();
        this._applyTransition(state);
        this._updateDisabledState();
      },
      onDisable: function() {
        this._hovered = false;
        this._pressed = false;
        true;
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.off(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.off(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _getButtonState: function() {
        var state;
        state = this.interactable ? this._pressed ? "pressed" : this._hovered ? "hover" : "normal" : "disabled";
        return state;
      },
      _updateColorTransition: function(state) {
        var color = this[state + "Color"];
        var target = this.target;
        false;
        this._fromColor = target.color.clone();
        this._toColor = color;
        this.time = 0;
        this._transitionFinished = false;
      },
      _updateSpriteTransition: function(state) {
        var sprite = this[state + "Sprite"];
        this._sprite && sprite && (this._sprite.spriteFrame = sprite);
      },
      _updateScaleTransition: function(state) {
        "pressed" === state ? this._zoomUp() : this._zoomBack();
      },
      _applyTransition: function(state) {
        var transition = this.transition;
        transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
      },
      _resizeNodeToTargetNode: false,
      _updateDisabledState: function() {
        this._sprite && this._sprite.setState(cc.Sprite.State.NORMAL);
        this.enableAutoGrayEffect && this.transition !== Transition.COLOR && (this.transition === Transition.SPRITE && this.disabledSprite || this._sprite && !this.interactable && this._sprite.setState(cc.Sprite.State.GRAY));
      }
    });
    cc.Button = module.exports = Button;
  }), {
    "../utils/misc": 233,
    "./CCComponent": 67
  } ],
  66: [ (function(require, module, exports) {
    var eventManager = require("../event-manager");
    var Camera = require("../camera/CCCamera");
    var Component = require("./CCComponent");
    var Canvas = cc.Class({
      name: "cc.Canvas",
      extends: Component,
      editor: false,
      resetInEditor: false,
      statics: {
        instance: null
      },
      properties: {
        _designResolution: cc.size(960, 640),
        designResolution: {
          get: function() {
            return cc.size(this._designResolution);
          },
          set: function(value) {
            this._designResolution.width = value.width;
            this._designResolution.height = value.height;
            this.applySettings();
          },
          tooltip: false
        },
        _fitWidth: false,
        _fitHeight: true,
        fitHeight: {
          get: function() {
            return this._fitHeight;
          },
          set: function(value) {
            if (this._fitHeight !== value) {
              this._fitHeight = value;
              this.applySettings();
            }
          },
          tooltip: false
        },
        fitWidth: {
          get: function() {
            return this._fitWidth;
          },
          set: function(value) {
            if (this._fitWidth !== value) {
              this._fitWidth = value;
              this.applySettings();
            }
          },
          tooltip: false
        }
      },
      ctor: function() {
        this._thisOnResized = this.onResized.bind(this);
      },
      __preload: function() {
        var Flags;
        false;
        if (Canvas.instance) return cc.errorID(6700, this.node.name, Canvas.instance.node.name);
        Canvas.instance = this;
        cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.alignWithScreen, this);
        false;
        cc.sys.isMobile ? window.addEventListener("resize", this._thisOnResized) : eventManager.addCustomListener("canvas-resize", this._thisOnResized);
        this.applySettings();
        this.onResized();
        var cameraNode = cc.find("Main Camera", this.node);
        if (!cameraNode) {
          cameraNode = new cc.Node("Main Camera");
          cameraNode.parent = this.node;
          cameraNode.setSiblingIndex(0);
        }
        var camera = cameraNode.getComponent(Camera);
        if (!camera) {
          camera = cameraNode.addComponent(Camera);
          var ClearFlags = Camera.ClearFlags;
          camera.clearFlags = ClearFlags.COLOR | ClearFlags.DEPTH;
          camera.depth = -1;
        }
        Camera.main = camera;
      },
      onDestroy: function() {
        cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.alignWithScreen, this);
        false;
        cc.sys.isMobile ? window.removeEventListener("resize", this._thisOnResized) : eventManager.removeCustomListeners("canvas-resize", this._thisOnResized);
        Canvas.instance === this && (Canvas.instance = null);
      },
      alignWithScreen: function() {
        var designSize, nodeSize;
        false;
        var canvasSize = nodeSize = cc.visibleRect;
        designSize = cc.view.getDesignResolutionSize();
        var clipTopRight = !this.fitHeight && !this.fitWidth;
        var offsetX = 0;
        var offsetY = 0;
        if (clipTopRight) {
          offsetX = .5 * (designSize.width - canvasSize.width);
          offsetY = .5 * (designSize.height - canvasSize.height);
        }
        this.node.setPosition(.5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY);
        this.node.width = nodeSize.width;
        this.node.height = nodeSize.height;
      },
      onResized: function() {
        this.alignWithScreen();
      },
      applySettings: function() {
        var ResolutionPolicy = cc.ResolutionPolicy;
        var policy;
        policy = this.fitHeight && this.fitWidth ? ResolutionPolicy.SHOW_ALL : this.fitHeight || this.fitWidth ? this.fitWidth ? ResolutionPolicy.FIXED_WIDTH : ResolutionPolicy.FIXED_HEIGHT : ResolutionPolicy.NO_BORDER;
        var designRes = this._designResolution;
        false;
        cc.view.setDesignResolutionSize(designRes.width, designRes.height, policy);
      }
    });
    cc.Canvas = module.exports = Canvas;
  }), {
    "../camera/CCCamera": 52,
    "../event-manager": 98,
    "./CCComponent": 67
  } ],
  67: [ (function(require, module, exports) {
    var CCObject = require("../platform/CCObject");
    var js = require("../platform/js");
    var idGenerater = new (require("../platform/id-generater"))("Comp");
    var IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
    var IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
    var Component = cc.Class({
      name: "cc.Component",
      extends: CCObject,
      ctor: function() {
        this._id = idGenerater.getNewId();
        this.__eventTargets = [];
      },
      properties: {
        node: {
          default: null,
          visible: false
        },
        name: {
          get: function() {
            if (this._name) return this._name;
            var className = cc.js.getClassName(this);
            var trimLeft = className.lastIndexOf(".");
            trimLeft >= 0 && (className = className.slice(trimLeft + 1));
            return this.node.name + "<" + className + ">";
          },
          set: function(value) {
            this._name = value;
          },
          visible: false
        },
        uuid: {
          get: function() {
            return this._id;
          },
          visible: false
        },
        __scriptAsset: false,
        _enabled: true,
        enabled: {
          get: function() {
            return this._enabled;
          },
          set: function(value) {
            if (this._enabled !== value) {
              this._enabled = value;
              if (this.node._activeInHierarchy) {
                var compScheduler = cc.director._compScheduler;
                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
              }
            }
          },
          visible: false
        },
        enabledInHierarchy: {
          get: function() {
            return (this._objFlags & IsOnEnableCalled) > 0;
          },
          visible: false
        },
        _isOnLoadCalled: {
          get: function() {
            return this._objFlags & IsOnLoadCalled;
          }
        }
      },
      update: null,
      lateUpdate: null,
      __preload: null,
      onLoad: null,
      start: null,
      onEnable: null,
      onDisable: null,
      onDestroy: null,
      onFocusInEditor: null,
      onLostFocusInEditor: null,
      resetInEditor: null,
      addComponent: function(typeOrClassName) {
        return this.node.addComponent(typeOrClassName);
      },
      getComponent: function(typeOrClassName) {
        return this.node.getComponent(typeOrClassName);
      },
      getComponents: function(typeOrClassName) {
        return this.node.getComponents(typeOrClassName);
      },
      getComponentInChildren: function(typeOrClassName) {
        return this.node.getComponentInChildren(typeOrClassName);
      },
      getComponentsInChildren: function(typeOrClassName) {
        return this.node.getComponentsInChildren(typeOrClassName);
      },
      _getLocalBounds: null,
      onRestore: null,
      destroy: function() {
        var depend;
        false;
        this._super() && this._enabled && this.node._activeInHierarchy && cc.director._compScheduler.disableComp(this);
      },
      _onPreDestroy: function() {
        this.unscheduleAllCallbacks();
        var eventTargets = this.__eventTargets;
        for (var i = 0, l = eventTargets.length; i < l; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        false;
        cc.director._nodeActivator.destroyComp(this);
        this.node._removeComponent(this);
      },
      _instantiate: function(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        cloned.node = null;
        return cloned;
      },
      schedule: function(callback, interval, repeat, delay) {
        cc.assertID(callback, 1619);
        cc.assertID(interval >= 0, 1620);
        interval = interval || 0;
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        var scheduler = cc.director.getScheduler();
        var paused = scheduler.isTargetPaused(this);
        scheduler.schedule(callback, this, interval, repeat, delay, paused);
      },
      scheduleOnce: function(callback, delay) {
        this.schedule(callback, 0, 0, delay);
      },
      unschedule: function(callback_fn) {
        if (!callback_fn) return;
        cc.director.getScheduler().unschedule(callback_fn, this);
      },
      unscheduleAllCallbacks: function() {
        cc.director.getScheduler().unscheduleAllForTarget(this);
      }
    });
    Component._requireComponent = null;
    Component._executionOrder = 0;
    false, false;
    js.value(Component, "_registerEditorProps", (function(cls, props) {
      var reqComp = props.requireComponent;
      reqComp && (cls._requireComponent = reqComp);
      var order = props.executionOrder;
      order && "number" === typeof order && (cls._executionOrder = order);
      var name;
      var key;
      var val;
      var willExecuteInEditMode;
      false, false;
    }));
    Component.prototype.__scriptUuid = "";
    cc.Component = module.exports = Component;
  }), {
    "../platform/CCObject": 161,
    "../platform/id-generater": 171,
    "../platform/js": 175
  } ],
  68: [ (function(require, module, exports) {
    cc.Component.EventHandler = cc.Class({
      name: "cc.ClickEvent",
      properties: {
        target: {
          default: null,
          type: cc.Node
        },
        component: {
          default: ""
        },
        handler: {
          default: ""
        },
        customEventData: {
          default: ""
        }
      },
      statics: {
        emitEvents: function(events) {
          "use strict";
          var args = void 0;
          if (arguments.length > 0) {
            args = new Array(arguments.length - 1);
            for (var i = 0, l = args.length; i < l; i++) args[i] = arguments[i + 1];
          }
          for (var _i = 0, _l = events.length; _i < _l; _i++) {
            var event = events[_i];
            if (!(event instanceof cc.Component.EventHandler)) continue;
            event.emit(args);
          }
        }
      },
      emit: function(params) {
        var target = this.target;
        if (!cc.isValid(target)) return;
        var comp = target.getComponent(this.component);
        if (!cc.isValid(comp)) return;
        var handler = comp[this.handler];
        if ("function" !== typeof handler) return;
        if (null != this.customEventData && "" !== this.customEventData) {
          params = params.slice();
          params.push(this.customEventData);
        }
        handler.apply(comp, params);
      }
    });
  }), {} ],
  69: [ (function(require, module, exports) {
    var macro = require("../platform/CCMacro");
    var RenderComponent = require("./CCRenderComponent");
    var renderer = require("../renderer");
    var renderEngine = require("../renderer/render-engine");
    var RenderFlow = require("../renderer/render-flow");
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var HorizontalAlign = macro.TextAlignment;
    var VerticalAlign = macro.VerticalTextAlignment;
    var Overflow = cc.Enum({
      NONE: 0,
      CLAMP: 1,
      SHRINK: 2,
      RESIZE_HEIGHT: 3
    });
    function debounce(func, wait, immediate) {
      var timeout = void 0;
      return function() {
        var context = this;
        var later = function() {
          timeout = null;
          immediate || func.apply(context, arguments);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        callNow && func.apply(context, arguments);
      };
    }
    var Label = cc.Class({
      name: "cc.Label",
      extends: RenderComponent,
      ctor: function() {
        false;
        this._actualFontSize = 0;
        this._assemblerData = null;
      },
      editor: false,
      properties: {
        _useOriginalSize: true,
        _string: {
          default: "",
          formerlySerializedAs: "_N$string"
        },
        string: {
          get: function() {
            return this._string;
          },
          set: function(value) {
            var oldValue = this._string;
            this._string = value.toString();
            this.string !== oldValue && this._updateRenderData();
            this._checkStringEmpty();
          },
          multiline: true,
          tooltip: false
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: false,
          notify: function(oldValue) {
            if (this.horizontalAlign === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        verticalAlign: {
          default: VerticalAlign.TOP,
          type: VerticalAlign,
          tooltip: false,
          notify: function(oldValue) {
            if (this.verticalAlign === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        actualFontSize: {
          displayName: "Actual Font Size",
          animatable: false,
          readonly: true,
          get: function() {
            return this._actualFontSize;
          }
        },
        _fontSize: 40,
        fontSize: {
          get: function() {
            return this._fontSize;
          },
          set: function(value) {
            if (this._fontSize === value) return;
            this._fontSize = value;
            this._updateRenderData();
          },
          tooltip: false
        },
        fontFamily: {
          default: "Arial",
          tooltip: false,
          notify: function(oldValue) {
            if (this.fontFamily === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        _lineHeight: 40,
        lineHeight: {
          get: function() {
            return this._lineHeight;
          },
          set: function(value) {
            if (this._lineHeight === value) return;
            this._lineHeight = value;
            this._updateRenderData();
          },
          tooltip: false
        },
        overflow: {
          default: Overflow.NONE,
          type: Overflow,
          tooltip: false,
          notify: function(oldValue) {
            if (this.overflow === oldValue) return;
            this._updateRenderData();
          },
          animatable: false
        },
        _enableWrapText: true,
        enableWrapText: {
          get: function() {
            return this._enableWrapText;
          },
          set: function(value) {
            if (this._enableWrapText === value) return;
            this._enableWrapText = value;
            this._updateRenderData();
          },
          animatable: false,
          tooltip: false
        },
        _N$file: null,
        font: {
          get: function() {
            return this._N$file;
          },
          set: function(value) {
            if (this.font === value) return;
            value || (this._isSystemFontUsed = true);
            false;
            this._N$file = value;
            this._bmFontOriginalSize = -1;
            value && this._isSystemFontUsed && (this._isSystemFontUsed = false);
            "string" === typeof value && cc.warnID(4e3);
            value instanceof cc.BitmapFont && (this._bmFontOriginalSize = value.fontSize);
            if (this._renderData) {
              this.destroyRenderData(this._renderData);
              this._renderData = null;
            }
            this._fontAtlas = null;
            this._updateAssembler();
            this._activateMaterial(true);
            this._updateRenderData();
          },
          type: cc.Font,
          tooltip: false,
          animatable: false
        },
        _isSystemFontUsed: true,
        useSystemFont: {
          get: function() {
            return this._isSystemFontUsed;
          },
          set: function(value) {
            if (this._isSystemFontUsed === value) return;
            this.destroyRenderData(this._renderData);
            this._renderData = null;
            false;
            this._isSystemFontUsed = !!value;
            value && (this.font = null);
          },
          animatable: false,
          tooltip: false
        },
        _bmFontOriginalSize: {
          displayName: "BMFont Original Size",
          default: -1,
          serializable: false,
          readonly: true,
          visible: true,
          animatable: false
        },
        _spacingX: 0,
        spacingX: {
          get: function() {
            return this._spacingX;
          },
          set: function(value) {
            this._spacingX = value;
            this._updateRenderData();
          }
        },
        _isBold: {
          default: false,
          serializable: false
        },
        _isItalic: {
          default: false,
          serializable: false
        },
        _isUnderline: {
          default: false,
          serializable: false
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign,
        Overflow: Overflow
      },
      onEnable: function() {
        this._super();
        this.font || this._isSystemFontUsed || (this.useSystemFont = true);
        this._checkStringEmpty();
        this._updateAssembler();
        this._activateMaterial();
      },
      onDestroy: function() {
        this._assembler._resetAssemblerData && this._assembler._resetAssemblerData(this._assemblerData);
        this._assemblerData = null;
        this._super();
      },
      _checkStringEmpty: function() {
        this.markForRender(!!this.string);
      },
      _updateAssembler: function() {
        var assembler = Label._assembler.getAssembler(this);
        if (this._assembler !== assembler) {
          this._assembler = assembler;
          this._renderData = null;
        }
        this._renderData || (this._renderData = this._assembler.createData(this));
      },
      _activateMaterial: function(force) {
        var material = this._material;
        if (material) {
          if (!force) return;
        } else material = new SpriteMaterial();
        var font = this.font;
        if (font instanceof cc.BitmapFont) {
          var spriteFrame = font.spriteFrame;
          if (!spriteFrame.textureLoaded()) return;
          this._texture = spriteFrame._texture;
        } else {
          this._texture = new cc.Texture2D();
          this._assemblerData = this._assembler._getAssemblerData();
          this._texture.initWithElement(this._assemblerData.canvas);
        }
        material.texture = this._texture;
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS && (this._texture.url = this.uuid + "_texture");
        this.setMaterial(material);
      },
      _updateColor: function() {
        var font = this.font;
        if (font instanceof cc.BitmapFont) this._super(); else {
          this._updateRenderData();
          this.node._renderFlag &= ~RenderFlow.FLAG_COLOR;
        }
      },
      _updateRenderData: function(force) {
        var renderData = this._renderData;
        if (renderData) {
          renderData.vertDirty = true;
          renderData.uvDirty = true;
          this.markForUpdateRenderData(true);
        }
        if (false, force) {
          this._updateAssembler();
          this._activateMaterial(force);
          this._assembler.updateRenderData(this);
        }
      },
      _enableBold: function(enabled) {
        this._isBold = !!enabled;
      },
      _enableItalics: function(enabled) {
        this._isItalic = !!enabled;
      },
      _enableUnderline: function(enabled) {
        this._isUnderline = !!enabled;
      }
    });
    cc.Label = module.exports = Label;
  }), {
    "../platform/CCMacro": 160,
    "../renderer": 196,
    "../renderer/render-engine": 197,
    "../renderer/render-flow": 198,
    "./CCRenderComponent": 77
  } ],
  70: [ (function(require, module, exports) {
    var LabelOutline = cc.Class({
      name: "cc.LabelOutline",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _color: cc.color(255, 255, 255, 255),
        _width: 1,
        color: {
          get: function() {
            return this._color;
          },
          set: function(value) {
            this._color = cc.color(value);
            this._updateRenderData();
          }
        },
        width: {
          get: function() {
            return this._width;
          },
          set: function(value) {
            this._width = value;
            this._updateRenderData();
          }
        }
      },
      _updateRenderData: function() {
        var label = this.node.getComponent(cc.Label);
        label && label._updateRenderData(true);
      }
    });
    cc.LabelOutline = module.exports = LabelOutline;
  }), {
    "./CCComponent": 67
  } ],
  71: [ (function(require, module, exports) {
    var NodeEvent = require("../CCNode").EventType;
    var Type = cc.Enum({
      NONE: 0,
      HORIZONTAL: 1,
      VERTICAL: 2,
      GRID: 3
    });
    var ResizeMode = cc.Enum({
      NONE: 0,
      CONTAINER: 1,
      CHILDREN: 2
    });
    var AxisDirection = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var VerticalDirection = cc.Enum({
      BOTTOM_TO_TOP: 0,
      TOP_TO_BOTTOM: 1
    });
    var HorizontalDirection = cc.Enum({
      LEFT_TO_RIGHT: 0,
      RIGHT_TO_LEFT: 1
    });
    var Layout = cc.Class({
      name: "cc.Layout",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layoutSize: cc.size(300, 200),
        _layoutDirty: {
          default: true,
          serializable: false
        },
        _resize: ResizeMode.NONE,
        _N$layoutType: Type.NONE,
        type: {
          type: Type,
          get: function() {
            return this._N$layoutType;
          },
          set: function(value) {
            this._N$layoutType = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        },
        resizeMode: {
          type: ResizeMode,
          tooltip: false,
          animatable: false,
          get: function() {
            return this._resize;
          },
          set: function(value) {
            if (this.type === Type.NONE && value === ResizeMode.CHILDREN) return;
            this._resize = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          }
        },
        cellSize: {
          default: cc.size(40, 40),
          tooltip: false,
          type: cc.Size,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        startAxis: {
          default: AxisDirection.HORIZONTAL,
          tooltip: false,
          type: AxisDirection,
          notify: function() {
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          animatable: false
        },
        _N$padding: {
          default: 0
        },
        paddingLeft: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingRight: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingTop: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        paddingBottom: {
          default: 0,
          tooltip: false,
          notify: function() {
            this._doLayoutDirty();
          }
        },
        spacingX: {
          default: 0,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false
        },
        spacingY: {
          default: 0,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false
        },
        verticalDirection: {
          default: VerticalDirection.TOP_TO_BOTTOM,
          type: VerticalDirection,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        },
        horizontalDirection: {
          default: HorizontalDirection.LEFT_TO_RIGHT,
          type: HorizontalDirection,
          notify: function() {
            this._doLayoutDirty();
          },
          tooltip: false,
          animatable: false
        }
      },
      statics: {
        Type: Type,
        VerticalDirection: VerticalDirection,
        HorizontalDirection: HorizontalDirection,
        ResizeMode: ResizeMode,
        AxisDirection: AxisDirection
      },
      _migratePaddingData: function() {
        this.paddingLeft = this._N$padding;
        this.paddingRight = this._N$padding;
        this.paddingTop = this._N$padding;
        this.paddingBottom = this._N$padding;
        this._N$padding = 0;
      },
      onEnable: function() {
        this._addEventListeners();
        this.node.getContentSize().equals(cc.size(0, 0)) && this.node.setContentSize(this._layoutSize);
        0 !== this._N$padding && this._migratePaddingData();
        this._doLayoutDirty();
      },
      onDisable: function() {
        this._removeEventListeners();
      },
      _doLayoutDirty: function() {
        this._layoutDirty = true;
      },
      _addEventListeners: function() {
        cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
        this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this);
        this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this);
        this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
        this.node.on(NodeEvent.CHILD_REORDER, this._doLayoutDirty, this);
        this._addChildrenEventListeners();
      },
      _removeEventListeners: function() {
        cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
        this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this);
        this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this);
        this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
        this.node.off(NodeEvent.CHILD_REORDER, this._doLayoutDirty, this);
        this._removeChildrenEventListeners();
      },
      _addChildrenEventListeners: function() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _removeChildrenEventListeners: function() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _childAdded: function(event) {
        var child = event.detail;
        child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
        child.on(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
        child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _childRemoved: function(event) {
        var child = event.detail;
        child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
        child.off(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
        child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _resized: function() {
        this._layoutSize = this.node.getContentSize();
        this._doLayoutDirty();
      },
      _doLayoutHorizontally: function(baseWidth, rowBreak, fnPositionY, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingX = this.paddingLeft;
        var leftBoundaryOfLayout = -layoutAnchor.x * baseWidth;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * baseWidth;
          paddingX = this.paddingRight;
        }
        var nextX = leftBoundaryOfLayout + sign * paddingX - sign * this.spacingX;
        var rowMaxHeight = 0;
        var tempMaxHeight = 0;
        var secondMaxHeight = 0;
        var row = 0;
        var containerResizeBoundary = 0;
        var maxHeightChildAnchorY = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildWidth = this.cellSize.width;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this.paddingLeft + this.paddingRight) - (activeChildCount - 1) * this.spacingX) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          if (!child.activeInHierarchy) continue;
          if (this._resize === ResizeMode.CHILDREN) {
            child.width = newChildWidth / child.scaleX;
            this.type === Type.GRID && (child.height = this.cellSize.height / child.scaleY);
          }
          var anchorX = child.anchorX;
          var childBoundingBoxWidth = child.width * child.scaleX;
          var childBoundingBoxHeight = child.height * child.scaleY;
          secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight);
          if (childBoundingBoxHeight >= tempMaxHeight) {
            secondMaxHeight = tempMaxHeight;
            tempMaxHeight = childBoundingBoxHeight;
            maxHeightChildAnchorY = child.getAnchorPoint().y;
          }
          this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - child.anchorX);
          nextX = nextX + sign * anchorX * childBoundingBoxWidth + sign * this.spacingX;
          var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
          if (rowBreak) {
            var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this.paddingRight : this.paddingLeft);
            var leftToRightRowBreak = this.horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth;
            var rightToLeftRowBreak = this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth;
            if (leftToRightRowBreak || rightToLeftRowBreak) {
              if (childBoundingBoxHeight >= tempMaxHeight) {
                0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight);
                rowMaxHeight += secondMaxHeight;
                secondMaxHeight = tempMaxHeight;
              } else {
                rowMaxHeight += tempMaxHeight;
                secondMaxHeight = childBoundingBoxHeight;
                tempMaxHeight = 0;
              }
              nextX = leftBoundaryOfLayout + sign * (paddingX + anchorX * child.width);
              row++;
            }
          }
          var finalPositionY = fnPositionY(child, rowMaxHeight, row);
          baseWidth >= child.width + this.paddingLeft + this.paddingRight && applyChildren && child.setPosition(cc.v2(nextX, finalPositionY));
          var signX = 1;
          var tempFinalPositionY;
          var topMarign = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.height;
            signX = -1;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingBottom);
            tempFinalPositionY < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.height;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingTop);
            tempFinalPositionY > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          }
          nextX += rightBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _getVerticalBaseHeight: function(children) {
        var newHeight = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newHeight += child.height * child.scaleY;
            }
          }
          newHeight += (activeChildCount - 1) * this.spacingY + this.paddingBottom + this.paddingTop;
        } else newHeight = this.node.getContentSize().height;
        return newHeight;
      },
      _doLayoutVertically: function(baseHeight, columnBreak, fnPositionX, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingY = this.paddingBottom;
        var bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight;
          paddingY = this.paddingTop;
        }
        var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this.spacingY;
        var columnMaxWidth = 0;
        var tempMaxWidth = 0;
        var secondMaxWidth = 0;
        var column = 0;
        var containerResizeBoundary = 0;
        var maxWidthChildAnchorX = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildHeight = this.cellSize.height;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this.paddingTop + this.paddingBottom) - (activeChildCount - 1) * this.spacingY) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          if (!child.activeInHierarchy) continue;
          if (this.resizeMode === ResizeMode.CHILDREN) {
            child.height = newChildHeight / child.scaleY;
            this.type === Type.GRID && (child.width = this.cellSize.width / child.scaleX);
          }
          var anchorY = child.anchorY;
          var childBoundingBoxWidth = child.width * child.scaleX;
          var childBoundingBoxHeight = child.height * child.scaleY;
          secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth);
          if (childBoundingBoxWidth >= tempMaxWidth) {
            secondMaxWidth = tempMaxWidth;
            tempMaxWidth = childBoundingBoxWidth;
            maxWidthChildAnchorX = child.getAnchorPoint().x;
          }
          this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - child.anchorY);
          nextY = nextY + sign * anchorY * childBoundingBoxHeight + sign * this.spacingY;
          var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
          if (columnBreak) {
            var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this.paddingTop : this.paddingBottom);
            var bottomToTopColumnBreak = this.verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight;
            var topToBottomColumnBreak = this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight;
            if (bottomToTopColumnBreak || topToBottomColumnBreak) {
              if (childBoundingBoxWidth >= tempMaxWidth) {
                0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth);
                columnMaxWidth += secondMaxWidth;
                secondMaxWidth = tempMaxWidth;
              } else {
                columnMaxWidth += tempMaxWidth;
                secondMaxWidth = childBoundingBoxWidth;
                tempMaxWidth = 0;
              }
              nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * childBoundingBoxHeight);
              column++;
            }
          }
          var finalPositionX = fnPositionX(child, columnMaxWidth, column);
          baseHeight >= childBoundingBoxHeight + (this.paddingTop + this.paddingBottom) && applyChildren && child.setPosition(cc.v2(finalPositionX, nextY));
          var signX = 1;
          var tempFinalPositionX;
          var rightMarign = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            signX = -1;
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingLeft);
            tempFinalPositionX < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingRight);
            tempFinalPositionX > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          }
          nextY += topBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _doLayoutBasic: function() {
        var children = this.node.children;
        var allChildrenBoundingBox = null;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && (allChildrenBoundingBox ? allChildrenBoundingBox.union(allChildrenBoundingBox, child.getBoundingBoxToWorld()) : allChildrenBoundingBox = child.getBoundingBoxToWorld());
        }
        if (allChildrenBoundingBox) {
          var leftBottomInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.v2(allChildrenBoundingBox.x, allChildrenBoundingBox.y));
          leftBottomInParentSpace = cc.v2(leftBottomInParentSpace.x - this.paddingLeft, leftBottomInParentSpace.y - this.paddingBottom);
          var rightTopInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.v2(allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height));
          rightTopInParentSpace = cc.v2(rightTopInParentSpace.x + this.paddingRight, rightTopInParentSpace.y + this.paddingTop);
          var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
          var layoutPosition = this.node.getPosition();
          var newAnchorX = (layoutPosition.x - leftBottomInParentSpace.x) / newSize.width;
          var newAnchorY = (layoutPosition.y - leftBottomInParentSpace.y) / newSize.height;
          var newAnchor = cc.v2(parseFloat(newAnchorX.toFixed(2)), parseFloat(newAnchorY.toFixed(2)));
          this.node.setAnchorPoint(newAnchor);
          this.node.setContentSize(newSize);
        }
      },
      _doLayoutGridAxisHorizontal: function(layoutAnchor, layoutSize) {
        var baseWidth = layoutSize.width;
        var sign = 1;
        var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
        var paddingY = this.paddingBottom;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
          paddingY = this.paddingTop;
        }
        var fnPositionY = function(child, topOffset, row) {
          return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height * child.scaleY + paddingY + row * this.spacingY);
        }.bind(this);
        var newHeight = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
          newHeight = bottomBoundaryOfLayout - boundary;
          newHeight < 0 && (newHeight *= -1);
          bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
          }
        }
        this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
      },
      _doLayoutGridAxisVertical: function(layoutAnchor, layoutSize) {
        var baseHeight = layoutSize.height;
        var sign = 1;
        var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
        var paddingX = this.paddingLeft;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
          paddingX = this.paddingRight;
        }
        var fnPositionX = function(child, leftOffset, column) {
          return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width * child.scaleX + paddingX + column * this.spacingX);
        }.bind(this);
        var newWidth = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
          newWidth = leftBoundaryOfLayout - boundary;
          newWidth < 0 && (newWidth *= -1);
          leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
          }
        }
        this._doLayoutVertically(baseHeight, true, fnPositionX, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
      },
      _doLayoutGrid: function() {
        var layoutAnchor = this.node.getAnchorPoint();
        var layoutSize = this.node.getContentSize();
        this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
      },
      _getHorizontalBaseWidth: function(children) {
        var newWidth = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newWidth += child.width * child.scaleX;
            }
          }
          newWidth += (activeChildCount - 1) * this.spacingX + this.paddingLeft + this.paddingRight;
        } else newWidth = this.node.getContentSize().width;
        return newWidth;
      },
      _doLayout: function() {
        if (this.type === Type.HORIZONTAL) {
          var newWidth = this._getHorizontalBaseWidth(this.node.children);
          var fnPositionY = function(child) {
            return child.y;
          };
          this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
          this.node.width = newWidth;
        } else if (this.type === Type.VERTICAL) {
          var newHeight = this._getVerticalBaseHeight(this.node.children);
          var fnPositionX = function(child) {
            return child.x;
          };
          this._doLayoutVertically(newHeight, false, fnPositionX, true);
          this.node.height = newHeight;
        } else this.type === Type.NONE ? this.resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this.type === Type.GRID && this._doLayoutGrid();
      },
      updateLayout: function() {
        if (this._layoutDirty && this.node.children.length > 0) {
          this._doLayout();
          this._layoutDirty = false;
        }
      }
    });
    Object.defineProperty(Layout.prototype, "padding", {
      get: function() {
        cc.warnID(4100);
        return this.paddingLeft;
      },
      set: function(value) {
        this._N$padding = value;
        this._migratePaddingData();
        this._doLayoutDirty();
      }
    });
    cc.Layout = module.exports = Layout;
  }), {
    "../CCNode": 30,
    "./CCComponent": 67
  } ],
  72: [ (function(require, module, exports) {
    var misc = require("../utils/misc");
    var renderEngine = require("../renderer/render-engine");
    var gfx = renderEngine.gfx;
    var math = renderEngine.math;
    var StencilMaterial = renderEngine.StencilMaterial;
    var RenderComponent = require("./CCRenderComponent");
    var RenderFlow = require("../renderer/render-flow");
    var _mat4_temp = math.mat4.create();
    var _rect_temp = cc.rect();
    var MaskType = cc.Enum({
      RECT: 0,
      ELLIPSE: 1,
      IMAGE_STENCIL: 2
    });
    var SEGEMENTS_MIN = 3;
    var SEGEMENTS_MAX = 1e4;
    var Mask = cc.Class({
      name: "cc.Mask",
      extends: RenderComponent,
      editor: false,
      properties: {
        _spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        _type: MaskType.RECT,
        type: {
          get: function() {
            return this._type;
          },
          set: function(value) {
            this._type = value;
            if (this._type !== MaskType.IMAGE_STENCIL) {
              this.spriteFrame = null;
              this.alphaThreshold = 0;
            }
            if (this._renderData) {
              this.destroyRenderData(this._renderData);
              this._renderData = null;
            }
            this._activateMaterial();
          },
          type: MaskType,
          tooltip: false
        },
        spriteFrame: {
          type: cc.SpriteFrame,
          tooltip: false,
          get: function() {
            return this._spriteFrame;
          },
          set: function(value) {
            var lastSprite = this._spriteFrame;
            false;
            if (lastSprite === value) return;
            this._spriteFrame = value;
            this._applySpriteFrame(lastSprite);
          }
        },
        alphaThreshold: {
          default: 0,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: false,
          notify: function() {
            if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4201);
              return;
            }
            if (this._frontMaterial) {
              this._frontMaterial.alphaThreshold = this.alphaThreshold;
              this._endMaterial.alphaThreshold = this.alphaThreshold;
              this._frontMaterial.updateHash();
              this._endMaterial._hash = -this._frontMaterial._hash;
            }
          }
        },
        inverted: {
          default: false,
          type: cc.Boolean,
          tooltip: false,
          notify: function() {
            if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4202);
              return;
            }
          }
        },
        _segments: 64,
        segements: {
          get: function() {
            return this._segments;
          },
          set: function(value) {
            this._segments = misc.clampf(value, SEGEMENTS_MIN, SEGEMENTS_MAX);
          },
          tooltip: false
        },
        _resizeToTarget: {
          animatable: false,
          set: function(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      statics: {
        Type: MaskType
      },
      _resizeNodeToTargetNode: false,
      _onTextureLoaded: function(event) {
        if (this._renderData) {
          this._renderData.uvDirty = true;
          this._renderData.vertDirty = true;
          this.markForUpdateRenderData(true);
        }
        this.enabledInHierarchy && this._activateMaterial();
      },
      _applySpriteFrame: function(oldFrame) {
        oldFrame && oldFrame.off && oldFrame.off("load", this._onTextureLoaded, this);
        var spriteFrame = this._spriteFrame;
        if (spriteFrame) if (spriteFrame.textureLoaded()) this._onTextureLoaded(null); else {
          spriteFrame.once("load", this._onTextureLoaded, this);
          spriteFrame.ensureLoadTexture();
        }
      },
      _activateMaterial: function() {
        if (this._type === MaskType.IMAGE_STENCIL && (!this.spriteFrame || !this.spriteFrame.textureLoaded())) {
          this.markForRender(false);
          return;
        }
        if (!this._frontMaterial) {
          this._frontMaterial = new StencilMaterial();
          this._endMaterial = new StencilMaterial();
        }
        this._material || (this._material = this._frontMaterial);
        if (this._type === MaskType.IMAGE_STENCIL) {
          var texture = this.spriteFrame.getTexture();
          this._frontMaterial.useTexture = true;
          this._frontMaterial.useColor = true;
          this._frontMaterial.texture = texture;
          this._frontMaterial.alphaThreshold = this.alphaThreshold;
          this._endMaterial.useTexture = true;
          this._endMaterial.useColor = true;
          this._endMaterial.texture = texture;
          this._endMaterial.alphaThreshold = this.alphaThreshold;
        } else {
          this._frontMaterial.useTexture = false;
          this._frontMaterial.useColor = false;
          this._endMaterial.useTexture = false;
          this._endMaterial.useColor = false;
        }
        this._frontMaterial.updateHash();
        this._endMaterial._hash = -this._frontMaterial._hash;
        this.markForRender(true);
      },
      _hitTest: function(point) {
        var node = this.node;
        var size = node.getContentSize(), w = size.width, h = size.height;
        node.getWorldMatrix(_mat4_temp);
        if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) {
          _rect_temp.x = -node.anchorX * w, _rect_temp.y = -node.anchorX * h;
          _rect_temp.width = w;
          _rect_temp.height = h;
          _rect_temp.transformMat4(_rect_temp, _mat4_temp);
          var left = point.x - _rect_temp.x, right = _rect_temp.x + _rect_temp.width - point.x, bottom = point.y - _rect_temp.y, top = _rect_temp.y + _rect_temp.height - point.y;
          return left >= 0 && right >= 0 && top >= 0 && bottom >= 0;
        }
        if (this.type === MaskType.ELLIPSE) {
          var rx = w / 2, ry = h / 2;
          var px = point.x - _mat4_temp.m12, py = point.y - _mat4_temp.m13;
          return px * px / (rx * rx) + py * py / (ry * ry) < 1;
        }
      },
      markForUpdateRenderData: function(enable) {
        enable && this.enabledInHierarchy ? this.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_UPDATE_RENDER_DATA : enable || (this.node._renderFlag &= ~(RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_UPDATE_RENDER_DATA));
      },
      markForRender: function(enable) {
        enable && this.enabledInHierarchy ? this.node._renderFlag |= RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_RENDER | RenderFlow.FLAG_POST_UPDATE_RENDER_DATA : enable || (this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_POST_RENDER));
      },
      disableRender: function() {
        this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_RENDER | RenderFlow.FLAG_POST_UPDATE_RENDER_DATA);
      },
      onEnable: function() {
        this._super();
        this._renderDatas = [];
        this._graphics = null;
        this.node._renderFlag |= RenderFlow.FLAG_POST_RENDER | RenderFlow.FLAG_POST_UPDATE_RENDER_DATA;
        this._activateMaterial();
      },
      onDisable: function() {
        this.node._renderFlag &= ~(RenderFlow.FLAG_POST_RENDER | RenderFlow.FLAG_POST_UPDATE_RENDER_DATA);
      },
      onDestroy: function() {
        this._super();
        this._renderDatas.length = 0;
        this._frontMaterial = null;
        this._endMaterial = null;
      }
    });
    cc.Mask = module.exports = Mask;
  }), {
    "../renderer/render-engine": 197,
    "../renderer/render-flow": 198,
    "../utils/misc": 233,
    "./CCRenderComponent": 77
  } ],
  73: [ (function(require, module, exports) {
    var RenderComponent = require("../components/CCRenderComponent");
    var renderer = require("../renderer");
    var renderEngine = require("../renderer/render-engine");
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var MotionStreak = cc.Class({
      name: "cc.MotionStreak",
      extends: RenderComponent,
      editor: false,
      ctor: function() {
        this._points = [];
      },
      properties: {
        preview: {
          default: false,
          editorOnly: true,
          notify: false,
          animatable: false
        },
        _fadeTime: 1,
        fadeTime: {
          get: function() {
            return this._fadeTime;
          },
          set: function(value) {
            this._fadeTime = value;
            this.reset();
          },
          animatable: false,
          tooltip: false
        },
        _minSeg: 1,
        minSeg: {
          get: function() {
            return this._minSeg;
          },
          set: function(value) {
            this._minSeg = value;
          },
          animatable: false,
          tooltip: false
        },
        _stroke: 64,
        stroke: {
          get: function() {
            return this._stroke;
          },
          set: function(value) {
            this._stroke = value;
          },
          animatable: false,
          tooltip: false
        },
        _texture: {
          default: null,
          type: cc.Texture2D
        },
        texture: {
          get: function() {
            return this._texture;
          },
          set: function(value) {
            if (this._texture === value) return;
            this._texture = value;
            if (value) {
              this.markForRender(true);
              this.markForUpdateRenderData(true);
              this._activateMaterial(true);
            } else this.disableRender();
          },
          type: cc.Texture2D,
          animatable: false,
          tooltip: false
        },
        _color: cc.Color.WHITE,
        color: {
          get: function() {
            return this._color;
          },
          set: function(value) {
            this._color = value;
          },
          tooltip: false
        },
        _fastMode: false,
        fastMode: {
          get: function() {
            return this._fastMode;
          },
          set: function(value) {
            this._fastMode = value;
          },
          animatable: false,
          tooltip: false
        }
      },
      onEnable: function() {
        this._super();
        this._texture && this._texture.loaded ? this._activateMaterial() : this.disableRender();
        this.reset();
      },
      _activateMaterial: function(force) {
        var material = this._material;
        if (material) {
          if (!force) return;
        } else {
          material = this._material = new SpriteMaterial();
          material.useColor = false;
        }
        material.texture = this._texture;
        this.setMaterial(material);
      },
      onFocusInEditor: false,
      onLostFocusInEditor: false,
      reset: function() {
        this._points.length = 0;
        var renderData = this._renderData;
        if (renderData) {
          renderData.dataLength = 0;
          renderData.vertexCount = 0;
          renderData.indiceCount = 0;
        }
        false;
      }
    });
    cc.MotionStreak = module.exports = MotionStreak;
  }), {
    "../components/CCRenderComponent": 77,
    "../renderer": 196,
    "../renderer/render-engine": 197
  } ],
  74: [ (function(require, module, exports) {
    var SizeMode = cc.Enum({
      Unified: 0,
      Free: 1
    });
    var Direction = cc.Enum({
      Horizontal: 0,
      Vertical: 1
    });
    var EventType = cc.Enum({
      PAGE_TURNING: 0
    });
    var PageView = cc.Class({
      name: "cc.PageView",
      extends: cc.ScrollView,
      editor: false,
      ctor: function() {
        this._curPageIdx = 0;
        this._lastPageIdx = 0;
        this._pages = [];
        this._scrollCenterOffsetX = [];
        this._scrollCenterOffsetY = [];
      },
      properties: {
        sizeMode: {
          default: SizeMode.Unified,
          type: SizeMode,
          tooltip: false,
          notify: function() {
            this._syncSizeMode();
          }
        },
        direction: {
          default: Direction.Horizontal,
          type: Direction,
          tooltip: false,
          notify: function() {
            this._syncScrollDirection();
          }
        },
        scrollThreshold: {
          default: .5,
          type: cc.Float,
          slide: true,
          range: [ 0, 1, .01 ],
          tooltip: false
        },
        autoPageTurningThreshold: {
          default: 100,
          type: cc.Float,
          tooltip: false
        },
        pageTurningEventTiming: {
          default: .1,
          type: cc.Float,
          range: [ 0, 1, .01 ],
          tooltip: false
        },
        indicator: {
          default: null,
          type: cc.PageViewIndicator,
          tooltip: false,
          notify: function() {
            this.indicator && this.indicator.setPageView(this);
          }
        },
        pageTurningSpeed: {
          default: .3,
          type: cc.Float,
          tooltip: false
        },
        pageEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        }
      },
      statics: {
        SizeMode: SizeMode,
        Direction: Direction,
        EventType: EventType
      },
      __preload: function() {
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._updateAllPagesSize, this);
      },
      onEnable: function() {
        this._super();
        true;
        this.node.on("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
      },
      onDisable: function() {
        this._super();
        true;
        this.node.off("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
      },
      onLoad: function() {
        this._initPages();
        this.indicator && this.indicator.setPageView(this);
      },
      onDestroy: function() {
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this._updateAllPagesSize, this);
      },
      getCurrentPageIndex: function() {
        return this._curPageIdx;
      },
      setCurrentPageIndex: function(index) {
        this.scrollToPage(index, true);
      },
      getPages: function() {
        return this._pages;
      },
      addPage: function(page) {
        if (!page || -1 !== this._pages.indexOf(page) || !this.content) return;
        this.content.addChild(page);
        this._pages.push(page);
        this._updatePageView();
      },
      insertPage: function(page, index) {
        if (index < 0 || !page || -1 !== this._pages.indexOf(page) || !this.content) return;
        var pageCount = this._pages.length;
        if (index >= pageCount) this.addPage(page); else {
          this._pages.splice(index, 0, page);
          this.content.addChild(page);
          this._updatePageView();
        }
      },
      removePage: function(page) {
        if (!page || !this.content) return;
        var index = this._pages.indexOf(page);
        if (-1 === index) {
          cc.warnID(4300, page.name);
          return;
        }
        this.removePageAtIndex(index);
      },
      removePageAtIndex: function(index) {
        var pageList = this._pages;
        if (index < 0 || index >= pageList.length) return;
        var page = pageList[index];
        if (!page) return;
        this.content.removeChild(page);
        pageList.splice(index, 1);
        this._updatePageView();
      },
      removeAllPages: function() {
        if (!this.content) return;
        var locPages = this._pages;
        for (var i = 0, len = locPages.length; i < len; i++) this.content.removeChild(locPages[i]);
        this._pages.length = 0;
        this._updatePageView();
      },
      scrollToPage: function(idx, timeInSecond) {
        if (idx < 0 || idx >= this._pages.length) return;
        timeInSecond = void 0 !== timeInSecond ? timeInSecond : .3;
        this._curPageIdx = idx;
        this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);
        this.indicator && this.indicator._changedState();
      },
      getScrollEndedEventTiming: function() {
        return this.pageTurningEventTiming;
      },
      _syncScrollDirection: function() {
        this.horizontal = this.direction === Direction.Horizontal;
        this.vertical = this.direction === Direction.Vertical;
      },
      _syncSizeMode: function() {
        if (!this.content) return;
        var layout = this.content.getComponent(cc.Layout);
        if (layout) {
          if (0 === this._pages.length) layout.padding = 0; else {
            var lastPage = this._pages[this._pages.length - 1];
            if (this.sizeMode === SizeMode.Free) if (this.direction === Direction.Horizontal) {
              layout.paddingLeft = (this.node.width - this._pages[0].width) / 2;
              layout.paddingRight = (this.node.width - lastPage.width) / 2;
            } else if (this.direction === Direction.Vertical) {
              layout.paddingTop = (this.node.height - this._pages[0].height) / 2;
              layout.paddingBottom = (this.node.height - lastPage.height) / 2;
            }
          }
          layout.updateLayout();
        }
      },
      _updatePageView: function() {
        var pageCount = this._pages.length;
        if (this._curPageIdx >= pageCount) {
          this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1;
          this._lastPageIdx = this._curPageIdx;
        }
        for (var i = 0; i < pageCount; ++i) {
          this._pages[i].setSiblingIndex(i);
          this.direction === Direction.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(this.content.x + this._pages[i].x) : this._scrollCenterOffsetY[i] = Math.abs(this.content.y + this._pages[i].y);
        }
        var layout = this.content.getComponent(cc.Layout);
        layout && layout.enabled && layout.updateLayout();
        this.indicator && this.indicator._refresh();
      },
      _updateAllPagesSize: function() {
        if (this.sizeMode !== SizeMode.Unified) return;
        var locPages = this._pages;
        var selfSize = this.node.getContentSize();
        for (var i = 0, len = locPages.length; i < len; i++) locPages[i].setContentSize(selfSize);
      },
      _initPages: function() {
        if (!this.content) return;
        var children = this.content.children;
        for (var i = 0; i < children.length; ++i) {
          var page = children[i];
          if (this._pages.indexOf(page) >= 0) continue;
          this._pages.push(page);
        }
        this._syncScrollDirection();
        this._syncSizeMode();
        this._updatePageView();
      },
      _dispatchPageTurningEvent: function() {
        if (this._lastPageIdx === this._curPageIdx) return;
        this._lastPageIdx = this._curPageIdx;
        cc.Component.EventHandler.emitEvents(this.pageEvents, this, EventType.PAGE_TURNING);
        this.node.emit("page-turning", this);
      },
      _isScrollable: function(offset, index, nextIndex) {
        if (this.sizeMode === SizeMode.Free) {
          var curPageCenter, nextPageCenter;
          if (this.direction === Direction.Horizontal) {
            curPageCenter = this._scrollCenterOffsetX[index];
            nextPageCenter = this._scrollCenterOffsetX[nextIndex];
            return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
          }
          if (this.direction === Direction.Vertical) {
            curPageCenter = this._scrollCenterOffsetY[index];
            nextPageCenter = this._scrollCenterOffsetY[nextIndex];
            return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
          }
        } else {
          if (this.direction === Direction.Horizontal) return Math.abs(offset.x) >= this.node.width * this.scrollThreshold;
          if (this.direction === Direction.Vertical) return Math.abs(offset.y) >= this.node.height * this.scrollThreshold;
        }
      },
      _isQuicklyScrollable: function(touchMoveVelocity) {
        if (this.direction === Direction.Horizontal) {
          if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) return true;
        } else if (this.direction === Direction.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) return true;
        return false;
      },
      _moveOffsetValue: function(idx) {
        var offset = cc.v2(0, 0);
        this.sizeMode === SizeMode.Free ? this.direction === Direction.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction.Vertical && (offset.y = this._scrollCenterOffsetY[idx]) : this.direction === Direction.Horizontal ? offset.x = idx * this.node.width : this.direction === Direction.Vertical && (offset.y = idx * this.node.height);
        return offset;
      },
      _getDragDirection: function(moveOffset) {
        if (this.direction === Direction.Horizontal) {
          if (0 === moveOffset.x) return 0;
          return moveOffset.x > 0 ? 1 : -1;
        }
        if (this.direction === Direction.Vertical) {
          if (0 === moveOffset.y) return 0;
          return moveOffset.y < 0 ? 1 : -1;
        }
      },
      _handleReleaseLogic: function(touch) {
        var bounceBackStarted = this._startBounceBackIfNeeded();
        var moveOffset = this._touchBeganPosition.sub(this._touchEndPosition);
        if (bounceBackStarted) {
          var dragDirection = this._getDragDirection(moveOffset);
          if (0 === dragDirection) return;
          this._curPageIdx = dragDirection > 0 ? this._pages.length - 1 : 0;
          this.indicator && this.indicator._changedState();
        } else {
          var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset);
          var timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
          if (nextIndex < this._pages.length) {
            if (this._isScrollable(moveOffset, index, nextIndex)) {
              this.scrollToPage(nextIndex, timeInSecond);
              return;
            }
            var touchMoveVelocity = this._calculateTouchMoveVelocity();
            if (this._isQuicklyScrollable(touchMoveVelocity)) {
              this.scrollToPage(nextIndex, timeInSecond);
              return;
            }
          }
          this.scrollToPage(index, timeInSecond);
        }
      },
      _onTouchBegan: function(event, captureListeners) {
        this._touchBeganPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onTouchMoved: function(event, captureListeners) {
        this._super(event, captureListeners);
      },
      _onTouchEnded: function(event, captureListeners) {
        this._touchEndPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onTouchCancelled: function(event, captureListeners) {
        this._touchEndPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onMouseWheel: function() {}
    });
    cc.PageView = module.exports = PageView;
  }), {} ],
  75: [ (function(require, module, exports) {
    var Direction = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var PageViewIndicator = cc.Class({
      name: "cc.PageViewIndicator",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layout: null,
        _pageView: null,
        _indicators: [],
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame,
          tooltip: false
        },
        direction: {
          default: Direction.HORIZONTAL,
          type: Direction,
          tooltip: false
        },
        cellSize: {
          default: cc.size(20, 20),
          tooltip: false
        },
        spacing: {
          default: 0,
          tooltip: false
        }
      },
      statics: {
        Direction: Direction
      },
      onLoad: function() {
        this._updateLayout();
      },
      setPageView: function(target) {
        this._pageView = target;
        this._refresh();
      },
      _updateLayout: function() {
        this._layout = this.getComponent(cc.Layout);
        this._layout || (this._layout = this.addComponent(cc.Layout));
        if (this.direction === Direction.HORIZONTAL) {
          this._layout.type = cc.Layout.Type.HORIZONTAL;
          this._layout.spacingX = this.spacing;
        } else if (this.direction === Direction.VERTICAL) {
          this._layout.type = cc.Layout.Type.VERTICAL;
          this._layout.spacingY = this.spacing;
        }
        this._layout.resizeMode = cc.Layout.ResizeMode.CONTAINER;
      },
      _createIndicator: function() {
        var node = new cc.Node();
        var sprite = node.addComponent(cc.Sprite);
        sprite.spriteFrame = this.spriteFrame;
        node.parent = this.node;
        node.width = this.cellSize.width;
        node.height = this.cellSize.height;
        return node;
      },
      _changedState: function() {
        var indicators = this._indicators;
        if (0 === indicators.length) return;
        var idx = this._pageView._curPageIdx;
        if (idx >= indicators.length) return;
        for (var i = 0; i < indicators.length; ++i) {
          var node = indicators[i];
          node.opacity = 127.5;
        }
        indicators[idx].opacity = 255;
      },
      _refresh: function() {
        if (!this._pageView) return;
        var indicators = this._indicators;
        var pages = this._pageView.getPages();
        if (pages.length === indicators.length) return;
        var i = 0;
        if (pages.length > indicators.length) for (i = 0; i < pages.length; ++i) indicators[i] || (indicators[i] = this._createIndicator()); else {
          var count = indicators.length - pages.length;
          for (i = count; i > 0; --i) {
            var node = indicators[i - 1];
            this.node.removeChild(node);
            indicators.splice(i - 1, 1);
          }
        }
        this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout();
        this._changedState();
      }
    });
    cc.PageViewIndicator = module.exports = PageViewIndicator;
  }), {
    "./CCComponent": 67
  } ],
  76: [ (function(require, module, exports) {
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var Mode = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      FILLED: 2
    });
    var ProgressBar = cc.Class({
      name: "cc.ProgressBar",
      extends: Component,
      editor: false,
      _initBarSprite: function() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var nodeSize = this.node.getContentSize();
          var nodeAnchor = this.node.getAnchorPoint();
          var entitySize = entity.getContentSize();
          entity.parent === this.node && this.node.setContentSize(entitySize);
          this.barSprite.fillType === cc.Sprite.FillType.RADIAL && (this.mode = Mode.FILLED);
          var barSpriteSize = entity.getContentSize();
          this.mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this.mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this.barSprite.fillRange;
          if (entity.parent === this.node) {
            var x = -nodeSize.width * nodeAnchor.x;
            var y = 0;
            entity.setPosition(cc.v2(x, y));
          }
        }
      },
      _updateBarStatus: function() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var entityAnchorPoint = entity.getAnchorPoint();
          var entitySize = entity.getContentSize();
          var entityPosition = entity.getPosition();
          var anchorPoint = cc.v2(0, .5);
          var progress = misc.clamp01(this.progress);
          var actualLenth = this.totalLength * progress;
          var finalContentSize;
          var totalWidth;
          var totalHeight;
          switch (this.mode) {
           case Mode.HORIZONTAL:
            this.reverse && (anchorPoint = cc.v2(1, .5));
            finalContentSize = cc.size(actualLenth, entitySize.height);
            totalWidth = this.totalLength;
            totalHeight = entitySize.height;
            break;

           case Mode.VERTICAL:
            anchorPoint = this.reverse ? cc.v2(.5, 1) : cc.v2(.5, 0);
            finalContentSize = cc.size(entitySize.width, actualLenth);
            totalWidth = entitySize.width;
            totalHeight = this.totalLength;
          }
          if (this.mode === Mode.FILLED) if (this.barSprite.type !== cc.Sprite.Type.FILLED) cc.warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!"); else {
            this.reverse && (actualLenth *= -1);
            this.barSprite.fillRange = actualLenth;
          } else if (this.barSprite.type !== cc.Sprite.Type.FILLED) {
            var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
            var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
            var finalPosition = cc.v2(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY);
            entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y);
            entity.setAnchorPoint(anchorPoint);
            entity.setContentSize(finalContentSize);
          } else cc.warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
        }
      },
      properties: {
        barSprite: {
          default: null,
          type: cc.Sprite,
          tooltip: false,
          notify: function() {
            this._initBarSprite();
          },
          animatable: false
        },
        mode: {
          default: Mode.HORIZONTAL,
          type: Mode,
          tooltip: false,
          notify: function() {
            if (this.barSprite) {
              var entity = this.barSprite.node;
              if (!entity) return;
              var entitySize = entity.getContentSize();
              this.mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this.mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this.mode === Mode.FILLED && (this.totalLength = this.barSprite.fillRange);
            }
          },
          animatable: false
        },
        _N$totalLength: 1,
        totalLength: {
          range: [ 0, Number.MAX_VALUE ],
          tooltip: false,
          get: function() {
            return this._N$totalLength;
          },
          set: function(value) {
            this.mode === Mode.FILLED && (value = misc.clamp01(value));
            this._N$totalLength = value;
            this._updateBarStatus();
          }
        },
        progress: {
          default: 1,
          type: "Float",
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: false,
          notify: function() {
            this._updateBarStatus();
          }
        },
        reverse: {
          default: false,
          tooltip: false,
          notify: function() {
            this.barSprite && (this.barSprite.fillStart = 1 - this.barSprite.fillStart);
            this._updateBarStatus();
          },
          animatable: false
        }
      },
      statics: {
        Mode: Mode
      }
    });
    cc.ProgressBar = module.exports = ProgressBar;
  }), {
    "../utils/misc": 233,
    "./CCComponent": 67
  } ],
  77: [ (function(require, module, exports) {
    var Component = require("./CCComponent");
    var defaultVertexFormat = require("../renderer/webgl/vertex-format");
    var renderEngine = require("../renderer/render-engine");
    var RenderFlow = require("../renderer/render-flow");
    var RenderData = renderEngine.RenderData;
    var RenderComponent = cc.Class({
      name: "RenderComponent",
      extends: Component,
      editor: false,
      ctor: function() {
        this._material = null;
        this._renderData = null;
        this.__allocedDatas = [];
        this._vertexFormat = defaultVertexFormat;
        this._toPostHandle = false;
        this._assembler = this.constructor._assembler;
        this._postAssembler = this.constructor._postAssembler;
      },
      onEnable: function() {
        this.node._renderComponent && (this.node._renderComponent.enabled = false);
        this.node._renderComponent = this;
        this.node._renderFlag |= RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_COLOR;
      },
      onDisable: function() {
        this.node._renderComponent = null;
        this.disableRender();
      },
      onDestroy: function() {
        for (var i = 0, l = this.__allocedDatas.length; i < l; i++) RenderData.free(this.__allocedDatas[i]);
        this.__allocedDatas.length = 0;
        this._material = null;
        this._renderData = null;
      },
      markForUpdateRenderData: function(enable) {
        enable && this._enabled ? this.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_UPDATE_RENDER_DATA);
      },
      markForRender: function(enable) {
        enable && this._enabled ? this.node._renderFlag |= RenderFlow.FLAG_RENDER : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_RENDER);
      },
      markForCustomIARender: function(enable) {
        enable && this._enabled ? this.node._renderFlag |= RenderFlow.FLAG_CUSTOM_IA_RENDER : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_CUSTOM_IA_RENDER);
      },
      disableRender: function() {
        this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | cc.RenderFlow.FLAG_CUSTOM_IA_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_COLOR);
      },
      requestRenderData: function() {
        var data = RenderData.alloc();
        this.__allocedDatas.push(data);
        return data;
      },
      destroyRenderData: function(data) {
        var index = this.__allocedDatas.indexOf(data);
        if (-1 !== index) {
          this.__allocedDatas.splice(index, 1);
          RenderData.free(data);
        }
      },
      _updateColor: function() {
        var material = this._material;
        if (material) {
          material.color = this.node.color;
          material.updateHash();
          this.node._renderFlag &= ~RenderFlow.FLAG_COLOR;
        }
      },
      getMaterial: function() {
        return this._material;
      },
      setMaterial: function(material) {
        material.updateHash();
        this._material = material;
      }
    });
    RenderComponent._assembler = null;
    RenderComponent._postAssembler = null;
    cc.RenderComponent = module.exports = RenderComponent;
  }), {
    "../renderer/render-engine": 197,
    "../renderer/render-flow": 198,
    "../renderer/webgl/vertex-format": 223,
    "./CCComponent": 67
  } ],
  78: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var macro = require("../platform/CCMacro");
    var utils = require("../utils/text-utils");
    var HtmlTextParser = utils.HtmlTextParser;
    var TextUtils = utils.TextUtils;
    var CustomFontLoader = utils.CustomFontLoader;
    var HorizontalAlign = macro.TextAlignment;
    var VerticalAlign = macro.VerticalTextAlignment;
    var RichTextChildName = "RICHTEXT_CHILD";
    var _htmlTextParser = new HtmlTextParser();
    function debounce(func, wait, immediate) {
      var timeout = void 0;
      return function() {
        var context = this;
        var later = function() {
          timeout = null;
          immediate || func.apply(context, arguments);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        callNow && func.apply(context, arguments);
      };
    }
    var pool = new js.Pool(function(node) {
      false;
      false;
      if (!cc.isValid(node)) return false;
      if (node.getComponent(cc.LabelOutline)) return false;
      return true;
    }, 20);
    pool.get = function(string, fontAsset, fontSize) {
      var labelNode = this._get();
      labelNode || (labelNode = new cc.PrivateNode(RichTextChildName));
      var labelComponent = labelNode.getComponent(cc.Label);
      labelComponent || (labelComponent = labelNode.addComponent(cc.Label));
      labelNode.setPosition(0, 0);
      labelNode.setAnchorPoint(.5, .5);
      labelNode.setContentSize(128, 128);
      labelNode.skewX = 0;
      "string" !== typeof string && (string = "" + string);
      var isAsset = fontAsset instanceof cc.Font;
      isAsset ? labelComponent.font = fontAsset : labelComponent.fontFamily = "Arial";
      labelComponent.string = string;
      labelComponent.horizontalAlign = HorizontalAlign.LEFT;
      labelComponent.verticalAlign = VerticalAlign.TOP;
      labelComponent.fontSize = fontSize || 40;
      labelComponent.overflow = 0;
      labelComponent.enableWrapText = true;
      labelComponent.lineHeight = 40;
      labelComponent._enableBold(false);
      labelComponent._enableItalics(false);
      labelComponent._enableUnderline(false);
      return labelNode;
    };
    var RichText = cc.Class({
      name: "cc.RichText",
      extends: cc.Component,
      ctor: function() {
        this._textArray = null;
        this._labelSegments = [];
        this._labelSegmentsCache = [];
        this._linesWidth = [];
        false;
        this._updateRichTextStatus = this._updateRichText;
      },
      editor: false,
      properties: {
        string: {
          default: "<color=#00ff00>Rich</c><color=#0fffff>Text</color>",
          multiline: true,
          tooltip: false,
          notify: function() {
            this._updateRichTextStatus();
          }
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: false,
          animatable: false,
          notify: function(oldValue) {
            if (this.horizontalAlign === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        fontSize: {
          default: 40,
          tooltip: false,
          notify: function(oldValue) {
            if (this.fontSize === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        font: {
          default: null,
          type: cc.TTFFont,
          tooltip: false,
          notify: function(oldValue) {
            if (this.font === oldValue) return;
            this._layoutDirty = true;
            this.font && this._onTTFLoaded();
            this._updateRichTextStatus();
          }
        },
        maxWidth: {
          default: 0,
          tooltip: false,
          notify: function(oldValue) {
            if (this.maxWidth === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        lineHeight: {
          default: 40,
          tooltip: false,
          notify: function(oldValue) {
            if (this.lineHeight === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        imageAtlas: {
          default: null,
          type: cc.SpriteAtlas,
          tooltip: false,
          notify: function(oldValue) {
            if (this.imageAtlas === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        handleTouchEvent: {
          default: true,
          tooltip: false,
          notify: function(oldValue) {
            if (this.handleTouchEvent === oldValue) return;
            this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners());
          }
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign
      },
      onEnable: function() {
        this.handleTouchEvent && this._addEventListeners();
        this._updateRichText();
      },
      onDisable: function() {
        this.handleTouchEvent && this._removeEventListeners();
        this._resetState();
      },
      start: function() {
        this._onTTFLoaded();
      },
      _addEventListeners: function() {
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _removeEventListeners: function() {
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _updateLabelSegmentTextAttributes: function() {
        this._labelSegments.forEach(function(item) {
          this._applyTextAttribute(item);
        }.bind(this));
      },
      _createFontLabel: function(string) {
        return pool.get(string, this.font, this.fontSize);
      },
      _getFontRawUrl: function() {
        var isAsset = this.font instanceof cc.TTFFont;
        return isAsset ? this.font.nativeUrl : "";
      },
      _onTTFLoaded: function() {
        var rawUrl = this._getFontRawUrl();
        if (!rawUrl) return;
        var self = this;
        var callback = function() {
          self._layoutDirty = true;
          self._updateRichText();
        };
        CustomFontLoader.loadTTF(rawUrl, callback);
      },
      _measureText: function(styleIndex, string) {
        var self = this;
        var func = function(string) {
          var label = void 0;
          if (0 === self._labelSegmentsCache.length) {
            label = self._createFontLabel(string);
            self._labelSegmentsCache.push(label);
          } else {
            label = self._labelSegmentsCache[0];
            label.getComponent(cc.Label).string = string;
          }
          label._styleIndex = styleIndex;
          self._applyTextAttribute(label);
          var labelSize = label.getContentSize();
          return labelSize.width;
        };
        return string ? func(string) : func;
      },
      _onTouchEnded: function(event) {
        var _this = this;
        var components = this.node.getComponents(cc.Component);
        var _loop = function(i) {
          var labelSegment = _this._labelSegments[i];
          var clickHandler = labelSegment._clickHandler;
          if (clickHandler && _this._containsTouchLocation(labelSegment, event.touch.getLocation())) {
            components.forEach((function(component) {
              component.enabledInHierarchy && component[clickHandler] && component[clickHandler](event);
            }));
            event.stopPropagation();
          }
        };
        for (var i = 0; i < this._labelSegments.length; ++i) _loop(i);
      },
      _containsTouchLocation: function(label, point) {
        var myRect = label.getBoundingBoxToWorld();
        return myRect.contains(point);
      },
      _resetState: function() {
        for (var i = this.node.children.length - 1; i >= 0; i--) {
          var child = this.node.children[i];
          if (child.name === RichTextChildName) {
            child.parent = null;
            pool.put(child);
          }
        }
        this._labelSegments.length = 0;
        this._labelSegmentsCache.length = 0;
        this._linesWidth.length = 0;
        this._lineOffsetX = 0;
        this._lineCount = 1;
        this._labelWidth = 0;
        this._labelHeight = 0;
        this._layoutDirty = true;
      },
      _addLabelSegment: function(stringToken, styleIndex) {
        var labelSegment = void 0;
        if (0 === this._labelSegmentsCache.length) labelSegment = this._createFontLabel(stringToken); else {
          labelSegment = this._labelSegmentsCache.pop();
          labelSegment.getComponent(cc.Label).string = stringToken;
        }
        labelSegment._styleIndex = styleIndex;
        labelSegment._lineCount = this._lineCount;
        labelSegment.setAnchorPoint(0, 0);
        this._applyTextAttribute(labelSegment);
        this.node.addChild(labelSegment);
        this._labelSegments.push(labelSegment);
        return labelSegment;
      },
      _updateRichTextWithMaxWidth: function(labelString, labelWidth, styleIndex) {
        var fragmentWidth = labelWidth;
        var labelSegment = void 0;
        if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this.maxWidth) {
          var checkStartIndex = 0;
          while (this._lineOffsetX <= this.maxWidth) {
            var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);
            var checkString = labelString.substr(checkStartIndex, checkEndIndex);
            var checkStringWidth = this._measureText(styleIndex, checkString);
            if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
              if (checkStartIndex > 0) {
                var remainingString = labelString.substr(0, checkStartIndex);
                this._addLabelSegment(remainingString, styleIndex);
                labelString = labelString.substr(checkStartIndex, labelString.length);
                fragmentWidth = this._measureText(styleIndex, labelString);
              }
              this._updateLineInfo();
              break;
            }
            this._lineOffsetX += checkStringWidth;
            checkStartIndex += checkEndIndex;
          }
        }
        if (fragmentWidth > this.maxWidth) {
          var fragments = TextUtils.fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex));
          for (var k = 0; k < fragments.length; ++k) {
            var splitString = fragments[k];
            labelSegment = this._addLabelSegment(splitString, styleIndex);
            var labelSize = labelSegment.getContentSize();
            this._lineOffsetX += labelSize.width;
            fragments.length > 1 && k < fragments.length - 1 && this._updateLineInfo();
          }
        } else {
          this._lineOffsetX += fragmentWidth;
          this._addLabelSegment(labelString, styleIndex);
        }
      },
      _isLastComponentCR: function(stringToken) {
        return stringToken.length - 1 === stringToken.lastIndexOf("\n");
      },
      _updateLineInfo: function() {
        this._linesWidth.push(this._lineOffsetX);
        this._lineOffsetX = 0;
        this._lineCount++;
      },
      _needsUpdateTextLayout: function(newTextArray) {
        if (this._layoutDirty || !this._textArray || !newTextArray) return true;
        if (this._textArray.length !== newTextArray.length) return true;
        for (var i = 0; i < this._textArray.length; ++i) {
          var oldItem = this._textArray[i];
          var newItem = newTextArray[i];
          if (oldItem.text !== newItem.text) return true;
          if (oldItem.style) {
            if (newItem.style) {
              if (!!newItem.style.outline !== !!oldItem.style.outline) return true;
              if (oldItem.style.size !== newItem.style.size || oldItem.style.italic !== newItem.style.italic || oldItem.style.isImage !== newItem.style.isImage) return true;
              if (oldItem.style.isImage === newItem.style.isImage && oldItem.style.src !== newItem.style.src) return true;
            } else if (oldItem.style.size || oldItem.style.italic || oldItem.style.isImage || oldItem.style.outline) return true;
          } else if (newItem.style && (newItem.style.size || newItem.style.italic || newItem.style.isImage || newItem.style.outline)) return true;
        }
        return false;
      },
      _addRichTextImageElement: function(richTextElement) {
        var spriteFrameName = richTextElement.style.src;
        var spriteFrame = this.imageAtlas.getSpriteFrame(spriteFrameName);
        if (spriteFrame) {
          var spriteNode = new cc.PrivateNode(RichTextChildName);
          var spriteComponent = spriteNode.addComponent(cc.Sprite);
          spriteNode.setAnchorPoint(0, 0);
          spriteComponent.type = cc.Sprite.Type.SLICED;
          spriteComponent.sizeMode = cc.Sprite.SizeMode.CUSTOM;
          this.node.addChild(spriteNode);
          this._labelSegments.push(spriteNode);
          var spriteRect = spriteFrame.getRect();
          var scaleFactor = 1;
          var spriteWidth = spriteRect.width;
          var spriteHeight = spriteRect.height;
          var expectWidth = richTextElement.style.imageWidth;
          var expectHeight = richTextElement.style.imageHeight;
          if (expectHeight > 0 && expectHeight < this.lineHeight) {
            scaleFactor = expectHeight / spriteHeight;
            spriteWidth *= scaleFactor;
            spriteHeight *= scaleFactor;
          } else {
            scaleFactor = this.lineHeight / spriteHeight;
            spriteWidth *= scaleFactor;
            spriteHeight *= scaleFactor;
          }
          expectWidth > 0 && (spriteWidth = expectWidth);
          if (this.maxWidth > 0) {
            this._lineOffsetX + spriteWidth > this.maxWidth && this._updateLineInfo();
            this._lineOffsetX += spriteWidth;
          } else {
            this._lineOffsetX += spriteWidth;
            this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX);
          }
          spriteComponent.spriteFrame = spriteFrame;
          spriteNode.setContentSize(spriteWidth, spriteHeight);
          spriteNode._lineCount = this._lineCount;
          richTextElement.style.event && richTextElement.style.event.click && (spriteNode._clickHandler = richTextElement.style.event.click);
        } else cc.warnID(4400);
      },
      _updateRichText: function() {
        if (!this.enabled) return;
        var newTextArray = _htmlTextParser.parse(this.string);
        if (!this._needsUpdateTextLayout(newTextArray)) {
          this._textArray = newTextArray;
          this._updateLabelSegmentTextAttributes();
          return;
        }
        this._textArray = newTextArray;
        this._resetState();
        var lastEmptyLine = false;
        var label = void 0;
        var labelSize = void 0;
        for (var i = 0; i < this._textArray.length; ++i) {
          var richTextElement = this._textArray[i];
          var text = richTextElement.text;
          if ("" === text) {
            if (richTextElement.style && richTextElement.style.newline) {
              this._updateLineInfo();
              continue;
            }
            if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
              this._addRichTextImageElement(richTextElement);
              continue;
            }
          }
          var multilineTexts = text.split("\n");
          for (var j = 0; j < multilineTexts.length; ++j) {
            var labelString = multilineTexts[j];
            if ("" === labelString) {
              if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) continue;
              this._updateLineInfo();
              lastEmptyLine = true;
              continue;
            }
            lastEmptyLine = false;
            if (this.maxWidth > 0) {
              var labelWidth = this._measureText(i, labelString);
              this._updateRichTextWithMaxWidth(labelString, labelWidth, i);
              multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
            } else {
              label = this._addLabelSegment(labelString, i);
              labelSize = label.getContentSize();
              this._lineOffsetX += labelSize.width;
              this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX);
              multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
            }
          }
        }
        lastEmptyLine || this._linesWidth.push(this._lineOffsetX);
        this.maxWidth > 0 && (this._labelWidth = this.maxWidth);
        this._labelHeight = this._lineCount * this.lineHeight;
        this.node.setContentSize(this._labelWidth, this._labelHeight);
        this._updateRichTextPosition();
        this._layoutDirty = false;
      },
      _getFirstWordLen: function(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (TextUtils.isUnicodeCJK(character) || TextUtils.isUnicodeSpace(character)) return 1;
        var len = 1;
        for (var index = startIndex + 1; index < textLen; ++index) {
          character = text.charAt(index);
          if (TextUtils.isUnicodeSpace(character) || TextUtils.isUnicodeCJK(character)) break;
          len++;
        }
        return len;
      },
      _updateRichTextPosition: function() {
        var nextTokenX = 0;
        var nextLineIndex = 1;
        var totalLineCount = this._lineCount;
        for (var i = 0; i < this._labelSegments.length; ++i) {
          var label = this._labelSegments[i];
          var lineCount = label._lineCount;
          if (lineCount > nextLineIndex) {
            nextTokenX = 0;
            nextLineIndex = lineCount;
          }
          var lineOffsetX = 0;
          switch (this.horizontalAlign) {
           case HorizontalAlign.LEFT:
            lineOffsetX = -this._labelWidth / 2;
            break;

           case HorizontalAlign.CENTER:
            lineOffsetX = -this._linesWidth[lineCount - 1] / 2;
            break;

           case HorizontalAlign.RIGHT:
            lineOffsetX = this._labelWidth / 2 - this._linesWidth[lineCount - 1];
          }
          label.x = nextTokenX + lineOffsetX;
          var labelSize = label.getContentSize();
          label.y = this.lineHeight * (totalLineCount - lineCount) - this._labelHeight / 2;
          lineCount === nextLineIndex && (nextTokenX += labelSize.width);
        }
      },
      _convertLiteralColorValue: function(color) {
        var colorValue = color.toUpperCase();
        if (cc.Color[colorValue]) return cc.Color[colorValue];
        var out = cc.color();
        return out.fromHEX(color);
      },
      _applyTextAttribute: function(labelNode) {
        var labelComponent = labelNode.getComponent(cc.Label);
        if (!labelComponent) return;
        var index = labelNode._styleIndex;
        labelComponent.lineHeight = this.lineHeight;
        labelComponent.horizontalAlign = HorizontalAlign.LEFT;
        labelComponent.verticalAlign = VerticalAlign.CENTER;
        var textStyle = null;
        this._textArray[index] && (textStyle = this._textArray[index].style);
        textStyle && textStyle.color ? labelNode.color = this._convertLiteralColorValue(textStyle.color) : labelNode.color = this._convertLiteralColorValue("white");
        labelComponent._enableBold(textStyle && textStyle.bold);
        labelComponent._enableItalics(textStyle && textStyle.italic);
        textStyle && textStyle.italic && (labelNode.skewX = 12);
        labelComponent._enableUnderline(textStyle && textStyle.underline);
        if (textStyle && textStyle.outline) {
          var labelOutlineComponent = labelNode.getComponent(cc.LabelOutline);
          labelOutlineComponent || (labelOutlineComponent = labelNode.addComponent(cc.LabelOutline));
          labelOutlineComponent.color = this._convertLiteralColorValue(textStyle.outline.color);
          labelOutlineComponent.width = textStyle.outline.width;
        }
        textStyle && textStyle.size ? labelComponent.fontSize = textStyle.size : labelComponent.fontSize = this.fontSize;
        labelComponent._updateRenderData(true);
        textStyle && textStyle.event && textStyle.event.click && (labelNode._clickHandler = textStyle.event.click);
      },
      onDestroy: function() {
        for (var i = 0; i < this._labelSegments.length; ++i) {
          this._labelSegments[i].removeFromParent();
          pool.put(this._labelSegments[i]);
        }
      }
    });
    cc.RichText = module.exports = RichText;
  }), {
    "../platform/CCMacro": 160,
    "../platform/js": 175,
    "../utils/text-utils": 240
  } ],
  79: [ (function(require, module, exports) {
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var GETTINGSHORTERFACTOR = 20;
    var Direction = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var Scrollbar = cc.Class({
      name: "cc.Scrollbar",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _scrollView: null,
        _touching: false,
        _autoHideRemainingTime: {
          default: 0,
          serializable: false
        },
        _opacity: 255,
        handle: {
          default: null,
          type: cc.Sprite,
          tooltip: false,
          notify: function() {
            this._onScroll(cc.v2(0, 0));
          },
          animatable: false
        },
        direction: {
          default: Direction.HORIZONTAL,
          type: Direction,
          tooltip: false,
          notify: function() {
            this._onScroll(cc.v2(0, 0));
          },
          animatable: false
        },
        enableAutoHide: {
          default: true,
          animatable: false,
          tooltip: false
        },
        autoHideTime: {
          default: 1,
          animatable: false,
          tooltip: false
        }
      },
      statics: {
        Direction: Direction
      },
      setTargetScrollView: function(scrollView) {
        this._scrollView = scrollView;
      },
      _convertToScrollViewSpace: function(content) {
        var worldSpacePos = content.convertToWorldSpace(cc.v2(0, 0));
        var scrollViewSpacePos = this._scrollView.node.convertToNodeSpace(worldSpacePos);
        return scrollViewSpacePos;
      },
      _setOpacity: function(opacity) {
        if (this.handle) {
          this.node.opacity = opacity;
          this.handle.node.opacity = opacity;
        }
      },
      _onScroll: function(outOfBoundary) {
        if (this._scrollView) {
          var content = this._scrollView.content;
          if (content) {
            var contentSize = content.getContentSize();
            var scrollViewSize = this._scrollView.node.getContentSize();
            var handleNodeSize = this.node.getContentSize();
            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
            if (this.enableAutoHide) {
              this._autoHideRemainingTime = this.autoHideTime;
              this._setOpacity(this._opacity);
            }
            var contentMeasure = 0;
            var scrollViewMeasure = 0;
            var outOfBoundaryValue = 0;
            var contentPosition = 0;
            var handleNodeMeasure = 0;
            if (this.direction === Direction.HORIZONTAL) {
              contentMeasure = contentSize.width;
              scrollViewMeasure = scrollViewSize.width;
              handleNodeMeasure = handleNodeSize.width;
              outOfBoundaryValue = outOfBoundary.x;
              contentPosition = -this._convertToScrollViewSpace(content).x;
            } else if (this.direction === Direction.VERTICAL) {
              contentMeasure = contentSize.height;
              scrollViewMeasure = scrollViewSize.height;
              handleNodeMeasure = handleNodeSize.height;
              outOfBoundaryValue = outOfBoundary.y;
              contentPosition = -this._convertToScrollViewSpace(content).y;
            }
            var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);
            var position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
            this._updateLength(length);
            this._updateHanlderPosition(position);
          }
        }
      },
      _updateHanlderPosition: function(position) {
        if (this.handle) {
          var oldPosition = this._fixupHandlerPosition();
          this.handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y);
        }
      },
      _fixupHandlerPosition: function() {
        var barSize = this.node.getContentSize();
        var barAnchor = this.node.getAnchorPoint();
        var handleSize = this.handle.node.getContentSize();
        var handleParent = this.handle.node.parent;
        var leftBottomWorldPosition = this.node.convertToWorldSpaceAR(cc.v2(-barSize.width * barAnchor.x, -barSize.height * barAnchor.y));
        var fixupPosition = handleParent.convertToNodeSpaceAR(leftBottomWorldPosition);
        this.direction === Direction.HORIZONTAL ? fixupPosition = cc.v2(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2) : this.direction === Direction.VERTICAL && (fixupPosition = cc.v2(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y));
        this.handle.node.setPosition(fixupPosition);
        return fixupPosition;
      },
      _onTouchBegan: function() {
        if (!this.enableAutoHide) return;
        this._touching = true;
      },
      _conditionalDisableScrollBar: function(contentSize, scrollViewSize) {
        if (contentSize.width <= scrollViewSize.width && this.direction === Direction.HORIZONTAL) return true;
        if (contentSize.height <= scrollViewSize.height && this.direction === Direction.VERTICAL) return true;
        return false;
      },
      _onTouchEnded: function() {
        if (!this.enableAutoHide) return;
        this._touching = false;
        if (this.autoHideTime <= 0) return;
        if (this._scrollView) {
          var content = this._scrollView.content;
          if (content) {
            var contentSize = content.getContentSize();
            var scrollViewSize = this._scrollView.node.getContentSize();
            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
          }
        }
        this._autoHideRemainingTime = this.autoHideTime;
      },
      _calculateLength: function(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
        var denominatorValue = contentMeasure;
        outOfBoundary && (denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTINGSHORTERFACTOR);
        var lengthRation = scrollViewMeasure / denominatorValue;
        return handleNodeMeasure * lengthRation;
      },
      _calculatePosition: function(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
        var denominatorValue = contentMeasure - scrollViewMeasure;
        outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
        var positionRatio = 0;
        if (denominatorValue) {
          positionRatio = contentPosition / denominatorValue;
          positionRatio = misc.clamp01(positionRatio);
        }
        var position = (handleNodeMeasure - actualLenth) * positionRatio;
        return this.direction === Direction.VERTICAL ? cc.v2(0, position) : cc.v2(position, 0);
      },
      _updateLength: function(length) {
        if (this.handle) {
          var handleNode = this.handle.node;
          var handleNodeSize = handleNode.getContentSize();
          handleNode.setAnchorPoint(cc.v2(0, 0));
          this.direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
        }
      },
      _processAutoHide: function(deltaTime) {
        if (!this.enableAutoHide || this._autoHideRemainingTime <= 0) return;
        if (this._touching) return;
        this._autoHideRemainingTime -= deltaTime;
        if (this._autoHideRemainingTime <= this.autoHideTime) {
          this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
          var opacity = this._opacity * (this._autoHideRemainingTime / this.autoHideTime);
          this._setOpacity(opacity);
        }
      },
      start: function() {
        this.enableAutoHide && this._setOpacity(0);
      },
      hide: function() {
        this._autoHideRemainingTime = 0;
        this._setOpacity(0);
      },
      show: function() {
        this._autoHideRemainingTime = this.autoHideTime;
        this._setOpacity(this._opacity);
      },
      update: function(dt) {
        this._processAutoHide(dt);
      }
    });
    cc.Scrollbar = module.exports = Scrollbar;
  }), {
    "../utils/misc": 233,
    "./CCComponent": 67
  } ],
  80: [ (function(require, module, exports) {
    var NodeEvent = require("../CCNode").EventType;
    var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
    var OUT_OF_BOUNDARY_BREAKING_FACTOR = .05;
    var EPSILON = 1e-4;
    var MOVEMENT_FACTOR = .7;
    var quintEaseOut = function(time) {
      time -= 1;
      return time * time * time * time * time + 1;
    };
    var getTimeInMilliseconds = function() {
      var currentTime = new Date();
      return currentTime.getMilliseconds();
    };
    var EventType = cc.Enum({
      SCROLL_TO_TOP: 0,
      SCROLL_TO_BOTTOM: 1,
      SCROLL_TO_LEFT: 2,
      SCROLL_TO_RIGHT: 3,
      SCROLLING: 4,
      BOUNCE_TOP: 5,
      BOUNCE_BOTTOM: 6,
      BOUNCE_LEFT: 7,
      BOUNCE_RIGHT: 8,
      SCROLL_ENDED: 9,
      TOUCH_UP: 10,
      AUTOSCROLL_ENDED_WITH_THRESHOLD: 11,
      SCROLL_BEGAN: 12
    });
    var eventMap = {
      "scroll-to-top": EventType.SCROLL_TO_TOP,
      "scroll-to-bottom": EventType.SCROLL_TO_BOTTOM,
      "scroll-to-left": EventType.SCROLL_TO_LEFT,
      "scroll-to-right": EventType.SCROLL_TO_RIGHT,
      scrolling: EventType.SCROLLING,
      "bounce-bottom": EventType.BOUNCE_BOTTOM,
      "bounce-left": EventType.BOUNCE_LEFT,
      "bounce-right": EventType.BOUNCE_RIGHT,
      "bounce-top": EventType.BOUNCE_TOP,
      "scroll-ended": EventType.SCROLL_ENDED,
      "touch-up": EventType.TOUCH_UP,
      "scroll-ended-with-threshold": EventType.AUTOSCROLL_ENDED_WITH_THRESHOLD,
      "scroll-began": EventType.SCROLL_BEGAN
    };
    var ScrollView = cc.Class({
      name: "cc.ScrollView",
      extends: require("./CCViewGroup"),
      editor: false,
      ctor: function() {
        this._topBoundary = 0;
        this._bottomBoundary = 0;
        this._leftBoundary = 0;
        this._rightBoundary = 0;
        this._touchMoveDisplacements = [];
        this._touchMoveTimeDeltas = [];
        this._touchMovePreviousTimestamp = 0;
        this._touchMoved = false;
        this._autoScrolling = false;
        this._autoScrollAttenuate = false;
        this._autoScrollStartPosition = cc.v2(0, 0);
        this._autoScrollTargetDelta = cc.v2(0, 0);
        this._autoScrollTotalTime = 0;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollCurrentlyOutOfBoundary = false;
        this._autoScrollBraking = false;
        this._autoScrollBrakingStartPosition = cc.v2(0, 0);
        this._outOfBoundaryAmount = cc.v2(0, 0);
        this._outOfBoundaryAmountDirty = true;
        this._stopMouseWheel = false;
        this._mouseWheelEventElapsedTime = 0;
        this._isScrollEndedWithThresholdEventFired = false;
        this._scrollEventEmitMask = 0;
        this._isBouncing = false;
        this._scrolling = false;
      },
      properties: {
        content: {
          default: void 0,
          type: cc.Node,
          tooltip: false
        },
        horizontal: {
          default: true,
          animatable: false,
          tooltip: false
        },
        vertical: {
          default: true,
          animatable: false,
          tooltip: false
        },
        inertia: {
          default: true,
          tooltip: false
        },
        brake: {
          default: .5,
          type: "Float",
          range: [ 0, 1, .1 ],
          tooltip: false
        },
        elastic: {
          default: true,
          animatable: false,
          tooltip: false
        },
        bounceDuration: {
          default: 1,
          range: [ 0, 10 ],
          tooltip: false
        },
        horizontalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: false,
          notify: function() {
            if (this.horizontalScrollBar) {
              this.horizontalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        verticalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: false,
          notify: function() {
            if (this.verticalScrollBar) {
              this.verticalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        scrollEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        },
        cancelInnerEvents: {
          default: true,
          animatable: false,
          tooltip: false
        }
      },
      statics: {
        EventType: EventType
      },
      scrollToBottom: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta, true);
      },
      scrollToTop: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 1),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToLeft: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToRight: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopLeft: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopRight: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomLeft: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomRight: function(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToOffset: function(offset, timeInSecond, attenuated) {
        var maxScrollOffset = this.getMaxScrollOffset();
        var anchor = cc.v2(0, 0);
        0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x;
        0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
        this.scrollTo(anchor, timeInSecond, attenuated);
      },
      getScrollOffset: function() {
        var topDelta = this._getContentTopBoundary() - this._topBoundary;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        return cc.v2(leftDeta, topDelta);
      },
      getMaxScrollOffset: function() {
        var scrollSize = this.node.getContentSize();
        var contentSize = this.content.getContentSize();
        var horizontalMaximizeOffset = contentSize.width - scrollSize.width;
        var verticalMaximizeOffset = contentSize.height - scrollSize.height;
        horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
        verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
        return cc.v2(horizontalMaximizeOffset, verticalMaximizeOffset);
      },
      scrollToPercentHorizontal: function(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(percent, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollTo: function(anchor, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(anchor),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToPercentVertical: function(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, percent),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      stopAutoScroll: function() {
        this._autoScrolling = false;
        this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
      },
      setContentPosition: function(position) {
        if (position.fuzzyEquals(this.getContentPosition(), EPSILON)) return;
        this.content.setPosition(position);
        this._outOfBoundaryAmountDirty = true;
      },
      getContentPosition: function() {
        return this.content.getPosition();
      },
      isScrolling: function() {
        return this._scrolling;
      },
      isAutoScrolling: function() {
        return this._autoScrolling;
      },
      _registerEvent: function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.on(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _unregisterEvent: function() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.off(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _onMouseWheel: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var deltaMove = cc.v2(0, 0);
        var wheelPrecision = -.1;
        false;
        this.vertical ? deltaMove = cc.v2(0, event.getScrollY() * wheelPrecision) : this.horizontal && (deltaMove = cc.v2(event.getScrollY() * wheelPrecision, 0));
        this._mouseWheelEventElapsedTime = 0;
        this._processDeltaMove(deltaMove);
        if (!this._stopMouseWheel) {
          this._handlePressLogic();
          this.schedule(this._checkMouseWheel, 1 / 60);
          this._stopMouseWheel = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _checkMouseWheel: function(dt) {
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        var maxElapsedTime = .1;
        if (!currentOutOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
          this._processInertiaScroll();
          this.unschedule(this._checkMouseWheel);
          this._stopMouseWheel = false;
          return;
        }
        this._mouseWheelEventElapsedTime += dt;
        if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
          this._onScrollBarTouchEnded();
          this.unschedule(this._checkMouseWheel);
          this._stopMouseWheel = false;
        }
      },
      _calculateMovePercentDelta: function(options) {
        var anchor = options.anchor;
        var applyToHorizontal = options.applyToHorizontal;
        var applyToVertical = options.applyToVertical;
        this._calculateBoundary();
        anchor = anchor.clampf(cc.v2(0, 0), cc.v2(1, 1));
        var scrollSize = this.node.getContentSize();
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        var moveDelta = cc.v2(0, 0);
        var totalScrollDelta = 0;
        if (applyToHorizontal) {
          totalScrollDelta = contentSize.width - scrollSize.width;
          moveDelta.x = leftDeta - totalScrollDelta * anchor.x;
        }
        if (applyToVertical) {
          totalScrollDelta = contentSize.height - scrollSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta * anchor.y;
        }
        return moveDelta;
      },
      _moveContentToTopLeft: function(scrollViewSize) {
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var moveDelta = cc.v2(0, 0);
        var totalScrollDelta = 0;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        if (contentSize.height < scrollViewSize.height) {
          totalScrollDelta = contentSize.height - scrollViewSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta;
          this.verticalScrollBar && this.verticalScrollBar.hide();
        } else this.verticalScrollBar && this.verticalScrollBar.show();
        if (contentSize.width < scrollViewSize.width) {
          totalScrollDelta = contentSize.width - scrollViewSize.width;
          moveDelta.x = leftDeta;
          this.horizontalScrollBar && this.horizontalScrollBar.hide();
        } else this.horizontalScrollBar && this.horizontalScrollBar.show();
        this._moveContent(moveDelta);
        this._adjustContentOutOfBoundary();
      },
      _calculateBoundary: function() {
        if (this.content) {
          var layout = this.content.getComponent(cc.Layout);
          layout && layout.enabledInHierarchy && layout.updateLayout();
          var scrollViewSize = this.node.getContentSize();
          var leftBottomPosition = this._convertToContentParentSpace(cc.v2(0, 0));
          this._leftBoundary = leftBottomPosition.x;
          this._bottomBoundary = leftBottomPosition.y;
          var topRightPosition = this._convertToContentParentSpace(cc.v2(scrollViewSize.width, scrollViewSize.height));
          this._rightBoundary = topRightPosition.x;
          this._topBoundary = topRightPosition.y;
          true;
          this._moveContentToTopLeft(scrollViewSize);
        }
      },
      _convertToContentParentSpace: function(position) {
        var scrollViewPositionInWorldSpace = this.node.convertToWorldSpace(position);
        var contentParent = this.content.parent;
        return contentParent.convertToNodeSpaceAR(scrollViewPositionInWorldSpace);
      },
      _hasNestedViewGroup: function(event, captureListeners) {
        if (event.eventPhase !== cc.Event.CAPTURING_PHASE) return;
        if (captureListeners) for (var i = 0; i < captureListeners.length; ++i) {
          var item = captureListeners[i];
          if (this.node === item) {
            if (event.target.getComponent(cc.ViewGroup)) return true;
            return false;
          }
          if (item.getComponent(cc.ViewGroup)) return true;
        }
        return false;
      },
      _stopPropagationIfTargetIsMe: function(event) {
        event.eventPhase === cc.Event.AT_TARGET && event.target === this.node && event.stopPropagation();
      },
      _onTouchBegan: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        this.content && this._handlePressLogic(touch);
        this._touchMoved = false;
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchMoved: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        this.content && this._handleMoveLogic(touch);
        if (!this.cancelInnerEvents) return;
        var deltaMove = touch.getLocation().sub(touch.getStartLocation());
        if (deltaMove.mag() > 7 && !this._touchMoved && event.target !== this.node) {
          var cancelEvent = new cc.Event.EventTouch(event.getTouches(), event.bubbles);
          cancelEvent.type = cc.Node.EventType.TOUCH_CANCEL;
          cancelEvent.touch = event.touch;
          cancelEvent.simulate = true;
          event.target.dispatchEvent(cancelEvent);
          this._touchMoved = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchEnded: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        this._dispatchEvent("touch-up");
        var touch = event.touch;
        this.content && this._handleReleaseLogic(touch);
        this._touchMoved ? event.stopPropagation() : this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchCancelled: function(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this._hasNestedViewGroup(event, captureListeners)) return;
        if (!event.simulate) {
          var touch = event.touch;
          this.content && this._handleReleaseLogic(touch);
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _processDeltaMove: function(deltaMove) {
        this._scrollChildren(deltaMove);
        this._gatherTouchMove(deltaMove);
      },
      _handleMoveLogic: function(touch) {
        var deltaMove = touch.getDelta();
        this._processDeltaMove(deltaMove);
      },
      _scrollChildren: function(deltaMove) {
        deltaMove = this._clampDelta(deltaMove);
        var realMove = deltaMove;
        var outOfBoundary = void 0;
        if (this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary();
          realMove.x *= 0 === outOfBoundary.x ? 1 : .5;
          realMove.y *= 0 === outOfBoundary.y ? 1 : .5;
        }
        if (!this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
          realMove = realMove.add(outOfBoundary);
        }
        var scrollEventType = -1;
        if (realMove.y > 0) {
          var icBottomPos = this.content.y - this.content.anchorY * this.content.height;
          icBottomPos + realMove.y > this._bottomBoundary && (scrollEventType = "scroll-to-bottom");
        } else if (realMove.y < 0) {
          var icTopPos = this.content.y - this.content.anchorY * this.content.height + this.content.height;
          icTopPos + realMove.y <= this._topBoundary && (scrollEventType = "scroll-to-top");
        } else if (realMove.x < 0) {
          var icRightPos = this.content.x - this.content.anchorX * this.content.width + this.content.width;
          icRightPos + realMove.x <= this._rightBoundary && (scrollEventType = "scroll-to-right");
        } else if (realMove.x > 0) {
          var icLeftPos = this.content.x - this.content.anchorX * this.content.width;
          icLeftPos + realMove.x >= this._leftBoundary && (scrollEventType = "scroll-to-left");
        }
        this._moveContent(realMove, false);
        if (0 !== realMove.x || 0 !== realMove.y) {
          if (!this._scrolling) {
            this._scrolling = true;
            this._dispatchEvent("scroll-began");
          }
          this._dispatchEvent("scrolling");
        }
        -1 !== scrollEventType && this._dispatchEvent(scrollEventType);
      },
      _handlePressLogic: function() {
        this._autoScrolling && this._dispatchEvent("scroll-ended");
        this._autoScrolling = false;
        this._isBouncing = false;
        this._touchMovePreviousTimestamp = getTimeInMilliseconds();
        this._touchMoveDisplacements.length = 0;
        this._touchMoveTimeDeltas.length = 0;
        this._onScrollBarTouchBegan();
      },
      _clampDelta: function(delta) {
        var contentSize = this.content.getContentSize();
        var scrollViewSize = this.node.getContentSize();
        contentSize.width < scrollViewSize.width && (delta.x = 0);
        contentSize.height < scrollViewSize.height && (delta.y = 0);
        return delta;
      },
      _gatherTouchMove: function(delta) {
        delta = this._clampDelta(delta);
        while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
          this._touchMoveDisplacements.shift();
          this._touchMoveTimeDeltas.shift();
        }
        this._touchMoveDisplacements.push(delta);
        var timeStamp = getTimeInMilliseconds();
        this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3);
        this._touchMovePreviousTimestamp = timeStamp;
      },
      _startBounceBackIfNeeded: function() {
        if (!this.elastic) return false;
        var bounceBackAmount = this._getHowMuchOutOfBoundary();
        bounceBackAmount = this._clampDelta(bounceBackAmount);
        if (bounceBackAmount.fuzzyEquals(cc.v2(0, 0), EPSILON)) return false;
        var bounceBackTime = Math.max(this.bounceDuration, 0);
        this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
        if (!this._isBouncing) {
          bounceBackAmount.y > 0 && this._dispatchEvent("bounce-top");
          bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom");
          bounceBackAmount.x > 0 && this._dispatchEvent("bounce-right");
          bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left");
          this._isBouncing = true;
        }
        return true;
      },
      _processInertiaScroll: function() {
        var bounceBackStarted = this._startBounceBackIfNeeded();
        if (!bounceBackStarted && this.inertia) {
          var touchMoveVelocity = this._calculateTouchMoveVelocity();
          !touchMoveVelocity.fuzzyEquals(cc.v2(0, 0), EPSILON) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
        }
        this._onScrollBarTouchEnded();
      },
      _handleReleaseLogic: function(touch) {
        var delta = touch.getDelta();
        this._gatherTouchMove(delta);
        this._processInertiaScroll();
        if (this._scrolling) {
          this._scrolling = false;
          this._autoScrolling || this._dispatchEvent("scroll-ended");
        }
      },
      _isOutOfBoundary: function() {
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        return !outOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON);
      },
      _isNecessaryAutoScrollBrake: function() {
        if (this._autoScrollBraking) return true;
        if (this._isOutOfBoundary()) {
          if (!this._autoScrollCurrentlyOutOfBoundary) {
            this._autoScrollCurrentlyOutOfBoundary = true;
            this._autoScrollBraking = true;
            this._autoScrollBrakingStartPosition = this.getContentPosition();
            return true;
          }
        } else this._autoScrollCurrentlyOutOfBoundary = false;
        return false;
      },
      getScrollEndedEventTiming: function() {
        return EPSILON;
      },
      _processAutoScrolling: function(dt) {
        var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
        var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
        this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
        var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
        this._autoScrollAttenuate && (percentage = quintEaseOut(percentage));
        var newPosition = this._autoScrollStartPosition.add(this._autoScrollTargetDelta.mul(percentage));
        var reachedEnd = Math.abs(percentage - 1) <= EPSILON;
        var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();
        if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
          this._dispatchEvent("scroll-ended-with-threshold");
          this._isScrollEndedWithThresholdEventFired = true;
        }
        if (this.elastic) {
          var brakeOffsetPosition = newPosition.sub(this._autoScrollBrakingStartPosition);
          isAutoScrollBrake && (brakeOffsetPosition = brakeOffsetPosition.mul(brakingFactor));
          newPosition = this._autoScrollBrakingStartPosition.add(brakeOffsetPosition);
        } else {
          var moveDelta = newPosition.sub(this.getContentPosition());
          var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
          if (!outOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
            newPosition = newPosition.add(outOfBoundary);
            reachedEnd = true;
          }
        }
        reachedEnd && (this._autoScrolling = false);
        var deltaMove = newPosition.sub(this.getContentPosition());
        this._moveContent(this._clampDelta(deltaMove), reachedEnd);
        this._dispatchEvent("scrolling");
        if (!this._autoScrolling) {
          this._isBouncing = false;
          this._dispatchEvent("scroll-ended");
        }
      },
      _startInertiaScroll: function(touchMoveVelocity) {
        var inertiaTotalMovement = touchMoveVelocity.mul(MOVEMENT_FACTOR);
        this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
      },
      _calculateAttenuatedFactor: function(distance) {
        if (this.brake <= 0) return 1 - this.brake;
        return (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
      },
      _startAttenuatingAutoScroll: function(deltaMove, initialVelocity) {
        var time = this._calculateAutoScrollTimeByInitalSpeed(initialVelocity.mag());
        var targetDelta = deltaMove.normalize();
        var contentSize = this.content.getContentSize();
        var scrollviewSize = this.node.getContentSize();
        var totalMoveWidth = contentSize.width - scrollviewSize.width;
        var totalMoveHeight = contentSize.height - scrollviewSize.height;
        var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
        var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
        targetDelta = cc.v2(targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake));
        var originalMoveLength = deltaMove.mag();
        var factor = targetDelta.mag() / originalMoveLength;
        targetDelta = targetDelta.add(deltaMove);
        if (this.brake > 0 && factor > 7) {
          factor = Math.sqrt(factor);
          targetDelta = deltaMove.mul(factor).add(deltaMove);
        }
        if (this.brake > 0 && factor > 3) {
          factor = 3;
          time *= factor;
        }
        0 === this.brake && factor > 1 && (time *= factor);
        this._startAutoScroll(targetDelta, time, true);
      },
      _calculateAutoScrollTimeByInitalSpeed: function(initalSpeed) {
        return Math.sqrt(Math.sqrt(initalSpeed / 5));
      },
      _startAutoScroll: function(deltaMove, timeInSecond, attenuated) {
        var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
        this._autoScrolling = true;
        this._autoScrollTargetDelta = adjustedDeltaMove;
        this._autoScrollAttenuate = attenuated;
        this._autoScrollStartPosition = this.getContentPosition();
        this._autoScrollTotalTime = timeInSecond;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollBraking = false;
        this._isScrollEndedWithThresholdEventFired = false;
        this._autoScrollBrakingStartPosition = cc.v2(0, 0);
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        if (!currentOutOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
          this._autoScrollCurrentlyOutOfBoundary = true;
          var afterOutOfBoundary = this._getHowMuchOutOfBoundary(adjustedDeltaMove);
          (currentOutOfBoundary.x * afterOutOfBoundary.x > 0 || currentOutOfBoundary.y * afterOutOfBoundary.y > 0) && (this._autoScrollBraking = true);
        }
      },
      _calculateTouchMoveVelocity: function() {
        var totalTime = 0;
        totalTime = this._touchMoveTimeDeltas.reduce((function(a, b) {
          return a + b;
        }), totalTime);
        if (totalTime <= 0 || totalTime >= .5) return cc.v2(0, 0);
        var totalMovement = cc.v2(0, 0);
        totalMovement = this._touchMoveDisplacements.reduce((function(a, b) {
          return a.add(b);
        }), totalMovement);
        return cc.v2(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime);
      },
      _flattenVectorByDirection: function(vector) {
        var result = vector;
        result.x = this.horizontal ? result.x : 0;
        result.y = this.vertical ? result.y : 0;
        return result;
      },
      _moveContent: function(deltaMove, canStartBounceBack) {
        var adjustedMove = this._flattenVectorByDirection(deltaMove);
        var newPosition = this.getContentPosition().add(adjustedMove);
        this.setContentPosition(newPosition);
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        this._updateScrollBar(outOfBoundary);
        this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
      },
      _getContentLeftBoundary: function() {
        var contentPos = this.getContentPosition();
        return contentPos.x - this.content.getAnchorPoint().x * this.content.getContentSize().width;
      },
      _getContentRightBoundary: function() {
        var contentSize = this.content.getContentSize();
        return this._getContentLeftBoundary() + contentSize.width;
      },
      _getContentTopBoundary: function() {
        var contentSize = this.content.getContentSize();
        return this._getContentBottomBoundary() + contentSize.height;
      },
      _getContentBottomBoundary: function() {
        var contentPos = this.getContentPosition();
        return contentPos.y - this.content.getAnchorPoint().y * this.content.getContentSize().height;
      },
      _getHowMuchOutOfBoundary: function(addition) {
        addition = addition || cc.v2(0, 0);
        if (addition.fuzzyEquals(cc.v2(0, 0), EPSILON) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
        var outOfBoundaryAmount = cc.v2(0, 0);
        this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x));
        this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y));
        if (addition.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
          this._outOfBoundaryAmount = outOfBoundaryAmount;
          this._outOfBoundaryAmountDirty = false;
        }
        outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
        return outOfBoundaryAmount;
      },
      _updateScrollBar: function(outOfBoundary) {
        this.horizontalScrollBar && this.horizontalScrollBar._onScroll(outOfBoundary);
        this.verticalScrollBar && this.verticalScrollBar._onScroll(outOfBoundary);
      },
      _onScrollBarTouchBegan: function() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchBegan();
        this.verticalScrollBar && this.verticalScrollBar._onTouchBegan();
      },
      _onScrollBarTouchEnded: function() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchEnded();
        this.verticalScrollBar && this.verticalScrollBar._onTouchEnded();
      },
      _dispatchEvent: function(event) {
        if ("scroll-ended" === event) this._scrollEventEmitMask = 0; else if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
          var flag = 1 << eventMap[event];
          if (this._scrollEventEmitMask & flag) return;
          this._scrollEventEmitMask |= flag;
        }
        cc.Component.EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
        this.node.emit(event, this);
      },
      _adjustContentOutOfBoundary: function() {
        this._outOfBoundaryAmountDirty = true;
        if (this._isOutOfBoundary()) {
          var outOfBoundary = this._getHowMuchOutOfBoundary(cc.v2(0, 0));
          var newPosition = this.getContentPosition().add(outOfBoundary);
          if (this.content) {
            this.content.setPosition(newPosition);
            this._updateScrollBar(0);
          }
        }
      },
      start: function() {
        this._calculateBoundary();
        this.content && cc.director.once(cc.Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
      },
      _hideScrollbar: function() {
        this.horizontalScrollBar && this.horizontalScrollBar.hide();
        this.verticalScrollBar && this.verticalScrollBar.hide();
      },
      _showScrollbar: function() {
        this.horizontalScrollBar && this.horizontalScrollBar.show();
        this.verticalScrollBar && this.verticalScrollBar.show();
      },
      onDisable: function() {
        true;
        this._unregisterEvent();
        this.node.off(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
        this.node.off(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
        if (this.content) {
          this.content.off(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          this.content.off(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
        }
        this._hideScrollbar();
        this.stopAutoScroll();
      },
      onEnable: function() {
        true;
        this._registerEvent();
        this.node.on(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
        this.node.on(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
        if (this.content) {
          this.content.on(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          this.content.on(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
        }
        this._showScrollbar();
      },
      update: function(dt) {
        this._autoScrolling && this._processAutoScrolling(dt);
      }
    });
    cc.ScrollView = module.exports = ScrollView;
  }), {
    "../CCNode": 30,
    "./CCViewGroup": 87
  } ],
  81: [ (function(require, module, exports) {
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var Direction = cc.Enum({
      Horizontal: 0,
      Vertical: 1
    });
    var Slider = cc.Class({
      name: "cc.Slider",
      extends: require("./CCComponent"),
      editor: false,
      ctor: function() {
        this._offset = cc.v2();
        this._touchHandle = false;
        this._dragging = false;
      },
      properties: {
        handle: {
          default: null,
          type: cc.Button,
          tooltip: false,
          notify: function() {
            false;
          }
        },
        direction: {
          default: Direction.Horizontal,
          type: Direction,
          tooltip: false
        },
        progress: {
          default: .5,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: false,
          notify: function() {
            this._updateHandlePosition();
          }
        },
        slideEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: false
        }
      },
      statics: {
        Direction: Direction
      },
      __preload: function() {
        this._updateHandlePosition();
      },
      onEnable: function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
        if (this.handle && this.handle.isValid) {
          this.handle.node.on(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
          this.handle.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.handle.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
      },
      onDisable: function() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
        if (this.handle && this.handle.isValid) {
          this.handle.node.off(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
          this.handle.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.handle.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
      },
      _onHandleDragStart: function(event) {
        this._dragging = true;
        this._touchHandle = true;
        this._offset = this.handle.node.convertToNodeSpaceAR(event.touch.getLocation());
        event.stopPropagation();
      },
      _onTouchBegan: function(event) {
        if (!this.handle) return;
        this._dragging = true;
        this._touchHandle || this._handleSliderLogic(event.touch);
        event.stopPropagation();
      },
      _onTouchMoved: function(event) {
        if (!this._dragging) return;
        this._handleSliderLogic(event.touch);
        event.stopPropagation();
      },
      _onTouchEnded: function(event) {
        this._dragging = false;
        this._touchHandle = false;
        this._offset = cc.v2();
        event.stopPropagation();
      },
      _onTouchCancelled: function(event) {
        this._dragging = false;
        event.stopPropagation();
      },
      _handleSliderLogic: function(touch) {
        this._updateProgress(touch);
        this._emitSlideEvent();
      },
      _emitSlideEvent: function() {
        cc.Component.EventHandler.emitEvents(this.slideEvents, this);
        this.node.emit("slide", this);
      },
      _updateProgress: function(touch) {
        if (!this.handle) return;
        var localTouchPos = this.node.convertToNodeSpaceAR(touch.getLocation());
        this.direction === Direction.Horizontal ? this.progress = misc.clamp01(.5 + (localTouchPos.x - this._offset.x) / this.node.width) : this.progress = misc.clamp01(.5 + (localTouchPos.y - this._offset.y) / this.node.height);
      },
      _updateHandlePosition: function() {
        if (!this.handle) return;
        var handlelocalPos;
        handlelocalPos = this.direction === Direction.Horizontal ? cc.v2(-this.node.width * this.node.anchorX + this.progress * this.node.width, 0) : cc.v2(0, -this.node.height * this.node.anchorY + this.progress * this.node.height);
        var worldSpacePos = this.node.convertToWorldSpaceAR(handlelocalPos);
        this.handle.node.position = this.handle.node.parent.convertToNodeSpaceAR(worldSpacePos);
      }
    });
    cc.Slider = module.exports = Slider;
  }), {
    "../utils/misc": 233,
    "./CCComponent": 67
  } ],
  82: [ (function(require, module, exports) {
    var misc = require("../utils/misc");
    var BlendFactor = require("../platform/CCMacro").BlendFactor;
    var NodeEvent = require("../CCNode").EventType;
    var RenderComponent = require("./CCRenderComponent");
    var RenderFlow = require("../renderer/render-flow");
    var renderer = require("../renderer");
    var renderEngine = require("../renderer/render-engine");
    var gfx = renderEngine.gfx;
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var GraySpriteMaterial = renderEngine.GraySpriteMaterial;
    var RenderData = renderEngine.RenderData;
    var SpriteType = cc.Enum({
      SIMPLE: 0,
      SLICED: 1,
      TILED: 2,
      FILLED: 3,
      MESH: 4
    });
    var FillType = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      RADIAL: 2
    });
    var SizeMode = cc.Enum({
      CUSTOM: 0,
      TRIMMED: 1,
      RAW: 2
    });
    var State = cc.Enum({
      NORMAL: 0,
      GRAY: 1
    });
    var Sprite = cc.Class({
      name: "cc.Sprite",
      extends: RenderComponent,
      ctor: function() {
        this._assembler = null;
        this._graySpriteMaterial = null;
        this._spriteMaterial = null;
      },
      editor: false,
      properties: {
        _spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        _type: SpriteType.SIMPLE,
        _sizeMode: SizeMode.TRIMMED,
        _fillType: 0,
        _fillCenter: cc.v2(0, 0),
        _fillStart: 0,
        _fillRange: 0,
        _isTrimmedMode: true,
        _state: 0,
        _srcBlendFactor: BlendFactor.SRC_ALPHA,
        _dstBlendFactor: BlendFactor.ONE_MINUS_SRC_ALPHA,
        _atlas: {
          default: null,
          type: cc.SpriteAtlas,
          tooltip: false,
          editorOnly: true,
          visible: true,
          animatable: false
        },
        spriteFrame: {
          get: function() {
            return this._spriteFrame;
          },
          set: function(value, force) {
            var lastSprite = this._spriteFrame;
            false;
            if (lastSprite === value) return;
            this._spriteFrame = value;
            (this._material && this._material._texture) !== (value && value._texture) && this.markForRender(false);
            this.markForUpdateRenderData(false);
            this._applySpriteFrame(lastSprite);
            false;
          },
          type: cc.SpriteFrame
        },
        type: {
          get: function() {
            return this._type;
          },
          set: function(value) {
            if (this._type !== value) {
              this.destroyRenderData(this._renderData);
              this._renderData = null;
              this._type = value;
              this._updateAssembler();
            }
          },
          type: SpriteType,
          animatable: false,
          tooltip: false
        },
        fillType: {
          get: function() {
            return this._fillType;
          },
          set: function(value) {
            if (value !== this._fillType) {
              if (value === FillType.RADIAL || this._fillType === FillType.RADIAL) {
                this.destroyRenderData(this._renderData);
                this._renderData = null;
              } else this._renderData && this.markForUpdateRenderData(true);
              this._fillType = value;
              this._updateAssembler();
            }
          },
          type: FillType,
          tooltip: false
        },
        fillCenter: {
          get: function() {
            return this._fillCenter;
          },
          set: function(value) {
            this._fillCenter = cc.v2(value);
            this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData(true);
          },
          tooltip: false
        },
        fillStart: {
          get: function() {
            return this._fillStart;
          },
          set: function(value) {
            this._fillStart = misc.clampf(value, -1, 1);
            this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData(true);
          },
          tooltip: false
        },
        fillRange: {
          get: function() {
            return this._fillRange;
          },
          set: function(value) {
            this._fillRange = misc.clampf(value, -1, 1);
            this._type === SpriteType.FILLED && this._renderData && this.markForUpdateRenderData(true);
          },
          tooltip: false
        },
        trim: {
          get: function() {
            return this._isTrimmedMode;
          },
          set: function(value) {
            if (this._isTrimmedMode !== value) {
              this._isTrimmedMode = value;
              this._type !== SpriteType.SIMPLE && this._type !== SpriteType.MESH || !this._renderData || this.markForUpdateRenderData(true);
            }
          },
          animatable: false,
          tooltip: false
        },
        srcBlendFactor: {
          get: function() {
            return this._srcBlendFactor;
          },
          set: function(value) {
            this._srcBlendFactor = value;
            this._updateBlendFunc();
          },
          animatable: false,
          type: BlendFactor,
          tooltip: false
        },
        dstBlendFactor: {
          get: function() {
            return this._dstBlendFactor;
          },
          set: function(value) {
            this._dstBlendFactor = value;
            this._updateBlendFunc();
          },
          animatable: false,
          type: BlendFactor,
          tooltip: false
        },
        sizeMode: {
          get: function() {
            return this._sizeMode;
          },
          set: function(value) {
            this._sizeMode = value;
            value !== SizeMode.CUSTOM && this._applySpriteSize();
          },
          animatable: false,
          type: SizeMode,
          tooltip: false
        }
      },
      statics: {
        FillType: FillType,
        Type: SpriteType,
        SizeMode: SizeMode,
        State: State
      },
      setVisible: function(visible) {
        this.enabled = visible;
      },
      setState: function(state) {
        if (this._state === state) return;
        this._state = state;
        this._activateMaterial();
      },
      getState: function() {
        return this._state;
      },
      onEnable: function() {
        this._super();
        this._spriteFrame && this._spriteFrame.textureLoaded() || this.disableRender();
        this._updateAssembler();
        this._renderData.uvDirty = true;
        this.node.on(NodeEvent.SIZE_CHANGED, this._onNodeSizeDirty, this);
        this.node.on(NodeEvent.ANCHOR_CHANGED, this._onNodeSizeDirty, this);
      },
      onDisable: function() {
        this._super();
        this.node.off(NodeEvent.SIZE_CHANGED, this._onNodeSizeDirty, this);
        this.node.off(NodeEvent.ANCHOR_CHANGED, this._onNodeSizeDirty, this);
      },
      _onNodeSizeDirty: function() {
        if (!this._renderData) return;
        this.markForUpdateRenderData(true);
      },
      _updateAssembler: function() {
        var assembler = Sprite._assembler.getAssembler(this);
        if (this._assembler !== assembler) {
          this._assembler = assembler;
          this._renderData = null;
        }
        if (!this._renderData) {
          this._renderData = this._assembler.createData(this);
          this._renderData.material = this._material;
          this.markForUpdateRenderData(true);
        }
      },
      _activateMaterial: function() {
        if (!this.enabledInHierarchy) {
          this.disableRender();
          return;
        }
        var spriteFrame = this._spriteFrame;
        if (!spriteFrame || !spriteFrame.textureLoaded()) {
          this.disableRender();
          return;
        }
        var texture = spriteFrame.getTexture();
        var material = void 0;
        if (this._state === State.GRAY) {
          this._graySpriteMaterial || (this._graySpriteMaterial = new GraySpriteMaterial());
          material = this._graySpriteMaterial;
        } else {
          this._spriteMaterial || (this._spriteMaterial = new SpriteMaterial());
          material = this._spriteMaterial;
          material.color = this.node.color;
        }
        material.texture = texture;
        this._renderData && (this._renderData.material = material);
        this._material = material;
        this.srcBlendFactor !== gfx.BLEND_SRC_ALPHA || this.dstBlendFactor !== gfx.BLEND_ONE_MINUS_SRC_ALPHA ? this._updateBlendFunc() : material.updateHash();
        this.markForUpdateRenderData(true);
        this.markForRender(true);
      },
      _updateBlendFunc: function() {
        if (!this._material) return;
        var pass = this._material._mainTech.passes[0];
        pass.setBlend(gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor, gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor);
        this._material.updateHash();
      },
      _applyAtlas: false,
      markForUpdateRenderData: function(enable) {
        enable && this._material && this.enabledInHierarchy ? this.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA : enable || (this.node._renderFlag &= ~RenderFlow.FLAG_UPDATE_RENDER_DATA);
        var renderData = this._renderData;
        if (renderData && enable) {
          renderData.uvDirty = true;
          renderData.vertDirty = true;
        }
      },
      _applySpriteSize: function() {
        if (this._spriteFrame) {
          if (SizeMode.RAW === this._sizeMode) {
            var size = this._spriteFrame.getOriginalSize();
            this.node.setContentSize(size);
          } else if (SizeMode.TRIMMED === this._sizeMode) {
            var rect = this._spriteFrame.getRect();
            this.node.setContentSize(rect.width, rect.height);
          }
          this._activateMaterial();
        }
      },
      _onTextureLoaded: function(event) {
        if (!this.isValid) return;
        this._applySpriteSize();
      },
      _applySpriteFrame: function(oldFrame) {
        oldFrame && oldFrame.off && oldFrame.off("load", this._onTextureLoaded, this);
        var spriteFrame = this._spriteFrame;
        if (spriteFrame) if (oldFrame && spriteFrame._texture === oldFrame._texture) this._applySpriteSize(); else if (spriteFrame.textureLoaded()) this._onTextureLoaded(null); else {
          spriteFrame.once("load", this._onTextureLoaded, this);
          spriteFrame.ensureLoadTexture();
        }
        false;
      },
      _resized: false
    });
    false;
    cc.Sprite = module.exports = Sprite;
  }), {
    "../CCNode": 30,
    "../platform/CCMacro": 160,
    "../renderer": 196,
    "../renderer/render-engine": 197,
    "../renderer/render-flow": 198,
    "../utils/misc": 233,
    "./CCRenderComponent": 77
  } ],
  83: [ (function(require, module, exports) {
    var ComponentType = cc.Enum({
      NONE: 0,
      CHECKBOX: 1,
      TEXT_ATLAS: 2,
      SLIDER_BAR: 3,
      LIST_VIEW: 4,
      PAGE_VIEW: 5
    });
    var ListDirection = cc.Enum({
      VERTICAL: 0,
      HORIZONTAL: 1
    });
    var VerticalAlign = cc.Enum({
      TOP: 0,
      CENTER: 1,
      BOTTOM: 2
    });
    var HorizontalAlign = cc.Enum({
      LEFT: 0,
      CENTER: 1,
      RIGHT: 2
    });
    var StudioComponent = cc.Class({
      name: "cc.StudioComponent",
      extends: cc.Component,
      editor: false,
      properties: false,
      statics: {
        ComponentType: ComponentType,
        ListDirection: ListDirection,
        VerticalAlign: VerticalAlign,
        HorizontalAlign: HorizontalAlign
      }
    });
    var PrefabHelper = require("../utils/prefab-helper");
    StudioComponent.PlaceHolder = cc.Class({
      name: "cc.StudioComponent.PlaceHolder",
      extends: cc.Component,
      properties: {
        _baseUrl: "",
        nestedPrefab: cc.Prefab
      },
      onLoad: function() {
        if (!this.nestedPrefab) {
          false;
          return;
        }
        this._replaceWithNestedPrefab();
      },
      _replaceWithNestedPrefab: function() {
        var node = this.node;
        var _prefab = node._prefab;
        _prefab.root = node;
        _prefab.asset = this.nestedPrefab;
        PrefabHelper.syncWithPrefab(node);
      }
    });
    cc.StudioComponent = module.exports = StudioComponent;
  }), {
    "../utils/prefab-helper": 236
  } ],
  84: [ (function(require, module, exports) {
    var Toggle = cc.Class({
      name: "cc.Toggle",
      extends: require("./CCButton"),
      editor: false,
      properties: {
        isChecked: {
          default: true,
          tooltip: false,
          notify: function() {
            this._updateCheckMark();
          }
        },
        toggleGroup: {
          default: null,
          tooltip: false,
          type: require("./CCToggleGroup")
        },
        checkMark: {
          default: null,
          type: cc.Sprite,
          tooltip: false
        },
        checkEvents: {
          default: [],
          type: cc.Component.EventHandler
        },
        _resizeToTarget: {
          animatable: false,
          set: function(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      onEnable: function() {
        this._super();
        true;
        this._registerToggleEvent();
        this.toggleGroup && this.toggleGroup.enabled && this.toggleGroup.addToggle(this);
      },
      onDisable: function() {
        this._super();
        true;
        this._unregisterToggleEvent();
        this.toggleGroup && this.toggleGroup.enabled && this.toggleGroup.removeToggle(this);
      },
      _updateCheckMark: function() {
        this.checkMark && (this.checkMark.node.active = !!this.isChecked);
      },
      _updateDisabledState: function() {
        this._super();
        this.checkMark && this.checkMark.setState(0);
        this.enableAutoGrayEffect && this.checkMark && !this.interactable && this.checkMark.setState(1);
      },
      _registerToggleEvent: function() {
        this.node.on("click", this.toggle, this);
      },
      _unregisterToggleEvent: function() {
        this.node.off("click", this.toggle, this);
      },
      toggle: function(event) {
        var group = this.toggleGroup || this._toggleContainer;
        if (group && group.enabled && this.isChecked && !group.allowSwitchOff) return;
        this.isChecked = !this.isChecked;
        this._updateCheckMark();
        group && group.enabled && group.updateToggles(this);
        this._emitToggleEvents(event);
      },
      _emitToggleEvents: function() {
        this.node.emit("toggle", this);
        this.checkEvents && cc.Component.EventHandler.emitEvents(this.checkEvents, this);
      },
      check: function() {
        var group = this.toggleGroup || this._toggleContainer;
        if (group && group.enabled && this.isChecked && !group.allowSwitchOff) return;
        this.isChecked = true;
        group && group.enabled && group.updateToggles(this);
        this._emitToggleEvents();
      },
      uncheck: function() {
        var group = this.toggleGroup || this._toggleContainer;
        if (group && group.enabled && this.isChecked && !group.allowSwitchOff) return;
        this.isChecked = false;
        this._emitToggleEvents();
      }
    });
    cc.Toggle = module.exports = Toggle;
    var js = require("../platform/js");
    js.get(Toggle.prototype, "_toggleContainer", (function() {
      var parent = this.node.parent;
      if (cc.Node.isNode(parent)) return parent.getComponent(cc.ToggleContainer);
      return null;
    }));
  }), {
    "../platform/js": 175,
    "./CCButton": 65,
    "./CCToggleGroup": 86
  } ],
  85: [ (function(require, module, exports) {
    var ToggleContainer = cc.Class({
      name: "cc.ToggleContainer",
      extends: cc.Component,
      editor: false,
      properties: {
        allowSwitchOff: {
          tooltip: false,
          default: false
        }
      },
      updateToggles: function(toggle) {
        this.toggleItems.forEach((function(item) {
          toggle.isChecked && item !== toggle && (item.isChecked = false);
        }));
      },
      _allowOnlyOneToggleChecked: function() {
        var isChecked = false;
        this.toggleItems.forEach((function(item) {
          isChecked ? item.isChecked = false : item.isChecked && (isChecked = true);
        }));
        return isChecked;
      },
      _makeAtLeastOneToggleChecked: function() {
        var isChecked = this._allowOnlyOneToggleChecked();
        if (!isChecked && !this.allowSwitchOff) {
          var toggleItems = this.toggleItems;
          toggleItems.length > 0 && toggleItems[0].check();
        }
      },
      onEnable: function() {
        this.node.on("child-added", this._allowOnlyOneToggleChecked, this);
        this.node.on("child-removed", this._makeAtLeastOneToggleChecked, this);
      },
      onDisable: function() {
        this.node.off("child-added", this._allowOnlyOneToggleChecked, this);
        this.node.off("child-removed", this._makeAtLeastOneToggleChecked, this);
      },
      start: function() {
        this._makeAtLeastOneToggleChecked();
      }
    });
    var js = require("../platform/js");
    js.get(ToggleContainer.prototype, "toggleItems", (function() {
      return this.node.getComponentsInChildren(cc.Toggle);
    }));
    cc.ToggleContainer = module.exports = ToggleContainer;
  }), {
    "../platform/js": 175
  } ],
  86: [ (function(require, module, exports) {
    var ToggleGroup = cc.Class({
      name: "cc.ToggleGroup",
      extends: cc.Component,
      ctor: function() {
        this._toggleItems = [];
      },
      editor: false,
      properties: {
        allowSwitchOff: {
          tooltip: false,
          default: false
        },
        toggleItems: {
          get: function() {
            return this._toggleItems;
          }
        }
      },
      updateToggles: function(toggle) {
        if (!this.enabledInHierarchy) return;
        this._toggleItems.forEach((function(item) {
          toggle.isChecked && item !== toggle && item.isChecked && item.enabled && (item.isChecked = false);
        }));
      },
      addToggle: function(toggle) {
        var index = this._toggleItems.indexOf(toggle);
        -1 === index && this._toggleItems.push(toggle);
        this._allowOnlyOneToggleChecked();
      },
      removeToggle: function(toggle) {
        var index = this._toggleItems.indexOf(toggle);
        index > -1 && this._toggleItems.splice(index, 1);
        this._makeAtLeastOneToggleChecked();
      },
      _allowOnlyOneToggleChecked: function() {
        var isChecked = false;
        this._toggleItems.forEach((function(item) {
          isChecked && item.enabled && (item.isChecked = false);
          item.isChecked && item.enabled && (isChecked = true);
        }));
        return isChecked;
      },
      _makeAtLeastOneToggleChecked: function() {
        var isChecked = this._allowOnlyOneToggleChecked();
        isChecked || this.allowSwitchOff || this._toggleItems.length > 0 && (this._toggleItems[0].isChecked = true);
      },
      start: function() {
        this._makeAtLeastOneToggleChecked();
      }
    });
    var js = require("../platform/js");
    var showed = false;
    js.get(cc, "ToggleGroup", (function() {
      if (!showed) {
        cc.logID(1405, "cc.ToggleGroup", "cc.ToggleContainer");
        showed = true;
      }
      return ToggleGroup;
    }));
    module.exports = ToggleGroup;
  }), {
    "../platform/js": 175
  } ],
  87: [ (function(require, module, exports) {
    var ViewGroup = cc.Class({
      name: "cc.ViewGroup",
      extends: require("./CCComponent")
    });
    cc.ViewGroup = module.exports = ViewGroup;
  }), {
    "./CCComponent": 67
  } ],
  88: [ (function(require, module, exports) {
    var WidgetManager = require("../base-ui/CCWidgetManager");
    var AlignMode = WidgetManager.AlignMode;
    var AlignFlags = WidgetManager._AlignFlags;
    var TOP = AlignFlags.TOP;
    var MID = AlignFlags.MID;
    var BOT = AlignFlags.BOT;
    var LEFT = AlignFlags.LEFT;
    var CENTER = AlignFlags.CENTER;
    var RIGHT = AlignFlags.RIGHT;
    var TOP_BOT = TOP | BOT;
    var LEFT_RIGHT = LEFT | RIGHT;
    var Widget = cc.Class({
      name: "cc.Widget",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        target: {
          get: function() {
            return this._target;
          },
          set: function(value) {
            this._target = value;
            false;
          },
          type: cc.Node,
          tooltip: false
        },
        isAlignTop: {
          get: function() {
            return (this._alignFlags & TOP) > 0;
          },
          set: function(value) {
            this._setAlign(TOP, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignVerticalCenter: {
          get: function() {
            return (this._alignFlags & MID) > 0;
          },
          set: function(value) {
            if (value) {
              this.isAlignTop = false;
              this.isAlignBottom = false;
              this._alignFlags |= MID;
            } else this._alignFlags &= ~MID;
          },
          animatable: false,
          tooltip: false
        },
        isAlignBottom: {
          get: function() {
            return (this._alignFlags & BOT) > 0;
          },
          set: function(value) {
            this._setAlign(BOT, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignLeft: {
          get: function() {
            return (this._alignFlags & LEFT) > 0;
          },
          set: function(value) {
            this._setAlign(LEFT, value);
          },
          animatable: false,
          tooltip: false
        },
        isAlignHorizontalCenter: {
          get: function() {
            return (this._alignFlags & CENTER) > 0;
          },
          set: function(value) {
            if (value) {
              this.isAlignLeft = false;
              this.isAlignRight = false;
              this._alignFlags |= CENTER;
            } else this._alignFlags &= ~CENTER;
          },
          animatable: false,
          tooltip: false
        },
        isAlignRight: {
          get: function() {
            return (this._alignFlags & RIGHT) > 0;
          },
          set: function(value) {
            this._setAlign(RIGHT, value);
          },
          animatable: false,
          tooltip: false
        },
        isStretchWidth: {
          get: function() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
          },
          visible: false
        },
        isStretchHeight: {
          get: function() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
          },
          visible: false
        },
        top: {
          get: function() {
            return this._top;
          },
          set: function(value) {
            this._top = value;
          },
          tooltip: false
        },
        bottom: {
          get: function() {
            return this._bottom;
          },
          set: function(value) {
            this._bottom = value;
          },
          tooltip: false
        },
        left: {
          get: function() {
            return this._left;
          },
          set: function(value) {
            this._left = value;
          },
          tooltip: false
        },
        right: {
          get: function() {
            return this._right;
          },
          set: function(value) {
            this._right = value;
          },
          tooltip: false
        },
        horizontalCenter: {
          get: function() {
            return this._horizontalCenter;
          },
          set: function(value) {
            this._horizontalCenter = value;
          },
          tooltip: false
        },
        verticalCenter: {
          get: function() {
            return this._verticalCenter;
          },
          set: function(value) {
            this._verticalCenter = value;
          },
          tooltip: false
        },
        isAbsoluteHorizontalCenter: {
          get: function() {
            return this._isAbsHorizontalCenter;
          },
          set: function(value) {
            this._isAbsHorizontalCenter = value;
          },
          animatable: false
        },
        isAbsoluteVerticalCenter: {
          get: function() {
            return this._isAbsVerticalCenter;
          },
          set: function(value) {
            this._isAbsVerticalCenter = value;
          },
          animatable: false
        },
        isAbsoluteTop: {
          get: function() {
            return this._isAbsTop;
          },
          set: function(value) {
            this._isAbsTop = value;
          },
          animatable: false
        },
        isAbsoluteBottom: {
          get: function() {
            return this._isAbsBottom;
          },
          set: function(value) {
            this._isAbsBottom = value;
          },
          animatable: false
        },
        isAbsoluteLeft: {
          get: function() {
            return this._isAbsLeft;
          },
          set: function(value) {
            this._isAbsLeft = value;
          },
          animatable: false
        },
        isAbsoluteRight: {
          get: function() {
            return this._isAbsRight;
          },
          set: function(value) {
            this._isAbsRight = value;
          },
          animatable: false
        },
        alignMode: {
          default: AlignMode.ON_WINDOW_RESIZE,
          type: AlignMode,
          tooltip: false
        },
        _wasAlignOnce: {
          default: void 0,
          formerlySerializedAs: "isAlignOnce"
        },
        _target: null,
        _alignFlags: 0,
        _left: 0,
        _right: 0,
        _top: 0,
        _bottom: 0,
        _verticalCenter: 0,
        _horizontalCenter: 0,
        _isAbsLeft: true,
        _isAbsRight: true,
        _isAbsTop: true,
        _isAbsBottom: true,
        _isAbsHorizontalCenter: true,
        _isAbsVerticalCenter: true,
        _originalWidth: 0,
        _originalHeight: 0
      },
      statics: {
        AlignMode: AlignMode
      },
      onLoad: function() {
        if (void 0 !== this._wasAlignOnce) {
          this.alignMode = this._wasAlignOnce ? AlignMode.ONCE : AlignMode.ALWAYS;
          this._wasAlignOnce = void 0;
        }
      },
      onEnable: function() {
        WidgetManager.add(this);
      },
      onDisable: function() {
        WidgetManager.remove(this);
      },
      _setAlign: function(flag, isAlign) {
        var current = (this._alignFlags & flag) > 0;
        if (isAlign == current) return;
        var isHorizontal = (flag & LEFT_RIGHT) > 0;
        if (isAlign) {
          this._alignFlags |= flag;
          if (isHorizontal) {
            this.isAlignHorizontalCenter = false;
            if (this.isStretchWidth) {
              this._originalWidth = this.node.width;
              false;
            }
          } else {
            this.isAlignVerticalCenter = false;
            if (this.isStretchHeight) {
              this._originalHeight = this.node.height;
              false;
            }
          }
          false;
        } else {
          isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight);
          this._alignFlags &= ~flag;
        }
      },
      updateAlignment: function() {
        WidgetManager.updateAlignment(this.node);
      }
    });
    Object.defineProperty(Widget.prototype, "isAlignOnce", {
      get: function() {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode === cc.Widget.AlignMode.ONCE` instead please.");
        return this.alignMode === AlignMode.ONCE;
      },
      set: function(value) {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode = cc.Widget.AlignMode.*` instead please.");
        this.alignMode = value ? AlignMode.ONCE : AlignMode.ALWAYS;
      }
    });
    cc.Widget = module.exports = Widget;
  }), {
    "../base-ui/CCWidgetManager": 51,
    "./CCComponent": 67
  } ],
  89: [ (function(require, module, exports) {
    var macro = require("../../platform/CCMacro");
    var EditBoxImpl = require("../editbox/CCEditBoxImpl");
    var Label = require("../CCLabel");
    var Types = require("./types");
    var InputMode = Types.InputMode;
    var InputFlag = Types.InputFlag;
    var KeyboardReturnType = Types.KeyboardReturnType;
    var LEFT_PADDING = 2;
    function capitalize(string) {
      return string.replace(/(?:^|\s)\S/g, (function(a) {
        return a.toUpperCase();
      }));
    }
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    var EditBox = cc.Class({
      name: "cc.EditBox",
      extends: cc.Component,
      editor: false,
      properties: {
        _useOriginalSize: true,
        _string: "",
        string: {
          tooltip: false,
          get: function() {
            return this._string;
          },
          set: function(value) {
            value.length >= this.maxLength && (value = value.slice(0, this.maxLength));
            this._string = value;
            this._updateString(value);
          }
        },
        backgroundImage: {
          tooltip: false,
          default: null,
          type: cc.SpriteFrame,
          notify: function() {
            this._createBackgroundSprite();
          }
        },
        returnType: {
          default: KeyboardReturnType.DEFAULT,
          tooltip: false,
          displayName: "KeyboardReturnType",
          type: KeyboardReturnType,
          notify: function() {
            this._impl.returnType = this.returnType;
          }
        },
        inputFlag: {
          tooltip: false,
          default: InputFlag.DEFAULT,
          type: InputFlag,
          notify: function() {
            this._impl.inputFlag = this.inputFlag;
          }
        },
        inputMode: {
          tooltip: false,
          default: InputMode.ANY,
          type: InputMode,
          notify: function() {
            this._impl.setInputMode(this.inputMode);
          }
        },
        fontSize: {
          tooltip: false,
          default: 20,
          notify: function() {
            this._textLabel.fontSize = this.fontSize;
          }
        },
        lineHeight: {
          tooltip: false,
          default: 40,
          notify: function() {
            this._textLabel.lineHeight = this.lineHeight;
          }
        },
        fontColor: {
          tooltip: false,
          default: cc.Color.WHITE,
          notify: function() {
            this._textLabel.node.color = this.fontColor;
          }
        },
        placeholder: {
          tooltip: false,
          default: "Enter text here...",
          notify: function() {
            this._placeholderLabel.string = this.placeholder;
          }
        },
        placeholderFontSize: {
          tooltip: false,
          default: 20,
          notify: function() {
            this._placeholderLabel.fontSize = this.placeholderFontSize;
          }
        },
        placeholderFontColor: {
          tooltip: false,
          default: cc.Color.GRAY,
          notify: function() {
            this._placeholderLabel.node.color = this.placeholderFontColor;
          }
        },
        maxLength: {
          tooltip: false,
          default: 20,
          notify: function() {
            this._impl.setMaxLength(this.maxLength);
          }
        },
        stayOnTop: {
          tooltip: false,
          default: false,
          notify: function() {
            this._updateStayOnTop();
          }
        },
        _tabIndex: 0,
        tabIndex: {
          tooltip: false,
          get: function() {
            return this._tabIndex;
          },
          set: function(value) {
            this._tabIndex = value;
            this._impl.setTabIndex(value);
          }
        },
        editingDidBegan: {
          default: [],
          type: cc.Component.EventHandler
        },
        textChanged: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingDidEnded: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingReturn: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        _EditBoxImpl: EditBoxImpl,
        KeyboardReturnType: KeyboardReturnType,
        InputFlag: InputFlag,
        InputMode: InputMode
      },
      _init: function() {
        this._createBackgroundSprite();
        this._createLabels();
        var impl = this._impl = new EditBoxImpl();
        impl.setNode(this.node);
        impl.setInputMode(this.inputMode);
        impl.setMaxLength(this.maxLength);
        impl.setInputFlag(this.inputFlag);
        impl.setReturnType(this.returnType);
        impl.setTabIndex(this.tabIndex);
        impl.setFontColor(this.fontColor);
        impl.setFontSize(this.fontSize);
        impl.setDelegate(this);
        this._updateStayOnTop();
        this._updateString(this.string);
        this._syncSize();
      },
      _updateStayOnTop: function() {
        this.stayOnTop ? this._hideLabels() : this._showLabels();
        this._impl.stayOnTop(this.stayOnTop);
      },
      _syncSize: function() {
        var size = this.node.getContentSize();
        this._background.node.setAnchorPoint(this.node.getAnchorPoint());
        this._background.node.setContentSize(size);
        this._updateLabelPosition(size);
        this._impl.setSize(size.width, size.height);
      },
      _updateLabelPosition: function(size) {
        var node = this.node;
        var offx = -node.anchorX * node.width;
        var offy = -node.anchorY * node.height;
        var placeholderLabel = this._placeholderLabel;
        var textLabel = this._textLabel;
        textLabel.node.setContentSize(size.width - LEFT_PADDING, size.height);
        placeholderLabel.node.setContentSize(size.width - LEFT_PADDING, size.height);
        placeholderLabel.lineHeight = size.height;
        placeholderLabel.node.setPosition(offx + LEFT_PADDING, offy + size.height);
        textLabel.node.setPosition(offx + LEFT_PADDING, offy + size.height);
        if (this.inputMode === InputMode.ANY) {
          placeholderLabel.verticalAlign = macro.VerticalTextAlignment.TOP;
          textLabel.verticalAlign = macro.VerticalTextAlignment.TOP;
          textLabel.enableWrapText = true;
        } else {
          placeholderLabel.verticalAlign = macro.VerticalTextAlignment.CENTER;
          textLabel.verticalAlign = macro.VerticalTextAlignment.CENTER;
          textLabel.enableWrapText = false;
        }
      },
      _createBackgroundSprite: function() {
        var background = this._background;
        if (!background) {
          var node = this.node.getChildByName("BACKGROUND_SPRITE");
          node || (node = new cc.Node("BACKGROUND_SPRITE"));
          background = node.getComponent(cc.Sprite);
          background || (background = node.addComponent(cc.Sprite));
          background.type = cc.Sprite.Type.SLICED;
          node.parent = this.node;
          this._background = background;
        }
        background.spriteFrame = this.backgroundImage;
      },
      _createLabels: function() {
        if (!this._textLabel) {
          var node = this.node.getChildByName("TEXT_LABEL");
          node || (node = new cc.Node("TEXT_LABEL"));
          node.color = this.fontColor;
          node.parent = this.node;
          node.setAnchorPoint(0, 1);
          var textLabel = node.getComponent(Label);
          textLabel || (textLabel = node.addComponent(Label));
          textLabel.overflow = Label.Overflow.CLAMP;
          textLabel.fontSize = this.fontSize;
          textLabel.lineHeight = this.lineHeight;
          this._textLabel = textLabel;
        }
        if (!this._placeholderLabel) {
          var _node = this.node.getChildByName("PLACEHOLDER_LABEL");
          _node || (_node = new cc.Node("PLACEHOLDER_LABEL"));
          _node.color = this.placeholderFontColor;
          _node.parent = this.node;
          _node.setAnchorPoint(0, 1);
          var placeholderLabel = _node.getComponent(Label);
          placeholderLabel || (placeholderLabel = _node.addComponent(Label));
          placeholderLabel.overflow = Label.Overflow.CLAMP;
          placeholderLabel.fontSize = this.placeholderFontSize;
          placeholderLabel.string = this.placeholder;
          this._placeholderLabel = placeholderLabel;
        }
      },
      _showLabels: function() {
        var displayText = this._textLabel.string;
        this._textLabel.node.active = "" !== displayText;
        this._placeholderLabel.node.active = "" === displayText;
      },
      _hideLabels: function() {
        this._textLabel.node.active = false;
        this._placeholderLabel.node.active = false;
      },
      _updateString: function(text) {
        var placeholderLabel = this._placeholderLabel;
        var textLabel = this._textLabel;
        var displayText = text;
        displayText && (displayText = this._updateLabelStringStyle(displayText));
        textLabel.string = displayText;
        this._impl.setString(text);
      },
      _updateLabelStringStyle: function(text, ignorePassword) {
        var inputFlag = this.inputFlag;
        if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = capitalize(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = capitalizeFirstLetter(text)); else {
          var passwordString = "";
          var len = text.length;
          for (var i = 0; i < len; ++i) passwordString += "\u25cf";
          text = passwordString;
        }
        return text;
      },
      editBoxEditingDidBegan: function() {
        this._hideLabels();
        cc.Component.EventHandler.emitEvents(this.editingDidBegan, this);
        this.node.emit("editing-did-began", this);
      },
      editBoxEditingDidEnded: function() {
        this.stayOnTop || this._showLabels();
        cc.Component.EventHandler.emitEvents(this.editingDidEnded, this);
        this.node.emit("editing-did-ended", this);
      },
      editBoxTextChanged: function(text) {
        text = this._updateLabelStringStyle(text, true);
        this.string = text;
        cc.Component.EventHandler.emitEvents(this.textChanged, text, this);
        this.node.emit("text-changed", this);
      },
      editBoxEditingReturn: function() {
        cc.Component.EventHandler.emitEvents(this.editingReturn, this);
        this.node.emit("editing-return", this);
      },
      onDestroy: function() {
        this._impl.clear();
      },
      __preload: function() {
        true;
        this._registerEvent();
        this._init();
      },
      _registerEvent: function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _onTouchBegan: function(event) {
        this._impl && this._impl._onTouchBegan(event.touch);
        event.stopPropagation();
      },
      _onTouchCancel: function(event) {
        this._impl && this._impl._onTouchCancel();
        event.stopPropagation();
      },
      _onTouchEnded: function(event) {
        this._impl && this._impl._onTouchEnded();
        event.stopPropagation();
      },
      setFocus: function() {
        this._impl && this._impl.setFocus();
      },
      isFocused: function() {
        var isFocused = false;
        this._impl && (isFocused = this._impl.isFocused());
        return isFocused;
      },
      update: function() {
        this._impl && this._impl.update();
      }
    });
    cc.EditBox = module.exports = EditBox;
  }), {
    "../../platform/CCMacro": 160,
    "../CCLabel": 69,
    "../editbox/CCEditBoxImpl": 90,
    "./types": 91
  } ],
  90: [ (function(require, module, exports) {
    var utils = require("../../platform/utils");
    var macro = require("../../platform/CCMacro");
    var Types = require("./types");
    var InputMode = Types.InputMode;
    var InputFlag = Types.InputFlag;
    var KeyboardReturnType = Types.KeyboardReturnType;
    var SCROLLY = 40;
    var LEFT_PADDING = 2;
    var DELAY_TIME = 400;
    var FOCUS_DELAY_UC = 400;
    var FOCUS_DELAY_FIREFOX = 0;
    var math = cc.vmath;
    var _matrix = math.mat4.create();
    var _vec3 = cc.v3();
    var polyfill = {
      zoomInvalid: false
    };
    cc.sys.OS_ANDROID !== cc.sys.os || cc.sys.browserType !== cc.sys.BROWSER_TYPE_SOUGOU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = true);
    function getKeyboardReturnType(type) {
      switch (type) {
       case KeyboardReturnType.DEFAULT:
       case KeyboardReturnType.DONE:
        return "done";

       case KeyboardReturnType.SEND:
        return "send";

       case KeyboardReturnType.SEARCH:
        return "search";

       case KeyboardReturnType.GO:
        return "go";

       case KeyboardReturnType.NEXT:
        return "next";
      }
      return "done";
    }
    var EditBoxImpl = cc.Class({
      ctor: function() {
        this._delegate = null;
        this._inputMode = -1;
        this._inputFlag = -1;
        this._returnType = KeyboardReturnType.DEFAULT;
        this._maxLength = 50;
        this._text = "";
        this._placeholderText = "";
        this._alwaysOnTop = false;
        this._size = cc.size();
        this._node = null;
        this._editing = false;
        this.__eventListeners = {};
        this.__fullscreen = false;
        this.__autoResize = false;
        this.__rotateScreen = false;
        this.__orientationChanged = null;
      },
      setTabIndex: function(index) {
        this._edTxt && (this._edTxt.tabIndex = index);
      },
      setFocus: function() {
        this._edTxt && this._edTxt.focus();
      },
      isFocused: function() {
        if (this._edTxt) return document.activeElement === this._edTxt;
        cc.warnID(4700);
        return false;
      },
      stayOnTop: function(flag) {
        if (this._alwaysOnTop === flag) return;
        this._alwaysOnTop = flag;
        this._edTxt.style.display = flag ? "" : "none";
      },
      setMaxLength: function(maxLength) {
        if (!isNaN(maxLength)) {
          maxLength < 0 && (maxLength = 65535);
          this._maxLength = maxLength;
          this._edTxt.maxLength = maxLength;
        }
      },
      setString: function(text) {
        this._text = text;
        this._edTxt.value = text;
      },
      getString: function() {
        return this._text;
      },
      setDelegate: function(delegate) {
        this._delegate = delegate;
      },
      setInputMode: function(inputMode) {
        if (this._inputMode === inputMode) return;
        this._inputMode = inputMode;
        true;
        this.createInput();
        this._updateDomInputType();
        this._updateSize(this._size.width, this._size.height);
      },
      setInputFlag: function(inputFlag) {
        if (this._inputFlag === inputFlag) return;
        this._inputFlag = inputFlag;
        this._updateDomInputType();
        var textTransform = "none";
        inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize");
        this._edTxt.style.textTransform = textTransform;
      },
      setReturnType: function(returnType) {
        this._returnType = returnType;
        this._updateDomInputType();
      },
      setFontSize: function(fontSize) {
        this._edFontSize = fontSize || this._edFontSize;
        this._edTxt.style.fontSize = this._edFontSize + "px";
      },
      setFontColor: function(color) {
        this._textColor = color;
        this._edTxt.style.color = color.toHEX();
      },
      setSize: function(width, height) {
        this._size.width = width;
        this._size.height = height;
        this._updateSize(width, height);
      },
      setNode: function(node) {
        this._node = node;
      },
      update: function() {
        this._updateMatrix();
      },
      clear: function() {
        this._node = null;
        this.setDelegate(null);
        this.removeDom();
      },
      _onTouchBegan: function(touch) {
        false;
      },
      _onTouchEnded: function() {
        this._beginEditing();
      },
      _beginEditing: function() {
        var _this = this;
        this._alwaysOnTop || "none" === this._edTxt.style.display && (function() {
          _this._edTxt.style.display = "";
          var self = _this;
          function startFocus() {
            self._edTxt.focus();
          }
          cc.sys.browserType === cc.sys.BROWSER_TYPE_UC ? setTimeout(startFocus, FOCUS_DELAY_UC) : cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX ? setTimeout(startFocus, FOCUS_DELAY_FIREFOX) : startFocus();
        })();
        cc.sys.isMobile && !this._editing && this._beginEditingOnMobile(this._editBox);
        this._editing = true;
      },
      _endEditing: function() {
        var self = this;
        var hideDomInputAndShowLabel = function() {
          self._alwaysOnTop || (self._edTxt.style.display = "none");
          self._delegate && self._delegate.editBoxEditingDidEnded && self._delegate.editBoxEditingDidEnded();
        };
        this._editing && (cc.sys.isMobile ? setTimeout((function() {
          self._endEditingOnMobile();
          hideDomInputAndShowLabel();
        }), DELAY_TIME) : hideDomInputAndShowLabel());
        this._editing = false;
      },
      _updateDomInputType: function() {
        var inputMode = this._inputMode;
        var edTxt = this._edTxt;
        if (this._inputFlag === InputFlag.PASSWORD) {
          edTxt.type = "password";
          return;
        }
        var type = edTxt.type;
        if (inputMode === InputMode.EMAIL_ADDR) type = "email"; else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) type = "number"; else if (inputMode === InputMode.PHONE_NUMBER) {
          type = "number";
          edTxt.pattern = "[0-9]*";
        } else if (inputMode === InputMode.URL) type = "url"; else {
          type = "text";
          this._returnType === KeyboardReturnType.SEARCH && (type = "search");
        }
        edTxt.type = type;
      },
      _updateSize: function(newWidth, newHeight) {
        var edTxt = this._edTxt;
        if (!edTxt) return;
        edTxt.style.width = newWidth + "px";
        edTxt.style.height = newHeight + "px";
      },
      _updateMatrix: function() {
        if (!this._edTxt) return;
        var node = this._node, scaleX = cc.view._scaleX, scaleY = cc.view._scaleY;
        var dpr = cc.view._devicePixelRatio;
        node.getWorldMatrix(_matrix);
        var contentSize = node._contentSize;
        _vec3.x = -node._anchorPoint.x * contentSize.width;
        _vec3.y = -node._anchorPoint.y * contentSize.height;
        math.mat4.translate(_matrix, _matrix, _vec3);
        scaleX /= dpr;
        scaleY /= dpr;
        var container = cc.game.container;
        var a = _matrix.m00 * scaleX, b = _matrix.m01, c = _matrix.m04, d = _matrix.m05 * scaleY;
        var offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
        var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
        var tx = _matrix.m12 * scaleX + offsetX, ty = _matrix.m13 * scaleY + offsetY;
        if (polyfill.zoomInvalid) {
          this._updateSize(this._size.width * a, this._size.height * d);
          a = 1;
          d = 1;
        }
        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
        this._edTxt.style["transform"] = matrix;
        this._edTxt.style["-webkit-transform"] = matrix;
        this._edTxt.style["transform-origin"] = "0px 100% 0px";
        this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
      },
      _adjustEditBoxPosition: function() {
        this._node.getWorldMatrix(_matrix);
        var y = _matrix.m13;
        var windowHeight = cc.visibleRect.height;
        var windowWidth = cc.visibleRect.width;
        var factor = .5;
        windowWidth > windowHeight && (factor = .7);
        setTimeout((function() {
          if (window.scrollY < SCROLLY && y < windowHeight * factor) {
            var scrollOffset = windowHeight * factor - y - window.scrollY;
            scrollOffset < 35 && (scrollOffset = 35);
            scrollOffset > 320 && (scrollOffset = 320);
            window.scrollTo(0, scrollOffset);
          }
        }), DELAY_TIME);
      }
    });
    var _p = EditBoxImpl.prototype;
    _p.createInput = function() {
      this._inputMode === InputMode.ANY ? this._createDomTextArea() : this._createDomInput();
    };
    _p._beginEditingOnMobile = function() {
      this.__orientationChanged = function() {
        this._adjustEditBoxPosition();
      };
      window.addEventListener("orientationchange", this.__orientationChanged);
      if (cc.view.isAutoFullScreenEnabled()) {
        this.__fullscreen = true;
        cc.view.enableAutoFullScreen(false);
        cc.screen.exitFullScreen();
      } else this.__fullscreen = false;
      this.__autoResize = cc.view._resizeWithBrowserSize;
      cc.view.resizeWithBrowserSize(false);
    };
    _p._endEditingOnMobile = function() {
      if (this.__rotateScreen) {
        cc.game.container.style["-webkit-transform"] = "rotate(90deg)";
        cc.game.container.style.transform = "rotate(90deg)";
        var view = cc.view;
        var width = view._originalDesignResolutionSize.width;
        var height = view._originalDesignResolutionSize.height;
        width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy);
        this.__rotateScreen = false;
      }
      window.removeEventListener("orientationchange", this.__orientationChanged);
      window.scrollTo && window.scrollTo(0, 0);
      this.__fullscreen && cc.view.enableAutoFullScreen(true);
      this.__autoResize && cc.view.resizeWithBrowserSize(true);
    };
    function _inputValueHandle(input, editBoxImpl) {
      input.value.length > editBoxImpl._maxLength && (input.value = input.value.slice(0, editBoxImpl._maxLength));
      if (editBoxImpl._delegate && editBoxImpl._delegate.editBoxTextChanged && editBoxImpl._text !== input.value) {
        editBoxImpl._text = input.value;
        editBoxImpl._delegate.editBoxTextChanged(editBoxImpl._text);
      }
    }
    function registerInputEventListener(tmpEdTxt, editBoxImpl, isTextarea) {
      var inputLock = false;
      var cbs = editBoxImpl.__eventListeners;
      cbs.compositionstart = function() {
        inputLock = true;
      };
      tmpEdTxt.addEventListener("compositionstart", cbs.compositionstart);
      cbs.compositionend = function() {
        inputLock = false;
        _inputValueHandle(this, editBoxImpl);
      };
      tmpEdTxt.addEventListener("compositionend", cbs.compositionend);
      cbs.input = function() {
        if (inputLock) return;
        _inputValueHandle(this, editBoxImpl);
      };
      tmpEdTxt.addEventListener("input", cbs.input);
      cbs.focus = function() {
        this.style.fontSize = editBoxImpl._edFontSize + "px";
        this.style.color = editBoxImpl._textColor.toHEX();
        cc.sys.isMobile && editBoxImpl._onFocusOnMobile();
        editBoxImpl._delegate && editBoxImpl._delegate.editBoxEditingDidBegan && editBoxImpl._delegate.editBoxEditingDidBegan();
      };
      tmpEdTxt.addEventListener("focus", cbs.focus);
      cbs.keypress = function(e) {
        if (e.keyCode === macro.KEY.enter) {
          e.stopPropagation();
          editBoxImpl._delegate && editBoxImpl._delegate.editBoxEditingReturn && editBoxImpl._delegate.editBoxEditingReturn();
          if (!isTextarea) {
            editBoxImpl._text = this.value;
            editBoxImpl._endEditing();
            cc.game.canvas.focus();
          }
        }
      };
      tmpEdTxt.addEventListener("keypress", cbs.keypress);
      cbs.blur = function() {
        editBoxImpl._text = this.value;
        editBoxImpl._endEditing();
      };
      tmpEdTxt.addEventListener("blur", cbs.blur);
      editBoxImpl._addDomToGameContainer();
    }
    _p._onFocusOnMobile = function(editBox) {
      if (cc.view._isRotated) {
        cc.game.container.style["-webkit-transform"] = "rotate(0deg)";
        cc.game.container.style.transform = "rotate(0deg)";
        cc.view._isRotated = false;
        var policy = cc.view.getResolutionPolicy();
        policy.apply(cc.view, cc.view.getDesignResolutionSize());
        cc.view._isRotated = true;
        window.scrollTo(35, 35);
        this.__rotateScreen = true;
      } else this.__rotateScreen = false;
      this._adjustEditBoxPosition();
    };
    _p._createDomInput = function() {
      this.removeDom();
      var tmpEdTxt = this._edTxt = document.createElement("input");
      tmpEdTxt.type = "text";
      tmpEdTxt.style.fontSize = this._edFontSize + "px";
      tmpEdTxt.style.color = "#000000";
      tmpEdTxt.style.border = 0;
      tmpEdTxt.style.background = "transparent";
      tmpEdTxt.style.width = "100%";
      tmpEdTxt.style.height = "100%";
      tmpEdTxt.style.active = 0;
      tmpEdTxt.style.outline = "medium";
      tmpEdTxt.style.padding = "0";
      tmpEdTxt.style.textTransform = "uppercase";
      tmpEdTxt.style.display = "none";
      tmpEdTxt.style.position = "absolute";
      tmpEdTxt.style.bottom = "0px";
      tmpEdTxt.style.left = LEFT_PADDING + "px";
      tmpEdTxt.style["-moz-appearance"] = "textfield";
      tmpEdTxt.style.className = "cocosEditBox";
      tmpEdTxt.style.fontFamily = "Arial";
      registerInputEventListener(tmpEdTxt, this);
      return tmpEdTxt;
    };
    _p._createDomTextArea = function() {
      this.removeDom();
      var tmpEdTxt = this._edTxt = document.createElement("textarea");
      tmpEdTxt.type = "text";
      tmpEdTxt.style.fontSize = this._edFontSize + "px";
      tmpEdTxt.style.color = "#000000";
      tmpEdTxt.style.border = 0;
      tmpEdTxt.style.background = "transparent";
      tmpEdTxt.style.width = "100%";
      tmpEdTxt.style.height = "100%";
      tmpEdTxt.style.active = 0;
      tmpEdTxt.style.outline = "medium";
      tmpEdTxt.style.padding = "0";
      tmpEdTxt.style.resize = "none";
      tmpEdTxt.style.textTransform = "uppercase";
      tmpEdTxt.style.overflow_y = "scroll";
      tmpEdTxt.style.display = "none";
      tmpEdTxt.style.position = "absolute";
      tmpEdTxt.style.bottom = "0px";
      tmpEdTxt.style.left = LEFT_PADDING + "px";
      tmpEdTxt.style.className = "cocosEditBox";
      tmpEdTxt.style.fontFamily = "Arial";
      registerInputEventListener(tmpEdTxt, this, true);
      return tmpEdTxt;
    };
    _p._addDomToGameContainer = function() {
      cc.game.container.appendChild(this._edTxt);
    };
    _p.removeDom = function() {
      var edTxt = this._edTxt;
      if (edTxt) {
        var cbs = this.__eventListeners;
        edTxt.removeEventListener("compositionstart", cbs.compositionstart);
        edTxt.removeEventListener("compositionend", cbs.compositionend);
        edTxt.removeEventListener("input", cbs.input);
        edTxt.removeEventListener("focus", cbs.focus);
        edTxt.removeEventListener("keypress", cbs.keypress);
        edTxt.removeEventListener("blur", cbs.blur);
        cbs.compositionstart = null;
        cbs.compositionend = null;
        cbs.input = null;
        cbs.focus = null;
        cbs.keypress = null;
        cbs.blur = null;
        var hasChild = utils.contains(cc.game.container, edTxt);
        hasChild && cc.game.container.removeChild(edTxt);
      }
      this._edTxt = null;
    };
    module.exports = EditBoxImpl;
  }), {
    "../../platform/CCMacro": 160,
    "../../platform/utils": 179,
    "./types": 91
  } ],
  91: [ (function(require, module, exports) {
    var KeyboardReturnType = cc.Enum({
      DEFAULT: 0,
      DONE: 1,
      SEND: 2,
      SEARCH: 3,
      GO: 4,
      NEXT: 5
    });
    var InputMode = cc.Enum({
      ANY: 0,
      EMAIL_ADDR: 1,
      NUMERIC: 2,
      PHONE_NUMBER: 3,
      URL: 4,
      DECIMAL: 5,
      SINGLE_LINE: 6
    });
    var InputFlag = cc.Enum({
      PASSWORD: 0,
      SENSITIVE: 1,
      INITIAL_CAPS_WORD: 2,
      INITIAL_CAPS_SENTENCE: 3,
      INITIAL_CAPS_ALL_CHARACTERS: 4,
      DEFAULT: 5
    });
    module.exports = {
      KeyboardReturnType: KeyboardReturnType,
      InputMode: InputMode,
      InputFlag: InputFlag
    };
  }), {} ],
  92: [ (function(require, module, exports) {
    require("./CCComponent");
    require("./CCComponentEventHandler");
    require("./missing-script");
    var components = [ require("./CCSprite"), require("./CCWidget"), require("./CCCanvas"), require("./CCAudioSource"), require("./CCAnimation"), require("./CCButton"), require("./CCLabel"), require("./CCProgressBar"), require("./CCMask"), require("./CCScrollBar"), require("./CCScrollView"), require("./CCPageViewIndicator"), require("./CCPageView"), require("./CCSlider"), require("./CCLayout"), require("./editbox/CCEditBox"), require("./CCLabelOutline"), require("./CCRichText"), require("./CCToggleContainer"), require("./CCToggleGroup"), require("./CCToggle"), require("./CCBlockInputEvents"), require("./CCMotionStreak") ];
    module.exports = components;
  }), {
    "./CCAnimation": 62,
    "./CCAudioSource": 63,
    "./CCBlockInputEvents": 64,
    "./CCButton": 65,
    "./CCCanvas": 66,
    "./CCComponent": 67,
    "./CCComponentEventHandler": 68,
    "./CCLabel": 69,
    "./CCLabelOutline": 70,
    "./CCLayout": 71,
    "./CCMask": 72,
    "./CCMotionStreak": 73,
    "./CCPageView": 74,
    "./CCPageViewIndicator": 75,
    "./CCProgressBar": 76,
    "./CCRichText": 78,
    "./CCScrollBar": 79,
    "./CCScrollView": 80,
    "./CCSlider": 81,
    "./CCSprite": 82,
    "./CCToggle": 84,
    "./CCToggleContainer": 85,
    "./CCToggleGroup": 86,
    "./CCWidget": 88,
    "./editbox/CCEditBox": 89,
    "./missing-script": 93
  } ],
  93: [ (function(require, module, exports) {
    var js = cc.js;
    var BUILTIN_CLASSID_RE = require("../utils/misc").BUILTIN_CLASSID_RE;
    var MissingClass = cc.Class({
      name: "cc.MissingClass",
      properties: {
        _$erialized: {
          default: null,
          visible: false,
          editorOnly: true
        }
      }
    });
    var MissingScript = cc.Class({
      name: "cc.MissingScript",
      extends: cc.Component,
      editor: {
        inspector: "packages://inspector/inspectors/comps/missing-script.js"
      },
      properties: {
        compiled: {
          default: false,
          serializable: false
        },
        _$erialized: {
          default: null,
          visible: false,
          editorOnly: true
        }
      },
      ctor: false,
      statics: {
        safeFindClass: function(id, data) {
          var cls = js._getClassById(id);
          if (cls) return cls;
          if (id) {
            cc.deserialize.reportMissingClass(id);
            return MissingScript.getMissingWrapper(id, data);
          }
          return null;
        },
        getMissingWrapper: function(id, data) {
          return data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id)) ? MissingScript : MissingClass;
        }
      },
      onLoad: function() {
        cc.warnID(4600, this.node.name);
      }
    });
    cc._MissingScript = module.exports = MissingScript;
  }), {
    "../utils/misc": 233
  } ],
  94: [ (function(require, module, exports) {
    var js = cc.js;
    require("../event/event");
    var EventMouse = function(eventType, bubbles) {
      cc.Event.call(this, cc.Event.MOUSE, bubbles);
      this._eventType = eventType;
      this._button = 0;
      this._x = 0;
      this._y = 0;
      this._prevX = 0;
      this._prevY = 0;
      this._scrollX = 0;
      this._scrollY = 0;
    };
    js.extend(EventMouse, cc.Event);
    var proto = EventMouse.prototype;
    proto.setScrollData = function(scrollX, scrollY) {
      this._scrollX = scrollX;
      this._scrollY = scrollY;
    };
    proto.getScrollX = function() {
      return this._scrollX;
    };
    proto.getScrollY = function() {
      return this._scrollY;
    };
    proto.setLocation = function(x, y) {
      this._x = x;
      this._y = y;
    };
    proto.getLocation = function() {
      return {
        x: this._x,
        y: this._y
      };
    };
    proto.getLocationInView = function() {
      return {
        x: this._x,
        y: cc.view._designResolutionSize.height - this._y
      };
    };
    proto._setPrevCursor = function(x, y) {
      this._prevX = x;
      this._prevY = y;
    };
    proto.getPreviousLocation = function() {
      return {
        x: this._prevX,
        y: this._prevY
      };
    };
    proto.getDelta = function() {
      return {
        x: this._x - this._prevX,
        y: this._y - this._prevY
      };
    };
    proto.getDeltaX = function() {
      return this._x - this._prevX;
    };
    proto.getDeltaY = function() {
      return this._y - this._prevY;
    };
    proto.setButton = function(button) {
      this._button = button;
    };
    proto.getButton = function() {
      return this._button;
    };
    proto.getLocationX = function() {
      return this._x;
    };
    proto.getLocationY = function() {
      return this._y;
    };
    EventMouse.NONE = 0;
    EventMouse.DOWN = 1;
    EventMouse.UP = 2;
    EventMouse.MOVE = 3;
    EventMouse.SCROLL = 4;
    EventMouse.BUTTON_LEFT = 0;
    EventMouse.BUTTON_RIGHT = 2;
    EventMouse.BUTTON_MIDDLE = 1;
    EventMouse.BUTTON_4 = 3;
    EventMouse.BUTTON_5 = 4;
    EventMouse.BUTTON_6 = 5;
    EventMouse.BUTTON_7 = 6;
    EventMouse.BUTTON_8 = 7;
    var EventTouch = function(touchArr, bubbles) {
      cc.Event.call(this, cc.Event.TOUCH, bubbles);
      this._eventCode = 0;
      this._touches = touchArr || [];
      this.touch = null;
      this.currentTouch = null;
    };
    js.extend(EventTouch, cc.Event);
    proto = EventTouch.prototype;
    proto.getEventCode = function() {
      return this._eventCode;
    };
    proto.getTouches = function() {
      return this._touches;
    };
    proto._setEventCode = function(eventCode) {
      this._eventCode = eventCode;
    };
    proto._setTouches = function(touches) {
      this._touches = touches;
    };
    proto.setLocation = function(x, y) {
      this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
    };
    proto.getLocation = function() {
      return this.touch ? this.touch.getLocation() : cc.v2();
    };
    proto.getLocationInView = function() {
      return this.touch ? this.touch.getLocationInView() : cc.v2();
    };
    proto.getPreviousLocation = function() {
      return this.touch ? this.touch.getPreviousLocation() : cc.v2();
    };
    proto.getStartLocation = function() {
      return this.touch ? this.touch.getStartLocation() : cc.v2();
    };
    proto.getID = function() {
      return this.touch ? this.touch.getID() : null;
    };
    proto.getDelta = function() {
      return this.touch ? this.touch.getDelta() : cc.v2();
    };
    proto.getDeltaX = function() {
      return this.touch ? this.touch.getDelta().x : 0;
    };
    proto.getDeltaY = function() {
      return this.touch ? this.touch.getDelta().y : 0;
    };
    proto.getLocationX = function() {
      return this.touch ? this.touch.getLocationX() : 0;
    };
    proto.getLocationY = function() {
      return this.touch ? this.touch.getLocationY() : 0;
    };
    EventTouch.MAX_TOUCHES = 5;
    EventTouch.BEGAN = 0;
    EventTouch.MOVED = 1;
    EventTouch.ENDED = 2;
    EventTouch.CANCELED = 3;
    var EventAcceleration = function(acc, bubbles) {
      cc.Event.call(this, cc.Event.ACCELERATION, bubbles);
      this.acc = acc;
    };
    js.extend(EventAcceleration, cc.Event);
    var EventKeyboard = function(keyCode, isPressed, bubbles) {
      cc.Event.call(this, cc.Event.KEYBOARD, bubbles);
      this.keyCode = keyCode;
      this.isPressed = isPressed;
    };
    js.extend(EventKeyboard, cc.Event);
    cc.Event.EventMouse = EventMouse;
    cc.Event.EventTouch = EventTouch;
    cc.Event.EventAcceleration = EventAcceleration;
    cc.Event.EventKeyboard = EventKeyboard;
    module.exports = cc.Event;
  }), {
    "../event/event": 101
  } ],
  95: [ (function(require, module, exports) {
    var js = require("../platform/js");
    cc.EventListener = function(type, listenerID, callback) {
      this._onEvent = callback;
      this._type = type || 0;
      this._listenerID = listenerID || "";
      this._registered = false;
      this._fixedPriority = 0;
      this._node = null;
      this._target = null;
      this._paused = true;
      this._isEnabled = true;
    };
    cc.EventListener.prototype = {
      constructor: cc.EventListener,
      _setPaused: function(paused) {
        this._paused = paused;
      },
      _isPaused: function() {
        return this._paused;
      },
      _setRegistered: function(registered) {
        this._registered = registered;
      },
      _isRegistered: function() {
        return this._registered;
      },
      _getType: function() {
        return this._type;
      },
      _getListenerID: function() {
        return this._listenerID;
      },
      _setFixedPriority: function(fixedPriority) {
        this._fixedPriority = fixedPriority;
      },
      _getFixedPriority: function() {
        return this._fixedPriority;
      },
      _setSceneGraphPriority: function(node) {
        this._target = node;
        this._node = node;
      },
      _getSceneGraphPriority: function() {
        return this._node;
      },
      checkAvailable: function() {
        return null !== this._onEvent;
      },
      clone: function() {
        return null;
      },
      setEnabled: function(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function() {
        return this._isEnabled;
      },
      retain: function() {},
      release: function() {}
    };
    cc.EventListener.UNKNOWN = 0;
    cc.EventListener.TOUCH_ONE_BY_ONE = 1;
    cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
    cc.EventListener.KEYBOARD = 3;
    cc.EventListener.MOUSE = 4;
    cc.EventListener.ACCELERATION = 6;
    cc.EventListener.CUSTOM = 8;
    var ListenerID = cc.EventListener.ListenerID = {
      MOUSE: "__cc_mouse",
      TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
      TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
      KEYBOARD: "__cc_keyboard",
      ACCELERATION: "__cc_acceleration"
    };
    var Custom = function(listenerId, callback) {
      this._onCustomEvent = callback;
      cc.EventListener.call(this, cc.EventListener.CUSTOM, listenerId, this._callback);
    };
    js.extend(Custom, cc.EventListener);
    js.mixin(Custom.prototype, {
      _onCustomEvent: null,
      _callback: function(event) {
        null !== this._onCustomEvent && this._onCustomEvent(event);
      },
      checkAvailable: function() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent;
      },
      clone: function() {
        return new Custom(this._listenerID, this._onCustomEvent);
      }
    });
    var Mouse = function() {
      cc.EventListener.call(this, cc.EventListener.MOUSE, ListenerID.MOUSE, this._callback);
    };
    js.extend(Mouse, cc.EventListener);
    js.mixin(Mouse.prototype, {
      onMouseDown: null,
      onMouseUp: null,
      onMouseMove: null,
      onMouseScroll: null,
      _callback: function(event) {
        var eventType = cc.Event.EventMouse;
        switch (event._eventType) {
         case eventType.DOWN:
          this.onMouseDown && this.onMouseDown(event);
          break;

         case eventType.UP:
          this.onMouseUp && this.onMouseUp(event);
          break;

         case eventType.MOVE:
          this.onMouseMove && this.onMouseMove(event);
          break;

         case eventType.SCROLL:
          this.onMouseScroll && this.onMouseScroll(event);
        }
      },
      clone: function() {
        var eventListener = new Mouse();
        eventListener.onMouseDown = this.onMouseDown;
        eventListener.onMouseUp = this.onMouseUp;
        eventListener.onMouseMove = this.onMouseMove;
        eventListener.onMouseScroll = this.onMouseScroll;
        return eventListener;
      },
      checkAvailable: function() {
        return true;
      }
    });
    var TouchOneByOne = function() {
      cc.EventListener.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null);
      this._claimedTouches = [];
    };
    js.extend(TouchOneByOne, cc.EventListener);
    js.mixin(TouchOneByOne.prototype, {
      constructor: TouchOneByOne,
      _claimedTouches: null,
      swallowTouches: false,
      onTouchBegan: null,
      onTouchMoved: null,
      onTouchEnded: null,
      onTouchCancelled: null,
      setSwallowTouches: function(needSwallow) {
        this.swallowTouches = needSwallow;
      },
      isSwallowTouches: function() {
        return this.swallowTouches;
      },
      clone: function() {
        var eventListener = new TouchOneByOne();
        eventListener.onTouchBegan = this.onTouchBegan;
        eventListener.onTouchMoved = this.onTouchMoved;
        eventListener.onTouchEnded = this.onTouchEnded;
        eventListener.onTouchCancelled = this.onTouchCancelled;
        eventListener.swallowTouches = this.swallowTouches;
        return eventListener;
      },
      checkAvailable: function() {
        if (!this.onTouchBegan) {
          cc.logID(1801);
          return false;
        }
        return true;
      }
    });
    var TouchAllAtOnce = function() {
      cc.EventListener.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null);
    };
    js.extend(TouchAllAtOnce, cc.EventListener);
    js.mixin(TouchAllAtOnce.prototype, {
      constructor: TouchAllAtOnce,
      onTouchesBegan: null,
      onTouchesMoved: null,
      onTouchesEnded: null,
      onTouchesCancelled: null,
      clone: function() {
        var eventListener = new TouchAllAtOnce();
        eventListener.onTouchesBegan = this.onTouchesBegan;
        eventListener.onTouchesMoved = this.onTouchesMoved;
        eventListener.onTouchesEnded = this.onTouchesEnded;
        eventListener.onTouchesCancelled = this.onTouchesCancelled;
        return eventListener;
      },
      checkAvailable: function() {
        if (null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled) {
          cc.logID(1802);
          return false;
        }
        return true;
      }
    });
    var Acceleration = function(callback) {
      this._onAccelerationEvent = callback;
      cc.EventListener.call(this, cc.EventListener.ACCELERATION, ListenerID.ACCELERATION, this._callback);
    };
    js.extend(Acceleration, cc.EventListener);
    js.mixin(Acceleration.prototype, {
      constructor: Acceleration,
      _onAccelerationEvent: null,
      _callback: function(event) {
        this._onAccelerationEvent(event.acc, event);
      },
      checkAvailable: function() {
        cc.assertID(this._onAccelerationEvent, 1803);
        return true;
      },
      clone: function() {
        return new Acceleration(this._onAccelerationEvent);
      }
    });
    var Keyboard = function() {
      cc.EventListener.call(this, cc.EventListener.KEYBOARD, ListenerID.KEYBOARD, this._callback);
    };
    js.extend(Keyboard, cc.EventListener);
    js.mixin(Keyboard.prototype, {
      constructor: Keyboard,
      onKeyPressed: null,
      onKeyReleased: null,
      _callback: function(event) {
        event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
      },
      clone: function() {
        var eventListener = new Keyboard();
        eventListener.onKeyPressed = this.onKeyPressed;
        eventListener.onKeyReleased = this.onKeyReleased;
        return eventListener;
      },
      checkAvailable: function() {
        if (null === this.onKeyPressed && null === this.onKeyReleased) {
          cc.logID(1800);
          return false;
        }
        return true;
      }
    });
    cc.EventListener.create = function(argObj) {
      cc.assertID(argObj && argObj.event, 1900);
      var listenerType = argObj.event;
      delete argObj.event;
      var listener = null;
      if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE) listener = new TouchOneByOne(); else if (listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE) listener = new TouchAllAtOnce(); else if (listenerType === cc.EventListener.MOUSE) listener = new Mouse(); else if (listenerType === cc.EventListener.CUSTOM) {
        listener = new Custom(argObj.eventName, argObj.callback);
        delete argObj.eventName;
        delete argObj.callback;
      } else if (listenerType === cc.EventListener.KEYBOARD) listener = new Keyboard(); else if (listenerType === cc.EventListener.ACCELERATION) {
        listener = new Acceleration(argObj.callback);
        delete argObj.callback;
      }
      for (var key in argObj) listener[key] = argObj[key];
      return listener;
    };
    module.exports = cc.EventListener;
  }), {
    "../platform/js": 175
  } ],
  96: [ (function(require, module, exports) {
    var js = require("../platform/js");
    require("./CCEventListener");
    var ListenerID = cc.EventListener.ListenerID;
    var _EventListenerVector = function() {
      this._fixedListeners = [];
      this._sceneGraphListeners = [];
      this.gt0Index = 0;
    };
    _EventListenerVector.prototype = {
      constructor: _EventListenerVector,
      size: function() {
        return this._fixedListeners.length + this._sceneGraphListeners.length;
      },
      empty: function() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
      },
      push: function(listener) {
        0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
      },
      clearSceneGraphListeners: function() {
        this._sceneGraphListeners.length = 0;
      },
      clearFixedListeners: function() {
        this._fixedListeners.length = 0;
      },
      clear: function() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0;
      },
      getFixedPriorityListeners: function() {
        return this._fixedListeners;
      },
      getSceneGraphPriorityListeners: function() {
        return this._sceneGraphListeners;
      }
    };
    var __getListenerID = function(event) {
      var eventType = cc.Event, type = event.type;
      if (type === eventType.ACCELERATION) return ListenerID.ACCELERATION;
      if (type === eventType.KEYBOARD) return ListenerID.KEYBOARD;
      if (type.startsWith(eventType.MOUSE)) return ListenerID.MOUSE;
      type.startsWith(eventType.TOUCH) && cc.logID(2e3);
      return "";
    };
    var eventManager = {
      DIRTY_NONE: 0,
      DIRTY_FIXED_PRIORITY: 1,
      DIRTY_SCENE_GRAPH_PRIORITY: 2,
      DIRTY_ALL: 3,
      _listenersMap: {},
      _priorityDirtyFlagMap: {},
      _nodeListenersMap: {},
      _nodePriorityMap: js.createMap(true),
      _globalZOrderNodeMap: [],
      _toAddedListeners: [],
      _toRemovedListeners: [],
      _dirtyNodes: [],
      _inDispatch: 0,
      _isEnabled: false,
      _nodePriorityIndex: 0,
      _internalCustomListenerIDs: [],
      _setDirtyForNode: function(node) {
        void 0 !== this._nodeListenersMap[node._id] && this._dirtyNodes.push(node);
        if (node.getChildren) {
          var _children = node.getChildren();
          for (var i = 0, len = _children ? _children.length : 0; i < len; i++) this._setDirtyForNode(_children[i]);
        }
      },
      pauseTarget: function(node, recursive) {
        if (!(node instanceof cc._BaseNode || node instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node._id], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) listeners[i]._setPaused(true);
        if (true === recursive) {
          var locChildren = node.getChildren();
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.pauseTarget(locChildren[i], true);
        }
      },
      resumeTarget: function(node, recursive) {
        if (!(node instanceof cc._BaseNode || node instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node._id], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) listeners[i]._setPaused(false);
        this._setDirtyForNode(node);
        if (true === recursive && node.getChildren) {
          var locChildren = node.getChildren();
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.resumeTarget(locChildren[i], true);
        }
      },
      _addListener: function(listener) {
        0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
      },
      _forceAddEventListener: function(listener) {
        var listenerID = listener._getListenerID();
        var listeners = this._listenersMap[listenerID];
        if (!listeners) {
          listeners = new _EventListenerVector();
          this._listenersMap[listenerID] = listeners;
        }
        listeners.push(listener);
        if (0 === listener._getFixedPriority()) {
          this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
          var node = listener._getSceneGraphPriority();
          null === node && cc.logID(3507);
          this._associateNodeAndEventListener(node, listener);
          node.activeInHierarchy && this.resumeTarget(node);
        } else this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
      },
      _getListeners: function(listenerID) {
        return this._listenersMap[listenerID];
      },
      _updateDirtyFlagForSceneGraph: function() {
        if (0 === this._dirtyNodes.length) return;
        var locDirtyNodes = this._dirtyNodes, selListeners, selListener, locNodeListenersMap = this._nodeListenersMap;
        for (var i = 0, len = locDirtyNodes.length; i < len; i++) {
          selListeners = locNodeListenersMap[locDirtyNodes[i]._id];
          if (selListeners) for (var j = 0, listenersLen = selListeners.length; j < listenersLen; j++) {
            selListener = selListeners[j];
            selListener && this._setDirty(selListener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
          }
        }
        this._dirtyNodes.length = 0;
      },
      _removeAllListenersInVector: function(listenerVector) {
        if (!listenerVector) return;
        var selListener;
        for (var i = 0; i < listenerVector.length; ) {
          selListener = listenerVector[i];
          selListener._setRegistered(false);
          if (null != selListener._getSceneGraphPriority()) {
            this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
            selListener._setSceneGraphPriority(null);
          }
          0 === this._inDispatch ? cc.js.array.remove(listenerVector, selListener) : ++i;
        }
      },
      _removeListenersForListenerID: function(listenerID) {
        var listeners = this._listenersMap[listenerID], i;
        if (listeners) {
          var fixedPriorityListeners = listeners.getFixedPriorityListeners();
          var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          this._removeAllListenersInVector(sceneGraphPriorityListeners);
          this._removeAllListenersInVector(fixedPriorityListeners);
          delete this._priorityDirtyFlagMap[listenerID];
          if (!this._inDispatch) {
            listeners.clear();
            delete this._listenersMap[listenerID];
          }
        }
        var locToAddedListeners = this._toAddedListeners, listener;
        for (i = 0; i < locToAddedListeners.length; ) {
          listener = locToAddedListeners[i];
          listener && listener._getListenerID() === listenerID ? cc.js.array.remove(locToAddedListeners, listener) : ++i;
        }
      },
      _sortEventListeners: function(listenerID) {
        var dirtyFlag = this.DIRTY_NONE, locFlagMap = this._priorityDirtyFlagMap;
        locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]);
        if (dirtyFlag !== this.DIRTY_NONE) {
          locFlagMap[listenerID] = this.DIRTY_NONE;
          dirtyFlag & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(listenerID);
          if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY) {
            var rootEntity = cc.director.getScene();
            rootEntity && this._sortListenersOfSceneGraphPriority(listenerID, rootEntity);
          }
        }
      },
      _sortListenersOfSceneGraphPriority: function(listenerID, rootNode) {
        var listeners = this._getListeners(listenerID);
        if (!listeners) return;
        var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
        if (!sceneGraphListener || 0 === sceneGraphListener.length) return;
        this._nodePriorityIndex = 0;
        this._nodePriorityMap = js.createMap(true);
        this._visitTarget(rootNode, true);
        listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
      },
      _sortEventListenersOfSceneGraphPriorityDes: function(l1, l2) {
        var locNodePriorityMap = eventManager._nodePriorityMap, node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
        if (!(l2 && node2 && locNodePriorityMap[node2._id])) return -1;
        if (!l1 || !node1 || !locNodePriorityMap[node1._id]) return 1;
        return locNodePriorityMap[node2._id] - locNodePriorityMap[node1._id];
      },
      _sortListenersOfFixedPriority: function(listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners) return;
        var fixedListeners = listeners.getFixedPriorityListeners();
        if (!fixedListeners || 0 === fixedListeners.length) return;
        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
        var index = 0;
        for (var len = fixedListeners.length; index < len; ) {
          if (fixedListeners[index]._getFixedPriority() >= 0) break;
          ++index;
        }
        listeners.gt0Index = index;
      },
      _sortListenersOfFixedPriorityAsc: function(l1, l2) {
        return l1._getFixedPriority() - l2._getFixedPriority();
      },
      _onUpdateListeners: function(listeners) {
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i, selListener, idx, toRemovedListeners = this._toRemovedListeners;
        if (sceneGraphPriorityListeners) for (i = 0; i < sceneGraphPriorityListeners.length; ) {
          selListener = sceneGraphPriorityListeners[i];
          if (selListener._isRegistered()) ++i; else {
            cc.js.array.remove(sceneGraphPriorityListeners, selListener);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        if (fixedPriorityListeners) for (i = 0; i < fixedPriorityListeners.length; ) {
          selListener = fixedPriorityListeners[i];
          if (selListener._isRegistered()) ++i; else {
            cc.js.array.remove(fixedPriorityListeners, selListener);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners();
        fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
      },
      frameUpdateListeners: function() {
        var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
        for (var selKey in locListenersMap) if (locListenersMap[selKey].empty()) {
          delete locPriorityDirtyFlagMap[selKey];
          delete locListenersMap[selKey];
        }
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          locToAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _updateTouchListeners: function(event) {
        var locInDispatch = this._inDispatch;
        cc.assertID(locInDispatch > 0, 3508);
        if (locInDispatch > 1) return;
        var listeners;
        listeners = this._listenersMap[ListenerID.TOUCH_ONE_BY_ONE];
        listeners && this._onUpdateListeners(listeners);
        listeners = this._listenersMap[ListenerID.TOUCH_ALL_AT_ONCE];
        listeners && this._onUpdateListeners(listeners);
        cc.assertID(1 === locInDispatch, 3509);
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          this._toAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _cleanToRemovedListeners: function() {
        var toRemovedListeners = this._toRemovedListeners;
        for (var i = 0; i < toRemovedListeners.length; i++) {
          var selListener = toRemovedListeners[i];
          var listeners = this._listenersMap[selListener._getListenerID()];
          if (!listeners) continue;
          var idx, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          if (sceneGraphPriorityListeners) {
            idx = sceneGraphPriorityListeners.indexOf(selListener);
            -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
          }
          if (fixedPriorityListeners) {
            idx = fixedPriorityListeners.indexOf(selListener);
            -1 !== idx && fixedPriorityListeners.splice(idx, 1);
          }
        }
        toRemovedListeners.length = 0;
      },
      _onTouchEventCallback: function(listener, argsObj) {
        if (!listener._isRegistered) return false;
        var event = argsObj.event, selTouch = event.currentTouch;
        event.currentTarget = listener._node;
        var isClaimed = false, removedIdx;
        var getCode = event.getEventCode(), EventTouch = cc.Event.EventTouch;
        if (getCode === EventTouch.BEGAN) {
          if (listener.onTouchBegan) {
            isClaimed = listener.onTouchBegan(selTouch, event);
            isClaimed && listener._registered && listener._claimedTouches.push(selTouch);
          }
        } else if (listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch))) {
          isClaimed = true;
          if (getCode === EventTouch.MOVED && listener.onTouchMoved) listener.onTouchMoved(selTouch, event); else if (getCode === EventTouch.ENDED) {
            listener.onTouchEnded && listener.onTouchEnded(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
          } else if (getCode === EventTouch.CANCELLED) {
            listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
          }
        }
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        if (isClaimed && listener._registered && listener.swallowTouches) {
          argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1);
          return true;
        }
        return false;
      },
      _dispatchTouchEvent: function(event) {
        this._sortEventListeners(ListenerID.TOUCH_ONE_BY_ONE);
        this._sortEventListeners(ListenerID.TOUCH_ALL_AT_ONCE);
        var oneByOneListeners = this._getListeners(ListenerID.TOUCH_ONE_BY_ONE);
        var allAtOnceListeners = this._getListeners(ListenerID.TOUCH_ALL_AT_ONCE);
        if (null === oneByOneListeners && null === allAtOnceListeners) return;
        var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches);
        var oneByOneArgsObj = {
          event: event,
          needsMutableSet: oneByOneListeners && allAtOnceListeners,
          touches: mutableTouches,
          selTouch: null
        };
        if (oneByOneListeners) for (var i = 0; i < originalTouches.length; i++) {
          event.currentTouch = originalTouches[i];
          event._propagationStopped = event._propagationImmediateStopped = false;
          this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
        }
        if (allAtOnceListeners && mutableTouches.length > 0) {
          this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
            event: event,
            touches: mutableTouches
          });
          if (event.isStopped()) return;
        }
        this._updateTouchListeners(event);
      },
      _onTouchesEventCallback: function(listener, callbackParams) {
        if (!listener._registered) return false;
        var EventTouch = cc.Event.EventTouch, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
        event.currentTarget = listener._node;
        getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event);
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        return false;
      },
      _associateNodeAndEventListener: function(node, listener) {
        var listeners = this._nodeListenersMap[node._id];
        if (!listeners) {
          listeners = [];
          this._nodeListenersMap[node._id] = listeners;
        }
        listeners.push(listener);
      },
      _dissociateNodeAndEventListener: function(node, listener) {
        var listeners = this._nodeListenersMap[node._id];
        if (listeners) {
          cc.js.array.remove(listeners, listener);
          0 === listeners.length && delete this._nodeListenersMap[node._id];
        }
      },
      _dispatchEventToListeners: function(listeners, onEvent, eventOrArgs) {
        var shouldStopPropagation = false;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i = 0, j, selListener;
        if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (sceneGraphPriorityListeners && !shouldStopPropagation) for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
          selListener = sceneGraphPriorityListeners[j];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
      },
      _setDirty: function(listenerID, flag) {
        var locDirtyFlagMap = this._priorityDirtyFlagMap;
        null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
      },
      _visitTarget: function(node, isRootNode) {
        node._reorderChildDirty && node.sortAllChildren();
        var children = node.getChildren(), i = 0;
        var childrenCount = children.length, locGlobalZOrderNodeMap = this._globalZOrderNodeMap, locNodeListenersMap = this._nodeListenersMap;
        if (childrenCount > 0) {
          if (void 0 !== locNodeListenersMap[node._id]) {
            locGlobalZOrderNodeMap || (locGlobalZOrderNodeMap = []);
            locGlobalZOrderNodeMap.push(node._id);
          }
          var child;
          for (;i < childrenCount; i++) {
            child = children[i];
            child && this._visitTarget(child, false);
          }
        } else if (void 0 !== locNodeListenersMap[node._id]) {
          locGlobalZOrderNodeMap || (locGlobalZOrderNodeMap = []);
          locGlobalZOrderNodeMap.push(node._id);
        }
        if (isRootNode) {
          var locNodePriorityMap = this._nodePriorityMap;
          for (var j = 0; j < locGlobalZOrderNodeMap.length; j++) locNodePriorityMap[locGlobalZOrderNodeMap[j]] = ++this._nodePriorityIndex;
          this._globalZOrderNodeMap.length = 0;
        }
      },
      _sortNumberAsc: function(a, b) {
        return a - b;
      },
      hasEventListener: function(listenerID) {
        return !!this._getListeners(listenerID);
      },
      addListener: function(listener, nodeOrPriority) {
        cc.assertID(listener && nodeOrPriority, 3503);
        if (!(cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode || nodeOrPriority instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        if (listener instanceof cc.EventListener) {
          if (listener._isRegistered()) {
            cc.logID(3505);
            return;
          }
        } else {
          cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504);
          listener = cc.EventListener.create(listener);
        }
        if (!listener.checkAvailable()) return;
        if (cc.js.isNumber(nodeOrPriority)) {
          if (0 === nodeOrPriority) {
            cc.logID(3500);
            return;
          }
          listener._setSceneGraphPriority(null);
          listener._setFixedPriority(nodeOrPriority);
          listener._setRegistered(true);
          listener._setPaused(false);
          this._addListener(listener);
        } else {
          listener._setSceneGraphPriority(nodeOrPriority);
          listener._setFixedPriority(0);
          listener._setRegistered(true);
          this._addListener(listener);
        }
        return listener;
      },
      addCustomListener: function(eventName, callback) {
        var listener = new cc.EventListener.create({
          event: cc.EventListener.CUSTOM,
          eventName: eventName,
          callback: callback
        });
        this.addListener(listener, 1);
        return listener;
      },
      removeListener: function(listener) {
        if (null == listener) return;
        var isFound, locListener = this._listenersMap;
        for (var selKey in locListener) {
          var listeners = locListener[selKey];
          var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
          if (isFound) this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY); else {
            isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
            isFound && this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
          }
          if (listeners.empty()) {
            delete this._priorityDirtyFlagMap[listener._getListenerID()];
            delete locListener[selKey];
          }
          if (isFound) break;
        }
        if (!isFound) {
          var locToAddedListeners = this._toAddedListeners;
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
            var selListener = locToAddedListeners[i];
            if (selListener === listener) {
              cc.js.array.remove(locToAddedListeners, selListener);
              selListener._setRegistered(false);
              break;
            }
          }
        }
      },
      _removeListenerInCallback: function(listeners, callback) {
        if (null == listeners) return false;
        for (var i = 0, len = listeners.length; i < len; i++) {
          var selListener = listeners[i];
          if (selListener._onCustomEvent === callback || selListener._onEvent === callback) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      _removeListenerInVector: function(listeners, listener) {
        if (null == listeners) return false;
        for (var i = 0, len = listeners.length; i < len; i++) {
          var selListener = listeners[i];
          if (selListener === listener) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      removeListeners: function(listenerType, recursive) {
        var i, _t = this;
        if (!(cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode || listenerType instanceof _ccsg.Node)) {
          cc.warnID(3506);
          return;
        }
        if (void 0 !== listenerType._id) {
          delete _t._nodePriorityMap[listenerType._id];
          cc.js.array.remove(_t._dirtyNodes, listenerType);
          var listeners = _t._nodeListenersMap[listenerType._id], i;
          if (listeners) {
            var listenersCopy = cc.js.array.copy(listeners);
            for (i = 0; i < listenersCopy.length; i++) _t.removeListener(listenersCopy[i]);
            delete _t._nodeListenersMap[listenerType._id];
          }
          var locToAddedListeners = _t._toAddedListeners;
          for (i = 0; i < locToAddedListeners.length; ) {
            var listener = locToAddedListeners[i];
            if (listener._getSceneGraphPriority() === listenerType) {
              listener._setSceneGraphPriority(null);
              listener._setRegistered(false);
              locToAddedListeners.splice(i, 1);
            } else ++i;
          }
          if (true === recursive) {
            var locChildren = listenerType.getChildren(), len;
            for (i = 0, len = locChildren.length; i < len; i++) _t.removeListeners(locChildren[i], true);
          }
        } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? _t._removeListenersForListenerID(ListenerID.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? _t._removeListenersForListenerID(ListenerID.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? _t._removeListenersForListenerID(ListenerID.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? _t._removeListenersForListenerID(ListenerID.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? _t._removeListenersForListenerID(ListenerID.KEYBOARD) : cc.logID(3501);
      },
      removeCustomListeners: function(customEventName) {
        this._removeListenersForListenerID(customEventName);
      },
      removeAllListeners: function() {
        var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
        for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
      },
      setPriority: function(listener, fixedPriority) {
        if (null == listener) return;
        var locListeners = this._listenersMap;
        for (var selKey in locListeners) {
          var selListeners = locListeners[selKey];
          var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
          if (fixedPriorityListeners) {
            var found = fixedPriorityListeners.indexOf(listener);
            if (-1 !== found) {
              null != listener._getSceneGraphPriority() && cc.logID(3502);
              if (listener._getFixedPriority() !== fixedPriority) {
                listener._setFixedPriority(fixedPriority);
                this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
              }
              return;
            }
          }
        }
      },
      setEnabled: function(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function() {
        return this._isEnabled;
      },
      dispatchEvent: function(event) {
        if (!this._isEnabled) return;
        this._updateDirtyFlagForSceneGraph();
        this._inDispatch++;
        if (!event || !event.getType) throw new Error(cc._getError(3511));
        if (event.getType().startsWith(cc.Event.TOUCH)) {
          this._dispatchTouchEvent(event);
          this._inDispatch--;
          return;
        }
        var listenerID = __getListenerID(event);
        this._sortEventListeners(listenerID);
        var selListeners = this._listenersMap[listenerID];
        if (null != selListeners) {
          this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
          this._onUpdateListeners(selListeners);
        }
        this._inDispatch--;
      },
      _onListenerCallback: function(listener, event) {
        event.currentTarget = listener._target;
        listener._onEvent(event);
        return event.isStopped();
      },
      dispatchCustomEvent: function(eventName, optionalUserData) {
        var ev = new cc.Event.EventCustom(eventName);
        ev.setUserData(optionalUserData);
        this.dispatchEvent(ev);
      }
    };
    js.get(cc, "eventManager", (function() {
      cc.warnID(1405, "cc.eventManager", "cc.EventTarget or cc.systemEvent");
      return eventManager;
    }));
    module.exports = eventManager;
  }), {
    "../platform/js": 175,
    "./CCEventListener": 95
  } ],
  97: [ (function(require, module, exports) {
    cc.Touch = function(x, y, id) {
      this._lastModified = 0;
      this.setTouchInfo(id, x, y);
    };
    cc.Touch.prototype = {
      constructor: cc.Touch,
      getLocation: function() {
        return cc.v2(this._point.x, this._point.y);
      },
      getLocationX: function() {
        return this._point.x;
      },
      getLocationY: function() {
        return this._point.y;
      },
      getPreviousLocation: function() {
        return cc.v2(this._prevPoint.x, this._prevPoint.y);
      },
      getStartLocation: function() {
        return cc.v2(this._startPoint.x, this._startPoint.y);
      },
      getDelta: function() {
        return this._point.sub(this._prevPoint);
      },
      getLocationInView: function() {
        return cc.v2(this._point.x, cc.view._designResolutionSize.height - this._point.y);
      },
      getPreviousLocationInView: function() {
        return cc.v2(this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y);
      },
      getStartLocationInView: function() {
        return cc.v2(this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y);
      },
      getID: function() {
        return this._id;
      },
      setTouchInfo: function(id, x, y) {
        this._prevPoint = this._point;
        this._point = cc.v2(x || 0, y || 0);
        this._id = id;
        if (!this._startPointCaptured) {
          this._startPoint = cc.v2(this._point);
          cc.view._convertPointWithScale(this._startPoint);
          this._startPointCaptured = true;
        }
      },
      _setPoint: function(x, y) {
        if (void 0 === y) {
          this._point.x = x.x;
          this._point.y = x.y;
        } else {
          this._point.x = x;
          this._point.y = y;
        }
      },
      _setPrevPoint: function(x, y) {
        this._prevPoint = void 0 === y ? cc.v2(x.x, x.y) : cc.v2(x || 0, y || 0);
      }
    };
  }), {} ],
  98: [ (function(require, module, exports) {
    require("./CCEvent");
    require("./CCTouch");
    require("./CCEventListener");
    var eventManager = require("./CCEventManager");
    module.exports = eventManager;
    false;
  }), {
    "./CCEvent": 94,
    "./CCEventListener": 95,
    "./CCEventManager": 96,
    "./CCTouch": 97
  } ],
  99: [ (function(require, module, exports) {
    var js = cc.js;
    var CallbacksHandler = require("../platform/callbacks-invoker").CallbacksHandler;
    function EventListeners() {
      CallbacksHandler.call(this);
    }
    js.extend(EventListeners, CallbacksHandler);
    EventListeners.prototype.invoke = function(event, captureListeners) {
      var key = event.type;
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          var callback = callbacks[i];
          if (callback) {
            var target = targets[i] || event.currentTarget;
            callback.call(target, event, captureListeners);
            if (event._propagationImmediateStopped) break;
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    module.exports = EventListeners;
    false;
  }), {
    "../platform/callbacks-invoker": 168
  } ],
  100: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var EventListeners = require("./event-listeners");
    require("./event");
    var fastRemove = js.array.fastRemove;
    function EventTarget() {
      EventListeners.call(this);
    }
    js.extend(EventTarget, EventListeners);
    var proto = EventTarget.prototype;
    proto.on = function(type, callback, target) {
      if (!callback) {
        cc.errorID(6800);
        return;
      }
      if (!this.hasEventListener(type, callback, target)) {
        this.add(type, callback, target);
        target && target.__eventTargets && target.__eventTargets.push(this);
      }
      return callback;
    };
    proto.off = function(type, callback, target) {
      if (callback) {
        this.remove(type, callback, target);
        target && target.__eventTargets && fastRemove(target.__eventTargets, this);
      } else this.removeAll(type);
    };
    proto.targetOff = proto.removeAll;
    proto.once = function(type, callback, target) {
      var eventType_hasOnceListener = "__ONCE_FLAG:" + type;
      var hasOnceListener = this.hasEventListener(eventType_hasOnceListener, callback, target);
      if (!hasOnceListener) {
        var self = this;
        var onceWrapper = function(event) {
          self.off(type, onceWrapper, target);
          self.remove(eventType_hasOnceListener, callback, target);
          callback.call(this, event);
        };
        this.on(type, onceWrapper, target);
        this.add(eventType_hasOnceListener, callback, target);
      }
    };
    proto.emit = function(type, detail, target) {
      false;
      if (this.hasEventListener(type)) {
        var event = cc.Event.EventCustom.get(type);
        event.detail = detail;
        event.eventPhase = 2;
        event.target = event.currentTarget = target || this;
        this.invoke(event);
        event.detail = null;
        cc.Event.EventCustom.put(event);
      }
    };
    proto.dispatchEvent = function(event) {
      this.hasEventListener(event.type) && this.invoke(event);
    };
    EventTarget.prototype._EventTargetOn = EventTarget.prototype.on;
    EventTarget.prototype._EventTargetOnce = EventTarget.prototype.once;
    EventTarget.prototype._EventTargetOff = EventTarget.prototype.off;
    EventTarget.prototype._EventTargetTargetOff = EventTarget.prototype.targetOff;
    cc.EventTarget = module.exports = EventTarget;
  }), {
    "../platform/js": 175,
    "./event": 101,
    "./event-listeners": 99
  } ],
  101: [ (function(require, module, exports) {
    var js = require("../platform/js");
    cc.Event = function(type, bubbles) {
      this.type = type;
      this.bubbles = !!bubbles;
      this.target = null;
      this.currentTarget = null;
      this.eventPhase = 0;
      this._propagationStopped = false;
      this._propagationImmediateStopped = false;
    };
    cc.Event.prototype = {
      constructor: cc.Event,
      unuse: function() {
        this.type = cc.Event.NO_TYPE;
        this.target = null;
        this.currentTarget = null;
        this.eventPhase = cc.Event.NONE;
        this._propagationStopped = false;
        this._propagationImmediateStopped = false;
      },
      reuse: function(type, bubbles) {
        this.type = type;
        this.bubbles = bubbles || false;
      },
      stopPropagation: function() {
        this._propagationStopped = true;
      },
      stopPropagationImmediate: function() {
        this._propagationImmediateStopped = true;
      },
      isStopped: function() {
        return this._propagationStopped || this._propagationImmediateStopped;
      },
      getCurrentTarget: function() {
        return this.currentTarget;
      },
      getType: function() {
        return this.type;
      }
    };
    cc.Event.NO_TYPE = "no_type";
    cc.Event.TOUCH = "touch";
    cc.Event.MOUSE = "mouse";
    cc.Event.KEYBOARD = "keyboard";
    cc.Event.ACCELERATION = "acceleration";
    cc.Event.NONE = 0;
    cc.Event.CAPTURING_PHASE = 1;
    cc.Event.AT_TARGET = 2;
    cc.Event.BUBBLING_PHASE = 3;
    var EventCustom = function(type, bubbles) {
      cc.Event.call(this, type, bubbles);
      this.detail = null;
    };
    js.extend(EventCustom, cc.Event);
    EventCustom.prototype.reset = EventCustom;
    EventCustom.prototype.setUserData = function(data) {
      this.detail = data;
    };
    EventCustom.prototype.getUserData = function() {
      return this.detail;
    };
    EventCustom.prototype.getEventName = cc.Event.prototype.getType;
    var MAX_POOL_SIZE = 10;
    var _eventPool = new js.Pool(MAX_POOL_SIZE);
    EventCustom.put = function(event) {
      _eventPool.put(event);
    };
    EventCustom.get = function(type, bubbles) {
      var event = _eventPool._get();
      event ? event.reset(type, bubbles) : event = new EventCustom(type, bubbles);
      return event;
    };
    cc.Event.EventCustom = EventCustom;
    module.exports = cc.Event;
  }), {
    "../platform/js": 175
  } ],
  102: [ (function(require, module, exports) {
    require("./event");
    require("./event-listeners");
    require("./event-target");
    require("./system-event");
  }), {
    "./event": 101,
    "./event-listeners": 99,
    "./event-target": 100,
    "./system-event": 103
  } ],
  103: [ (function(require, module, exports) {
    var EventTarget = require("../event/event-target");
    var eventManager = require("../event-manager");
    var inputManger = require("../platform/CCInputManager");
    var EventType = cc.Enum({
      KEY_DOWN: "keydown",
      KEY_UP: "keyup",
      DEVICEMOTION: "devicemotion"
    });
    var keyboardListener = null;
    var accelerationListener = null;
    var SystemEvent = cc.Class({
      name: "SystemEvent",
      extends: EventTarget,
      statics: {
        EventType: EventType
      },
      setAccelerometerEnabled: function(isEnable) {
        inputManger.setAccelerometerEnabled(isEnable);
      },
      setAccelerometerInterval: function(interval) {
        inputManger.setAccelerometerInterval(interval);
      },
      on: function(type, callback, target) {
        this._super(type, callback, target);
        if (type === EventType.KEY_DOWN || type === EventType.KEY_UP) {
          keyboardListener || (keyboardListener = cc.EventListener.create({
            event: cc.EventListener.KEYBOARD,
            onKeyPressed: function(keyCode, event) {
              event.type = EventType.KEY_DOWN;
              cc.systemEvent.dispatchEvent(event);
            },
            onKeyReleased: function(keyCode, event) {
              event.type = EventType.KEY_UP;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          eventManager.hasEventListener(cc.EventListener.ListenerID.KEYBOARD) || eventManager.addListener(keyboardListener, 1);
        }
        if (type === EventType.DEVICEMOTION) {
          accelerationListener || (accelerationListener = cc.EventListener.create({
            event: cc.EventListener.ACCELERATION,
            callback: function(acc, event) {
              event.type = EventType.DEVICEMOTION;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          eventManager.hasEventListener(cc.EventListener.ListenerID.ACCELERATION) || eventManager.addListener(accelerationListener, 1);
        }
      },
      off: function(type, callback, target) {
        this._super(type, callback, target);
        if (keyboardListener && (type === EventType.KEY_DOWN || type === EventType.KEY_UP)) {
          var hasKeyDownEventListener = this.hasEventListener(EventType.KEY_DOWN);
          var hasKeyUpEventListener = this.hasEventListener(EventType.KEY_UP);
          hasKeyDownEventListener || hasKeyUpEventListener || eventManager.removeListener(keyboardListener);
        }
        accelerationListener && type === EventType.DEVICEMOTION && eventManager.removeListener(accelerationListener);
      }
    });
    cc.SystemEvent = module.exports = SystemEvent;
    true;
    cc.systemEvent = new cc.SystemEvent();
  }), {
    "../event-manager": 98,
    "../event/event-target": 100,
    "../platform/CCInputManager": 159
  } ],
  104: [ (function(require, module, exports) {
    var RenderComponent = require("../components/CCRenderComponent");
    var renderer = require("../renderer");
    var renderEngine = require("../renderer/render-engine");
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var Helper = require("./helper");
    var Types = require("./types");
    var LineCap = Types.LineCap;
    var LineJoin = Types.LineJoin;
    var Graphics = cc.Class({
      name: "cc.Graphics",
      extends: RenderComponent,
      editor: false,
      ctor: function() {
        this._impl = Graphics._assembler.createImpl();
      },
      properties: {
        _lineWidth: 1,
        _strokeColor: cc.Color.BLACK,
        _lineJoin: LineJoin.MITER,
        _lineCap: LineCap.BUTT,
        _fillColor: cc.Color.WHITE,
        _miterLimit: 10,
        lineWidth: {
          get: function() {
            return this._lineWidth;
          },
          set: function(value) {
            this._lineWidth = value;
            this._impl.lineWidth = value;
          }
        },
        lineJoin: {
          get: function() {
            return this._lineJoin;
          },
          set: function(value) {
            this._lineJoin = value;
            this._impl.lineJoin = value;
          },
          type: LineJoin
        },
        lineCap: {
          get: function() {
            return this._lineCap;
          },
          set: function(value) {
            this._lineCap = value;
            this._impl.lineCap = value;
          },
          type: LineCap
        },
        strokeColor: {
          get: function() {
            return this._strokeColor;
          },
          set: function(value) {
            this._impl.strokeColor = this._strokeColor = cc.color(value);
          }
        },
        fillColor: {
          get: function() {
            return this._fillColor;
          },
          set: function(value) {
            this._impl.fillColor = this._fillColor = cc.color(value);
          }
        },
        miterLimit: {
          get: function() {
            return this._miterLimit;
          },
          set: function(value) {
            this._miterLimit = value;
            this._impl.miterLimit = value;
          }
        }
      },
      statics: {
        LineJoin: LineJoin,
        LineCap: LineCap
      },
      onEnable: function() {
        this._super();
        this._activateMaterial();
      },
      onDestroy: function() {
        this._super();
        this._impl = null;
      },
      _activateMaterial: function() {
        if (this._material) return;
        var material = new SpriteMaterial();
        material.useColor = false;
        material.useTexture = false;
        this.setMaterial(material);
      },
      moveTo: function(x, y) {
        this._impl.moveTo(x, y);
      },
      lineTo: function(x, y) {
        this._impl.lineTo(x, y);
      },
      bezierCurveTo: function(c1x, c1y, c2x, c2y, x, y) {
        this._impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
      },
      quadraticCurveTo: function(cx, cy, x, y) {
        this._impl.quadraticCurveTo(cx, cy, x, y);
      },
      arc: function(cx, cy, r, startAngle, endAngle, counterclockwise) {
        this._impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
      },
      ellipse: function(cx, cy, rx, ry) {
        this._impl.ellipse(cx, cy, rx, ry);
      },
      circle: function(cx, cy, r) {
        this._impl.circle(cx, cy, r);
      },
      rect: function(x, y, w, h) {
        this._impl.rect(x, y, w, h);
      },
      roundRect: function(x, y, w, h, r) {
        this._impl.roundRect(x, y, w, h, r);
      },
      fillRect: function(x, y, w, h) {
        this.rect(x, y, w, h);
        this.fill();
      },
      clear: function(clean) {
        this._impl.clear(this, clean);
      },
      close: function() {
        this._impl.close();
      },
      stroke: function() {
        Graphics._assembler.stroke(this);
      },
      fill: function() {
        Graphics._assembler.fill(this);
      }
    });
    cc.Graphics = module.exports = Graphics;
  }), {
    "../components/CCRenderComponent": 77,
    "../renderer": 196,
    "../renderer/render-engine": 197,
    "./helper": 105,
    "./types": 107
  } ],
  105: [ (function(require, module, exports) {
    var PointFlags = require("./types").PointFlags;
    var PI = Math.PI;
    var min = Math.min;
    var max = Math.max;
    var cos = Math.cos;
    var sin = Math.sin;
    var abs = Math.abs;
    var sign = Math.sign;
    var KAPPA90 = .5522847493;
    function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
      counterclockwise = counterclockwise || false;
      var a = 0, da = 0, hda = 0, kappa = 0;
      var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
      var px = 0, py = 0, ptanx = 0, ptany = 0;
      var i, ndivs;
      da = endAngle - startAngle;
      if (counterclockwise) if (abs(da) >= 2 * PI) da = 2 * PI; else while (da < 0) da += 2 * PI; else if (abs(da) >= 2 * PI) da = 2 * -PI; else while (da > 0) da -= 2 * PI;
      ndivs = 0 | max(1, min(abs(da) / (.5 * PI) + .5, 5));
      hda = da / ndivs / 2;
      kappa = abs(4 / 3 * (1 - cos(hda)) / sin(hda));
      counterclockwise || (kappa = -kappa);
      for (i = 0; i <= ndivs; i++) {
        a = startAngle + da * (i / ndivs);
        dx = cos(a);
        dy = sin(a);
        x = cx + dx * r;
        y = cy + dy * r;
        tanx = -dy * r * kappa;
        tany = dx * r * kappa;
        0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
        px = x;
        py = y;
        ptanx = tanx;
        ptany = tany;
      }
    }
    function ellipse(ctx, cx, cy, rx, ry) {
      ctx.moveTo(cx - rx, cy);
      ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
      ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
      ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
      ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
      ctx.close();
    }
    function roundRect(ctx, x, y, w, h, r) {
      if (r < .1) {
        ctx.rect(x, y, w, h);
        return;
      }
      var rx = min(r, .5 * abs(w)) * sign(w), ry = min(r, .5 * abs(h)) * sign(h);
      ctx.moveTo(x, y + ry);
      ctx.lineTo(x, y + h - ry);
      ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
      ctx.lineTo(x + w - rx, y + h);
      ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
      ctx.lineTo(x + w, y + ry);
      ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
      ctx.lineTo(x + rx, y);
      ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
      ctx.close();
    }
    function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
      var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234;
      var dx, dy, d2, d3;
      if (level > 10) return;
      x12 = .5 * (x1 + x2);
      y12 = .5 * (y1 + y2);
      x23 = .5 * (x2 + x3);
      y23 = .5 * (y2 + y3);
      x34 = .5 * (x3 + x4);
      y34 = .5 * (y3 + y4);
      x123 = .5 * (x12 + x23);
      y123 = .5 * (y12 + y23);
      dx = x4 - x1;
      dy = y4 - y1;
      d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
      d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);
      if ((d2 + d3) * (d2 + d3) < ctx._tessTol * (dx * dx + dy * dy)) {
        ctx._addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type);
        return;
      }
      x234 = .5 * (x23 + x34);
      y234 = .5 * (y23 + y34);
      x1234 = .5 * (x123 + x234);
      y1234 = .5 * (y123 + y234);
      tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
      tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
    }
    module.exports = {
      arc: arc,
      ellipse: ellipse,
      roundRect: roundRect,
      tesselateBezier: tesselateBezier
    };
  }), {
    "./types": 107
  } ],
  106: [ (function(require, module, exports) {
    "use strict";
    require("./graphics");
  }), {
    "./graphics": 104
  } ],
  107: [ (function(require, module, exports) {
    "use strict";
    var LineCap = cc.Enum({
      BUTT: 0,
      ROUND: 1,
      SQUARE: 2
    });
    var LineJoin = cc.Enum({
      BEVEL: 0,
      ROUND: 1,
      MITER: 2
    });
    var PointFlags = cc.Enum({
      PT_CORNER: 1,
      PT_LEFT: 2,
      PT_BEVEL: 4,
      PT_INNERBEVEL: 8
    });
    module.exports = {
      LineCap: LineCap,
      LineJoin: LineJoin,
      PointFlags: PointFlags
    };
  }), {} ],
  108: [ (function(require, module, exports) {
    require("./platform");
    require("./assets");
    true;
    require("./CCNode");
    require("./CCPrivateNode");
    require("./CCScene");
    require("./components");
    require("./graphics");
    require("./collider");
    require("./collider/CCIntersection");
    require("./physics");
    require("./camera/CCCamera");
    require("./utils/polyfill-3d");
    require("./base-ui/CCWidgetManager");
  }), {
    "./CCNode": 30,
    "./CCPrivateNode": 31,
    "./CCScene": 32,
    "./assets": 50,
    "./base-ui/CCWidgetManager": 51,
    "./camera/CCCamera": 52,
    "./collider": 60,
    "./collider/CCIntersection": 58,
    "./components": 92,
    "./graphics": 106,
    "./physics": 139,
    "./platform": 172,
    "./utils/polyfill-3d": 235
  } ],
  109: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var Pipeline = require("./pipeline");
    var LoadingItems = require("./loading-items");
    var AssetLoader = require("./asset-loader");
    var Downloader = require("./downloader");
    var Loader = require("./loader");
    var AssetTable = require("./asset-table");
    var callInNextTick = require("../platform/utils").callInNextTick;
    var AutoReleaseUtils = require("./auto-release-utils");
    var ReleasedAssetChecker = (true, require("./released-asset-checker"));
    var resources = new AssetTable();
    function getXMLHttpRequest() {
      return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
    }
    var _info = {
      url: null,
      raw: false
    };
    function getResWithUrl(res) {
      var id, result, isUuid;
      if ("object" === typeof res) {
        result = res;
        if (res.url) return result;
        id = res.uuid;
      } else {
        result = {};
        id = res;
      }
      isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._getAssetUrl(id);
      cc.AssetLibrary._getAssetInfoInRuntime(id, _info);
      result.url = isUuid ? _info.url : id;
      if (_info.url && "uuid" === result.type && _info.raw) {
        result.type = null;
        result.isRawAsset = true;
      } else isUuid || (result.isRawAsset = true);
      return result;
    }
    var _sharedResources = [];
    var _sharedList = [];
    function CCLoader() {
      var assetLoader = new AssetLoader();
      var downloader = new Downloader();
      var loader = new Loader();
      Pipeline.call(this, [ assetLoader, downloader, loader ]);
      this.assetLoader = assetLoader;
      this.downloader = downloader;
      this.loader = loader;
      this.onProgress = null;
      this._autoReleaseSetting = js.createMap(true);
      true;
      this._releasedAssetChecker_DEBUG = new ReleasedAssetChecker();
    }
    js.extend(CCLoader, Pipeline);
    var proto = CCLoader.prototype;
    proto.init = function(director) {
      true;
      var self = this;
      director.on(cc.Director.EVENT_AFTER_UPDATE, (function() {
        self._releasedAssetChecker_DEBUG.checkCouldRelease(self._cache);
      }));
    };
    proto.getXMLHttpRequest = getXMLHttpRequest;
    proto.addDownloadHandlers = function(extMap) {
      this.downloader.addHandlers(extMap);
    };
    proto.addLoadHandlers = function(extMap) {
      this.loader.addHandlers(extMap);
    };
    proto.load = function(resources, progressCallback, completeCallback) {
      if (void 0 === completeCallback) {
        completeCallback = progressCallback;
        progressCallback = this.onProgress || null;
      }
      var self = this;
      var singleRes = false;
      var res;
      if (!(resources instanceof Array)) {
        singleRes = true;
        resources = resources ? [ resources ] : [];
      }
      _sharedResources.length = 0;
      for (var i = 0; i < resources.length; ++i) {
        var resource = resources[i];
        if (resource && resource.id) {
          cc.warnID(4920, resource.id);
          resource.uuid || resource.url || (resource.url = resource.id);
        }
        res = getResWithUrl(resource);
        if (!res.url && !res.uuid) continue;
        var item = this._cache[res.url];
        _sharedResources.push(item || res);
      }
      var queue = LoadingItems.create(this, progressCallback, (function(errors, items) {
        callInNextTick((function() {
          if (completeCallback) {
            if (singleRes) {
              var id = res.url;
              completeCallback.call(self, items.getError(id), items.getContent(id));
            } else completeCallback.call(self, errors, items);
            completeCallback = null;
          }
          var _id;
          false;
          items.destroy();
        }));
      }));
      LoadingItems.initQueueDeps(queue);
      queue.append(_sharedResources);
      _sharedResources.length = 0;
    };
    proto.flowInDeps = function(owner, urlList, callback) {
      _sharedList.length = 0;
      for (var i = 0; i < urlList.length; ++i) {
        var res = getResWithUrl(urlList[i]);
        if (!res.url && !res.uuid) continue;
        var item = this._cache[res.url];
        item ? _sharedList.push(item) : _sharedList.push(res);
      }
      var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
        this._ownerQueue && this._ownerQueue.onProgress && this._ownerQueue._childOnProgress(item);
      } : null, (function(errors, items) {
        callback(errors, items);
        owner && owner.deps && (owner.deps.length = 0);
        items.destroy();
      }));
      if (owner) {
        var ownerQueue = LoadingItems.getQueue(owner);
        queue._ownerQueue = ownerQueue._ownerQueue || ownerQueue;
      }
      var accepted = queue.append(_sharedList, owner);
      _sharedList.length = 0;
      return accepted;
    };
    proto._resources = resources;
    proto._getResUuid = function(url, type, quiet) {
      if (!url) return null;
      var index = url.indexOf("?");
      -1 !== index && (url = url.substr(0, index));
      var uuid = resources.getUuid(url, type);
      if (!uuid) {
        var extname = cc.path.extname(url);
        if (extname) {
          url = url.slice(0, -extname.length);
          uuid = resources.getUuid(url, type);
          uuid && !quiet && cc.warnID(4901, url, extname);
        }
      }
      return uuid;
    };
    proto._getReferenceKey = function(assetOrUrlOrUuid) {
      var key;
      "object" === typeof assetOrUrlOrUuid ? key = assetOrUrlOrUuid._uuid || null : "string" === typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, true) || assetOrUrlOrUuid);
      if (!key) {
        cc.warnID(4800, assetOrUrlOrUuid);
        return key;
      }
      cc.AssetLibrary._getAssetInfoInRuntime(key, _info);
      return this._cache[_info.url] ? _info.url : key;
    };
    proto._urlNotFound = function(url, type, completeCallback) {
      callInNextTick((function() {
        url = cc.url.normalize(url);
        var info = (type ? js.getClassName(type) : "Asset") + ' in "resources/' + url + '" does not exist.';
        completeCallback && completeCallback(new Error(info), []);
      }));
    };
    proto._parseLoadResArgs = function(type, onProgress, onComplete) {
      if (void 0 === onComplete) {
        var isValidType = js.isChildClassOf(type, cc.RawAsset);
        if (onProgress) {
          onComplete = onProgress;
          isValidType && (onProgress = this.onProgress || null);
        } else if (void 0 === onProgress && !isValidType) {
          onComplete = type;
          onProgress = this.onProgress || null;
          type = null;
        }
        if (void 0 !== onProgress && !isValidType) {
          onProgress = type;
          type = null;
        }
      }
      return {
        type: type,
        onProgress: onProgress,
        onComplete: onComplete
      };
    };
    proto.loadRes = function(url, type, progressCallback, completeCallback) {
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var self = this;
      var uuid = self._getResUuid(url, type);
      uuid ? this.load({
        type: "uuid",
        uuid: uuid
      }, progressCallback, (function(err, asset) {
        asset && self.setAutoReleaseRecursively(uuid, false);
        completeCallback && completeCallback(err, asset);
      })) : self._urlNotFound(url, type, completeCallback);
    };
    proto._loadResUuids = function(uuids, progressCallback, completeCallback, urls) {
      if (uuids.length > 0) {
        var self = this;
        var res = uuids.map((function(uuid) {
          return {
            type: "uuid",
            uuid: uuid
          };
        }));
        this.load(res, progressCallback, (function(errors, items) {
          if (completeCallback) {
            var assetRes = [];
            var urlRes = urls && [];
            for (var i = 0; i < res.length; ++i) {
              var uuid = res[i].uuid;
              var id = this._getReferenceKey(uuid);
              var item = items.getContent(id);
              if (item) {
                self.setAutoReleaseRecursively(uuid, false);
                assetRes.push(item);
                urlRes && urlRes.push(urls[i]);
              }
            }
            urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
          }
        }));
      } else completeCallback && callInNextTick((function() {
        urls ? completeCallback(null, [], []) : completeCallback(null, []);
      }));
    };
    proto.loadResArray = function(urls, type, progressCallback, completeCallback) {
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var uuids = [];
      for (var i = 0; i < urls.length; i++) {
        var url = urls[i];
        var uuid = this._getResUuid(url, type);
        if (!uuid) {
          this._urlNotFound(url, type, completeCallback);
          return;
        }
        uuids.push(uuid);
      }
      this._loadResUuids(uuids, progressCallback, completeCallback);
    };
    proto.loadResDir = function(url, type, progressCallback, completeCallback) {
      var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
      type = args.type;
      progressCallback = args.onProgress;
      completeCallback = args.onComplete;
      var urls = [];
      var uuids = resources.getUuidArray(url, type, urls);
      this._loadResUuids(uuids, progressCallback, completeCallback, urls);
    };
    proto.getRes = function(url, type) {
      var item = this._cache[url];
      if (!item) {
        var uuid = this._getResUuid(url, type, true);
        if (!uuid) return null;
        var ref = this._getReferenceKey(uuid);
        item = this._cache[ref];
      }
      item && item.alias && (item = item.alias);
      return item && item.complete ? item.content : null;
    };
    proto.getResCount = function() {
      return Object.keys(this._cache).length;
    };
    proto.getDependsRecursively = function(owner) {
      if (owner) {
        var key = this._getReferenceKey(owner);
        var assets = AutoReleaseUtils.getDependsRecursively(key);
        assets.push(key);
        return assets;
      }
      return [];
    };
    proto.release = function(asset) {
      if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
        var key = asset[i];
        this.release(key);
      } else if (asset) {
        var id = this._getReferenceKey(asset);
        var item = this.getItem(id);
        if (item) {
          var removed = this.removeItem(id);
          asset = item.content;
          if (cc.Class.isInstanceOf(asset, cc.Asset)) {
            var nativeUrl = asset.nativeUrl;
            nativeUrl && this.release(nativeUrl);
            asset.destroy();
          }
          (true, removed) && this._releasedAssetChecker_DEBUG.setReleased(item, id);
        }
      }
    };
    proto.releaseAsset = function(asset) {
      var uuid = asset._uuid;
      uuid && this.release(uuid);
    };
    proto.releaseRes = function(url, type) {
      var uuid = this._getResUuid(url, type);
      uuid ? this.release(uuid) : cc.errorID(4914, url);
    };
    proto.releaseResDir = function(url, type) {
      var uuids = resources.getUuidArray(url, type);
      for (var i = 0; i < uuids.length; i++) {
        var uuid = uuids[i];
        this.release(uuid);
      }
    };
    proto.releaseAll = function() {
      for (var id in this._cache) this.release(id);
    };
    proto.removeItem = function(key) {
      var removed = Pipeline.prototype.removeItem.call(this, key);
      delete this._autoReleaseSetting[key];
      return removed;
    };
    proto.setAutoRelease = function(assetOrUrlOrUuid, autoRelease) {
      var key = this._getReferenceKey(assetOrUrlOrUuid);
      !!key && (this._autoReleaseSetting[key] = !!autoRelease);
    };
    proto.setAutoReleaseRecursively = function(assetOrUrlOrUuid, autoRelease) {
      autoRelease = !!autoRelease;
      var key = this._getReferenceKey(assetOrUrlOrUuid);
      if (key) {
        this._autoReleaseSetting[key] = autoRelease;
        var depends = AutoReleaseUtils.getDependsRecursively(key);
        for (var i = 0; i < depends.length; i++) {
          var depend = depends[i];
          this._autoReleaseSetting[depend] = autoRelease;
        }
      } else false;
    };
    proto.isAutoRelease = function(assetOrUrl) {
      var key = this._getReferenceKey(assetOrUrl);
      if (key) return !!this._autoReleaseSetting[key];
      return false;
    };
    cc.loader = new CCLoader();
    false;
    module.exports = cc.loader;
  }), {
    "../platform/js": 175,
    "../platform/utils": 179,
    "./asset-loader": 110,
    "./asset-table": 111,
    "./auto-release-utils": 113,
    "./downloader": 115,
    "./loader": 117,
    "./loading-items": 118,
    "./pipeline": 121,
    "./released-asset-checker": 122
  } ],
  110: [ (function(require, module, exports) {
    require("../utils/CCPath");
    var Pipeline = require("./pipeline");
    var LoadingItems = require("./loading-items");
    var ID = "AssetLoader";
    var AssetLoader = function(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
    };
    AssetLoader.ID = ID;
    var reusedArray = [];
    AssetLoader.prototype.handle = function(item, callback) {
      var uuid = item.uuid;
      if (!uuid) return !item.content ? null : item.content;
      var self = this;
      cc.AssetLibrary.queryAssetInfo(uuid, (function(error, url, isRawAsset) {
        if (error) callback(error); else {
          item.url = item.rawUrl = url;
          item.isRawAsset = isRawAsset;
          if (isRawAsset) {
            var ext = cc.path.extname(url).toLowerCase();
            if (!ext) {
              callback(new Error(cc._getError(4931, uuid, url)));
              return;
            }
            ext = ext.substr(1);
            var queue = LoadingItems.getQueue(item);
            reusedArray[0] = {
              queueId: item.queueId,
              id: url,
              url: url,
              type: ext,
              error: null,
              alias: item,
              complete: true
            };
            false;
            queue.append(reusedArray);
            item.type = ext;
            callback(null, item.content);
          } else {
            item.type = "uuid";
            callback(null, item.content);
          }
        }
      }));
    };
    Pipeline.AssetLoader = module.exports = AssetLoader;
  }), {
    "../utils/CCPath": 224,
    "./loading-items": 118,
    "./pipeline": 121
  } ],
  111: [ (function(require, module, exports) {
    var pushToMap = require("../utils/misc").pushToMap;
    var js = require("../platform/js");
    function Entry(uuid, type) {
      this.uuid = uuid;
      this.type = type;
    }
    function AssetTable() {
      this._pathToUuid = js.createMap(true);
    }
    function isMatchByWord(path, test) {
      if (path.length > test.length) {
        var nextAscii = path.charCodeAt(test.length);
        return 46 === nextAscii || 47 === nextAscii;
      }
      return true;
    }
    var proto = AssetTable.prototype;
    proto.getUuid = function(path, type) {
      path = cc.url.normalize(path);
      var item = this._pathToUuid[path];
      if (item) if (Array.isArray(item)) {
        if (!type) return item[0].uuid;
        for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (js.isChildClassOf(entry.type, type)) return entry.uuid;
        }
        if (true, js.isChildClassOf(type, cc.SpriteFrame)) for (var _i = 0; _i < item.length; _i++) {
          var _entry = item[_i];
          if (js.isChildClassOf(_entry.type, cc.SpriteAtlas)) {
            cc.errorID(4932, path);
            break;
          }
        }
      } else {
        if (!type || js.isChildClassOf(item.type, type)) return item.uuid;
        (true, js.isChildClassOf(type, cc.SpriteFrame)) && js.isChildClassOf(item.type, cc.SpriteAtlas) && cc.errorID(4932, path);
      }
      return "";
    };
    proto.getUuidArray = function(path, type, out_urls) {
      path = cc.url.normalize(path);
      "/" === path[path.length - 1] && (path = path.slice(0, -1));
      var path2uuid = this._pathToUuid;
      var uuids = [];
      var isChildClassOf = js.isChildClassOf;
      var _foundAtlasUrl;
      for (var p in path2uuid) if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
        var item = path2uuid[p];
        if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (!type || isChildClassOf(entry.type, type)) {
            uuids.push(entry.uuid);
            out_urls && out_urls.push(p);
          } else (true, entry.type === cc.SpriteAtlas) && (_foundAtlasUrl = p);
        } else if (!type || isChildClassOf(item.type, type)) {
          uuids.push(item.uuid);
          out_urls && out_urls.push(p);
        } else (true, item.type === cc.SpriteAtlas) && (_foundAtlasUrl = p);
      }
      (true, 0 === uuids.length) && _foundAtlasUrl && js.isChildClassOf(type, cc.SpriteFrame) && cc.errorID(4932, _foundAtlasUrl);
      return uuids;
    };
    proto.add = function(path, uuid, type, isMainAsset) {
      path = path.substring(0, path.length - cc.path.extname(path).length);
      var newEntry = new Entry(uuid, type);
      pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
    };
    proto._getInfo_DEBUG = (true, function(uuid, out_info) {
      var path2uuid = this._pathToUuid;
      var paths = Object.keys(path2uuid);
      for (var p = 0; p < paths.length; ++p) {
        var path = paths[p];
        var item = path2uuid[path];
        if (Array.isArray(item)) for (var i = 0; i < item.length; i++) {
          var entry = item[i];
          if (entry.uuid === uuid) {
            out_info.path = path;
            out_info.type = entry.type;
            return true;
          }
        } else if (item.uuid === uuid) {
          out_info.path = path;
          out_info.type = item.type;
          return true;
        }
      }
      return false;
    });
    proto.reset = function() {
      this._pathToUuid = js.createMap(true);
    };
    module.exports = AssetTable;
  }), {
    "../platform/js": 175,
    "../utils/misc": 233
  } ],
  112: [ (function(require, module, exports) {
    var sys = require("../platform/CCSys");
    var __audioSupport = sys.__audioSupport;
    var formatSupport = __audioSupport.format;
    var context = __audioSupport.context;
    function loadDomAudio(item, callback) {
      var dom = document.createElement("audio");
      dom.src = item.url;
      false;
      var clearEvent = function() {
        clearTimeout(timer);
        dom.removeEventListener("canplaythrough", success, false);
        dom.removeEventListener("error", failure, false);
        __audioSupport.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
      };
      var timer = setTimeout((function() {
        0 === dom.readyState ? failure() : success();
      }), 8e3);
      var success = function() {
        clearEvent();
        callback(null, dom);
      };
      var failure = function() {
        clearEvent();
        var message = "load audio failure - " + item.url;
        cc.log(message);
        callback(message);
      };
      dom.addEventListener("canplaythrough", success, false);
      dom.addEventListener("error", failure, false);
      __audioSupport.USE_LOADER_EVENT && dom.addEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
    }
    function loadWebAudio(item, callback) {
      context || callback(new Error(cc._getError(4926)));
      var request = cc.loader.getXMLHttpRequest();
      request.open("GET", item.url, true);
      request.responseType = "arraybuffer";
      request.onload = function() {
        context["decodeAudioData"](request.response, (function(buffer) {
          callback(null, buffer);
        }), (function() {
          callback("decode error - " + item.id, null);
        }));
      };
      request.onerror = function() {
        callback("request error - " + item.id, null);
      };
      request.send();
    }
    function downloadAudio(item, callback) {
      if (0 === formatSupport.length) return new Error(cc._getError(4927));
      var loader;
      if (__audioSupport.WEB_AUDIO) {
        var loadByDeserializedAudio = item._owner instanceof cc.AudioClip;
        loader = loadByDeserializedAudio ? item._owner.loadMode === cc.AudioClip.LoadMode.WEB_AUDIO ? loadWebAudio : loadDomAudio : item.urlParam && item.urlParam["useDom"] ? loadDomAudio : loadWebAudio;
      } else loader = loadDomAudio;
      loader(item, callback);
    }
    module.exports = downloadAudio;
  }), {
    "../platform/CCSys": 164
  } ],
  113: [ (function(require, module, exports) {
    var js = require("../platform/js");
    function parseDepends(key, parsed) {
      var item = cc.loader.getItem(key);
      if (item) {
        var depends = item.dependKeys;
        if (depends) for (var i = 0; i < depends.length; i++) {
          var depend = depends[i];
          if (!parsed[depend]) {
            parsed[depend] = true;
            parseDepends(depend, parsed);
          }
        }
      }
    }
    function visitAsset(asset, excludeMap) {
      if (!asset._uuid) return;
      var key = cc.loader._getReferenceKey(asset);
      if (!excludeMap[key]) {
        excludeMap[key] = true;
        parseDepends(key, excludeMap);
      }
    }
    function visitComponent(comp, excludeMap) {
      var props = Object.getOwnPropertyNames(comp);
      for (var i = 0; i < props.length; i++) {
        var value = comp[props[i]];
        if ("object" === typeof value && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
          var val = value[j];
          cc.Class.isInstanceOf(val, cc.RawAsset) && visitAsset(val, excludeMap);
        } else if (value.constructor && value.constructor !== Object) cc.Class.isInstanceOf(value, cc.RawAsset) && visitAsset(value, excludeMap); else {
          var keys = Object.getOwnPropertyNames(value);
          for (var _j = 0; _j < keys.length; _j++) {
            var _val = value[keys[_j]];
            cc.Class.isInstanceOf(_val, cc.RawAsset) && visitAsset(_val, excludeMap);
          }
        }
      }
    }
    function visitNode(node, excludeMap) {
      for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], excludeMap);
      for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], excludeMap);
    }
    module.exports = {
      autoRelease: function(oldSceneAssets, nextSceneAssets, persistNodes) {
        var releaseSettings = cc.loader._autoReleaseSetting;
        var excludeMap = js.createMap();
        if (nextSceneAssets) for (var i = 0; i < nextSceneAssets.length; i++) excludeMap[nextSceneAssets[i]] = true;
        for (var _i2 = 0; _i2 < persistNodes.length; _i2++) visitNode(persistNodes[_i2], excludeMap);
        if (oldSceneAssets) for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
          var key = oldSceneAssets[_i3];
          false === releaseSettings[key] || excludeMap[key] || cc.loader.release(key);
        }
        var keys = Object.keys(releaseSettings);
        for (var _i4 = 0; _i4 < keys.length; _i4++) {
          var _key = keys[_i4];
          true !== releaseSettings[_key] || excludeMap[_key] || cc.loader.release(_key);
        }
      },
      getDependsRecursively: function(key) {
        var depends = {};
        parseDepends(key, depends);
        return Object.keys(depends);
      }
    };
  }), {
    "../platform/js": 175
  } ],
  114: [ (function(require, module, exports) {
    false;
    {
      function downloadBinary(item, callback) {
        var url = item.url;
        var self = this;
        var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load binary data failed: " + url;
        xhr.open("GET", url, true);
        xhr.responseType = "arraybuffer";
        xhr.onload = function() {
          var arrayBuffer = xhr.response;
          if (arrayBuffer) {
            var result = new Uint8Array(arrayBuffer);
            callback(null, result);
          } else callback({
            status: xhr.status,
            errorMessage: errInfo + "(no response)"
          });
        };
        xhr.onerror = function() {
          callback({
            status: xhr.status,
            errorMessage: errInfo + "(error)"
          });
        };
        xhr.ontimeout = function() {
          callback({
            status: xhr.status,
            errorMessage: errInfo + "(time out)"
          });
        };
        xhr.send(null);
      }
      module.exports = downloadBinary;
    }
  }), {} ],
  115: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var sys = require("../platform/CCSys");
    require("../utils/CCPath");
    var Pipeline = require("./pipeline");
    var PackDownloader = require("./pack-downloader");
    var downloadBinary = require("./binary-downloader");
    var downloadText = require("./text-downloader");
    var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
    var downloadAudio;
    true;
    downloadAudio = require("./audio-downloader");
    function downloadScript(item, callback, isAsync) {
      if (sys.platform === sys.WECHAT_GAME) {
        require(item.url);
        callback(null, item.url);
        return;
      }
      var url = item.url, d = document, s = document.createElement("script");
      s.async = isAsync;
      s.src = urlAppendTimestamp(url);
      function loadHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        callback(null, url);
      }
      function errorHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        callback(new Error(cc._getError(4928, url)));
      }
      s.addEventListener("load", loadHandler, false);
      s.addEventListener("error", errorHandler, false);
      d.body.appendChild(s);
    }
    function downloadWebp(item, callback, isCrossOrigin, img) {
      if (!cc.sys.capabilities.webp) return new Error(cc._getError(4929, item.url));
      return downloadImage(item, callback, isCrossOrigin, img);
    }
    function downloadImage(item, callback, isCrossOrigin, img) {
      void 0 === isCrossOrigin && (isCrossOrigin = true);
      var url = urlAppendTimestamp(item.url);
      img = img || new Image();
      isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null;
      if (img.complete && img.naturalWidth > 0 && img.src === url) return img;
      (function() {
        function loadCallback() {
          img.removeEventListener("load", loadCallback);
          img.removeEventListener("error", errorCallback);
          callback(null, img);
        }
        function errorCallback() {
          img.removeEventListener("load", loadCallback);
          img.removeEventListener("error", errorCallback);
          "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, false, img) : callback(new Error(cc._getError(4930, url)));
        }
        img.addEventListener("load", loadCallback);
        img.addEventListener("error", errorCallback);
        img.src = url;
      })();
    }
    var FONT_TYPE = {
      ".eot": "embedded-opentype",
      ".ttf": "truetype",
      ".ttc": "truetype",
      ".woff": "woff",
      ".svg": "svg"
    };
    function _loadFont(name, srcs, type) {
      var doc = document, fontStyle = document.createElement("style");
      fontStyle.type = "text/css";
      doc.body.appendChild(fontStyle);
      var fontStr = "";
      isNaN(name - 0) ? fontStr += "@font-face { font-family:" + name + "; src:" : fontStr += "@font-face { font-family:'" + name + "'; src:";
      if (srcs instanceof Array) for (var i = 0, li = srcs.length; i < li; i++) {
        var src = srcs[i];
        type = cc.path.extname(src).toLowerCase();
        fontStr += "url('" + srcs[i] + "') format('" + FONT_TYPE[type] + "')";
        fontStr += i === li - 1 ? ";" : ",";
      } else {
        type = type.toLowerCase();
        fontStr += "url('" + srcs + "') format('" + FONT_TYPE[type] + "');";
      }
      fontStyle.textContent += fontStr + "}";
      var preloadDiv = document.createElement("div");
      var _divStyle = preloadDiv.style;
      _divStyle.fontFamily = name;
      preloadDiv.innerHTML = ".";
      _divStyle.position = "absolute";
      _divStyle.left = "-100px";
      _divStyle.top = "-100px";
      doc.body.appendChild(preloadDiv);
    }
    function downloadFont(item, callback) {
      var url = item.url, type = item.type, name = item.name, srcs = item.srcs;
      if (name && srcs) {
        -1 === srcs.indexOf(url) && srcs.push(url);
        _loadFont(name, srcs);
      } else {
        type = cc.path.extname(url);
        name = cc.path.basename(url, type);
        _loadFont(name, url, type);
      }
      if (!document.fonts) return null;
      document.fonts.load("1em " + name).then((function() {
        callback(null, null);
      }), (function(err) {
        callback(err);
      }));
    }
    function downloadUuid(item, callback) {
      var result = PackDownloader.load(item, callback);
      if (void 0 === result) return this.extMap["json"](item, callback);
      return result || void 0;
    }
    var defaultMap = {
      js: downloadScript,
      png: downloadImage,
      jpg: downloadImage,
      bmp: downloadImage,
      jpeg: downloadImage,
      gif: downloadImage,
      ico: downloadImage,
      tiff: downloadImage,
      webp: downloadWebp,
      image: downloadImage,
      mp3: downloadAudio,
      ogg: downloadAudio,
      wav: downloadAudio,
      m4a: downloadAudio,
      txt: downloadText,
      xml: downloadText,
      vsh: downloadText,
      fsh: downloadText,
      atlas: downloadText,
      tmx: downloadText,
      tsx: downloadText,
      json: downloadText,
      ExportJson: downloadText,
      plist: downloadText,
      fnt: downloadText,
      font: downloadFont,
      eot: downloadFont,
      ttf: downloadFont,
      woff: downloadFont,
      svg: downloadFont,
      ttc: downloadFont,
      uuid: downloadUuid,
      binary: downloadBinary,
      default: downloadText
    };
    var ID = "Downloader";
    var Downloader = function(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
      this._curConcurrent = 0;
      this._loadQueue = [];
      this.extMap = js.mixin(extMap, defaultMap);
    };
    Downloader.ID = ID;
    Downloader.PackDownloader = PackDownloader;
    Downloader.prototype.addHandlers = function(extMap) {
      js.mixin(this.extMap, extMap);
    };
    Downloader.prototype._handleLoadQueue = function() {
      while (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
        var nextOne = this._loadQueue.shift();
        if (!nextOne) break;
        var syncRet = this.handle(nextOne.item, nextOne.callback);
        void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
      }
    };
    Downloader.prototype.handle = function(item, callback) {
      var self = this;
      var downloadFunc = this.extMap[item.type] || this.extMap["default"];
      var syncRet = void 0;
      if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
        this._curConcurrent++;
        syncRet = downloadFunc.call(this, item, (function(err, result) {
          self._curConcurrent = Math.max(0, self._curConcurrent - 1);
          self._handleLoadQueue();
          callback && callback(err, result);
        }));
        if (void 0 !== syncRet) {
          this._curConcurrent = Math.max(0, this._curConcurrent - 1);
          this._handleLoadQueue();
          return syncRet;
        }
      } else if (item.ignoreMaxConcurrency) {
        syncRet = downloadFunc.call(this, item, callback);
        if (void 0 !== syncRet) return syncRet;
      } else this._loadQueue.push({
        item: item,
        callback: callback
      });
    };
    Pipeline.Downloader = module.exports = Downloader;
  }), {
    "../platform/CCSys": 164,
    "../platform/js": 175,
    "../utils/CCPath": 224,
    "./audio-downloader": 112,
    "./binary-downloader": 114,
    "./pack-downloader": 120,
    "./pipeline": 121,
    "./text-downloader": 123,
    "./utils": 125
  } ],
  116: [ (function(require, module, exports) {
    require("./downloader");
    require("./loader");
    require("./loading-items");
    require("./pipeline");
    require("./CCLoader");
  }), {
    "./CCLoader": 109,
    "./downloader": 115,
    "./loader": 117,
    "./loading-items": 118,
    "./pipeline": 121
  } ],
  117: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var sys = require("../platform/CCSys");
    var Pipeline = require("./pipeline");
    var Texture2D = require("../assets/CCTexture2D");
    var loadUuid = require("./uuid-loader");
    function loadNothing(item, callback) {
      return null;
    }
    function loadJSON(item, callback) {
      if ("string" !== typeof item.content) return new Error("JSON Loader: Input item doesn't contain string content");
      try {
        var result = JSON.parse(item.content);
        return result;
      } catch (e) {
        return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
      }
    }
    function loadImage(item, callback) {
      var loadByDeserializedAsset = cc.Class.isInstanceOf(item._owner, cc.Asset);
      if (loadByDeserializedAsset) return null;
      var image = item.content;
      if ((true, true) && !(image instanceof Image)) return new Error("Image Loader: Input item doesn't contain Image content");
      var rawUrl = item.rawUrl;
      var tex = item.texture || new Texture2D();
      tex._uuid = item.uuid;
      tex.url = rawUrl;
      tex._setRawAsset(rawUrl, false);
      tex._nativeAsset = image;
      return tex;
    }
    function loadAudioAsAsset(item, callback) {
      var loadByDeserializedAsset = cc.Class.isInstanceOf(item._owner, cc.Asset);
      if (loadByDeserializedAsset) return null;
      var audioClip = new cc.AudioClip();
      audioClip._setRawAsset(item.rawUrl, false);
      audioClip._nativeAsset = item.content;
      return audioClip;
    }
    function loadPlist(item, callback) {
      if ("string" !== typeof item.content) return new Error("Plist Loader: Input item doesn't contain string content");
      var result = cc.plistParser.parse(item.content);
      return result || new Error("Plist Loader: Parse [" + item.id + "] failed");
    }
    function loadBinary(item, callback) {
      return item.load ? item.load(item.content) : null;
    }
    var defaultMap = {
      png: loadImage,
      jpg: loadImage,
      bmp: loadImage,
      jpeg: loadImage,
      gif: loadImage,
      ico: loadImage,
      tiff: loadImage,
      webp: loadImage,
      image: loadImage,
      mp3: loadAudioAsAsset,
      ogg: loadAudioAsAsset,
      wav: loadAudioAsAsset,
      m4a: loadAudioAsAsset,
      json: loadJSON,
      ExportJson: loadJSON,
      plist: loadPlist,
      uuid: loadUuid,
      prefab: loadUuid,
      fire: loadUuid,
      scene: loadUuid,
      binary: loadBinary,
      default: loadNothing
    };
    var ID = "Loader";
    var Loader = function(extMap) {
      this.id = ID;
      this.async = true;
      this.pipeline = null;
      this.extMap = js.mixin(extMap, defaultMap);
    };
    Loader.ID = ID;
    Loader.prototype.addHandlers = function(extMap) {
      this.extMap = js.mixin(this.extMap, extMap);
    };
    Loader.prototype.handle = function(item, callback) {
      var loadFunc = this.extMap[item.type] || this.extMap["default"];
      return loadFunc.call(this, item, callback);
    };
    Pipeline.Loader = module.exports = Loader;
  }), {
    "../assets/CCTexture2D": 49,
    "../platform/CCSys": 164,
    "../platform/js": 175,
    "./pipeline": 121,
    "./uuid-loader": 126
  } ],
  118: [ (function(require, module, exports) {
    var CallbacksInvoker = require("../platform/callbacks-invoker");
    require("../utils/CCPath");
    var js = require("../platform/js");
    var _qid = 0 | 998 * Math.random();
    var _queues = js.createMap(true);
    var _pool = [];
    var _POOL_MAX_LENGTH = 10;
    var ItemState = {
      WORKING: 1,
      COMPLETE: 2,
      ERROR: 3
    };
    var _queueDeps = js.createMap(true);
    function isIdValid(id) {
      var realId = id.url || id;
      return "string" === typeof realId;
    }
    function _parseUrlParam(url) {
      if (!url) return;
      var split = url.split("?");
      if (!split || !split[0] || !split[1]) return;
      var urlParam = {};
      var queries = split[1].split("&");
      queries.forEach((function(item) {
        var itemSplit = item.split("=");
        urlParam[itemSplit[0]] = itemSplit[1];
      }));
      return urlParam;
    }
    function createItem(id, queueId) {
      var url = "object" === typeof id ? id.url : id;
      var result = {
        queueId: queueId,
        id: url,
        url: url,
        rawUrl: void 0,
        urlParam: _parseUrlParam(url),
        type: "",
        error: null,
        content: null,
        complete: false,
        states: {},
        deps: null
      };
      if ("object" === typeof id) {
        js.mixin(result, id);
        if (id.skips) for (var i = 0; i < id.skips.length; i++) {
          var skip = id.skips[i];
          result.states[skip] = ItemState.COMPLETE;
        }
      }
      result.rawUrl = result.url;
      url && !result.type && (result.type = cc.path.extname(url).toLowerCase().substr(1));
      return result;
    }
    var checkedIds = [];
    function checkCircleReference(owner, item, recursiveCall) {
      if (!owner || !item) return false;
      var result = false;
      checkedIds.push(item.id);
      if (item.deps) {
        var i, deps = item.deps, subDep;
        for (i = 0; i < deps.length; i++) {
          subDep = deps[i];
          if (subDep.id === owner.id) {
            result = true;
            break;
          }
          if (checkedIds.indexOf(subDep.id) >= 0) continue;
          if (subDep.deps && checkCircleReference(owner, subDep, true)) {
            result = true;
            break;
          }
        }
      }
      recursiveCall || (checkedIds.length = 0);
      return result;
    }
    var LoadingItems = function(pipeline, urlList, onProgress, onComplete) {
      CallbacksInvoker.call(this);
      this._id = ++_qid;
      _queues[this._id] = this;
      this._pipeline = pipeline;
      this._errorUrls = [];
      this._appending = false;
      this._ownerQueue = null;
      this.onProgress = onProgress;
      this.onComplete = onComplete;
      this.map = js.createMap(true);
      this.completed = {};
      this.totalCount = 0;
      this.completedCount = 0;
      this._pipeline ? this.active = true : this.active = false;
      urlList && (urlList.length > 0 ? this.append(urlList) : this.allComplete());
    };
    LoadingItems.ItemState = new cc.Enum(ItemState);
    LoadingItems.create = function(pipeline, urlList, onProgress, onComplete) {
      if (void 0 === onProgress) {
        if ("function" === typeof urlList) {
          onComplete = urlList;
          urlList = onProgress = null;
        }
      } else if (void 0 === onComplete) if ("function" === typeof urlList) {
        onComplete = onProgress;
        onProgress = urlList;
        urlList = null;
      } else {
        onComplete = onProgress;
        onProgress = null;
      }
      var queue = _pool.pop();
      if (queue) {
        queue._pipeline = pipeline;
        queue.onProgress = onProgress;
        queue.onComplete = onComplete;
        _queues[queue._id] = queue;
        queue._pipeline && (queue.active = true);
        urlList && queue.append(urlList);
      } else queue = new LoadingItems(pipeline, urlList, onProgress, onComplete);
      return queue;
    };
    LoadingItems.getQueue = function(item) {
      return item.queueId ? _queues[item.queueId] : null;
    };
    LoadingItems.itemComplete = function(item) {
      var queue = _queues[item.queueId];
      queue && queue.itemComplete(item.id);
    };
    LoadingItems.initQueueDeps = function(queue) {
      var dep = _queueDeps[queue._id];
      if (dep) {
        dep.completed.length = 0;
        dep.deps.length = 0;
      } else dep = _queueDeps[queue._id] = {
        completed: [],
        deps: []
      };
    };
    LoadingItems.registerQueueDep = function(owner, depId) {
      var queueId = owner.queueId || owner;
      if (!queueId) return false;
      var queueDepList = _queueDeps[queueId];
      if (queueDepList) -1 === queueDepList.deps.indexOf(depId) && queueDepList.deps.push(depId); else if (owner.id) for (var id in _queueDeps) {
        var queue = _queueDeps[id];
        -1 !== queue.deps.indexOf(owner.id) && -1 === queue.deps.indexOf(depId) && queue.deps.push(depId);
      }
    };
    LoadingItems.finishDep = function(depId) {
      for (var id in _queueDeps) {
        var queue = _queueDeps[id];
        -1 !== queue.deps.indexOf(depId) && -1 === queue.completed.indexOf(depId) && queue.completed.push(depId);
      }
    };
    var proto = LoadingItems.prototype;
    js.mixin(proto, CallbacksInvoker.prototype);
    proto.append = function(urlList, owner) {
      if (!this.active) return [];
      owner && !owner.deps && (owner.deps = []);
      this._appending = true;
      var accepted = [], i, url, item;
      for (i = 0; i < urlList.length; ++i) {
        url = urlList[i];
        if (url.queueId && !this.map[url.id]) {
          this.map[url.id] = url;
          owner && owner.deps.push(url);
          if (url.complete || checkCircleReference(owner, url)) {
            this.totalCount++;
            this.itemComplete(url.id);
            continue;
          }
          var self = this;
          var queue = _queues[url.queueId];
          if (queue) {
            this.totalCount++;
            LoadingItems.registerQueueDep(owner || this._id, url.id);
            queue.addListener(url.id, (function(item) {
              self.itemComplete(item.id);
            }));
          }
          continue;
        }
        if (isIdValid(url)) {
          item = createItem(url, this._id);
          var key = item.id;
          if (!this.map[key]) {
            this.map[key] = item;
            this.totalCount++;
            owner && owner.deps.push(item);
            LoadingItems.registerQueueDep(owner || this._id, key);
            accepted.push(item);
          }
        }
      }
      this._appending = false;
      this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted);
      return accepted;
    };
    proto._childOnProgress = function(item) {
      if (this.onProgress) {
        var dep = _queueDeps[this._id];
        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
      }
    };
    proto.allComplete = function() {
      var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
      this.onComplete && this.onComplete(errors, this);
    };
    proto.isCompleted = function() {
      return this.completedCount >= this.totalCount;
    };
    proto.isItemCompleted = function(id) {
      return !!this.completed[id];
    };
    proto.exists = function(id) {
      return !!this.map[id];
    };
    proto.getContent = function(id) {
      var item = this.map[id];
      var ret = null;
      item && (item.content ? ret = item.content : item.alias && (ret = item.alias.content));
      return ret;
    };
    proto.getError = function(id) {
      var item = this.map[id];
      var ret = null;
      item && (item.error ? ret = item.error : item.alias && (ret = item.alias.error));
      return ret;
    };
    proto.addListener = CallbacksInvoker.prototype.add;
    proto.hasListener = CallbacksInvoker.prototype.has;
    proto.removeListener = CallbacksInvoker.prototype.remove;
    proto.removeAllListeners = CallbacksInvoker.prototype.removeAll;
    proto.removeItem = function(url) {
      var item = this.map[url];
      if (!item) return;
      if (!this.completed[item.alias || url]) return;
      delete this.completed[url];
      delete this.map[url];
      if (item.alias) {
        delete this.completed[item.alias.id];
        delete this.map[item.alias.id];
      }
      this.completedCount--;
      this.totalCount--;
    };
    proto.itemComplete = function(id) {
      var item = this.map[id];
      if (!item) return;
      var errorListId = this._errorUrls.indexOf(id);
      item.error && -1 === errorListId ? this._errorUrls.push(id) : item.error || -1 === errorListId || this._errorUrls.splice(errorListId, 1);
      this.completed[id] = item;
      this.completedCount++;
      LoadingItems.finishDep(item.id);
      if (this.onProgress) {
        var dep = _queueDeps[this._id];
        this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
      }
      this.invoke(id, item);
      this.removeAll(id);
      !this._appending && this.completedCount >= this.totalCount && this.allComplete();
    };
    proto.destroy = function() {
      this.active = false;
      this._appending = false;
      this._pipeline = null;
      this._ownerQueue = null;
      this._errorUrls.length = 0;
      this.onProgress = null;
      this.onComplete = null;
      this.map = js.createMap(true);
      this.completed = {};
      this.totalCount = 0;
      this.completedCount = 0;
      CallbacksInvoker.call(this);
      _queues[this._id] = null;
      if (_queueDeps[this._id]) {
        _queueDeps[this._id].completed.length = 0;
        _queueDeps[this._id].deps.length = 0;
      }
      -1 === _pool.indexOf(this) && _pool.length < _POOL_MAX_LENGTH && _pool.push(this);
    };
    cc.LoadingItems = module.exports = LoadingItems;
  }), {
    "../platform/callbacks-invoker": 168,
    "../platform/js": 175,
    "../utils/CCPath": 224
  } ],
  119: [ (function(require, module, exports) {
    var Pipeline = require("./pipeline");
    var ID = "MD5Pipe";
    var ExtnameRegex = /(\.[^.\n\\/]*)$/;
    var MD5Pipe = function(md5AssetsMap, libraryBase, rawAssetsBase) {
      this.id = ID;
      this.async = false;
      this.pipeline = null;
      this.md5AssetsMap = md5AssetsMap;
      this.libraryBase = libraryBase;
      this.rawAssetsBase = rawAssetsBase;
    };
    MD5Pipe.ID = ID;
    MD5Pipe.prototype.handle = function(item) {
      item.url = this.transformURL(item.url);
      return item;
    };
    MD5Pipe.prototype.transformURL = function(url, hashPatchInFolder) {
      var index = url.indexOf("?");
      var key = url;
      -1 !== index && (key = url.substr(0, index));
      if (key.startsWith(this.libraryBase)) key = key.slice(this.libraryBase.length); else {
        if (!key.startsWith(this.rawAssetsBase)) return url;
        key = key.slice(this.rawAssetsBase.length);
      }
      var hashValue = this.md5AssetsMap[key];
      if (hashValue) if (hashPatchInFolder) {
        var dirname = cc.path.dirname(url);
        var basename = cc.path.basename(url);
        url = dirname + "." + hashValue + "/" + basename;
      } else {
        var matched = false;
        url = url.replace(ExtnameRegex, (function(match, p1) {
          matched = true;
          return "." + hashValue + p1;
        }));
        matched || (url = url + "." + hashValue);
      }
      return url;
    };
    Pipeline.MD5Pipe = module.exports = MD5Pipe;
  }), {
    "./pipeline": 121
  } ],
  120: [ (function(require, module, exports) {
    var Unpackers = require("./unpackers");
    var pushToMap = require("../utils/misc").pushToMap;
    var PackState = {
      Invalid: 0,
      Removed: 1,
      Downloading: 2,
      Loaded: 3
    };
    function UnpackerData() {
      this.unpacker = null;
      this.state = PackState.Invalid;
    }
    var uuidToPack = {};
    var packIndices = {};
    var globalUnpackers = {};
    function error(uuid, packUuid) {
      return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
    }
    module.exports = {
      initPacks: function(packs) {
        packIndices = packs;
        for (var packUuid in packs) {
          var uuids = packs[packUuid];
          for (var i = 0; i < uuids.length; i++) {
            var uuid = uuids[i];
            var pushFront = 1 === uuids.length;
            pushToMap(uuidToPack, uuid, packUuid, pushFront);
          }
        }
      },
      _loadNewPack: function(uuid, packUuid, callback) {
        var self = this;
        var packUrl = cc.AssetLibrary.getLibUrlNoExt(packUuid) + ".json";
        cc.loader.load({
          url: packUrl,
          ignoreMaxConcurrency: true
        }, (function(err, packJson) {
          if (err) {
            cc.errorID(4916, uuid);
            return callback(err);
          }
          var res = self._doLoadNewPack(uuid, packUuid, packJson);
          res ? callback(null, res) : callback(error(uuid, packUuid));
        }));
      },
      _doPreload: function(packUuid, packJson) {
        var unpackerData = globalUnpackers[packUuid];
        if (!unpackerData) {
          unpackerData = globalUnpackers[packUuid] = new UnpackerData();
          unpackerData.state = PackState.Downloading;
        }
        if (unpackerData.state !== PackState.Loaded) {
          unpackerData.unpacker = new Unpackers.JsonUnpacker();
          unpackerData.unpacker.load(packIndices[packUuid], packJson);
          unpackerData.state = PackState.Loaded;
        }
      },
      _doLoadNewPack: function(uuid, packUuid, packedJson) {
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData.state !== PackState.Loaded) {
          "string" === typeof packedJson && (packedJson = JSON.parse(packedJson));
          Array.isArray(packedJson) ? unpackerData.unpacker = new Unpackers.JsonUnpacker() : packedJson.type === Unpackers.TextureUnpacker.ID && (unpackerData.unpacker = new Unpackers.TextureUnpacker());
          unpackerData.unpacker.load(packIndices[packUuid], packedJson);
          unpackerData.state = PackState.Loaded;
        }
        return unpackerData.unpacker.retrieve(uuid);
      },
      _selectLoadedPack: function(packUuids) {
        var existsPackState = PackState.Invalid;
        var existsPackUuid = "";
        for (var i = 0; i < packUuids.length; i++) {
          var packUuid = packUuids[i];
          var unpackerData = globalUnpackers[packUuid];
          if (unpackerData) {
            var state = unpackerData.state;
            if (state === PackState.Loaded) return packUuid;
            if (state > existsPackState) {
              existsPackState = state;
              existsPackUuid = packUuid;
            }
          }
        }
        return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
      },
      load: function(item, callback) {
        var uuid = item.uuid;
        var packUuid = uuidToPack[uuid];
        if (!packUuid) return;
        Array.isArray(packUuid) && (packUuid = this._selectLoadedPack(packUuid));
        var unpackerData = globalUnpackers[packUuid];
        if (unpackerData && unpackerData.state === PackState.Loaded) {
          var json = unpackerData.unpacker.retrieve(uuid);
          return json || error(uuid, packUuid);
        }
        if (!unpackerData) {
          true;
          console.log("Create unpacker %s for %s", packUuid, uuid);
          unpackerData = globalUnpackers[packUuid] = new UnpackerData();
          unpackerData.state = PackState.Downloading;
        }
        this._loadNewPack(uuid, packUuid, callback);
        return null;
      }
    };
    false;
  }), {
    "../utils/misc": 233,
    "./unpackers": 124
  } ],
  121: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var LoadingItems = require("./loading-items");
    var ItemState = LoadingItems.ItemState;
    function flow(pipe, item) {
      var pipeId = pipe.id;
      var itemState = item.states[pipeId];
      var next = pipe.next;
      var pipeline = pipe.pipeline;
      if (item.error || itemState === ItemState.WORKING || itemState === ItemState.ERROR) return;
      if (itemState === ItemState.COMPLETE) next ? flow(next, item) : pipeline.flowOut(item); else {
        item.states[pipeId] = ItemState.WORKING;
        var result = pipe.handle(item, (function(err, result) {
          if (err) {
            item.error = err;
            item.states[pipeId] = ItemState.ERROR;
            pipeline.flowOut(item);
          } else {
            result && (item.content = result);
            item.states[pipeId] = ItemState.COMPLETE;
            next ? flow(next, item) : pipeline.flowOut(item);
          }
        }));
        if (result instanceof Error) {
          item.error = result;
          item.states[pipeId] = ItemState.ERROR;
          pipeline.flowOut(item);
        } else if (void 0 !== result) {
          null !== result && (item.content = result);
          item.states[pipeId] = ItemState.COMPLETE;
          next ? flow(next, item) : pipeline.flowOut(item);
        }
      }
    }
    var Pipeline = function(pipes) {
      this._pipes = pipes;
      this._cache = js.createMap(true);
      for (var i = 0; i < pipes.length; ++i) {
        var pipe = pipes[i];
        if (!pipe.handle || !pipe.id) continue;
        pipe.pipeline = this;
        pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null;
      }
    };
    Pipeline.ItemState = ItemState;
    var proto = Pipeline.prototype;
    proto.insertPipe = function(pipe, index) {
      if (!pipe.handle || !pipe.id || index > this._pipes.length) {
        cc.warnID(4921);
        return;
      }
      if (this._pipes.indexOf(pipe) > 0) {
        cc.warnID(4922);
        return;
      }
      pipe.pipeline = this;
      var nextPipe = null;
      index < this._pipes.length && (nextPipe = this._pipes[index]);
      var previousPipe = null;
      index > 0 && (previousPipe = this._pipes[index - 1]);
      previousPipe && (previousPipe.next = pipe);
      pipe.next = nextPipe;
      this._pipes.splice(index, 0, pipe);
    };
    proto.insertPipeAfter = function(refPipe, newPipe) {
      var index = this._pipes.indexOf(refPipe);
      if (index < 0) return;
      this.insertPipe(newPipe, index + 1);
    };
    proto.appendPipe = function(pipe) {
      if (!pipe.handle || !pipe.id) return;
      pipe.pipeline = this;
      pipe.next = null;
      this._pipes.length > 0 && (this._pipes[this._pipes.length - 1].next = pipe);
      this._pipes.push(pipe);
    };
    proto.flowIn = function(items) {
      var i, pipe = this._pipes[0], item;
      if (pipe) {
        for (i = 0; i < items.length; i++) {
          item = items[i];
          this._cache[item.id] = item;
        }
        for (i = 0; i < items.length; i++) {
          item = items[i];
          flow(pipe, item);
        }
      } else for (i = 0; i < items.length; i++) this.flowOut(items[i]);
    };
    proto.flowInDeps = function(owner, urlList, callback) {
      var deps = LoadingItems.create(this, (function(errors, items) {
        callback(errors, items);
        items.destroy();
      }));
      return deps.append(urlList, owner);
    };
    proto.flowOut = function(item) {
      item.error ? delete this._cache[item.id] : this._cache[item.id] || (this._cache[item.id] = item);
      item.complete = true;
      LoadingItems.itemComplete(item);
    };
    proto.copyItemStates = function(srcItem, dstItems) {
      if (!(dstItems instanceof Array)) {
        dstItems.states = srcItem.states;
        return;
      }
      for (var i = 0; i < dstItems.length; ++i) dstItems[i].states = srcItem.states;
    };
    proto.getItem = function(id) {
      var item = this._cache[id];
      if (!item) return item;
      item.alias && (item = item.alias);
      return item;
    };
    proto.removeItem = function(id) {
      var removed = this._cache[id];
      removed && removed.complete && delete this._cache[id];
      return removed;
    };
    proto.clear = function() {
      for (var id in this._cache) {
        var item = this._cache[id];
        delete this._cache[id];
        if (!item.complete) {
          item.error = new Error("Canceled manually");
          this.flowOut(item);
        }
      }
    };
    cc.Pipeline = module.exports = Pipeline;
  }), {
    "../platform/js": 175,
    "./loading-items": 118
  } ],
  122: [ (function(require, module, exports) {
    true;
    var js;
    var tmpInfo;
    (function() {
      js = require("../platform/js");
      function ReleasedAssetChecker() {
        this._releasedKeys = js.createMap(true);
        this._dirty = false;
      }
      ReleasedAssetChecker.prototype.setReleased = function(item, releasedKey) {
        this._releasedKeys[releasedKey] = true;
        this._dirty = true;
      };
      tmpInfo = null;
      function getItemDesc(item) {
        if (item.uuid) {
          tmpInfo || (tmpInfo = {
            path: "",
            type: null
          });
          if (cc.loader._resources._getInfo_DEBUG(item.uuid, tmpInfo)) {
            tmpInfo.path = "resources/" + tmpInfo.path;
            return '"' + tmpInfo.path + '" (type: ' + js.getClassName(tmpInfo.type) + ", uuid: " + item.uuid + ")";
          }
          return '"' + item.rawUrl + '" (' + item.uuid + ")";
        }
        return '"' + item.rawUrl + '"';
      }
      function doCheckCouldRelease(releasedKey, refOwnerItem, caches) {
        var loadedAgain = caches[releasedKey];
        loadedAgain || cc.log('"' + releasedKey + '" was released but maybe still referenced by ' + getItemDesc(refOwnerItem));
      }
      ReleasedAssetChecker.prototype.checkCouldRelease = function(caches) {
        if (!this._dirty) return;
        this._dirty = false;
        var released = this._releasedKeys;
        for (var id in caches) {
          var item = caches[id];
          item.alias && (item = item.alias);
          var depends = item.dependKeys;
          if (depends) for (var i = 0; i < depends.length; ++i) {
            var depend = depends[i];
            if (released[depend]) {
              doCheckCouldRelease(depend, item, caches);
              delete released[depend];
            }
          }
        }
        js.clear(released);
      };
      module.exports = ReleasedAssetChecker;
    })();
  }), {
    "../platform/js": 175
  } ],
  123: [ (function(require, module, exports) {
    var sys = require("../platform/CCSys");
    false;
    var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
    module.exports = function(item, callback) {
      var url = item.url;
      url = urlAppendTimestamp(url);
      var xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load text file failed: " + url, navigator = window.navigator;
      xhr.open("GET", url, true);
      xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8");
      xhr.onload = function() {
        4 === xhr.readyState ? 200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
          status: xhr.status,
          errorMessage: errInfo + "(wrong status)"
        }) : callback({
          status: xhr.status,
          errorMessage: errInfo + "(wrong readyState)"
        });
      };
      xhr.onerror = function() {
        callback({
          status: xhr.status,
          errorMessage: errInfo + "(error)"
        });
      };
      xhr.ontimeout = function() {
        callback({
          status: xhr.status,
          errorMessage: errInfo + "(time out)"
        });
      };
      xhr.send(null);
    };
  }), {
    "../platform/CCSys": 164,
    "./utils": 125
  } ],
  124: [ (function(require, module, exports) {
    var Texture2D = require("../assets/CCTexture2D");
    var js = require("../platform/js");
    function JsonUnpacker() {
      this.jsons = {};
    }
    JsonUnpacker.prototype.load = function(indices, packedJson) {
      packedJson.length !== indices.length && cc.errorID(4915);
      for (var i = 0; i < indices.length; i++) {
        var key = indices[i];
        var json = packedJson[i];
        this.jsons[key] = json;
      }
    };
    JsonUnpacker.prototype.retrieve = function(key) {
      return this.jsons[key] || null;
    };
    function TextureUnpacker() {
      this.contents = {};
    }
    TextureUnpacker.ID = js._getClassId(Texture2D);
    TextureUnpacker.prototype.load = function(indices, packedJson) {
      var datas = packedJson.data.split("|");
      datas.length !== indices.length && cc.errorID(4915);
      for (var i = 0; i < indices.length; i++) this.contents[indices[i]] = datas[i];
    };
    TextureUnpacker.prototype.retrieve = function(key) {
      var content = this.contents[key];
      return content ? {
        __type__: TextureUnpacker.ID,
        content: content
      } : null;
    };
    false;
    module.exports = {
      JsonUnpacker: JsonUnpacker,
      TextureUnpacker: TextureUnpacker
    };
  }), {
    "../assets/CCTexture2D": 49,
    "../platform/js": 175
  } ],
  125: [ (function(require, module, exports) {
    var _noCacheRex = /\?/;
    module.exports = {
      urlAppendTimestamp: function(url) {
        cc.game.config["noCache"] && "string" === typeof url && (_noCacheRex.test(url) ? url += "&_t=" + (new Date() - 0) : url += "?_t=" + (new Date() - 0));
        return url;
      }
    };
  }), {} ],
  126: [ (function(require, module, exports) {
    var js = require("../platform/js");
    require("../platform/deserialize");
    var LoadingItems = require("./loading-items");
    function isSceneObj(json) {
      var SCENE_ID = "cc.Scene";
      var PREFAB_ID = "cc.Prefab";
      return json && (json[0] && json[0].__type__ === SCENE_ID || json[1] && json[1].__type__ === SCENE_ID || json[0] && json[0].__type__ === PREFAB_ID);
    }
    function parseDepends(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
      var uuidList = tdInfo.uuidList;
      var objList = tdInfo.uuidObjList;
      var propList = tdInfo.uuidPropList;
      var stillUseUrl = tdInfo._stillUseUrl;
      var depends;
      var i, dependUuid;
      var dependKeys = item.dependKeys = [];
      if (deferredLoadRawAssetsInRuntime) {
        depends = [];
        for (i = 0; i < uuidList.length; i++) {
          dependUuid = uuidList[i];
          var obj = objList[i];
          var prop = propList[i];
          var info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
          if (info.raw) {
            var url = info.url;
            obj[prop] = url;
            dependKeys.push(url);
          } else depends.push({
            type: "uuid",
            uuid: dependUuid,
            deferredLoadRaw: true,
            _owner: obj,
            _ownerProp: prop,
            _stillUseUrl: stillUseUrl[i]
          });
        }
      } else {
        depends = new Array(uuidList.length);
        for (i = 0; i < uuidList.length; i++) {
          dependUuid = uuidList[i];
          depends[i] = {
            type: "uuid",
            uuid: dependUuid,
            _owner: objList[i],
            _ownerProp: propList[i],
            _stillUseUrl: stillUseUrl[i]
          };
        }
        asset._native && !asset.constructor.preventPreloadNativeObject && depends.push({
          url: asset.nativeUrl,
          _owner: asset,
          _ownerProp: "_nativeAsset"
        });
      }
      return depends;
    }
    function loadDepends(pipeline, item, asset, depends, callback) {
      item.content = asset;
      var dependKeys = item.dependKeys;
      pipeline.flowInDeps(item, depends, (function(errors, items) {
        var item, missingAssetReporter;
        var itemsMap = items.map;
        for (var src in itemsMap) {
          item = itemsMap[src];
          item.uuid && item.content && (item.content._uuid = item.uuid);
        }
        for (var i = 0; i < depends.length; i++) {
          var dep = depends[i];
          var dependSrc = dep.uuid;
          var dependUrl = dep.url;
          var dependObj = dep._owner;
          var dependProp = dep._ownerProp;
          item = itemsMap[dependUrl];
          if (!item) continue;
          var loadCallbackCtx = dep;
          function loadCallback(item) {
            var value = item.content;
            this._stillUseUrl && (value = value && cc.RawAsset.wasRawAssetType(value.constructor) ? value.nativeUrl : item.rawUrl);
            this._owner[this._ownerProp] = value;
            item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
          }
          if (item.complete || item.content) if (item.error) {
            var MissingObjectReporter;
            false;
            cc._throw(item.error);
          } else loadCallback.call(loadCallbackCtx, item); else {
            var queue = LoadingItems.getQueue(item);
            var list = queue._callbackTable[dependSrc];
            list ? list.unshift(loadCallback, loadCallbackCtx) : queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
          }
        }
        false;
        callback(null, asset);
      }));
    }
    function canDeferredLoad(asset, item, isScene) {
      false;
      var res = item.deferredLoadRaw;
      res ? cc.Class.isInstanceOf(asset, cc.Asset) && asset.constructor.preventDeferredLoadDependents && (res = false) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets);
      return res;
    }
    var MissingClass;
    function loadUuid(item, callback) {
      false;
      var json;
      if ("string" === typeof item.content) try {
        json = JSON.parse(item.content);
      } catch (e) {
        return new Error(cc._getError(4923, item.id, e.stack));
      } else {
        if ("object" !== typeof item.content) return new Error(cc._getError(4924));
        json = item.content;
      }
      var classFinder;
      var isScene = isSceneObj(json);
      if (isScene) {
        false;
        classFinder = cc._MissingScript.safeFindClass;
      } else classFinder = function(id) {
        var cls = js._getClassById(id);
        if (cls) return cls;
        cc.warnID(4903, id);
        return Object;
      };
      var tdInfo = cc.deserialize.Details.pool.get();
      var asset;
      try {
        asset = cc.deserialize(json, tdInfo, {
          classFinder: classFinder,
          target: item.existingAsset,
          customEnv: item
        });
      } catch (e) {
        cc.deserialize.Details.pool.put(tdInfo);
        var err = e.stack;
        return new Error(cc._getError(4925, item.id, err));
      }
      asset._uuid = item.uuid;
      false;
      var deferredLoad = canDeferredLoad(asset, item, isScene);
      var depends = parseDepends(item, asset, tdInfo, deferredLoad);
      cc.deserialize.Details.pool.put(tdInfo);
      if (0 === depends.length) return callback(null, asset);
      loadDepends(this.pipeline, item, asset, depends, callback);
    }
    module.exports = loadUuid;
    loadUuid.isSceneObj = isSceneObj;
  }), {
    "../platform/deserialize": 170,
    "../platform/js": 175,
    "./loading-items": 118
  } ],
  127: [ (function(require, module, exports) {
    var CompScheduler = require("./component-scheduler");
    var Flags = require("./platform/CCObject").Flags;
    var js = require("./platform/js");
    var callerFunctor = false;
    var MAX_POOL_SIZE = 4;
    var IsPreloadStarted = Flags.IsPreloadStarted;
    var IsOnLoadStarted = Flags.IsOnLoadStarted;
    var IsOnLoadCalled = Flags.IsOnLoadCalled;
    var Deactivating = Flags.Deactivating;
    var callPreloadInTryCatch = false;
    var callOnLoadInTryCatch = false;
    var callOnDestroyInTryCatch = false;
    var callResetInTryCatch = false;
    var callOnFocusInTryCatch = false;
    var callOnLostFocusInTryCatch = false;
    var callPreload = "c.__preload();";
    var callOnLoad = "c.onLoad();c._objFlags|=" + IsOnLoadCalled;
    var UnsortedInvoker = cc.Class({
      extends: CompScheduler.LifeCycleInvoker,
      add: function(comp) {
        this._zero.array.push(comp);
      },
      remove: function(comp) {
        this._zero.fastRemove(comp);
      },
      cancelInactive: function(flagToClear) {
        CompScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
      },
      invoke: function() {
        this._invoke(this._zero);
        this._zero.array.length = 0;
      }
    });
    var invokePreload = CompScheduler.createInvokeImpl(callPreload);
    var invokeOnLoad = CompScheduler.createInvokeImpl(callOnLoad);
    var activateTasksPool = new js.Pool(MAX_POOL_SIZE);
    activateTasksPool.get = function getActivateTask() {
      var task = this._get() || {
        preload: new UnsortedInvoker(invokePreload),
        onLoad: new CompScheduler.OneOffInvoker(invokeOnLoad),
        onEnable: new CompScheduler.OneOffInvoker(CompScheduler.invokeOnEnable)
      };
      task.preload._zero.i = -1;
      var invoker = task.onLoad;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      invoker = task.onEnable;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      return task;
    };
    function _componentCorrupted(node, comp, index) {
      false;
      comp ? node._removeComponent(comp) : js.array.removeAt(node._components, index);
    }
    function _onLoadInEditor(comp) {
      if (comp.onLoad && !cc.engine._isPlaying) {
        var focused = Editor.Selection.curActivate("node") === comp.node.uuid;
        focused && comp.onFocusInEditor ? callOnFocusInTryCatch(comp) : comp.onLostFocusInEditor && callOnLostFocusInTryCatch(comp);
      }
      true;
      _Scene.AssetsWatcher.start(comp);
    }
    function ctor() {
      this._activatingStack = [];
    }
    var NodeActivator = cc.Class({
      ctor: ctor,
      reset: ctor,
      _activateNodeRecursively: function(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (node._objFlags & Deactivating) {
          cc.errorID(3816, node.name);
          return;
        }
        node._activeInHierarchy = true;
        var originCount = node._components.length;
        for (var i = 0; i < originCount; ++i) {
          var component = node._components[i];
          if (component instanceof cc.Component) this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker); else {
            _componentCorrupted(node, component, i);
            --i;
            --originCount;
          }
        }
        for (var _i = 0, len = node._children.length; _i < len; ++_i) {
          var child = node._children[_i];
          child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
        }
        node._onPostActivated(true);
      },
      _deactivateNodeRecursively: function(node) {
        false;
        node._objFlags |= Deactivating;
        node._activeInHierarchy = false;
        var originCount = node._components.length;
        for (var c = 0; c < originCount; ++c) {
          var component = node._components[c];
          if (component._enabled) {
            cc.director._compScheduler.disableComp(component);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        for (var i = 0, len = node._children.length; i < len; ++i) {
          var child = node._children[i];
          if (child._activeInHierarchy) {
            this._deactivateNodeRecursively(child);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        node._onPostActivated(false);
        node._objFlags &= ~Deactivating;
      },
      activateNode: function(node, active) {
        if (active) {
          var task = activateTasksPool.get();
          this._activatingStack.push(task);
          this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
          task.preload.invoke();
          task.onLoad.invoke();
          task.onEnable.invoke();
          this._activatingStack.pop();
          activateTasksPool.put(task);
        } else {
          this._deactivateNodeRecursively(node);
          var stack = this._activatingStack;
          for (var i = 0; i < stack.length; i++) {
            var lastTask = stack[i];
            lastTask.preload.cancelInactive(IsPreloadStarted);
            lastTask.onLoad.cancelInactive(IsOnLoadStarted);
            lastTask.onEnable.cancelInactive();
          }
        }
        node.emit("active-in-hierarchy-changed", node);
      },
      activateComp: function(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (!(comp._objFlags & IsPreloadStarted)) {
          comp._objFlags |= IsPreloadStarted;
          comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload());
        }
        if (!(comp._objFlags & IsOnLoadStarted)) {
          comp._objFlags |= IsOnLoadStarted;
          if (comp.onLoad) if (onLoadInvoker) onLoadInvoker.add(comp); else {
            comp.onLoad();
            comp._objFlags |= IsOnLoadCalled;
          } else comp._objFlags |= IsOnLoadCalled;
        }
        if (comp._enabled) {
          var deactivatedOnLoading = !comp.node._activeInHierarchy;
          if (deactivatedOnLoading) return;
          cc.director._compScheduler.enableComp(comp, onEnableInvoker);
        }
      },
      destroyComp: function(comp) {
        cc.director._compScheduler.disableComp(comp);
        comp.onDestroy && comp._objFlags & IsOnLoadCalled && comp.onDestroy();
      },
      resetComp: false
    });
    module.exports = NodeActivator;
  }), {
    "./component-scheduler": 61,
    "./platform/CCObject": 161,
    "./platform/js": 175,
    "./utils/misc": 233
  } ],
  128: [ (function(require, module, exports) {
    var PTM_RATIO = require("./CCPhysicsTypes").PTM_RATIO;
    var ContactType = require("./CCPhysicsTypes").ContactType;
    var pools = [];
    var pointCache = [ cc.v2(), cc.v2() ];
    var b2worldmanifold = new b2.WorldManifold();
    var worldmanifold = {
      points: [],
      separations: [],
      normal: cc.v2()
    };
    function ManifoldPoint() {
      this.localPoint = cc.v2();
      this.normalImpulse = 0;
      this.tangentImpulse = 0;
    }
    var manifoldPointCache = [ new ManifoldPoint(), new ManifoldPoint() ];
    var b2manifold = new b2.Manifold();
    var manifold = {
      type: 0,
      localPoint: cc.v2(),
      localNormal: cc.v2(),
      points: []
    };
    var impulse = {
      normalImpulses: [],
      tangentImpulses: []
    };
    function PhysicsContact() {}
    PhysicsContact.prototype.init = function(b2contact) {
      this.colliderA = b2contact.GetFixtureA().collider;
      this.colliderB = b2contact.GetFixtureB().collider;
      this.disabled = false;
      this.disabledOnce = false;
      this._impulse = null;
      this._inverted = false;
      this._b2contact = b2contact;
      b2contact._contact = this;
    };
    PhysicsContact.prototype.reset = function() {
      this.colliderA = null;
      this.colliderB = null;
      this.disabled = false;
      this._impulse = null;
      this._b2contact._contact = null;
      this._b2contact = null;
    };
    PhysicsContact.prototype.getWorldManifold = function() {
      var points = worldmanifold.points;
      var separations = worldmanifold.separations;
      var normal = worldmanifold.normal;
      this._b2contact.GetWorldManifold(b2worldmanifold);
      var b2points = b2worldmanifold.points;
      var b2separations = b2worldmanifold.separations;
      var count = this._b2contact.GetManifold().pointCount;
      points.length = separations.length = count;
      for (var i = 0; i < count; i++) {
        var p = pointCache[i];
        p.x = b2points[i].x * PTM_RATIO;
        p.y = b2points[i].y * PTM_RATIO;
        points[i] = p;
        separations[i] = b2separations[i] * PTM_RATIO;
      }
      normal.x = b2worldmanifold.normal.x;
      normal.y = b2worldmanifold.normal.y;
      if (this._inverted) {
        normal.x *= -1;
        normal.y *= -1;
      }
      return worldmanifold;
    };
    PhysicsContact.prototype.getManifold = function() {
      var points = manifold.points;
      var localNormal = manifold.localNormal;
      var localPoint = manifold.localPoint;
      var b2manifold = this._b2contact.GetManifold();
      var b2points = b2manifold.points;
      var count = points.length = b2manifold.pointCount;
      for (var i = 0; i < count; i++) {
        var p = manifoldPointCache[i];
        var b2p = b2points[i];
        p.localPoint.x = b2p.localPoint.x * PTM_RATIO;
        p.localPoint.Y = b2p.localPoint.Y * PTM_RATIO;
        p.normalImpulse = b2p.normalImpulse * PTM_RATIO;
        p.tangentImpulse = b2p.tangentImpulse;
        points[i] = p;
      }
      localPoint.x = b2manifold.localPoint.x * PTM_RATIO;
      localPoint.y = b2manifold.localPoint.y * PTM_RATIO;
      localNormal.x = b2manifold.localNormal.x;
      localNormal.y = b2manifold.localNormal.y;
      manifold.type = b2manifold.type;
      if (this._inverted) {
        localNormal.x *= -1;
        localNormal.y *= -1;
      }
      return manifold;
    };
    PhysicsContact.prototype.getImpulse = function() {
      var b2impulse = this._impulse;
      if (!b2impulse) return null;
      var normalImpulses = impulse.normalImpulses;
      var tangentImpulses = impulse.tangentImpulses;
      var count = b2impulse.count;
      for (var i = 0; i < count; i++) {
        normalImpulses[i] = b2impulse.normalImpulses[i] * PTM_RATIO;
        tangentImpulses[i] = b2impulse.tangentImpulses[i];
      }
      tangentImpulses.length = normalImpulses.length = count;
      return impulse;
    };
    PhysicsContact.prototype.emit = function(contactType) {
      var func;
      switch (contactType) {
       case ContactType.BEGIN_CONTACT:
        func = "onBeginContact";
        break;

       case ContactType.END_CONTACT:
        func = "onEndContact";
        break;

       case ContactType.PRE_SOLVE:
        func = "onPreSolve";
        break;

       case ContactType.POST_SOLVE:
        func = "onPostSolve";
      }
      var colliderA = this.colliderA;
      var colliderB = this.colliderB;
      var bodyA = colliderA.body;
      var bodyB = colliderB.body;
      var comps;
      var i, l, comp;
      if (bodyA.enabledContactListener) {
        comps = bodyA.node._components;
        this._inverted = false;
        for (i = 0, l = comps.length; i < l; i++) {
          comp = comps[i];
          comp[func] && comp[func](this, colliderA, colliderB);
        }
      }
      if (bodyB.enabledContactListener) {
        comps = bodyB.node._components;
        this._inverted = true;
        for (i = 0, l = comps.length; i < l; i++) {
          comp = comps[i];
          comp[func] && comp[func](this, colliderB, colliderA);
        }
      }
      if (this.disabled || this.disabledOnce) {
        this.setEnabled(false);
        this.disabledOnce = false;
      }
    };
    PhysicsContact.get = function(b2contact) {
      var c;
      c = 0 === pools.length ? new cc.PhysicsContact() : pools.pop();
      c.init(b2contact);
      return c;
    };
    PhysicsContact.put = function(b2contact) {
      var c = b2contact._contact;
      if (!c) return;
      pools.push(c);
      c.reset();
    };
    var _p = PhysicsContact.prototype;
    _p.setEnabled = function(value) {
      this._b2contact.SetEnabled(value);
    };
    _p.isTouching = function() {
      return this._b2contact.IsTouching();
    };
    _p.setTangentSpeed = function(value) {
      this._b2contact.SetTangentSpeed(value / PTM_RATIO);
    };
    _p.getTangentSpeed = function() {
      return this._b2contact.GetTangentSpeed() * PTM_RATIO;
    };
    _p.setFriction = function(value) {
      this._b2contact.SetFriction(value);
    };
    _p.getFriction = function() {
      return this._b2contact.GetFriction();
    };
    _p.resetFriction = function() {
      return this._b2contact.ResetFriction();
    };
    _p.setRestitution = function(value) {
      this._b2contact.SetRestitution(value);
    };
    _p.getRestitution = function() {
      return this._b2contact.GetRestitution();
    };
    _p.resetRestitution = function() {
      return this._b2contact.ResetRestitution();
    };
    PhysicsContact.ContactType = ContactType;
    cc.PhysicsContact = module.exports = PhysicsContact;
  }), {
    "./CCPhysicsTypes": 131
  } ],
  129: [ (function(require, module, exports) {
    var PhysicsTypes = require("./CCPhysicsTypes");
    var BodyType = PhysicsTypes.BodyType;
    var DrawBits = PhysicsTypes.DrawBits;
    var PTM_RATIO = PhysicsTypes.PTM_RATIO;
    var math = cc.vmath;
    var mat4 = math.mat4;
    var vec2 = math.vec2;
    var ShapeInactiveColor = cc.color(127, 127, 76, 150);
    var ShapeStaticColor = cc.color(127, 229, 127, 150);
    var ShapeKinematicColor = cc.color(127, 127, 229, 150);
    var ShapeInawakeColor = cc.color(153, 153, 153, 150);
    var ShapeNormalColor = cc.color(229, 178, 178, 150);
    var JointColor = cc.color(127, 204, 204, 150);
    var AabbColor = cc.color(229, 77, 229, 255);
    var _vec2_tmp1 = cc.v2();
    var _vec2_tmp2 = cc.v2();
    var _mat4_tmp = mat4.create();
    var _rect_tmp = cc.rect();
    function drawPoints(g, points, offset, color, matrix) {
      for (var i = 0, l = points.length; i < l; i++) {
        _vec2_tmp1.x = points[i].x + offset.x;
        _vec2_tmp1.y = points[i].y + offset.y;
        vec2.transformMat4(_vec2_tmp1, _vec2_tmp1, matrix);
        0 === i ? g.moveTo(_vec2_tmp1.x, _vec2_tmp1.y) : g.lineTo(_vec2_tmp1.x, _vec2_tmp1.y);
      }
    }
    function drawCollider(g, collider, color, matrix) {
      if (!collider.body) return;
      if (collider instanceof cc.PhysicsBoxCollider) {
        var offset = collider.offset;
        var size = collider.size;
        var points = [ cc.v2(-size.width / 2, -size.height / 2), cc.v2(+size.width / 2, -size.height / 2), cc.v2(+size.width / 2, +size.height / 2), cc.v2(-size.width / 2, +size.height / 2) ];
        drawPoints(g, points, collider.offset, color, matrix);
        g.close();
      } else if (collider instanceof cc.PhysicsPolygonCollider) {
        drawPoints(g, collider.points, collider.offset, color, matrix);
        g.close();
      } else if (collider instanceof cc.PhysicsChainCollider) drawPoints(g, collider.points, color, matrix); else {
        if (!(collider instanceof cc.PhysicsCircleCollider)) return;
        vec2.transformMat4(_vec2_tmp1, collider.offset, matrix);
        g.circle(_vec2_tmp1.x, _vec2_tmp1.y, collider.radius * collider._scale.x);
      }
      g.fillColor = color;
      g.fill();
      g.stroke();
    }
    function drawSegment(g, p1, p2, color) {
      if (p1.x === p2.x && p1.y === p2.y) {
        g.fillColor = color;
        g.circle(p1.x, p1.y, 1);
        g.fill();
        return;
      }
      g.strokeColor = color;
      g.moveTo(p1.x, p1.y);
      g.lineTo(p2.x, p2.y);
      g.stroke();
    }
    module.exports = function(manager) {
      var flags = manager.debugDrawFlags;
      if (!flags) return;
      manager._checkDebugDrawValid();
      var debugDrawer = manager._debugDrawer;
      debugDrawer.clear();
      if (flags & DrawBits.e_shapeBit || flags & DrawBits.e_aabbBit) {
        var bodies = manager._bodies;
        for (var i = 0, l = bodies.length; i < l; i++) {
          var body = bodies[i];
          var colliders = body.node.getComponents(cc.PhysicsCollider);
          if (0 === colliders.length) continue;
          body.node.getWorldMatrix(_mat4_tmp);
          if (flags & DrawBits.e_shapeBit) {
            var color = ShapeNormalColor;
            body.active ? body.type == BodyType.Static ? color = ShapeStaticColor : body.type == BodyType.Kinematic ? color = ShapeKinematicColor : body.awake || (color = ShapeInawakeColor) : color = ShapeInactiveColor;
            for (var i2 = 0, l2 = colliders.length; i2 < l2; i2++) drawCollider(debugDrawer, colliders[i2], color, _mat4_tmp);
          }
          if (flags & DrawBits.e_aabbBit && body.active) for (var _i = 0, _l = colliders.length; _i < _l; _i++) {
            var aabb = colliders[_i].getAABB();
            debugDrawer.strokeColor = AabbColor;
            debugDrawer.rect(aabb.x, aabb.y, aabb.width, aabb.height);
            debugDrawer.stroke();
          }
        }
      }
      if (flags & DrawBits.e_jointBit) {
        var joints = manager._joints;
        for (var _i2 = 0, _l2 = joints.length; _i2 < _l2; _i2++) {
          var joint = joints[_i2];
          var bodyA = joint.body;
          var bodyB = joint.connectedBody;
          if (!bodyA || !bodyB) continue;
          bodyA.node.getWorldMatrix(_mat4_tmp);
          _vec2_tmp1.x = _mat4_tmp.m12;
          _vec2_tmp1.y = _mat4_tmp.m13;
          bodyB.node.getWorldMatrix(_mat4_tmp);
          _vec2_tmp2.x = _mat4_tmp.m12;
          _vec2_tmp2.y = _mat4_tmp.m13;
          var p1 = cc.v2(joint._joint.GetAnchorA()).mulSelf(PTM_RATIO);
          var p2 = cc.v2(joint._joint.GetAnchorB()).mulSelf(PTM_RATIO);
          if (joint instanceof cc.DistanceJoint) drawSegment(debugDrawer, p1, p2, JointColor); else {
            drawSegment(debugDrawer, _vec2_tmp1, p1, JointColor);
            drawSegment(debugDrawer, p1, p2, JointColor);
            drawSegment(debugDrawer, _vec2_tmp2, p2, JointColor);
          }
        }
      }
    };
  }), {
    "./CCPhysicsTypes": 131
  } ],
  130: [ (function(require, module, exports) {
    var PhysicsTypes = require("./CCPhysicsTypes");
    var ContactType = PhysicsTypes.ContactType;
    var BodyType = PhysicsTypes.BodyType;
    var RayCastType = PhysicsTypes.RayCastType;
    var DrawBits = PhysicsTypes.DrawBits;
    var PTM_RATIO = PhysicsTypes.PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = PhysicsTypes.ANGLE_TO_PHYSICS_ANGLE;
    var PHYSICS_ANGLE_TO_ANGLE = PhysicsTypes.PHYSICS_ANGLE_TO_ANGLE;
    var debugDraw = require("./CCPhysicsDebugDraw");
    var convertToNodeRotation = require("./utils").convertToNodeRotation;
    var b2_aabb_tmp = new b2.AABB();
    var b2_vec2_tmp1 = new b2.Vec2();
    var b2_vec2_tmp2 = new b2.Vec2();
    var vec2_tmp = cc.v2();
    var PhysicsManager = cc.Class({
      mixins: [ cc.EventTarget ],
      statics: {
        DrawBits: DrawBits,
        PTM_RATIO: PTM_RATIO,
        VELOCITY_ITERATIONS: 10,
        POSITION_ITERATIONS: 10,
        FIXED_TIME_STEP: 1 / 60,
        MAX_ACCUMULATOR: .2
      },
      ctor: function() {
        this._debugDrawFlags = 0;
        this._debugDrawer = null;
        this._world = null;
        this._bodies = [];
        this._joints = [];
        this._contactMap = {};
        this._contactID = 0;
        this._delayEvents = [];
        this._accumulator = 0;
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
        this.enabledAccumulator = false;
      },
      pushDelayEvent: function(target, func, args) {
        this._steping ? this._delayEvents.push({
          target: target,
          func: func,
          args: args
        }) : target[func].apply(target, args);
      },
      update: function(dt) {
        var world = this._world;
        if (!world || !this.enabled) return;
        this.emit("before-step");
        this._steping = true;
        var velocityIterations = PhysicsManager.VELOCITY_ITERATIONS;
        var positionIterations = PhysicsManager.POSITION_ITERATIONS;
        if (this.enabledAccumulator) {
          this._accumulator += dt;
          var FIXED_TIME_STEP = PhysicsManager.FIXED_TIME_STEP;
          var MAX_ACCUMULATOR = PhysicsManager.MAX_ACCUMULATOR;
          this._accumulator > MAX_ACCUMULATOR && (this._accumulator = MAX_ACCUMULATOR);
          while (this._accumulator > FIXED_TIME_STEP) {
            world.Step(FIXED_TIME_STEP, velocityIterations, positionIterations);
            this._accumulator -= FIXED_TIME_STEP;
          }
        } else {
          var timeStep = 1 / cc.game.config["frameRate"];
          world.Step(timeStep, velocityIterations, positionIterations);
        }
        this._steping = false;
        var events = this._delayEvents;
        for (var i = 0, l = events.length; i < l; i++) {
          var event = events[i];
          event.target[event.func].apply(event.target, event.args);
        }
        events.length = 0;
        this._syncNode();
        debugDraw(this);
      },
      testPoint: function(point) {
        var x = b2_vec2_tmp1.x = point.x / PTM_RATIO;
        var y = b2_vec2_tmp1.y = point.y / PTM_RATIO;
        var d = .2 / PTM_RATIO;
        b2_aabb_tmp.lowerBound.x = x - d;
        b2_aabb_tmp.lowerBound.y = y - d;
        b2_aabb_tmp.upperBound.x = x + d;
        b2_aabb_tmp.upperBound.y = y + d;
        var callback = this._aabbQueryCallback;
        callback.init(b2_vec2_tmp1);
        this._world.QueryAABB(callback, b2_aabb_tmp);
        var fixture = callback.getFixture();
        if (fixture) return fixture.collider;
        return null;
      },
      testAABB: function(rect) {
        b2_aabb_tmp.lowerBound.x = rect.xMin / PTM_RATIO;
        b2_aabb_tmp.lowerBound.y = rect.yMin / PTM_RATIO;
        b2_aabb_tmp.upperBound.x = rect.xMax / PTM_RATIO;
        b2_aabb_tmp.upperBound.y = rect.yMax / PTM_RATIO;
        var callback = this._aabbQueryCallback;
        callback.init();
        this._world.QueryAABB(callback, b2_aabb_tmp);
        var fixtures = callback.getFixtures();
        var colliders = fixtures.map((function(fixture) {
          return fixture.collider;
        }));
        return colliders;
      },
      rayCast: function(p1, p2, type) {
        if (p1.equals(p2)) return [];
        type = type || RayCastType.Closest;
        b2_vec2_tmp1.x = p1.x / PTM_RATIO;
        b2_vec2_tmp1.y = p1.y / PTM_RATIO;
        b2_vec2_tmp2.x = p2.x / PTM_RATIO;
        b2_vec2_tmp2.y = p2.y / PTM_RATIO;
        var callback = this._raycastQueryCallback;
        callback.init(type);
        this._world.RayCast(callback, b2_vec2_tmp1, b2_vec2_tmp2);
        var fixtures = callback.getFixtures();
        if (fixtures.length > 0) {
          var points = callback.getPoints();
          var normals = callback.getNormals();
          var fractions = callback.getFractions();
          var results = [];
          for (var i = 0, l = fixtures.length; i < l; i++) {
            var fixture = fixtures[i];
            var collider = fixture.collider;
            if (type === RayCastType.AllClosest) {
              var result = results.find((function(result) {
                return result.collider === collider;
              }));
              if (result) {
                if (fractions[i] < result.fraction) {
                  result.fixtureIndex = collider._getFixtureIndex(fixture);
                  result.point.x = points[i].x * PTM_RATIO;
                  result.point.y = points[i].y * PTM_RATIO;
                  result.normal.x = normals[i].x;
                  result.normal.y = normals[i].y;
                  result.fraction = fractions[i];
                }
                continue;
              }
            }
            results.push({
              collider: collider,
              fixtureIndex: collider._getFixtureIndex(fixture),
              point: cc.v2(points[i].x * PTM_RATIO, points[i].y * PTM_RATIO),
              normal: cc.v2(normals[i]),
              fraction: fractions[i]
            });
          }
          return results;
        }
        return [];
      },
      syncPosition: function() {
        var bodies = this._bodies;
        for (var i = 0; i < bodies.length; i++) bodies[i].syncPosition();
      },
      syncRotation: function() {
        var bodies = this._bodies;
        for (var i = 0; i < bodies.length; i++) bodies[i].syncRotation();
      },
      _registerContactFixture: function(fixture) {
        this._contactListener.registerContactFixture(fixture);
      },
      _unregisterContactFixture: function(fixture) {
        this._contactListener.unregisterContactFixture(fixture);
      },
      _addBody: function(body, bodyDef) {
        var world = this._world;
        var node = body.node;
        if (!world || !node) return;
        body._b2Body = world.CreateBody(bodyDef);
        body._b2Body.body = body;
        this._bodies.push(body);
      },
      _removeBody: function(body) {
        var world = this._world;
        if (!world) return;
        body._b2Body.body = null;
        world.DestroyBody(body._b2Body);
        body._b2Body = null;
        cc.js.array.remove(this._bodies, body);
      },
      _addJoint: function(joint, jointDef) {
        var b2joint = this._world.CreateJoint(jointDef);
        if (!b2joint) return;
        b2joint._joint = joint;
        joint._joint = b2joint;
        this._joints.push(joint);
      },
      _removeJoint: function(joint) {
        joint._isValid() && this._world.DestroyJoint(joint._joint);
        joint._joint && (joint._joint._joint = null);
        cc.js.array.remove(this._joints, joint);
      },
      _initCallback: function() {
        if (!this._world) {
          cc.warn("Please init PhysicsManager first");
          return;
        }
        if (this._contactListener) return;
        var listener = new cc.PhysicsContactListener();
        listener.setBeginContact(this._onBeginContact);
        listener.setEndContact(this._onEndContact);
        listener.setPreSolve(this._onPreSolve);
        listener.setPostSolve(this._onPostSolve);
        this._world.SetContactListener(listener);
        this._contactListener = listener;
        this._aabbQueryCallback = new cc.PhysicsAABBQueryCallback();
        this._raycastQueryCallback = new cc.PhysicsRayCastCallback();
      },
      _init: function() {
        this.enabled = true;
        this.debugDrawFlags = b2.Draw.e_shapeBit;
      },
      _getWorld: function() {
        return this._world;
      },
      _syncNode: function() {
        var bodies = this._bodies;
        for (var i = 0, l = bodies.length; i < l; i++) {
          var body = bodies[i];
          var node = body.node;
          var b2body = body._b2Body;
          var pos = b2body.GetPosition();
          vec2_tmp.x = pos.x * PTM_RATIO;
          vec2_tmp.y = pos.y * PTM_RATIO;
          var angle = b2body.GetAngle() * PHYSICS_ANGLE_TO_ANGLE;
          if (null !== node.parent.parent) {
            vec2_tmp = node.parent.convertToNodeSpaceAR(vec2_tmp);
            angle = convertToNodeRotation(node.parent, angle);
          }
          var tempMask = node._eventMask;
          node._eventMask = 0;
          node.position = vec2_tmp;
          node.rotation = angle;
          node._eventMask = tempMask;
          body.type === BodyType.Animated && body.resetVelocity();
        }
      },
      _onBeginContact: function(b2contact) {
        var c = cc.PhysicsContact.get(b2contact);
        c.emit(ContactType.BEGIN_CONTACT);
      },
      _onEndContact: function(b2contact) {
        var c = b2contact._contact;
        if (!c) return;
        c.emit(ContactType.END_CONTACT);
        cc.PhysicsContact.put(b2contact);
      },
      _onPreSolve: function(b2contact) {
        var c = b2contact._contact;
        if (!c) return;
        c.emit(ContactType.PRE_SOLVE);
      },
      _onPostSolve: function(b2contact, impulse) {
        var c = b2contact._contact;
        if (!c) return;
        c._impulse = impulse;
        c.emit(ContactType.POST_SOLVE);
        c._impulse = null;
      },
      _checkDebugDrawValid: function() {
        if (!this._debugDrawer || !this._debugDrawer.isValid) {
          var node = new cc.Node("PHYSICS_MANAGER_DEBUG_DRAW");
          node.zIndex = cc.macro.MAX_ZINDEX;
          cc.game.addPersistRootNode(node);
          this._debugDrawer = node.addComponent(cc.Graphics);
        }
      }
    });
    cc.js.getset(PhysicsManager.prototype, "enabled", (function() {
      return this._enabled;
    }), (function(value) {
      if (value && !this._world) {
        var world = new b2.World(new b2.Vec2(0, -10));
        world.SetAllowSleeping(true);
        this._world = world;
        this._initCallback();
      }
      this._enabled = value;
    }));
    cc.js.getset(PhysicsManager.prototype, "debugDrawFlags", (function() {
      return this._debugDrawFlags;
    }), (function(value) {
      value && !this._debugDrawFlags ? this._debugDrawer && this._debugDrawer.node && (this._debugDrawer.node.active = true) : !value && this._debugDrawFlags && this._debugDrawer && this._debugDrawer.node && (this._debugDrawer.node.active = false);
      this._debugDrawFlags = value;
    }));
    cc.js.getset(PhysicsManager.prototype, "gravity", (function() {
      if (this._world) {
        var g = this._world.GetGravity();
        return cc.v2(g.x * PTM_RATIO, g.y * PTM_RATIO);
      }
      return cc.v2();
    }), (function(value) {
      this._world && this._world.SetGravity(new b2.Vec2(value.x / PTM_RATIO, value.y / PTM_RATIO));
    }));
    cc.PhysicsManager = module.exports = PhysicsManager;
  }), {
    "./CCPhysicsDebugDraw": 129,
    "./CCPhysicsTypes": 131,
    "./utils": 152
  } ],
  131: [ (function(require, module, exports) {
    var ContactType = {
      BEGIN_CONTACT: "begin-contact",
      END_CONTACT: "end-contact",
      PRE_SOLVE: "pre-solve",
      POST_SOLVE: "post-solve"
    };
    var BodyType = cc.Enum({
      Static: 0,
      Kinematic: 1,
      Dynamic: 2,
      Animated: 3
    });
    cc.RigidBodyType = BodyType;
    var RayCastType = cc.Enum({
      Closest: 0,
      Any: 1,
      AllClosest: 2,
      All: 3
    });
    cc.RayCastType = RayCastType;
    var DrawBits = b2.Draw;
    module.exports = {
      BodyType: BodyType,
      ContactType: ContactType,
      RayCastType: RayCastType,
      DrawBits: DrawBits,
      PTM_RATIO: 32,
      ANGLE_TO_PHYSICS_ANGLE: -Math.PI / 180,
      PHYSICS_ANGLE_TO_ANGLE: -180 / Math.PI
    };
  }), {} ],
  132: [ (function(require, module, exports) {
    function At(i, vertices) {
      var s = vertices.length;
      return vertices[i < 0 ? s - -i % s : i % s];
    }
    function Copy(i, j, vertices) {
      var p = [];
      while (j < i) j += vertices.length;
      for (;i <= j; ++i) p.push(At(i, vertices));
      return p;
    }
    function ConvexPartition(vertices) {
      ForceCounterClockWise(vertices);
      var list = [];
      var d, lowerDist, upperDist;
      var p;
      var lowerInt = cc.v2();
      var upperInt = cc.v2();
      var lowerIndex = 0, upperIndex = 0;
      var lowerPoly, upperPoly;
      for (var i = 0; i < vertices.length; ++i) if (Reflex(i, vertices)) {
        lowerDist = upperDist = 1e8;
        for (var j = 0; j < vertices.length; ++j) {
          if (Left(At(i - 1, vertices), At(i, vertices), At(j, vertices)) && RightOn(At(i - 1, vertices), At(i, vertices), At(j - 1, vertices))) {
            p = LineIntersect(At(i - 1, vertices), At(i, vertices), At(j, vertices), At(j - 1, vertices));
            if (Right(At(i + 1, vertices), At(i, vertices), p)) {
              d = SquareDist(At(i, vertices), p);
              if (d < lowerDist) {
                lowerDist = d;
                lowerInt = p;
                lowerIndex = j;
              }
            }
          }
          if (Left(At(i + 1, vertices), At(i, vertices), At(j + 1, vertices)) && RightOn(At(i + 1, vertices), At(i, vertices), At(j, vertices))) {
            p = LineIntersect(At(i + 1, vertices), At(i, vertices), At(j, vertices), At(j + 1, vertices));
            if (Left(At(i - 1, vertices), At(i, vertices), p)) {
              d = SquareDist(At(i, vertices), p);
              if (d < upperDist) {
                upperDist = d;
                upperIndex = j;
                upperInt = p;
              }
            }
          }
        }
        if (lowerIndex == (upperIndex + 1) % vertices.length) {
          var sp = lowerInt.add(upperInt).div(2);
          lowerPoly = Copy(i, upperIndex, vertices);
          lowerPoly.push(sp);
          upperPoly = Copy(lowerIndex, i, vertices);
          upperPoly.push(sp);
        } else {
          var highestScore = 0, bestIndex = lowerIndex;
          while (upperIndex < lowerIndex) upperIndex += vertices.length;
          for (var j = lowerIndex; j <= upperIndex; ++j) if (CanSee(i, j, vertices)) {
            var score = 1 / (SquareDist(At(i, vertices), At(j, vertices)) + 1);
            Reflex(j, vertices) ? RightOn(At(j - 1, vertices), At(j, vertices), At(i, vertices)) && LeftOn(At(j + 1, vertices), At(j, vertices), At(i, vertices)) ? score += 3 : score += 2 : score += 1;
            if (score > highestScore) {
              bestIndex = j;
              highestScore = score;
            }
          }
          lowerPoly = Copy(i, bestIndex, vertices);
          upperPoly = Copy(bestIndex, i, vertices);
        }
        list = list.concat(ConvexPartition(lowerPoly));
        list = list.concat(ConvexPartition(upperPoly));
        return list;
      }
      list.push(vertices);
      for (var i = list.length - 1; i >= 0; i--) 0 == list[i].length && list.splice(i, 0);
      return list;
    }
    function CanSee(i, j, vertices) {
      if (Reflex(i, vertices)) {
        if (LeftOn(At(i, vertices), At(i - 1, vertices), At(j, vertices)) && RightOn(At(i, vertices), At(i + 1, vertices), At(j, vertices))) return false;
      } else if (RightOn(At(i, vertices), At(i + 1, vertices), At(j, vertices)) || LeftOn(At(i, vertices), At(i - 1, vertices), At(j, vertices))) return false;
      if (Reflex(j, vertices)) {
        if (LeftOn(At(j, vertices), At(j - 1, vertices), At(i, vertices)) && RightOn(At(j, vertices), At(j + 1, vertices), At(i, vertices))) return false;
      } else if (RightOn(At(j, vertices), At(j + 1, vertices), At(i, vertices)) || LeftOn(At(j, vertices), At(j - 1, vertices), At(i, vertices))) return false;
      for (var k = 0; k < vertices.length; ++k) {
        if ((k + 1) % vertices.length == i || k == i || (k + 1) % vertices.length == j || k == j) continue;
        var intersectionPoint = cc.v2();
        if (LineIntersect2(At(i, vertices), At(j, vertices), At(k, vertices), At(k + 1, vertices), intersectionPoint)) return false;
      }
      return true;
    }
    function Reflex(i, vertices) {
      return Right(i, vertices);
    }
    function Right(a, b, c) {
      if ("undefined" === typeof c) {
        var i = a, vertices = b;
        a = At(i - 1, vertices);
        b = At(i, vertices);
        c = At(i + 1, vertices);
      }
      return Area(a, b, c) < 0;
    }
    function Left(a, b, c) {
      return Area(a, b, c) > 0;
    }
    function LeftOn(a, b, c) {
      return Area(a, b, c) >= 0;
    }
    function RightOn(a, b, c) {
      return Area(a, b, c) <= 0;
    }
    function SquareDist(a, b) {
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      return dx * dx + dy * dy;
    }
    function ForceCounterClockWise(vertices) {
      IsCounterClockWise(vertices) || vertices.reverse();
    }
    function IsCounterClockWise(vertices) {
      if (vertices.length < 3) return true;
      return GetSignedArea(vertices) > 0;
    }
    function GetSignedArea(vertices) {
      var i;
      var area = 0;
      for (i = 0; i < vertices.length; i++) {
        var j = (i + 1) % vertices.length;
        area += vertices[i].x * vertices[j].y;
        area -= vertices[i].y * vertices[j].x;
      }
      area /= 2;
      return area;
    }
    function LineIntersect(p1, p2, q1, q2) {
      var i = cc.v2();
      var a1 = p2.y - p1.y;
      var b1 = p1.x - p2.x;
      var c1 = a1 * p1.x + b1 * p1.y;
      var a2 = q2.y - q1.y;
      var b2 = q1.x - q2.x;
      var c2 = a2 * q1.x + b2 * q1.y;
      var det = a1 * b2 - a2 * b1;
      if (!FloatEquals(det, 0)) {
        i.x = (b2 * c1 - b1 * c2) / det;
        i.y = (a1 * c2 - a2 * c1) / det;
      }
      return i;
    }
    function LineIntersect2(a0, a1, b0, b1, intersectionPoint) {
      if (a0 == b0 || a0 == b1 || a1 == b0 || a1 == b1) return false;
      var x1 = a0.x;
      var y1 = a0.y;
      var x2 = a1.x;
      var y2 = a1.y;
      var x3 = b0.x;
      var y3 = b0.y;
      var x4 = b1.x;
      var y4 = b1.y;
      if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(x3, x4) < Math.min(x1, x2)) return false;
      if (Math.max(y1, y2) < Math.min(y3, y4) || Math.max(y3, y4) < Math.min(y1, y2)) return false;
      var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      if (Math.abs(denom) < 1e-6) return false;
      ua /= denom;
      ub /= denom;
      if (0 < ua && ua < 1 && 0 < ub && ub < 1) {
        intersectionPoint.x = x1 + ua * (x2 - x1);
        intersectionPoint.y = y1 + ua * (y2 - y1);
        return true;
      }
      return false;
    }
    function FloatEquals(value1, value2) {
      return Math.abs(value1 - value2) <= 1e-6;
    }
    function Area(a, b, c) {
      return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);
    }
    module.exports = {
      ConvexPartition: ConvexPartition,
      ForceCounterClockWise: ForceCounterClockWise,
      IsCounterClockWise: IsCounterClockWise
    };
  }), {} ],
  133: [ (function(require, module, exports) {
    var NodeEvent = require("../CCNode").EventType;
    var PTM_RATIO = require("./CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("./CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var PHYSICS_ANGLE_TO_ANGLE = require("./CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
    var getWorldRotation = require("./utils").getWorldRotation;
    var BodyType = require("./CCPhysicsTypes").BodyType;
    var tempb2Vec21 = new b2.Vec2();
    var tempb2Vec22 = new b2.Vec2();
    var VEC2_ZERO = cc.Vec2.ZERO;
    var RigidBody = cc.Class({
      name: "cc.RigidBody",
      extends: cc.Component,
      editor: false,
      properties: {
        _type: BodyType.Dynamic,
        _allowSleep: true,
        _gravityScale: 1,
        _linearDamping: 0,
        _angularDamping: 0,
        _linearVelocity: cc.v2(0, 0),
        _angularVelocity: 0,
        _fixedRotation: false,
        enabled: {
          get: function() {
            return this._enabled;
          },
          set: function() {
            cc.warnID("8200");
          },
          visible: false,
          override: true
        },
        enabledContactListener: {
          default: false,
          tooltip: false
        },
        bullet: {
          default: false,
          tooltip: false
        },
        type: {
          type: BodyType,
          tooltip: false,
          get: function() {
            return this._type;
          },
          set: function(value) {
            this._type = value;
            this._b2Body && (value === BodyType.Animated ? this._b2Body.SetType(BodyType.Kinematic) : this._b2Body.SetType(value));
          }
        },
        allowSleep: {
          tooltip: false,
          get: function() {
            if (this._b2Body) return this._b2Body.IsSleepingAllowed();
            return this._allowSleep;
          },
          set: function(value) {
            this._allowSleep = value;
            this._b2Body && this._b2Body.SetSleepingAllowed(value);
          }
        },
        gravityScale: {
          tooltip: false,
          get: function() {
            return this._gravityScale;
          },
          set: function(value) {
            this._gravityScale = value;
            this._b2Body && this._b2Body.SetGravityScale(value);
          }
        },
        linearDamping: {
          tooltip: false,
          get: function() {
            return this._linearDamping;
          },
          set: function(value) {
            this._linearDamping = value;
            this._b2Body && this._b2Body.SetLinearDamping(this._linearDamping);
          }
        },
        angularDamping: {
          tooltip: false,
          get: function() {
            return this._angularDamping;
          },
          set: function(value) {
            this._angularDamping = value;
            this._b2Body && this._b2Body.SetAngularDamping(value);
          }
        },
        linearVelocity: {
          tooltip: false,
          type: cc.Vec2,
          get: function() {
            var lv = this._linearVelocity;
            if (this._b2Body) {
              var velocity = this._b2Body.GetLinearVelocity();
              lv.x = velocity.x * PTM_RATIO;
              lv.y = velocity.y * PTM_RATIO;
            }
            return lv;
          },
          set: function(value) {
            this._linearVelocity = value;
            var b2body = this._b2Body;
            if (b2body) {
              var temp = b2body.m_linearVelocity;
              temp.Set(value.x / PTM_RATIO, value.y / PTM_RATIO);
              b2body.SetLinearVelocity(temp);
            }
          }
        },
        angularVelocity: {
          tooltip: false,
          get: function() {
            if (this._b2Body) return this._b2Body.GetAngularVelocity() * PHYSICS_ANGLE_TO_ANGLE;
            return this._angularVelocity;
          },
          set: function(value) {
            this._angularVelocity = value;
            this._b2Body && this._b2Body.SetAngularVelocity(value * ANGLE_TO_PHYSICS_ANGLE);
          }
        },
        fixedRotation: {
          tooltip: false,
          get: function() {
            return this._fixedRotation;
          },
          set: function(value) {
            this._fixedRotation = value;
            this._b2Body && this._b2Body.SetFixedRotation(value);
          }
        },
        awake: {
          tooltip: false,
          get: function() {
            return !!this._b2Body && this._b2Body.IsAwake();
          },
          set: function(value) {
            this._b2Body && this._b2Body.SetAwake(value);
          }
        },
        active: {
          visible: false,
          get: function() {
            return !!this._b2Body && this._b2Body.IsActive();
          },
          set: function(value) {
            this._b2Body && this._b2Body.SetActive(value);
          }
        }
      },
      getLocalPoint: function(worldPoint, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(worldPoint.x / PTM_RATIO, worldPoint.y / PTM_RATIO);
          var pos = this._b2Body.GetLocalPoint(tempb2Vec21);
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldPoint: function(localPoint, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(localPoint.x / PTM_RATIO, localPoint.y / PTM_RATIO);
          var pos = this._b2Body.GetWorldPoint(tempb2Vec21);
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldVector: function(localVector, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(localVector.x / PTM_RATIO, localVector.y / PTM_RATIO);
          var vector = this._b2Body.GetWorldVector(tempb2Vec21);
          out.x = vector.x * PTM_RATIO;
          out.y = vector.y * PTM_RATIO;
        }
        return out;
      },
      getLocalVector: function(worldVector, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(worldVector.x / PTM_RATIO, worldVector.y / PTM_RATIO);
          var vector = this._b2Body.GetLocalVector(tempb2Vec21);
          out.x = vector.x * PTM_RATIO;
          out.y = vector.y * PTM_RATIO;
        }
        return out;
      },
      getWorldPosition: function(out) {
        out = out || cc.v2();
        if (this._b2Body) {
          var pos = this._b2Body.GetPosition();
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldRotation: function() {
        if (this._b2Body) return this._b2Body.GetAngle() * PHYSICS_ANGLE_TO_ANGLE;
        return 0;
      },
      getLocalCenter: function(out) {
        out = out || cc.v2();
        if (this._b2Body) {
          var pos = this._b2Body.GetLocalCenter();
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldCenter: function(out) {
        out = out || cc.v2();
        if (this._b2Body) {
          var pos = this._b2Body.GetWorldCenter();
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getLinearVelocityFromWorldPoint: function(worldPoint, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(worldPoint.x / PTM_RATIO, worldPoint.y / PTM_RATIO);
          var velocity = this._b2Body.GetLinearVelocityFromWorldPoint(tempb2Vec21);
          out.x = velocity.x * PTM_RATIO;
          out.y = velocity.y * PTM_RATIO;
        }
        return out;
      },
      getMass: function() {
        return this._b2Body ? this._b2Body.GetMass() : 0;
      },
      getInertia: function() {
        return this._b2Body ? this._b2Body.GetInertia() * PTM_RATIO * PTM_RATIO : 0;
      },
      getJointList: function() {
        if (!this._b2Body) return [];
        var joints = [];
        var list = this._b2Body.GetJointList();
        if (!list) return [];
        joints.push(list.joint._joint);
        var prev = list.prev;
        while (prev) {
          joints.push(prev.joint._joint);
          prev = prev.prev;
        }
        var next = list.next;
        while (next) {
          joints.push(next.joint._joint);
          next = next.next;
        }
        return joints;
      },
      applyForce: function(force, point, wake) {
        if (this._b2Body) {
          tempb2Vec21.Set(force.x / PTM_RATIO, force.y / PTM_RATIO);
          tempb2Vec22.Set(point.x / PTM_RATIO, point.y / PTM_RATIO);
          this._b2Body.ApplyForce(tempb2Vec21, tempb2Vec22, wake);
        }
      },
      applyForceToCenter: function(force, wake) {
        if (this._b2Body) {
          tempb2Vec21.Set(force.x / PTM_RATIO, force.y / PTM_RATIO);
          this._b2Body.ApplyForceToCenter(tempb2Vec21, wake);
        }
      },
      applyTorque: function(torque, wake) {
        this._b2Body && this._b2Body.ApplyTorque(torque / PTM_RATIO, wake);
      },
      applyLinearImpulse: function(impulse, point, wake) {
        if (this._b2Body) {
          tempb2Vec21.Set(impulse.x / PTM_RATIO, impulse.y / PTM_RATIO);
          tempb2Vec22.Set(point.x / PTM_RATIO, point.y / PTM_RATIO);
          this._b2Body.ApplyLinearImpulse(tempb2Vec21, tempb2Vec22, wake);
        }
      },
      applyAngularImpulse: function(impulse, wake) {
        this._b2Body && this._b2Body.ApplyAngularImpulse(impulse / PTM_RATIO / PTM_RATIO, wake);
      },
      syncPosition: function(enableAnimated) {
        var b2body = this._b2Body;
        if (!b2body) return;
        var pos = this.node.convertToWorldSpaceAR(VEC2_ZERO);
        var temp;
        temp = this.type === BodyType.Animated ? b2body.GetLinearVelocity() : b2body.GetPosition();
        temp.x = pos.x / PTM_RATIO;
        temp.y = pos.y / PTM_RATIO;
        if (this.type === BodyType.Animated && enableAnimated) {
          var b2Pos = b2body.GetPosition();
          var timeStep = cc.game.config["frameRate"];
          temp.x = (temp.x - b2Pos.x) * timeStep;
          temp.y = (temp.y - b2Pos.y) * timeStep;
          b2body.SetAwake(true);
          b2body.SetLinearVelocity(temp);
        } else b2body.SetTransform(temp, b2body.GetAngle());
      },
      syncRotation: function(enableAnimated) {
        var b2body = this._b2Body;
        if (!b2body) return;
        var rotation = ANGLE_TO_PHYSICS_ANGLE * getWorldRotation(this.node);
        if (this.type === BodyType.Animated && enableAnimated) {
          var b2Rotation = b2body.GetAngle();
          var timeStep = cc.game.config["frameRate"];
          b2body.SetAwake(true);
          b2body.SetAngularVelocity((rotation - b2Rotation) * timeStep);
        } else b2body.SetTransform(b2body.GetPosition(), rotation);
      },
      resetVelocity: function() {
        var b2body = this._b2Body;
        if (!b2body) return;
        var temp = b2body.m_linearVelocity;
        temp.Set(0, 0);
        b2body.SetLinearVelocity(temp);
        b2body.SetAngularVelocity(0);
      },
      onEnable: function() {
        this._init();
      },
      onDisable: function() {
        this._destroy();
      },
      _registerNodeEvents: function() {
        var node = this.node;
        node.on(NodeEvent.POSITION_CHANGED, this._onNodePositionChanged, this);
        node.on(NodeEvent.ROTATION_CHANGED, this._onNodeRotationChanged, this);
        node.on(NodeEvent.SCALE_CHANGED, this._onNodeScaleChanged, this);
      },
      _unregisterNodeEvents: function() {
        var node = this.node;
        node.off(NodeEvent.POSITION_CHANGED, this._onNodePositionChanged, this);
        node.off(NodeEvent.ROTATION_CHANGED, this._onNodeRotationChanged, this);
        node.off(NodeEvent.SCALE_CHANGED, this._onNodeScaleChanged, this);
      },
      _onNodePositionChanged: function() {
        this.syncPosition(true);
      },
      _onNodeRotationChanged: function(event) {
        this.syncRotation(true);
      },
      _onNodeScaleChanged: function(event) {
        if (this._b2Body) {
          var colliders = this.getComponents(cc.PhysicsCollider);
          for (var i = 0; i < colliders.length; i++) colliders[i].apply();
        }
      },
      _init: function() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
      },
      _destroy: function() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
      },
      __init: function() {
        if (this._inited) return;
        this._registerNodeEvents();
        var bodyDef = new b2.BodyDef();
        this.type === BodyType.Animated ? bodyDef.type = BodyType.Kinematic : bodyDef.type = this.type;
        bodyDef.allowSleep = this.allowSleep;
        bodyDef.gravityScale = this.gravityScale;
        bodyDef.linearDamping = this.linearDamping;
        bodyDef.angularDamping = this.angularDamping;
        var linearVelocity = this.linearVelocity;
        bodyDef.linearVelocity = new b2.Vec2(linearVelocity.x / PTM_RATIO, linearVelocity.y / PTM_RATIO);
        bodyDef.angularVelocity = this.angularVelocity * ANGLE_TO_PHYSICS_ANGLE;
        bodyDef.fixedRotation = this.fixedRotation;
        bodyDef.bullet = this.bullet;
        var node = this.node;
        var pos = node.convertToWorldSpaceAR(VEC2_ZERO);
        bodyDef.position = new b2.Vec2(pos.x / PTM_RATIO, pos.y / PTM_RATIO);
        bodyDef.angle = -Math.PI / 180 * getWorldRotation(node);
        cc.director.getPhysicsManager()._addBody(this, bodyDef);
        this._inited = true;
      },
      __destroy: function() {
        if (!this._inited) return;
        cc.director.getPhysicsManager()._removeBody(this);
        this._unregisterNodeEvents();
        this._inited = false;
      },
      _getBody: function() {
        return this._b2Body;
      }
    });
    cc.RigidBody = module.exports = RigidBody;
  }), {
    "../CCNode": 30,
    "./CCPhysicsTypes": 131,
    "./utils": 152
  } ],
  134: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PhysicsBoxCollider = cc.Class({
      name: "cc.PhysicsBoxCollider",
      extends: cc.PhysicsCollider,
      mixins: [ cc.Collider.Box ],
      editor: {
        menu: false,
        requireComponent: cc.RigidBody
      },
      _createShape: function(scale) {
        var scaleX = Math.abs(scale.x);
        var scaleY = Math.abs(scale.y);
        var width = this.size.width / 2 / PTM_RATIO * scaleX;
        var height = this.size.height / 2 / PTM_RATIO * scaleY;
        var offsetX = this.offset.x / PTM_RATIO * scaleX;
        var offsetY = this.offset.y / PTM_RATIO * scaleY;
        var shape = new b2.PolygonShape();
        shape.SetAsBox(width, height, new b2.Vec2(offsetX, offsetY), 0);
        return shape;
      }
    });
    cc.PhysicsBoxCollider = module.exports = PhysicsBoxCollider;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  135: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PhysicsChainCollider = cc.Class({
      name: "cc.PhysicsChainCollider",
      extends: cc.PhysicsCollider,
      editor: {
        menu: false,
        inspector: false,
        requireComponent: cc.RigidBody
      },
      properties: {
        loop: false,
        points: {
          default: function() {
            return [ cc.v2(-50, 0), cc.v2(50, 0) ];
          },
          type: [ cc.Vec2 ]
        },
        threshold: {
          default: 1,
          serializable: false,
          visible: false
        }
      },
      _createShape: function(scale) {
        var shape = new b2.ChainShape();
        var points = this.points;
        var vertices = [];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          vertices.push(new b2.Vec2(p.x / PTM_RATIO * scale.x, p.y / PTM_RATIO * scale.y));
        }
        this.loop ? shape.CreateLoop(vertices, vertices.length) : shape.CreateChain(vertices, vertices.length);
        return shape;
      },
      resetInEditor: false,
      resetPointsByContour: false
    });
    cc.PhysicsChainCollider = module.exports = PhysicsChainCollider;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  136: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PhysicsCircleCollider = cc.Class({
      name: "cc.PhysicsCircleCollider",
      extends: cc.PhysicsCollider,
      mixins: [ cc.Collider.Circle ],
      editor: {
        menu: false,
        requireComponent: cc.RigidBody
      },
      _createShape: function(scale) {
        var scaleX = Math.abs(scale.x);
        var scaleY = Math.abs(scale.y);
        var offsetX = this.offset.x / PTM_RATIO * scaleX;
        var offsetY = this.offset.y / PTM_RATIO * scaleY;
        var shape = new b2.CircleShape();
        shape.m_radius = this.radius / PTM_RATIO * scaleX;
        shape.m_p = new b2.Vec2(offsetX, offsetY);
        return shape;
      }
    });
    cc.PhysicsCircleCollider = module.exports = PhysicsCircleCollider;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  137: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var getWorldScale = require("../utils").getWorldScale;
    var PhysicsCollider = cc.Class({
      name: "cc.PhysicsCollider",
      extends: cc.Collider,
      ctor: function() {
        this._fixtures = [];
        this._shapes = [];
        this._inited = false;
        this._rect = cc.rect();
      },
      properties: {
        _density: 1,
        _sensor: false,
        _friction: .2,
        _restitution: 0,
        density: {
          tooltip: false,
          get: function() {
            return this._density;
          },
          set: function(value) {
            this._density = value;
          }
        },
        sensor: {
          tooltip: false,
          get: function() {
            return this._sensor;
          },
          set: function(value) {
            this._sensor = value;
          }
        },
        friction: {
          tooltip: false,
          get: function() {
            return this._friction;
          },
          set: function(value) {
            this._friction = value;
          }
        },
        restitution: {
          tooltip: false,
          get: function() {
            return this._restitution;
          },
          set: function(value) {
            this._restitution = value;
          }
        },
        body: {
          default: null,
          type: cc.RigidBody,
          visible: false
        }
      },
      onDisable: function() {
        this._destroy();
      },
      onEnable: function() {
        this._init();
      },
      start: function() {
        this._init();
      },
      _getFixtureIndex: function(fixture) {
        return this._fixtures.indexOf(fixture);
      },
      _init: function() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
      },
      _destroy: function() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
      },
      __init: function() {
        if (this._inited) return;
        var body = this.body || this.getComponent(cc.RigidBody);
        if (!body) return;
        var innerBody = body._getBody();
        if (!innerBody) return;
        var node = body.node;
        var scale = getWorldScale(node);
        this._scale = scale;
        var shapes = 0 === scale.x && 0 === scale.y ? [] : this._createShape(scale);
        shapes instanceof Array || (shapes = [ shapes ]);
        var categoryBits = 1 << node.groupIndex;
        var maskBits = 0;
        var bits = cc.game.collisionMatrix[node.groupIndex];
        for (var i = 0; i < bits.length; i++) {
          if (!bits[i]) continue;
          maskBits |= 1 << i;
        }
        var filter = {
          categoryBits: categoryBits,
          maskBits: maskBits,
          groupIndex: 0
        };
        var manager = cc.director.getPhysicsManager();
        for (var _i = 0; _i < shapes.length; _i++) {
          var shape = shapes[_i];
          var fixDef = new b2.FixtureDef();
          fixDef.density = this.density;
          fixDef.isSensor = this.sensor;
          fixDef.friction = this.friction;
          fixDef.restitution = this.restitution;
          fixDef.shape = shape;
          fixDef.filter = filter;
          var fixture = innerBody.CreateFixture(fixDef);
          fixture.collider = this;
          body.enabledContactListener && manager._registerContactFixture(fixture);
          this._shapes.push(shape);
          this._fixtures.push(fixture);
        }
        this.body = body;
        this._inited = true;
      },
      __destroy: function() {
        if (!this._inited) return;
        var fixtures = this._fixtures;
        var body = this.body._getBody();
        var manager = cc.director.getPhysicsManager();
        for (var i = fixtures.length - 1; i >= 0; i--) {
          var fixture = fixtures[i];
          fixture.collider = null;
          manager._unregisterContactFixture(fixture);
          body && body.DestroyFixture(fixture);
        }
        this.body = null;
        this._fixtures.length = 0;
        this._shapes.length = 0;
        this._inited = false;
      },
      _createShape: function() {},
      apply: function() {
        this._destroy();
        this._init();
      },
      getAABB: function() {
        var MAX = 1e7;
        var minX = MAX, minY = MAX;
        var maxX = -MAX, maxY = -MAX;
        var fixtures = this._fixtures;
        for (var i = 0; i < fixtures.length; i++) {
          var fixture = fixtures[i];
          var count = fixture.GetShape().GetChildCount();
          for (var j = 0; j < count; j++) {
            var aabb = fixture.GetAABB(j);
            aabb.lowerBound.x < minX && (minX = aabb.lowerBound.x);
            aabb.lowerBound.y < minY && (minY = aabb.lowerBound.y);
            aabb.upperBound.x > maxX && (maxX = aabb.upperBound.x);
            aabb.upperBound.y > maxY && (maxY = aabb.upperBound.y);
          }
        }
        minX *= PTM_RATIO;
        minY *= PTM_RATIO;
        maxX *= PTM_RATIO;
        maxY *= PTM_RATIO;
        var r = this._rect;
        r.x = minX;
        r.y = minY;
        r.width = maxX - minX;
        r.height = maxY - minY;
        return r;
      }
    });
    cc.PhysicsCollider = module.exports = PhysicsCollider;
  }), {
    "../CCPhysicsTypes": 131,
    "../utils": 152
  } ],
  138: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PolygonSeparator = require("../CCPolygonSeparator");
    var PhysicsPolygonCollider = cc.Class({
      name: "cc.PhysicsPolygonCollider",
      extends: cc.PhysicsCollider,
      mixins: [ cc.Collider.Polygon ],
      editor: {
        menu: false,
        inspector: false,
        requireComponent: cc.RigidBody
      },
      _createShape: function(scale) {
        var shapes = [];
        var points = this.points;
        points.length > 0 && points[0].equals(points[points.length - 1]) && (points.length -= 1);
        var polys = PolygonSeparator.ConvexPartition(points);
        var offset = this.offset;
        for (var i = 0; i < polys.length; i++) {
          var poly = polys[i];
          var shape = null, vertices = [];
          var firstVertice = null;
          for (var j = 0, l = poly.length; j < l; j++) {
            shape || (shape = new b2.PolygonShape());
            var p = poly[j];
            var x = (p.x + offset.x) / PTM_RATIO * scale.x;
            var y = (p.y + offset.y) / PTM_RATIO * scale.y;
            var v = new b2.Vec2(x, y);
            vertices.push(v);
            firstVertice || (firstVertice = v);
            if (vertices.length === b2.maxPolygonVertices) {
              shape.Set(vertices, vertices.length);
              shapes.push(shape);
              shape = null;
              j < l - 1 && (vertices = [ firstVertice, vertices[vertices.length - 1] ]);
            }
          }
          if (shape) {
            shape.Set(vertices, vertices.length);
            shapes.push(shape);
          }
        }
        return shapes;
      }
    });
    cc.PhysicsPolygonCollider = module.exports = PhysicsPolygonCollider;
  }), {
    "../CCPhysicsTypes": 131,
    "../CCPolygonSeparator": 132
  } ],
  139: [ (function(require, module, exports) {
    window.b2 = require("../../../external/box2d/box2d");
    false;
    require("./CCPhysicsManager");
    require("./CCRigidBody");
    require("./CCPhysicsContact");
    require("./collider/CCPhysicsCollider");
    require("./collider/CCPhysicsChainCollider");
    require("./collider/CCPhysicsCircleCollider");
    require("./collider/CCPhysicsBoxCollider");
    require("./collider/CCPhysicsPolygonCollider");
    require("./joint/CCJoint");
    require("./joint/CCDistanceJoint");
    require("./joint/CCRevoluteJoint");
    require("./joint/CCMouseJoint");
    require("./joint/CCMotorJoint");
    require("./joint/CCPrismaticJoint");
    require("./joint/CCWeldJoint");
    require("./joint/CCWheelJoint");
    require("./joint/CCRopeJoint");
    require("./platform/CCPhysicsContactListner");
    require("./platform/CCPhysicsAABBQueryCallback");
    require("./platform/CCPhysicsRayCastCallback");
  }), {
    "../../../external/box2d/box2d": 290,
    "./CCPhysicsContact": 128,
    "./CCPhysicsManager": 130,
    "./CCRigidBody": 133,
    "./collider/CCPhysicsBoxCollider": 134,
    "./collider/CCPhysicsChainCollider": 135,
    "./collider/CCPhysicsCircleCollider": 136,
    "./collider/CCPhysicsCollider": 137,
    "./collider/CCPhysicsPolygonCollider": 138,
    "./joint/CCDistanceJoint": 140,
    "./joint/CCJoint": 141,
    "./joint/CCMotorJoint": 142,
    "./joint/CCMouseJoint": 143,
    "./joint/CCPrismaticJoint": 144,
    "./joint/CCRevoluteJoint": 145,
    "./joint/CCRopeJoint": 146,
    "./joint/CCWeldJoint": 147,
    "./joint/CCWheelJoint": 148,
    "./platform/CCPhysicsAABBQueryCallback": 149,
    "./platform/CCPhysicsContactListner": 150,
    "./platform/CCPhysicsRayCastCallback": 151
  } ],
  140: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var DistanceJoint = cc.Class({
      name: "cc.DistanceJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _distance: 1,
        _frequency: 0,
        _dampingRatio: 0,
        distance: {
          tooltip: false,
          get: function() {
            return this._distance;
          },
          set: function(value) {
            this._distance = value;
            this._joint && this._joint.SetLength(value);
          }
        },
        frequency: {
          tooltip: false,
          get: function() {
            return this._frequency;
          },
          set: function(value) {
            this._frequency = value;
            this._joint && this._joint.SetFrequency(value);
          }
        },
        dampingRatio: {
          tooltip: false,
          get: function() {
            return this._dampingRatio;
          },
          set: function(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        }
      },
      _createJointDef: function() {
        var def = new b2.DistanceJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.length = this.distance / PTM_RATIO;
        def.dampingRatio = this.dampingRatio;
        def.frequencyHz = this.frequency;
        return def;
      }
    });
    cc.DistanceJoint = module.exports = DistanceJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  141: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var Joint = cc.Class({
      name: "cc.Joint",
      extends: cc.Component,
      editor: {
        requireComponent: cc.RigidBody
      },
      properties: {
        anchor: {
          default: cc.v2(0, 0),
          tooltip: false
        },
        connectedAnchor: {
          default: cc.v2(0, 0),
          tooltip: false
        },
        connectedBody: {
          default: null,
          type: cc.RigidBody,
          tooltip: false
        },
        collideConnected: {
          default: false,
          tooltip: false
        }
      },
      onDisable: function() {
        this._destroy();
      },
      onEnable: function() {
        this._init();
      },
      start: function() {
        this._init();
      },
      apply: function() {
        this._destroy();
        this._init();
      },
      getWorldAnchor: function() {
        if (this._joint) {
          var anchor = this._joint.GetAnchorA();
          return cc.v2(anchor.x * PTM_RATIO, anchor.y * PTM_RATIO);
        }
        return cc.Vec2.ZERO;
      },
      getWorldConnectedAnchor: function() {
        if (this._joint) {
          var anchor = this._joint.GetAnchorB();
          return cc.v2(anchor.x * PTM_RATIO, anchor.y * PTM_RATIO);
        }
        return cc.Vec2.ZERO;
      },
      getReactionForce: function(timeStep) {
        if (this._joint) return this._joint.GetReactionForce(timeStep);
        return 0;
      },
      getReactionTorque: function(timeStep) {
        if (this._joint) return this._joint.GetReactionTorque(timeStep);
        return 0;
      },
      _init: function() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
      },
      _destroy: function() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
      },
      __init: function() {
        if (this._inited) return;
        this.body = this.getComponent(cc.RigidBody);
        if (this._isValid()) {
          var def = this._createJointDef();
          if (!def) return;
          def.bodyA = this.body._getBody();
          def.bodyB = this.connectedBody._getBody();
          def.collideConnected = this.collideConnected;
          cc.director.getPhysicsManager()._addJoint(this, def);
          this._inited = true;
        }
      },
      __destroy: function() {
        if (!this._inited) return;
        cc.director.getPhysicsManager()._removeJoint(this);
        this._joint = null;
        this._inited = false;
      },
      _createJointDef: function() {
        return null;
      },
      _isValid: function() {
        return this.body && this.body._getBody() && this.connectedBody && this.connectedBody._getBody();
      }
    });
    cc.Joint = module.exports = Joint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  142: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var MotorJoint = cc.Class({
      name: "cc.MotorJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _linearOffset: cc.v2(0, 0),
        _angularOffset: 0,
        _maxForce: 1,
        _maxTorque: 1,
        _correctionFactor: .3,
        anchor: {
          tooltip: false,
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        connectedAnchor: {
          tooltip: false,
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        linearOffset: {
          tooltip: false,
          get: function() {
            return this._linearOffset;
          },
          set: function(value) {
            this._linearOffset = value;
            this._joint && this._joint.SetLinearOffset(new b2.Vec2(value.x / PTM_RATIO, value.y / PTM_RATIO));
          }
        },
        angularOffset: {
          tooltip: false,
          get: function() {
            return this._angularOffset;
          },
          set: function(value) {
            this._angularOffset = value;
            this._joint && this._joint.SetAngularOffset(value);
          }
        },
        maxForce: {
          tooltip: false,
          get: function() {
            return this._maxForce;
          },
          set: function(value) {
            this._maxForce = value;
            this._joint && this._joint.SetMaxForce(value);
          }
        },
        maxTorque: {
          tooltip: false,
          get: function() {
            return this._maxTorque;
          },
          set: function(value) {
            this._maxTorque = value;
            this._joint && this._joint.SetMaxTorque(value);
          }
        },
        correctionFactor: {
          tooltip: false,
          get: function() {
            return this._correctionFactor;
          },
          set: function(value) {
            this._correctionFactor = value;
            this._joint && this._joint.SetCorrectionFactor(value);
          }
        }
      },
      _createJointDef: function() {
        var def = new b2.MotorJointDef();
        def.linearOffset = new b2.Vec2(this.linearOffset.x / PTM_RATIO, this.linearOffset.y / PTM_RATIO);
        def.angularOffset = this.angularOffset * ANGLE_TO_PHYSICS_ANGLE;
        def.maxForce = this.maxForce;
        def.maxTorque = this.maxTorque;
        def.correctionFactor = this.correctionFactor;
        return def;
      }
    });
    cc.MotorJoint = module.exports = MotorJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  143: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var tempB2Vec2 = new b2.Vec2();
    var MouseJoint = cc.Class({
      name: "cc.MouseJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _target: 1,
        _frequency: 5,
        _dampingRatio: .7,
        _maxForce: 0,
        connectedBody: {
          default: null,
          type: cc.RigidBody,
          visible: false,
          override: true
        },
        collideConnected: {
          default: true,
          visible: false,
          override: true
        },
        anchor: {
          tooltip: false,
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        connectedAnchor: {
          tooltip: false,
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        mouseRegion: {
          tooltip: false,
          default: null,
          type: cc.Node
        },
        target: {
          tooltip: false,
          visible: false,
          get: function() {
            return this._target;
          },
          set: function(value) {
            this._target = value;
            if (this._joint) {
              tempB2Vec2.x = value.x / PTM_RATIO;
              tempB2Vec2.y = value.y / PTM_RATIO;
              this._joint.SetTarget(tempB2Vec2);
            }
          }
        },
        frequency: {
          tooltip: false,
          get: function() {
            return this._frequency;
          },
          set: function(value) {
            this._frequency = value;
            this._joint && this._joint.SetFrequency(value);
          }
        },
        dampingRatio: {
          tooltip: false,
          get: function() {
            return this._dampingRatio;
          },
          set: function(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        },
        maxForce: {
          tooltip: false,
          visible: false,
          get: function() {
            return this._maxForce;
          },
          set: function(value) {
            this._maxForce = value;
            this._joint && this._joint.SetMaxForce(value);
          }
        }
      },
      onLoad: function() {
        var mouseRegion = this.mouseRegion || this.node;
        mouseRegion.on(cc.Node.EventType.TOUCH_START, this.onTouchBegan, this);
        mouseRegion.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
        mouseRegion.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this);
      },
      onEnable: function() {},
      start: function() {},
      onTouchBegan: function(event) {
        var manager = cc.director.getPhysicsManager();
        var target = this._pressPoint = event.touch.getLocation();
        cc.Camera && cc.Camera.main && (target = cc.Camera.main.getCameraToWorldPoint(target));
        var collider = manager.testPoint(target);
        if (!collider) return;
        var body = this.connectedBody = collider.body;
        body.awake = true;
        this.maxForce = 1e3 * this.connectedBody.getMass();
        this.target = target;
        this._init();
      },
      onTouchMove: function(event) {
        this._pressPoint = event.touch.getLocation();
      },
      onTouchEnd: function(event) {
        this._destroy();
        this._pressPoint = null;
      },
      _createJointDef: function() {
        var def = new b2.MouseJointDef();
        tempB2Vec2.x = this.target.x / PTM_RATIO;
        tempB2Vec2.y = this.target.y / PTM_RATIO;
        def.target = tempB2Vec2;
        def.maxForce = this.maxForce;
        def.dampingRatio = this.dampingRatio;
        def.frequencyHz = this.frequency;
        return def;
      },
      update: function() {
        if (!this._pressPoint || !this._isValid()) return;
        var camera = cc.Camera.findCamera(this.node);
        this.target = camera ? camera.getCameraToWorldPoint(this._pressPoint) : this._pressPoint;
      }
    });
    cc.MouseJoint = module.exports = MouseJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  144: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var PrismaticJoint = cc.Class({
      name: "cc.PrismaticJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        localAxisA: {
          default: cc.v2(1, 0),
          tooltip: false
        },
        referenceAngle: {
          default: 0,
          tooltip: false
        },
        enableLimit: {
          default: false,
          tooltip: false
        },
        enableMotor: {
          default: false,
          tooltip: false
        },
        lowerLimit: {
          default: 0,
          tooltip: false
        },
        upperLimit: {
          default: 0,
          tooltip: false
        },
        _maxMotorForce: 0,
        _motorSpeed: 0,
        maxMotorForce: {
          tooltip: false,
          get: function() {
            return this._maxMotorForce;
          },
          set: function(value) {
            this._maxMotorForce = value;
            this._joint && this._joint.SetMaxMotorForce(value);
          }
        },
        motorSpeed: {
          tooltip: false,
          get: function() {
            return this._motorSpeed;
          },
          set: function(value) {
            this._motorSpeed = value;
            this._joint && this._joint.SetMotorSpeed(value);
          }
        }
      },
      _createJointDef: function() {
        var def = new b2.PrismaticJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.localAxisA = new b2.Vec2(this.localAxisA.x, this.localAxisA.y);
        def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
        def.enableLimit = this.enableLimit;
        def.lowerTranslation = this.lowerLimit / PTM_RATIO;
        def.upperTranslation = this.upperLimit / PTM_RATIO;
        def.enableMotor = this.enableMotor;
        def.maxMotorForce = this.maxMotorForce;
        def.motorSpeed = this.motorSpeed;
        return def;
      }
    });
    cc.PrismaticJoint = module.exports = PrismaticJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  145: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var PHYSICS_ANGLE_TO_ANGLE = require("../CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
    var RevoluteJoint = cc.Class({
      name: "cc.RevoluteJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _maxMotorTorque: 0,
        _motorSpeed: 0,
        _enableLimit: false,
        _enableMotor: false,
        referenceAngle: {
          default: 0,
          tooltip: false
        },
        lowerAngle: {
          default: 0,
          tooltip: false
        },
        upperAngle: {
          default: 0,
          tooltip: false
        },
        maxMotorTorque: {
          tooltip: false,
          get: function() {
            return this._maxMotorTorque;
          },
          set: function(value) {
            this._maxMotorTorque = value;
            this._joint && this._joint.SetMaxMotorTorque(value);
          }
        },
        motorSpeed: {
          tooltip: false,
          get: function() {
            return this._motorSpeed;
          },
          set: function(value) {
            this._motorSpeed = value;
            this._joint && this._joint.SetMotorSpeed(value * ANGLE_TO_PHYSICS_ANGLE);
          }
        },
        enableLimit: {
          tooltip: false,
          get: function() {
            return this._enableLimit;
          },
          set: function(value) {
            this._enableLimit = value;
            this._joint && this._joint.EnableLimit(value);
          }
        },
        enableMotor: {
          tooltip: false,
          get: function() {
            return this._enableMotor;
          },
          set: function(value) {
            this._enableMotor = value;
            this._joint && this._joint.EnableMotor(value);
          }
        }
      },
      getJointAngle: function() {
        if (this._joint) return this._joint.GetJointAngle() * PHYSICS_ANGLE_TO_ANGLE;
        return 0;
      },
      _createJointDef: function() {
        var def = new b2.RevoluteJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.lowerAngle = (this.upperAngle + 90) * ANGLE_TO_PHYSICS_ANGLE;
        def.upperAngle = (this.lowerAngle + 90) * ANGLE_TO_PHYSICS_ANGLE;
        def.maxMotorTorque = this.maxMotorTorque;
        def.motorSpeed = this.motorSpeed * ANGLE_TO_PHYSICS_ANGLE;
        def.enableLimit = this.enableLimit;
        def.enableMotor = this.enableMotor;
        def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
        return def;
      }
    });
    cc.RevoluteJoint = module.exports = RevoluteJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  146: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var RopeJoint = cc.Class({
      name: "cc.RopeJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _maxLength: 1,
        maxLength: {
          tooltip: false,
          get: function() {
            return this._maxLength;
          },
          set: function(value) {
            this._maxLength = value;
            this._joint && this._joint.SetMaxLength(value);
          }
        }
      },
      _createJointDef: function() {
        var def = new b2.RopeJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.maxLength = this.maxLength / PTM_RATIO;
        return def;
      }
    });
    cc.RopeJoint = module.exports = RopeJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  147: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var WeldJoint = cc.Class({
      name: "cc.WeldJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        referenceAngle: {
          default: 0,
          tooltip: false
        },
        _frequency: 0,
        _dampingRatio: 0,
        frequency: {
          tooltip: false,
          get: function() {
            return this._frequency;
          },
          set: function(value) {
            this._frequency = value;
            this._joint && this._joint.SetFrequency(value);
          }
        },
        dampingRatio: {
          tooltip: false,
          get: function() {
            return this._dampingRatio;
          },
          set: function(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        }
      },
      _createJointDef: function() {
        var def = new b2.WeldJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
        def.frequencyHz = this.frequency;
        def.dampingRatio = this.dampingRatio;
        return def;
      }
    });
    cc.WeldJoint = module.exports = WeldJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  148: [ (function(require, module, exports) {
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var WheelJoint = cc.Class({
      name: "cc.WheelJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _maxMotorTorque: 0,
        _motorSpeed: 0,
        _enableMotor: false,
        _frequency: 2,
        _dampingRatio: .7,
        localAxisA: {
          default: cc.v2(1, 0),
          tooltip: false
        },
        maxMotorTorque: {
          tooltip: false,
          get: function() {
            return this._maxMotorTorque;
          },
          set: function(value) {
            this._maxMotorTorque = value;
            this._joint && this._joint.SetMaxMotorTorque(value);
          }
        },
        motorSpeed: {
          tooltip: false,
          get: function() {
            return this._motorSpeed;
          },
          set: function(value) {
            this._motorSpeed = value;
            this._joint && this._joint.SetMotorSpeed(value * ANGLE_TO_PHYSICS_ANGLE);
          }
        },
        enableMotor: {
          tooltip: false,
          get: function() {
            return this._enableMotor;
          },
          set: function(value) {
            this._enableMotor = value;
            this._joint && this._joint.EnableMotor(value);
          }
        },
        frequency: {
          tooltip: false,
          get: function() {
            return this._frequency;
          },
          set: function(value) {
            this._frequency = value;
            this._joint && this._joint.SetFrequency(value);
          }
        },
        dampingRatio: {
          tooltip: false,
          get: function() {
            return this._dampingRatio;
          },
          set: function(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        }
      },
      _createJointDef: function() {
        var def = new b2.WheelJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.localAxisA = new b2.Vec2(this.localAxisA.x, this.localAxisA.y);
        def.maxMotorTorque = this.maxMotorTorque;
        def.motorSpeed = this.motorSpeed * ANGLE_TO_PHYSICS_ANGLE;
        def.enableMotor = this.enableMotor;
        def.dampingRatio = this.dampingRatio;
        def.frequencyHz = this.frequency;
        return def;
      }
    });
    cc.WheelJoint = module.exports = WheelJoint;
  }), {
    "../CCPhysicsTypes": 131
  } ],
  149: [ (function(require, module, exports) {
    function PhysicsAABBQueryCallback() {
      this._point = new b2.Vec2();
      this._isPoint = false;
      this._fixtures = [];
    }
    PhysicsAABBQueryCallback.prototype.init = function(point) {
      if (point) {
        this._isPoint = true;
        this._point.x = point.x;
        this._point.y = point.y;
      } else this._isPoint = false;
      this._fixtures.length = 0;
    };
    PhysicsAABBQueryCallback.prototype.ReportFixture = function(fixture) {
      var body = fixture.GetBody();
      if (body.GetType() === b2.Body.b2_dynamicBody) if (this._isPoint) {
        if (fixture.TestPoint(this._point)) {
          this._fixtures.push(fixture);
          return false;
        }
      } else this._fixtures.push(fixture);
      return true;
    };
    PhysicsAABBQueryCallback.prototype.getFixture = function() {
      return this._fixtures[0];
    };
    PhysicsAABBQueryCallback.prototype.getFixtures = function() {
      return this._fixtures;
    };
    cc.PhysicsAABBQueryCallback = module.exports = PhysicsAABBQueryCallback;
  }), {} ],
  150: [ (function(require, module, exports) {
    function PhysicsContactListener() {
      this._contactFixtures = [];
    }
    PhysicsContactListener.prototype.setBeginContact = function(cb) {
      this._BeginContact = cb;
    };
    PhysicsContactListener.prototype.setEndContact = function(cb) {
      this._EndContact = cb;
    };
    PhysicsContactListener.prototype.setPreSolve = function(cb) {
      this._PreSolve = cb;
    };
    PhysicsContactListener.prototype.setPostSolve = function(cb) {
      this._PostSolve = cb;
    };
    PhysicsContactListener.prototype.BeginContact = function(contact) {
      if (!this._BeginContact) return;
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var fixtures = this._contactFixtures;
      contact._shouldReport = false;
      if (-1 !== fixtures.indexOf(fixtureA) || -1 !== fixtures.indexOf(fixtureB)) {
        contact._shouldReport = true;
        this._BeginContact(contact);
      }
    };
    PhysicsContactListener.prototype.EndContact = function(contact) {
      if (this._EndContact && contact._shouldReport) {
        contact._shouldReport = false;
        this._EndContact(contact);
      }
    };
    PhysicsContactListener.prototype.PreSolve = function(contact, oldManifold) {
      this._PreSolve && contact._shouldReport && this._PreSolve(contact, oldManifold);
    };
    PhysicsContactListener.prototype.PostSolve = function(contact, impulse) {
      this._PostSolve && contact._shouldReport && this._PostSolve(contact, impulse);
    };
    PhysicsContactListener.prototype.registerContactFixture = function(fixture) {
      this._contactFixtures.push(fixture);
    };
    PhysicsContactListener.prototype.unregisterContactFixture = function(fixture) {
      cc.js.array.remove(this._contactFixtures, fixture);
    };
    cc.PhysicsContactListener = module.exports = PhysicsContactListener;
  }), {} ],
  151: [ (function(require, module, exports) {
    function PhysicsRayCastCallback() {
      this._type = 0;
      this._fixtures = [];
      this._points = [];
      this._normals = [];
      this._fractions = [];
    }
    PhysicsRayCastCallback.prototype.init = function(type) {
      this._type = type;
      this._fixtures.length = 0;
      this._points.length = 0;
      this._normals.length = 0;
      this._fractions.length = 0;
    };
    PhysicsRayCastCallback.prototype.ReportFixture = function(fixture, point, normal, fraction) {
      if (0 === this._type) {
        this._fixtures[0] = fixture;
        this._points[0] = point;
        this._normals[0] = normal;
        this._fractions[0] = fraction;
        return fraction;
      }
      this._fixtures.push(fixture);
      this._points.push(point);
      this._normals.push(normal);
      this._fractions.push(fraction);
      if (1 === this._type) return 0;
      if (this._type >= 2) return 1;
      return fraction;
    };
    PhysicsRayCastCallback.prototype.getFixtures = function() {
      return this._fixtures;
    };
    PhysicsRayCastCallback.prototype.getPoints = function() {
      return this._points;
    };
    PhysicsRayCastCallback.prototype.getNormals = function() {
      return this._normals;
    };
    PhysicsRayCastCallback.prototype.getFractions = function() {
      return this._fractions;
    };
    cc.PhysicsRayCastCallback = module.exports = PhysicsRayCastCallback;
  }), {} ],
  152: [ (function(require, module, exports) {
    function getWorldRotation(node) {
      var rot = node.rotationX;
      var parent = node.parent;
      while (parent.parent) {
        rot += parent.rotationX;
        parent = parent.parent;
      }
      return rot;
    }
    function getWorldScale(node) {
      var scaleX = node.scaleX;
      var scaleY = node.scaleY;
      var parent = node.parent;
      while (parent.parent) {
        scaleX *= parent.scaleX;
        scaleY *= parent.scaleY;
        parent = parent.parent;
      }
      return cc.v2(scaleX, scaleY);
    }
    function convertToNodeRotation(node, rotation) {
      rotation -= node.rotationX;
      var parent = node.parent;
      while (parent.parent) {
        rotation -= parent.rotationX;
        parent = parent.parent;
      }
      return rotation;
    }
    module.exports = {
      getWorldRotation: getWorldRotation,
      getWorldScale: getWorldScale,
      convertToNodeRotation: convertToNodeRotation
    };
  }), {} ],
  153: [ (function(require, module, exports) {
    var js;
    var macro;
    var sys;
    var eventManager;
    var TOUCH_TIMEOUT;
    var bkInputManager;
    false;
  }), {
    "../event-manager": 98,
    "../platform/js": 175,
    "./CCMacro": 160,
    "./CCSys": 164
  } ],
  154: [ (function(require, module, exports) {
    var Asset = require("../assets/CCAsset");
    var callInNextTick = require("./utils").callInNextTick;
    var Loader = require("../load-pipeline/CCLoader");
    var PackDownloader = require("../load-pipeline/pack-downloader");
    var AutoReleaseUtils = require("../load-pipeline/auto-release-utils");
    var decodeUuid = require("../utils/decode-uuid");
    var MD5Pipe = require("../load-pipeline/md5-pipe");
    var js = require("./js");
    var _libraryBase = "";
    var _rawAssetsBase = "";
    var _uuidToRawAsset = js.createMap(true);
    function isScene(asset) {
      return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
    }
    function RawAssetEntry(url, type) {
      this.url = url;
      this.type = type;
    }
    var AssetLibrary = {
      loadAsset: function(uuid, callback, options) {
        if ("string" !== typeof uuid) return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
        var item = {
          uuid: uuid,
          type: "uuid"
        };
        options && options.existingAsset && (item.existingAsset = options.existingAsset);
        Loader.load(item, (function(error, asset) {
          if (error || !asset) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error ? error.message : "Unknown error")); else {
            if (asset.constructor === cc.SceneAsset) {
              false;
              var key = cc.loader._getReferenceKey(uuid);
              asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
            }
            if (false, isScene(asset)) {
              var id = cc.loader._getReferenceKey(uuid);
              Loader.removeItem(id);
            }
          }
          callback && callback(error, asset);
        }));
      },
      getLibUrlNoExt: function(uuid) {
        true;
        uuid = decodeUuid(uuid);
        return _libraryBase + uuid.slice(0, 2) + "/" + uuid;
      },
      _queryAssetInfoInEditor: function(uuid, callback) {
        false;
      },
      _getAssetInfoInRuntime: function(uuid, result) {
        result = result || {
          url: null,
          raw: false
        };
        var info = _uuidToRawAsset[uuid];
        if (info && !js.isChildClassOf(info.type, cc.Asset)) {
          result.url = _rawAssetsBase + info.url;
          result.raw = true;
        } else {
          result.url = this.getLibUrlNoExt(uuid) + ".json";
          result.raw = false;
        }
        return result;
      },
      _getAssetUrl: function(uuid) {
        var info = _uuidToRawAsset[uuid];
        if (info) return _rawAssetsBase + info.url;
        return null;
      },
      queryAssetInfo: function(uuid, callback) {
        false;
        var info = this._getAssetInfoInRuntime(uuid);
        callback(null, info.url, info.raw);
      },
      parseUuidInEditor: function(url) {
        var uuid;
        var isImported;
        var dir;
        var dirBasename;
        var isAssetUrl;
        var index;
        false;
      },
      loadJson: function(json, callback) {
        var randomUuid = "" + (new Date().getTime() + Math.random());
        var item = {
          uuid: randomUuid,
          type: "uuid",
          content: json,
          skips: [ Loader.assetLoader.id, Loader.downloader.id ]
        };
        Loader.load(item, (function(error, asset) {
          if (error) error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message); else {
            if (asset.constructor === cc.SceneAsset) {
              var key = cc.loader._getReferenceKey(randomUuid);
              asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
            }
            if (false, isScene(asset)) {
              var id = cc.loader._getReferenceKey(randomUuid);
              Loader.removeItem(id);
            }
          }
          asset._uuid = "";
          callback && callback(error, asset);
        }));
      },
      getAssetByUuid: function(uuid) {
        return AssetLibrary._uuidToAsset[uuid] || null;
      },
      init: function(options) {
        false;
        var libraryPath = options.libraryPath;
        libraryPath = libraryPath.replace(/\\/g, "/");
        _libraryBase = cc.path.stripSep(libraryPath) + "/";
        _rawAssetsBase = options.rawAssetsBase;
        var md5AssetsMap = options.md5AssetsMap;
        if (md5AssetsMap) {
          var md5Pipe = new MD5Pipe(md5AssetsMap, _libraryBase, _rawAssetsBase);
          cc.loader.insertPipeAfter(cc.loader.assetLoader, md5Pipe);
          cc.loader.md5Pipe = md5Pipe;
        }
        var resources = Loader._resources;
        resources.reset();
        var rawAssets = options.rawAssets;
        if (rawAssets) for (var mountPoint in rawAssets) {
          var assets = rawAssets[mountPoint];
          for (var uuid in assets) {
            var info = assets[uuid];
            var url = info[0];
            var typeId = info[1];
            var type = cc.js._getClassById(typeId);
            if (!type) {
              cc.error("Cannot get", typeId);
              continue;
            }
            _uuidToRawAsset[uuid] = new RawAssetEntry(mountPoint + "/" + url, type);
            if ("assets" === mountPoint) {
              var ext = cc.path.extname(url);
              ext && (url = url.slice(0, -ext.length));
              var isSubAsset = 1 === info[2];
              resources.add(url, uuid, type, !isSubAsset);
            }
          }
        }
        options.packedAssets && PackDownloader.initPacks(options.packedAssets);
        var mountPaths = options.mountPaths;
        mountPaths || (mountPaths = {
          assets: _rawAssetsBase + "assets",
          internal: _rawAssetsBase + "internal"
        });
        cc.url._init(mountPaths);
      }
    };
    AssetLibrary._uuidToAsset = {};
    module.exports = cc.AssetLibrary = AssetLibrary;
  }), {
    "../assets/CCAsset": 34,
    "../load-pipeline/CCLoader": 109,
    "../load-pipeline/auto-release-utils": 113,
    "../load-pipeline/md5-pipe": 119,
    "../load-pipeline/pack-downloader": 120,
    "../utils/decode-uuid": 228,
    "./js": 175,
    "./utils": 179
  } ],
  155: [ (function(require, module, exports) {
    var js = require("./js");
    var Enum = require("./CCEnum");
    var utils = require("./utils");
    var _isPlainEmptyObj_DEV = utils.isPlainEmptyObj_DEV;
    var _cloneable_DEV = utils.cloneable_DEV;
    var Attr = require("./attribute");
    var DELIMETER = Attr.DELIMETER;
    var getTypeChecker = Attr.getTypeChecker;
    var preprocess = require("./preprocess-class");
    require("./requiring-frame");
    var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
    var INVALID_STATICS_DEV = false;
    function pushUnique(array, item) {
      array.indexOf(item) < 0 && array.push(item);
    }
    var deferredInitializer = {
      datas: null,
      push: function(data) {
        if (this.datas) this.datas.push(data); else {
          this.datas = [ data ];
          var self = this;
          setTimeout((function() {
            self.init();
          }), 0);
        }
      },
      init: function() {
        var datas = this.datas;
        if (datas) {
          for (var i = 0; i < datas.length; ++i) {
            var data = datas[i];
            var cls = data.cls;
            var properties = data.props;
            "function" === typeof properties && (properties = properties());
            var name = js.getClassName(cls);
            properties ? declareProperties(cls, name, properties, cls.$super, data.mixins) : cc.errorID(3633, name);
          }
          this.datas = null;
        }
      }
    };
    function appendProp(cls, name) {
      false;
      pushUnique(cls.__props__, name);
    }
    var tmpArray = [];
    function defineProp(cls, className, propName, val, es6) {
      var defaultValue = val.default;
      false;
      Attr.setClassAttr(cls, propName, "default", defaultValue);
      appendProp(cls, propName);
      var attrs = parseAttributes(cls, val, className, propName, false);
      if (attrs) {
        var onAfterProp = tmpArray;
        for (var i = 0; i < attrs.length; i++) {
          var attr = attrs[i];
          Attr.attr(cls, propName, attr);
          attr._onAfterProp && onAfterProp.push(attr._onAfterProp);
        }
        for (var c = 0; c < onAfterProp.length; c++) onAfterProp[c](cls, propName);
        tmpArray.length = 0;
        attrs.length = 0;
      }
    }
    function defineGetSet(cls, name, propName, val, es6) {
      var getter = val.get;
      var setter = val.set;
      var proto = cls.prototype;
      var d = Object.getOwnPropertyDescriptor(proto, propName);
      var setterUndefined = !d;
      if (getter) {
        false;
        var attrs = parseAttributes(cls, val, name, propName, true);
        for (var i = 0; i < attrs.length; i++) Attr.attr(cls, propName, attrs[i]);
        attrs.length = 0;
        var ForceSerializable = false;
        ForceSerializable || Attr.setClassAttr(cls, propName, "serializable", false);
        !!ForceSerializable && appendProp(cls, propName);
        es6 || js.get(proto, propName, getter, setterUndefined, setterUndefined);
        false, false;
      }
      if (setter) {
        if (!es6) {
          false;
          js.set(proto, propName, setter, setterUndefined, setterUndefined);
        }
        false, false;
      }
    }
    function getDefault(defaultVal) {
      if ("function" === typeof defaultVal) {
        false;
        return defaultVal();
      }
      return defaultVal;
    }
    function mixinWithInherited(dest, src, filter) {
      for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, js.getPropertyDescriptor(src, prop));
    }
    function doDefine(className, baseClass, mixins, options) {
      var shouldAddProtoCtor;
      var __ctor__ = options.__ctor__;
      var ctor = options.ctor;
      var __es6__ = options.__ES6__;
      var ctorToUse;
      false;
      var ctors;
      var fireClass;
      if (__es6__) {
        ctors = [ ctor ];
        fireClass = ctor;
      } else {
        ctors = __ctor__ ? [ __ctor__ ] : _getAllCtors(baseClass, mixins, options);
        fireClass = _createCtor(ctors, baseClass, className, options);
        js.value(fireClass, "extend", (function(options) {
          options.extends = this;
          return CCClass(options);
        }), true);
      }
      js.value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, true);
      var prototype = fireClass.prototype;
      if (baseClass) {
        if (!__es6__) {
          js.extend(fireClass, baseClass);
          prototype = fireClass.prototype;
        }
        fireClass.$super = baseClass;
        false;
      }
      if (mixins) {
        for (var m = mixins.length - 1; m >= 0; m--) {
          var mixin = mixins[m];
          mixinWithInherited(prototype, mixin.prototype);
          mixinWithInherited(fireClass, mixin, (function(prop) {
            return mixin.hasOwnProperty(prop) && true;
          }));
          CCClass._isCCClass(mixin) && mixinWithInherited(Attr.getClassAttrs(fireClass).constructor.prototype, Attr.getClassAttrs(mixin).constructor.prototype);
        }
        prototype.constructor = fireClass;
      }
      __es6__ || (prototype.__initProps__ = compileProps);
      js.setClassName(className, fireClass);
      return fireClass;
    }
    function define(className, baseClass, mixins, options) {
      var Component = cc.Component;
      var frame = cc._RF.peek();
      if (frame && js.isChildClassOf(baseClass, Component)) {
        if (js.isChildClassOf(frame.cls, Component)) {
          cc.errorID(3615);
          return null;
        }
        false;
        className = className || frame.script;
      }
      var cls = doDefine(className, baseClass, mixins, options);
      if (frame) if (js.isChildClassOf(baseClass, Component)) {
        var uuid = frame.uuid;
        if (uuid) {
          js._setClassId(uuid, cls);
          false;
        }
        frame.cls = cls;
      } else js.isChildClassOf(frame.cls, Component) || (frame.cls = cls);
      return cls;
    }
    function normalizeClassName_DEV(className) {
      var DefaultName = "CCClass";
      if (className) {
        className = className.replace(/^[^$A-Za-z_]/, "_").replace(/[^0-9A-Za-z_$]/g, "_");
        try {
          Function("function " + className + "(){}")();
          return className;
        } catch (e) {}
      }
      return DefaultName;
    }
    function getNewValueTypeCode(value) {
      var clsName = js.getClassName(value);
      var type = value.constructor;
      var res = "new " + clsName + "(";
      for (var i = 0; i < type.__props__.length; i++) {
        var prop = type.__props__[i];
        var propVal = value[prop];
        if ("object" === typeof propVal) {
          cc.errorID(3641, clsName);
          return "new " + clsName + "()";
        }
        res += propVal;
        i < type.__props__.length - 1 && (res += ",");
      }
      return res + ")";
    }
    function getNewValueType(value) {
      var clsName = js.getClassName(value);
      var type = value.constructor;
      var res = new type();
      for (var i = 0; i < type.__props__.length; i++) {
        var prop = type.__props__[i];
        var propVal = value[prop];
        if ("object" === typeof propVal) {
          cc.errorID(3641, clsName);
          return res;
        }
        res[prop] = propVal;
      }
      return res;
    }
    function escapeForJS(s) {
      return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function getInitPropsJit(attrs, propList) {
      var F = [];
      var func = "";
      for (var i = 0; i < propList.length; i++) {
        var prop = propList[i];
        var attrKey = prop + DELIMETER + "default";
        if (attrKey in attrs) {
          var statement;
          statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
          var expression;
          var def = attrs[attrKey];
          if ("object" === typeof def && def) expression = def instanceof cc.ValueType ? getNewValueTypeCode(def) : Array.isArray(def) ? "[]" : "{}"; else if ("function" === typeof def) {
            var index = F.length;
            F.push(def);
            expression = "F[" + index + "]()";
            false;
          } else expression = "string" === typeof def ? escapeForJS(def) : def;
          statement = statement + expression + ";\n";
          func += statement;
        }
      }
      var initProps;
      initProps = 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
      return initProps;
    }
    function getInitProps(attrs, propList) {
      function func() {
        var F = [];
        for (var i = 0; i < propList.length; i++) {
          var prop = propList[i];
          var attrKey = prop + DELIMETER + "default";
          if (attrKey in attrs) {
            var expression;
            var def = attrs[attrKey];
            if ("object" === typeof def && def) expression = def instanceof cc.ValueType ? getNewValueType(def) : Array.isArray(def) ? [] : {}; else if ("function" === typeof def) {
              var index = F.length;
              F.push(def);
              expression = F[index]();
              false;
            } else expression = def;
            this[prop] = expression;
          }
        }
      }
      return func;
    }
    var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
    function compileProps(actualClass) {
      var attrs = Attr.getClassAttrs(actualClass);
      var propList = actualClass.__props__;
      if (null === propList) {
        deferredInitializer.init();
        propList = actualClass.__props__;
      }
      var initProps = getInitPropsJit(attrs, propList);
      actualClass.prototype.__initProps__ = initProps;
      initProps.call(this);
    }
    var _createCtor = function(ctors, baseClass, className, options) {
      var superCallBounded = baseClass && boundSuperCalls(baseClass, options, className);
      var ctorName = "CCClass";
      var body = "return function " + ctorName + "(){\n";
      superCallBounded && (body += "this._super=null;\n");
      body += "this.__initProps__(" + ctorName + ");\n";
      var ctorLen = ctors.length;
      if (ctorLen > 0) {
        var useTryCatch = !(className && className.startsWith("cc."));
        useTryCatch && (body += "try{\n");
        var SNIPPET = "].apply(this,arguments);\n";
        if (1 === ctorLen) body += ctorName + ".__ctors__[0" + SNIPPET; else {
          body += "var cs=" + ctorName + ".__ctors__;\n";
          for (var i = 0; i < ctorLen; i++) body += "cs[" + i + SNIPPET;
        }
        useTryCatch && (body += "}catch(e){\ncc._throw(e);\n}\n");
      }
      body += "}";
      return Function(body)();
    };
    function _validateCtor_DEV(ctor, baseClass, className, options) {
      var originCtor;
      false;
      !(ctor.length > 0) || className && className.startsWith("cc.") || cc.warnID(3617, className);
      return ctor;
    }
    function _getAllCtors(baseClass, mixins, options) {
      function getCtors(cls) {
        return CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ];
      }
      var ctors = [];
      var baseOrMixins = [ baseClass ].concat(mixins);
      for (var b = 0; b < baseOrMixins.length; b++) {
        var baseOrMixin = baseOrMixins[b];
        if (baseOrMixin) {
          var baseCtors = getCtors(baseOrMixin);
          for (var c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
        }
      }
      var ctor = options.ctor;
      ctor && ctors.push(ctor);
      return ctors;
    }
    var SuperCallReg = /xyz/.test((function() {
      xyz;
    })) ? /\b\._super\b/ : /.*/;
    var SuperCallRegStrict = /xyz/.test((function() {
      xyz;
    })) ? /this\._super\s*\(/ : /(NONE){99}/;
    function boundSuperCalls(baseClass, options, className) {
      var hasSuperCall = false;
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if ("function" !== typeof func) continue;
        var pd = js.getPropertyDescriptor(baseClass.prototype, funcName);
        if (pd) {
          var superFunc = pd.value;
          if ("function" === typeof superFunc) {
            if (SuperCallReg.test(func)) {
              hasSuperCall = true;
              options[funcName] = (function(superFunc, func) {
                return function() {
                  var tmp = this._super;
                  this._super = superFunc;
                  var ret = func.apply(this, arguments);
                  this._super = tmp;
                  return ret;
                };
              })(superFunc, func);
            }
            continue;
          }
        }
        false;
      }
      return hasSuperCall;
    }
    function declareProperties(cls, className, properties, baseClass, mixins, es6) {
      cls.__props__ = [];
      baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice());
      if (mixins) for (var m = 0; m < mixins.length; ++m) {
        var mixin = mixins[m];
        mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter((function(x) {
          return cls.__props__.indexOf(x) < 0;
        }))));
      }
      if (properties) {
        preprocess.preprocessAttrs(properties, className, cls, es6);
        for (var propName in properties) {
          var val = properties[propName];
          "default" in val ? defineProp(cls, className, propName, val, es6) : defineGetSet(cls, className, propName, val, es6);
        }
      }
    }
    function CCClass(options) {
      options = options || {};
      var name = options.name;
      var base = options.extends;
      var mixins = options.mixins;
      var cls = define(name, base, mixins, options);
      name || (name = cc.js.getClassName(cls));
      cls._sealed = true;
      base && (base._sealed = false);
      var properties = options.properties;
      if ("function" === typeof properties || base && null === base.__props__ || mixins && mixins.some((function(x) {
        return null === x.__props__;
      }))) {
        false;
        deferredInitializer.push({
          cls: cls,
          props: properties,
          mixins: mixins
        });
        cls.__props__ = null;
      } else declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
      var statics = options.statics;
      if (statics) {
        var staticPropName;
        false;
        for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
      }
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if (!preprocess.validateMethodWithProps(func, funcName, name, cls, base)) continue;
        js.value(cls.prototype, funcName, func, true, true);
      }
      var editor = options.editor;
      editor && !!js.isChildClassOf(base, cc.Component) && cc.Component._registerEditorProps(cls, editor);
      return cls;
    }
    CCClass._isCCClass = function(constructor) {
      return constructor && constructor.hasOwnProperty("__ctors__");
    };
    CCClass._fastDefine = function(className, constructor, serializableFields) {
      js.setClassName(className, constructor);
      var props = constructor.__props__ = Object.keys(serializableFields);
      var attrProtos = Attr.getClassAttrsProto(constructor);
      for (var i = 0; i < props.length; i++) {
        var key = props[i];
        attrProtos[key + DELIMETER + "visible"] = false;
        attrProtos[key + DELIMETER + "default"] = serializableFields[key];
      }
    };
    CCClass.Attr = Attr;
    CCClass.attr = Attr.attr;
    CCClass.getInheritanceChain = function(klass) {
      var chain = [];
      for (;;) {
        klass = js.getSuper(klass);
        if (!klass) break;
        klass !== Object && chain.push(klass);
      }
      return chain;
    };
    CCClass.isInstanceOf = function(obj__skip_jsb_warning, klass) {
      return obj__skip_jsb_warning instanceof klass;
    };
    var PrimitiveTypes = {
      Integer: "Number",
      Float: "Number",
      Boolean: "Boolean",
      String: "String"
    };
    var tmpAttrs = [];
    function parseAttributes(cls, attrs, className, propName, usedInGetter) {
      var ERR_Type = "";
      var attrsProto = null;
      var attrsProtoKey = "";
      function getAttrsProto() {
        attrsProtoKey = propName + DELIMETER;
        return attrsProto = Attr.getClassAttrsProto(cls);
      }
      tmpAttrs.length = 0;
      var result = tmpAttrs;
      var type = attrs.type;
      if (type) {
        var primitiveType = PrimitiveTypes[type];
        if (primitiveType) result.push({
          type: type,
          _onAfterProp: getTypeChecker(primitiveType, "cc." + type)
        }); else if ("Object" === type) false; else if (type === Attr.ScriptUuid) {
          var attr = Attr.ObjectType(cc.ScriptAsset);
          attr.type = "Script";
          result.push(attr);
        } else "object" === typeof type ? !!Enum.isEnum(type) && result.push({
          type: "Enum",
          enumList: Enum.getList(type)
        }) : "function" === typeof type && (attrs.url ? result.push({
          type: "Object",
          ctor: type,
          _onAfterProp: getTypeChecker("String", "cc.String")
        }) : result.push(attrs._short ? {
          type: "Object",
          ctor: type
        } : Attr.ObjectType(type)));
      }
      function parseSimpleAttr(attrName, expectType) {
        if (attrName in attrs) {
          var val = attrs[attrName];
          typeof val === expectType && ((attrsProto || getAttrsProto())[attrsProtoKey + attrName] = val);
        }
      }
      if (attrs.editorOnly) {
        false;
        (attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = true;
      }
      false;
      attrs.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = true);
      if (false === attrs.serializable) {
        false;
        (attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = false;
      }
      parseSimpleAttr("formerlySerializedAs", "string");
      false;
      var visible;
      var startsWithUS;
      false;
      var range = attrs.range;
      if (range) if (Array.isArray(range)) if (range.length >= 2) {
        (attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0];
        attrsProto[attrsProtoKey + "max"] = range[1];
        range.length > 2 && (attrsProto[attrsProtoKey + "step"] = range[2]);
      } else false; else false;
      parseSimpleAttr("min", "number");
      parseSimpleAttr("max", "number");
      parseSimpleAttr("step", "number");
      return result;
    }
    cc.Class = CCClass;
    module.exports = {
      isArray: function(defaultVal) {
        defaultVal = getDefault(defaultVal);
        return Array.isArray(defaultVal);
      },
      fastDefine: CCClass._fastDefine,
      getNewValueTypeCode: getNewValueTypeCode,
      IDENTIFIER_RE: IDENTIFIER_RE,
      escapeForJS: escapeForJS,
      getDefault: getDefault
    };
    false;
  }), {
    "./CCEnum": 157,
    "./attribute": 167,
    "./js": 175,
    "./preprocess-class": 176,
    "./requiring-frame": 177,
    "./utils": 179
  } ],
  156: [ (function(require, module, exports) {
    require("./CCClass");
    var Preprocess = require("./preprocess-class");
    var js = require("./js");
    var isPlainEmptyObj_DEV = false;
    var CACHE_KEY = "__ccclassCache__";
    function fNOP(ctor) {
      return ctor;
    }
    function getSubDict(obj, key) {
      return obj[key] || (obj[key] = {});
    }
    function checkCtorArgument(decorate) {
      return function(target) {
        if ("function" === typeof target) return decorate(target);
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
      return function(target) {
        false;
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    var checkCompArgument = _checkNormalArgument.bind(null, false);
    function _argumentChecker(type) {
      return _checkNormalArgument.bind(null, false);
    }
    var checkStringArgument = _argumentChecker("string");
    var checkNumberArgument = _argumentChecker("number");
    function getClassCache(ctor, decoratorName) {
      false;
      return getSubDict(ctor, CACHE_KEY);
    }
    function getDefaultFromInitializer(initializer) {
      var value;
      try {
        value = initializer();
      } catch (e) {
        return initializer;
      }
      return "object" !== typeof value || null === value ? value : initializer;
    }
    function extractActualDefaultValues(ctor) {
      var dummyObj;
      try {
        dummyObj = new ctor();
      } catch (e) {
        false;
        return {};
      }
      return dummyObj;
    }
    function genProperty(ctor, properties, propName, options, desc, cache) {
      var fullOptions;
      if (options) {
        fullOptions = Preprocess.getFullFormOfProperty(options);
        fullOptions = fullOptions || options;
      }
      var existsProperty = properties[propName];
      var prop = js.mixin(existsProperty || {}, fullOptions || {});
      var isGetset = desc && (desc.get || desc.set);
      if (isGetset) {
        var errorProps;
        false;
        desc.get && (prop.get = desc.get);
        desc.set && (prop.set = desc.set);
      } else {
        false;
        var defaultValue = void 0;
        var isDefaultValueSpecified = false;
        if (desc) {
          if (desc.initializer) {
            defaultValue = getDefaultFromInitializer(desc.initializer);
            isDefaultValueSpecified = true;
          }
        } else {
          var actualDefaultValues = cache.default || (cache.default = extractActualDefaultValues(ctor));
          if (actualDefaultValues.hasOwnProperty(propName)) {
            defaultValue = actualDefaultValues[propName];
            isDefaultValueSpecified = true;
          }
        }
        false;
        prop.default = defaultValue;
      }
      properties[propName] = prop;
    }
    var ccclass = checkCtorArgument((function(ctor, name) {
      var base = js.getSuper(ctor);
      base === Object && (base = null);
      var proto = {
        name: name,
        extends: base,
        ctor: ctor,
        __ES6__: true
      };
      var cache = ctor[CACHE_KEY];
      if (cache) {
        var decoratedProto = cache.proto;
        decoratedProto && js.mixin(proto, decoratedProto);
        ctor[CACHE_KEY] = void 0;
      }
      var res = cc.Class(proto);
      var propNames;
      var i;
      var prop;
      var desc;
      var func;
      false;
      return res;
    }));
    function property(ctorProtoOrOptions, propName, desc) {
      var options = null;
      function normalized(ctorProto, propName, desc) {
        var cache = getClassCache(ctorProto.constructor);
        if (cache) {
          var ccclassProto = getSubDict(cache, "proto");
          var properties = getSubDict(ccclassProto, "properties");
          genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
        }
      }
      if ("undefined" === typeof propName) {
        options = ctorProtoOrOptions;
        return normalized;
      }
      normalized(ctorProtoOrOptions, propName, desc);
    }
    function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
      return argCheckFunc((function(ctor, decoratedValue) {
        var cache = getClassCache(ctor, editorPropName);
        if (cache) {
          var value = void 0 !== staticValue ? staticValue : decoratedValue;
          var proto = getSubDict(cache, "proto");
          getSubDict(proto, "editor")[editorPropName] = value;
        }
      }), editorPropName);
    }
    function createDummyDecorator(argCheckFunc) {
      return argCheckFunc(fNOP);
    }
    var executeInEditMode = createDummyDecorator(checkCtorArgument, "executeInEditMode", true);
    var requireComponent = createEditorDecorator(checkCompArgument, "requireComponent");
    var menu = createDummyDecorator(checkStringArgument, "menu");
    var executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder");
    var disallowMultiple = createDummyDecorator(checkCtorArgument, "disallowMultiple");
    var playOnFocus = createDummyDecorator(checkCtorArgument, "playOnFocus");
    var inspector = createDummyDecorator(checkStringArgument, "inspector");
    var icon = createDummyDecorator(checkStringArgument, "icon");
    var help = createDummyDecorator(checkStringArgument, "help");
    function mixins() {
      var mixins = [];
      for (var i = 0; i < arguments.length; i++) mixins[i] = arguments[i];
      return function(ctor) {
        var cache = getClassCache(ctor, "mixins");
        cache && (getSubDict(cache, "proto").mixins = mixins);
      };
    }
    cc._decorator = module.exports = {
      ccclass: ccclass,
      property: property,
      executeInEditMode: executeInEditMode,
      requireComponent: requireComponent,
      menu: menu,
      executionOrder: executionOrder,
      disallowMultiple: disallowMultiple,
      playOnFocus: playOnFocus,
      inspector: inspector,
      icon: icon,
      help: help,
      mixins: mixins
    };
  }), {
    "./CCClass": 155,
    "./js": 175,
    "./preprocess-class": 176,
    "./utils": 179
  } ],
  157: [ (function(require, module, exports) {
    var js = require("./js");
    function Enum(obj) {
      if ("__enums__" in obj) return obj;
      js.value(obj, "__enums__", null, true);
      var lastIndex = -1;
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (-1 === val) {
          val = ++lastIndex;
          obj[key] = val;
        } else if ("number" === typeof val) lastIndex = val; else if ("string" === typeof val && Number.isInteger(parseFloat(key))) continue;
        var reverseKey = "" + val;
        if (key !== reverseKey) {
          if ((false, false) && reverseKey in obj && obj[reverseKey] !== key) {
            cc.errorID(7100, reverseKey);
            continue;
          }
          js.value(obj, reverseKey, key);
        }
      }
      return obj;
    }
    Enum.isEnum = function(enumType) {
      return enumType && enumType.hasOwnProperty("__enums__");
    };
    Enum.getList = function(enumDef) {
      if (enumDef.__enums__) return enumDef.__enums__;
      var enums = enumDef.__enums__ = [];
      for (var name in enumDef) {
        var value = enumDef[name];
        Number.isInteger(value) && enums.push({
          name: name,
          value: value
        });
      }
      enums.sort((function(a, b) {
        return a.value - b.value;
      }));
      return enums;
    };
    var _TestEnum;
    false;
    module.exports = cc.Enum = Enum;
  }), {
    "./js": 175
  } ],
  158: [ (function(require, module, exports) {
    var eventManager = require("../event-manager");
    var inputManager = require("./CCInputManager");
    var PORTRAIT = 0;
    var LANDSCAPE_LEFT = -90;
    var PORTRAIT_UPSIDE_DOWN = 180;
    var LANDSCAPE_RIGHT = 90;
    var _didAccelerateFun = void 0;
    cc.Acceleration = function(x, y, z, timestamp) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.timestamp = timestamp || 0;
    };
    inputManager.setAccelerometerEnabled = function(isEnable) {
      var _t = this;
      if (_t._accelEnabled === isEnable) return;
      _t._accelEnabled = isEnable;
      var scheduler = cc.director.getScheduler();
      scheduler.enableForTarget(_t);
      if (_t._accelEnabled) {
        _t._registerAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.scheduleUpdate(_t);
      } else {
        _t._unregisterAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.unscheduleUpdate(_t);
      }
    };
    inputManager.setAccelerometerInterval = function(interval) {
      this._accelInterval !== interval && (this._accelInterval = interval);
    };
    inputManager._registerKeyboardEvent = function() {
      cc.game.canvas.addEventListener("keydown", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, true));
        e.stopPropagation();
        e.preventDefault();
      }), false);
      cc.game.canvas.addEventListener("keyup", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, false));
        e.stopPropagation();
        e.preventDefault();
      }), false);
    };
    inputManager._registerAccelerometerEvent = function() {
      var w = window, _t = this;
      _t._acceleration = new cc.Acceleration();
      _t._accelDeviceEvent = w.DeviceMotionEvent || w.DeviceOrientationEvent;
      cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (_t._accelDeviceEvent = window.DeviceOrientationEvent);
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      var ua = navigator.userAgent;
      (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (_t._minus = -1);
      _didAccelerateFun = _t.didAccelerate.bind(_t);
      w.addEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager._unregisterAccelerometerEvent = function() {
      var w = window, _t = this;
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      _didAccelerateFun && w.removeEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager.didAccelerate = function(eventData) {
      var _t = this, w = window;
      if (!_t._accelEnabled) return;
      var mAcceleration = _t._acceleration;
      var x = void 0, y = void 0, z = void 0;
      if (_t._accelDeviceEvent === window.DeviceMotionEvent) {
        var eventAcceleration = eventData["accelerationIncludingGravity"];
        x = _t._accelMinus * eventAcceleration.x * .1;
        y = _t._accelMinus * eventAcceleration.y * .1;
        z = .1 * eventAcceleration.z;
      } else {
        x = eventData["gamma"] / 90 * .981;
        y = -eventData["beta"] / 90 * .981;
        z = eventData["alpha"] / 90 * .981;
      }
      if (cc.view._isRotated) {
        var tmp = x;
        x = -y;
        y = tmp;
      }
      mAcceleration.x = x;
      mAcceleration.y = y;
      mAcceleration.z = z;
      mAcceleration.timestamp = eventData.timeStamp || Date.now();
      var tmpX = mAcceleration.x;
      if (w.orientation === LANDSCAPE_RIGHT) {
        mAcceleration.x = -mAcceleration.y;
        mAcceleration.y = tmpX;
      } else if (w.orientation === LANDSCAPE_LEFT) {
        mAcceleration.x = mAcceleration.y;
        mAcceleration.y = -tmpX;
      } else if (w.orientation === PORTRAIT_UPSIDE_DOWN) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
      if (cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
    };
  }), {
    "../event-manager": 98,
    "./CCInputManager": 159
  } ],
  159: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var macro = require("./CCMacro");
    var sys = require("./CCSys");
    var eventManager = require("../event-manager");
    var TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT;
    var inputManager = {
      _mousePressed: false,
      _isRegisterEvent: false,
      _preTouchPoint: cc.v2(0, 0),
      _prevMousePoint: cc.v2(0, 0),
      _preTouchPool: [],
      _preTouchPoolPointer: 0,
      _touches: [],
      _touchesIntegerDict: {},
      _indexBitsUsed: 0,
      _maxTouches: 8,
      _accelEnabled: false,
      _accelInterval: .2,
      _accelMinus: 1,
      _accelCurTime: 0,
      _acceleration: null,
      _accelDeviceEvent: null,
      _getUnUsedIndex: function() {
        var temp = this._indexBitsUsed;
        var now = cc.sys.now();
        for (var i = 0; i < this._maxTouches; i++) {
          if (!(1 & temp)) {
            this._indexBitsUsed |= 1 << i;
            return i;
          }
          var touch = this._touches[i];
          if (now - touch._lastModified > TOUCH_TIMEOUT) {
            this._removeUsedIndexBit(i);
            delete this._touchesIntegerDict[touch.getID()];
            return i;
          }
          temp >>= 1;
        }
        return -1;
      },
      _removeUsedIndexBit: function(index) {
        if (index < 0 || index >= this._maxTouches) return;
        var temp = 1 << index;
        temp = ~temp;
        this._indexBitsUsed &= temp;
      },
      _glView: null,
      handleTouchesBegin: function(touches) {
        var selTouch = void 0, index = void 0, curTouch = void 0, touchID = void 0, handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = sys.now();
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchIntDict[touchID];
          if (null == index) {
            var unusedIndex = this._getUnUsedIndex();
            if (-1 === unusedIndex) {
              cc.logID(2300, unusedIndex);
              continue;
            }
            curTouch = this._touches[unusedIndex] = new cc.Touch(selTouch._point.x, selTouch._point.y, selTouch.getID());
            curTouch._lastModified = now;
            curTouch._setPrevPoint(selTouch._prevPoint);
            locTouchIntDict[touchID] = unusedIndex;
            handleTouches.push(curTouch);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.BEGAN;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesMove: function(touches) {
        var selTouch = void 0, index = void 0, touchID = void 0, handleTouches = [], locTouches = this._touches, now = sys.now();
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = this._touchesIntegerDict[touchID];
          if (null == index) continue;
          if (locTouches[index]) {
            locTouches[index]._setPoint(selTouch._point);
            locTouches[index]._setPrevPoint(selTouch._prevPoint);
            locTouches[index]._lastModified = now;
            handleTouches.push(locTouches[index]);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.MOVED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesEnd: function(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.ENDED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesCancel: function(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.CANCELLED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      getSetOfTouchesEndOrCancel: function(touches) {
        var selTouch = void 0, index = void 0, touchID = void 0, handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict;
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchesIntDict[touchID];
          if (null == index) continue;
          if (locTouches[index]) {
            locTouches[index]._setPoint(selTouch._point);
            locTouches[index]._setPrevPoint(selTouch._prevPoint);
            handleTouches.push(locTouches[index]);
            this._removeUsedIndexBit(index);
            delete locTouchesIntDict[touchID];
          }
        }
        return handleTouches;
      },
      getHTMLElementPosition: function(element) {
        if (sys.platform === sys.WECHAT_GAME) return {
          left: 0,
          top: 0,
          width: window.innerWidth,
          height: window.innerHeight
        };
        var docElem = document.documentElement;
        var leftOffset = window.pageXOffset - docElem.clientLeft;
        var topOffset = window.pageYOffset - docElem.clientTop;
        if (element.getBoundingClientRect) {
          var box = element.getBoundingClientRect();
          return {
            left: box.left + leftOffset,
            top: box.top + topOffset,
            width: box.width,
            height: box.height
          };
        }
        return element instanceof HTMLCanvasElement ? {
          left: leftOffset,
          top: topOffset,
          width: element.width,
          height: element.height
        } : {
          left: leftOffset,
          top: topOffset,
          width: parseInt(element.style.width),
          height: parseInt(element.style.height)
        };
      },
      getPreTouch: function(touch) {
        var preTouch = null;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          preTouch = locPreTouchPool[i];
          break;
        }
        preTouch || (preTouch = touch);
        return preTouch;
      },
      setPreTouch: function(touch) {
        var find = false;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          locPreTouchPool[i] = touch;
          find = true;
          break;
        }
        if (!find) if (locPreTouchPool.length <= 50) locPreTouchPool.push(touch); else {
          locPreTouchPool[this._preTouchPoolPointer] = touch;
          this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
        }
      },
      getTouchByXY: function(tx, ty, pos) {
        var locPreTouch = this._preTouchPoint;
        var location = this._glView.convertToLocationInView(tx, ty, pos);
        var touch = new cc.Touch(location.x, location.y, 0);
        touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
        locPreTouch.x = location.x;
        locPreTouch.y = location.y;
        return touch;
      },
      getMouseEvent: function(location, pos, eventType) {
        var locPreMouse = this._prevMousePoint;
        var mouseEvent = new cc.Event.EventMouse(eventType);
        mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
        locPreMouse.x = location.x;
        locPreMouse.y = location.y;
        this._glView._convertMouseToLocationInView(locPreMouse, pos);
        mouseEvent.setLocation(locPreMouse.x, locPreMouse.y);
        return mouseEvent;
      },
      getPointByEvent: function(event, pos) {
        if (null != event.pageX) return {
          x: event.pageX,
          y: event.pageY
        };
        if (sys.platform === sys.WECHAT_GAME) {
          pos.left = 0;
          pos.top = 0;
        } else {
          pos.left -= document.body.scrollLeft;
          pos.top -= document.body.scrollTop;
        }
        return {
          x: event.clientX,
          y: event.clientY
        };
      },
      getTouchesByEvent: function(event, pos) {
        var touchArr = [], locView = this._glView;
        var touch_event = void 0, touch = void 0, preLocation = void 0;
        var locPreTouch = this._preTouchPoint;
        var length = event.changedTouches.length;
        for (var i = 0; i < length; i++) {
          touch_event = event.changedTouches[i];
          if (touch_event) {
            var location = void 0;
            location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos) : locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos);
            if (null != touch_event.identifier) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = this.getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              this.setPreTouch(touch);
            } else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
            }
            locPreTouch.x = location.x;
            locPreTouch.y = location.y;
            touchArr.push(touch);
          }
        }
        return touchArr;
      },
      registerSystemEvent: function(element) {
        if (this._isRegisterEvent) return;
        this._glView = cc.view;
        var selfPointer = this;
        var prohibition = sys.isMobile;
        var supportMouse = "mouse" in sys.capabilities;
        var supportTouches = "touches" in sys.capabilities;
        if (sys.platform === sys.WECHAT_GAME) {
          prohibition = false;
          supportTouches = true;
          supportMouse = false;
        }
        if (supportMouse) {
          if (!prohibition) {
            window.addEventListener("mousedown", (function() {
              selfPointer._mousePressed = true;
            }), false);
            window.addEventListener("mouseup", (function(event) {
              if (!selfPointer._mousePressed) return;
              selfPointer._mousePressed = false;
              var pos = selfPointer.getHTMLElementPosition(element);
              var location = selfPointer.getPointByEvent(event, pos);
              if (!cc.rect(pos.left, pos.top, pos.width, pos.height).contains(location)) {
                selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.UP);
                mouseEvent.setButton(event.button);
                eventManager.dispatchEvent(mouseEvent);
              }
            }), false);
          }
          var EventMouse = cc.Event.EventMouse;
          var _mouseEventsOnElement = [ !prohibition && [ "mousedown", EventMouse.DOWN, function(event, mouseEvent, location, pos) {
            selfPointer._mousePressed = true;
            selfPointer.handleTouchesBegin([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
            element.focus();
          } ], !prohibition && [ "mouseup", EventMouse.UP, function(event, mouseEvent, location, pos) {
            selfPointer._mousePressed = false;
            selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
          } ], !prohibition && [ "mousemove", EventMouse.MOVE, function(event, mouseEvent, location, pos) {
            selfPointer.handleTouchesMove([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
            selfPointer._mousePressed || mouseEvent.setButton(null);
          } ], [ "mousewheel", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, event.wheelDelta);
          } ], [ "DOMMouseScroll", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, -120 * event.detail);
          } ] ];
          for (var i = 0; i < _mouseEventsOnElement.length; ++i) {
            var entry = _mouseEventsOnElement[i];
            entry && (function() {
              var name = entry[0];
              var type = entry[1];
              var handler = entry[2];
              element.addEventListener(name, (function(event) {
                var pos = selfPointer.getHTMLElementPosition(element);
                var location = selfPointer.getPointByEvent(event, pos);
                var mouseEvent = selfPointer.getMouseEvent(location, pos, type);
                mouseEvent.setButton(event.button);
                handler(event, mouseEvent, location, pos);
                eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
              }), false);
            })();
          }
        }
        if (window.navigator.msPointerEnabled) {
          var _pointerEventsMap = {
            MSPointerDown: selfPointer.handleTouchesBegin,
            MSPointerMove: selfPointer.handleTouchesMove,
            MSPointerUp: selfPointer.handleTouchesEnd,
            MSPointerCancel: selfPointer.handleTouchesCancel
          };
          var _loop = function(eventName) {
            var touchEvent = _pointerEventsMap[eventName];
            element.addEventListener(eventName, (function(event) {
              var pos = selfPointer.getHTMLElementPosition(element);
              pos.left -= document.documentElement.scrollLeft;
              pos.top -= document.documentElement.scrollTop;
              touchEvent.call(selfPointer, [ selfPointer.getTouchByXY(event.clientX, event.clientY, pos) ]);
              event.stopPropagation();
            }), false);
          };
          for (var eventName in _pointerEventsMap) _loop(eventName);
        }
        supportTouches && (function() {
          var _touchEventsMap = {
            touchstart: function(touchesToHandle) {
              selfPointer.handleTouchesBegin(touchesToHandle);
              sys.platform !== sys.WECHAT_GAME && element.focus();
            },
            touchmove: function(touchesToHandle) {
              selfPointer.handleTouchesMove(touchesToHandle);
            },
            touchend: function(touchesToHandle) {
              selfPointer.handleTouchesEnd(touchesToHandle);
            },
            touchcancel: function(touchesToHandle) {
              selfPointer.handleTouchesCancel(touchesToHandle);
            }
          };
          var registerTouchEvent = void 0;
          if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) {
            _touchEventsMap = {
              onTouchStart: _touchEventsMap.touchstart,
              onTouchMove: _touchEventsMap.touchmove,
              onTouchEnd: _touchEventsMap.touchend,
              onTouchCancel: _touchEventsMap.touchcancel
            };
            registerTouchEvent = function(eventName) {
              var handler = _touchEventsMap[eventName];
              wx[eventName]((function(event) {
                if (!event.changedTouches) return;
                var pos = selfPointer.getHTMLElementPosition(element);
                var body = document.body;
                pos.left -= body.scrollLeft || 0;
                pos.top -= body.scrollTop || 0;
                handler(selfPointer.getTouchesByEvent(event, pos));
              }));
            };
          } else registerTouchEvent = function(eventName) {
            var handler = _touchEventsMap[eventName];
            element.addEventListener(eventName, (function(event) {
              if (!event.changedTouches) return;
              var pos = selfPointer.getHTMLElementPosition(element);
              var body = document.body;
              pos.left -= body.scrollLeft || 0;
              pos.top -= body.scrollTop || 0;
              handler(selfPointer.getTouchesByEvent(event, pos));
              event.stopPropagation();
              event.preventDefault();
            }), false);
          };
          for (var eventName in _touchEventsMap) registerTouchEvent(eventName);
        })();
        cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB && this._registerKeyboardEvent();
        this._isRegisterEvent = true;
      },
      _registerKeyboardEvent: function() {},
      _registerAccelerometerEvent: function() {},
      update: function(dt) {
        if (this._accelCurTime > this._accelInterval) {
          this._accelCurTime -= this._accelInterval;
          eventManager.dispatchEvent(new cc.Event.EventAcceleration(this._acceleration));
        }
        this._accelCurTime += dt;
      }
    };
    _cc.inputManager = inputManager;
    module.exports = inputManager;
  }), {
    "../event-manager": 98,
    "../platform/js": 175,
    "./CCMacro": 160,
    "./CCSys": 164
  } ],
  160: [ (function(require, module, exports) {
    var js = require("./js");
    cc.macro = {
      RAD: Math.PI / 180,
      DEG: 180 / Math.PI,
      REPEAT_FOREVER: Number.MAX_VALUE - 1,
      FLT_EPSILON: 1.192092896e-7,
      MIN_ZINDEX: -Math.pow(2, 15),
      MAX_ZINDEX: Math.pow(2, 15) - 1,
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_ALPHA_SATURATE: 776,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775,
      ONE_MINUS_CONSTANT_ALPHA: 32772,
      ONE_MINUS_CONSTANT_COLOR: 32770,
      ORIENTATION_PORTRAIT: 1,
      ORIENTATION_LANDSCAPE: 2,
      ORIENTATION_AUTO: 3,
      DENSITYDPI_DEVICE: "device-dpi",
      DENSITYDPI_HIGH: "high-dpi",
      DENSITYDPI_MEDIUM: "medium-dpi",
      DENSITYDPI_LOW: "low-dpi",
      FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: true,
      DIRECTOR_STATS_POSITION: cc.v2(0, 0),
      ENABLE_STACKABLE_ACTIONS: true,
      TOUCH_TIMEOUT: 5e3,
      BATCH_VERTEX_COUNT: 2e4,
      ENABLE_GC_FOR_NATIVE_OBJECTS: true,
      ENABLE_TILEDMAP_CULLING: true,
      DOWNLOAD_MAX_CONCURRENT: 64,
      ENABLE_TRANSPARENT_CANVAS: false,
      ENABLE_WEBGL_ANTIALIAS: false,
      ENABLE_CULLING: false
    };
    js.getset(cc.macro, "ENABLE_3D", (function() {
      return cc._polyfill3D.enabled;
    }), (function(enabled) {
      enabled ? cc._polyfill3D.enable() : cc._polyfill3D.disable();
    }));
    cc.macro.KEY = {
      none: 0,
      back: 6,
      menu: 18,
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      select: 41,
      insert: 45,
      Delete: 46,
      0: 48,
      1: 49,
      2: 50,
      3: 51,
      4: 52,
      5: 53,
      6: 54,
      7: 55,
      8: 56,
      9: 57,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      num0: 96,
      num1: 97,
      num2: 98,
      num3: 99,
      num4: 100,
      num5: 101,
      num6: 102,
      num7: 103,
      num8: 104,
      num9: 105,
      "*": 106,
      "+": 107,
      "-": 109,
      numdel: 110,
      "/": 111,
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      semicolon: 186,
      equal: 187,
      "=": 187,
      ",": 188,
      comma: 188,
      dash: 189,
      ".": 190,
      period: 190,
      forwardslash: 191,
      grave: 192,
      "[": 219,
      openbracket: 219,
      backslash: 220,
      "]": 221,
      closebracket: 221,
      quote: 222,
      dpadLeft: 1e3,
      dpadRight: 1001,
      dpadUp: 1003,
      dpadDown: 1004,
      dpadCenter: 1005
    };
    cc.macro.ImageFormat = cc.Enum({
      JPG: 0,
      PNG: 1,
      TIFF: 2,
      WEBP: 3,
      PVR: 4,
      ETC: 5,
      S3TC: 6,
      ATITC: 7,
      TGA: 8,
      RAWDATA: 9,
      UNKNOWN: 10
    });
    cc.macro.BlendFactor = cc.Enum({
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775
    });
    cc.macro.TextAlignment = cc.Enum({
      LEFT: 0,
      CENTER: 1,
      RIGHT: 2
    });
    cc.macro.VerticalTextAlignment = cc.Enum({
      TOP: 0,
      CENTER: 1,
      BOTTOM: 2
    });
    module.exports = cc.macro;
  }), {
    "./js": 175
  } ],
  161: [ (function(require, module, exports) {
    var js = require("./js");
    var CCClass = require("./CCClass");
    var Destroyed = 1;
    var RealDestroyed = 2;
    var ToDestroy = 4;
    var DontSave = 8;
    var EditorOnly = 16;
    var Dirty = 32;
    var DontDestroy = 64;
    var Destroying = 128;
    var Deactivating = 256;
    var LockedInEditor = 512;
    var IsOnEnableCalled = 2048;
    var IsEditorOnEnableCalled = 4096;
    var IsPreloadStarted = 8192;
    var IsOnLoadCalled = 16384;
    var IsOnLoadStarted = 32768;
    var IsStartCalled = 65536;
    var IsRotationLocked = 1 << 17;
    var IsScaleLocked = 1 << 18;
    var IsAnchorLocked = 1 << 19;
    var IsSizeLocked = 1 << 20;
    var IsPositionLocked = 1 << 21;
    var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
    function CCObject() {
      this._name = "";
      this._objFlags = 0;
    }
    CCClass.fastDefine("cc.Object", CCObject, {
      _name: "",
      _objFlags: 0
    });
    js.value(CCObject, "Flags", {
      Destroyed: Destroyed,
      DontSave: DontSave,
      EditorOnly: EditorOnly,
      Dirty: Dirty,
      DontDestroy: DontDestroy,
      PersistentMask: PersistentMask,
      Destroying: Destroying,
      Deactivating: Deactivating,
      LockedInEditor: LockedInEditor,
      IsPreloadStarted: IsPreloadStarted,
      IsOnLoadStarted: IsOnLoadStarted,
      IsOnLoadCalled: IsOnLoadCalled,
      IsOnEnableCalled: IsOnEnableCalled,
      IsStartCalled: IsStartCalled,
      IsEditorOnEnableCalled: IsEditorOnEnableCalled,
      IsPositionLocked: IsPositionLocked,
      IsRotationLocked: IsRotationLocked,
      IsScaleLocked: IsScaleLocked,
      IsAnchorLocked: IsAnchorLocked,
      IsSizeLocked: IsSizeLocked
    });
    var objectsToDestroy = [];
    function deferredDestroy() {
      var deleteCount = objectsToDestroy.length;
      for (var i = 0; i < deleteCount; ++i) {
        var obj = objectsToDestroy[i];
        obj._objFlags & Destroyed || obj._destroyImmediate();
      }
      deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
      false;
    }
    js.value(CCObject, "_deferredDestroy", deferredDestroy);
    false;
    var prototype = CCObject.prototype;
    js.getset(prototype, "name", (function() {
      return this._name;
    }), (function(value) {
      this._name = value;
    }), true);
    js.get(prototype, "isValid", (function() {
      return !(this._objFlags & Destroyed);
    }), true);
    false, false;
    var deferredDestroyTimer = null;
    prototype.destroy = function() {
      if (this._objFlags & Destroyed) {
        cc.warnID(5e3);
        return false;
      }
      if (this._objFlags & ToDestroy) return false;
      this._objFlags |= ToDestroy;
      objectsToDestroy.push(this);
      false;
      return true;
    };
    false, false;
    function compileDestruct(obj, ctor) {
      var key, propsToReset = {};
      for (key in obj) if (obj.hasOwnProperty(key)) switch (typeof obj[key]) {
       case "string":
        propsToReset[key] = "";
        break;

       case "object":
       case "function":
        propsToReset[key] = null;
      }
      if (cc.Class._isCCClass(ctor)) {
        var attrs = cc.Class.Attr.getClassAttrs(ctor);
        var propList = ctor.__props__;
        for (var i = 0; i < propList.length; i++) {
          key = propList[i];
          var attrKey = key + cc.Class.Attr.DELIMETER + "default";
          if (attrKey in attrs) switch (typeof attrs[attrKey]) {
           case "string":
            propsToReset[key] = "";
            break;

           case "object":
           case "function":
            propsToReset[key] = null;
            break;

           case "undefined":
            propsToReset[key] = void 0;
          }
        }
      }
      var skipId = obj instanceof cc._BaseNode || obj instanceof cc.Component;
      true;
      var func = "";
      for (key in propsToReset) {
        if (skipId && "_id" === key) continue;
        var statement;
        statement = CCClass.IDENTIFIER_RE.test(key) ? "o." + key + "=" : "o[" + CCClass.escapeForJS(key) + "]=";
        var val = propsToReset[key];
        "" === val && (val = '""');
        func += statement + val + ";\n";
      }
      return Function("o", func);
    }
    prototype._destruct = function() {
      var ctor = this.constructor;
      var destruct = ctor.__destruct__;
      if (!destruct) {
        destruct = compileDestruct(this, ctor);
        js.value(ctor, "__destruct__", destruct, true);
      }
      destruct(this);
    };
    prototype._onPreDestroy = null;
    prototype._destroyImmediate = function() {
      if (this._objFlags & Destroyed) {
        cc.errorID(5e3);
        return;
      }
      this._onPreDestroy && this._onPreDestroy();
      true;
      this._destruct();
      this._objFlags |= Destroyed;
    };
    false;
    prototype._deserialize = null;
    cc.isValid = function(value, strictMode) {
      return "object" === typeof value ? !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed)) : "undefined" !== typeof value;
    };
    false, false;
    cc.Object = module.exports = CCObject;
  }), {
    "./CCClass": 155,
    "./js": 175
  } ],
  162: [ (function(require, module, exports) {
    var js = require("../platform/js");
    cc.SAXParser = function() {
      if (window.DOMParser) {
        this._isSupportDOMParser = true;
        this._parser = new DOMParser();
      } else {
        this._isSupportDOMParser = false;
        this._parser = null;
      }
    };
    cc.SAXParser.prototype = {
      constructor: cc.SAXParser,
      parse: function(xmlTxt) {
        return this._parseXML(xmlTxt);
      },
      _parseXML: function(textxml) {
        var xmlDoc;
        if (this._isSupportDOMParser) xmlDoc = this._parser.parseFromString(textxml, "text/xml"); else {
          xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
          xmlDoc.async = "false";
          xmlDoc.loadXML(textxml);
        }
        return xmlDoc;
      }
    };
    cc.PlistParser = function() {
      cc.SAXParser.call(this);
    };
    js.extend(cc.PlistParser, cc.SAXParser);
    js.mixin(cc.PlistParser.prototype, {
      parse: function(xmlTxt) {
        var xmlDoc = this._parseXML(xmlTxt);
        var plist = xmlDoc.documentElement;
        if ("plist" !== plist.tagName) {
          cc.warnID(5100);
          return {};
        }
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
          node = plist.childNodes[i];
          if (1 === node.nodeType) break;
        }
        xmlDoc = null;
        return this._parseNode(node);
      },
      _parseNode: function(node) {
        var data = null, tagName = node.tagName;
        if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
          data = "";
          for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
        } else "false" === tagName ? data = false : "true" === tagName ? data = true : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
        return data;
      },
      _parseArray: function(node) {
        var data = [];
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
          var child = node.childNodes[i];
          if (1 !== child.nodeType) continue;
          data.push(this._parseNode(child));
        }
        return data;
      },
      _parseDict: function(node) {
        var data = {};
        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
          var child = node.childNodes[i];
          if (1 !== child.nodeType) continue;
          "key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child);
        }
        return data;
      }
    });
    cc.saxParser = new cc.SAXParser();
    cc.plistParser = new cc.PlistParser();
  }), {
    "../platform/js": 175
  } ],
  163: [ (function(require, module, exports) {
    cc.screen = {
      _supportsFullScreen: false,
      _preOnFullScreenChange: null,
      _touchEvent: "",
      _fn: null,
      _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
      init: function() {
        this._fn = {};
        var i, l, val, map = this._fnMap, valL;
        for (i = 0, l = map.length; i < l; i++) {
          val = map[i];
          if (val && val[1] in document) {
            for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
            break;
          }
        }
        this._supportsFullScreen = void 0 !== this._fn.requestFullscreen;
        this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
      },
      fullScreen: function() {
        return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
      },
      requestFullScreen: function(element, onFullScreenChange) {
        if (!this._supportsFullScreen) return;
        element = element || document.documentElement;
        if (onFullScreenChange) {
          var eventName = this._fn.fullscreenchange;
          this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange);
          this._preOnFullScreenChange = onFullScreenChange;
          document.addEventListener(eventName, onFullScreenChange, false);
        }
        return element[this._fn.requestFullscreen]();
      },
      exitFullScreen: function() {
        return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
      },
      autoFullScreen: function(element, onFullScreenChange) {
        element = element || document.body;
        var touchTarget = cc.game.canvas || element;
        var theScreen = this;
        function callback() {
          touchTarget.removeEventListener(theScreen._touchEvent, callback);
          theScreen.requestFullScreen(element, onFullScreenChange);
        }
        this.requestFullScreen(element, onFullScreenChange);
        touchTarget.addEventListener(this._touchEvent, callback);
      }
    };
    cc.screen.init();
  }), {} ],
  164: [ (function(require, module, exports) {
    function initSys() {
      cc.sys = {};
      var sys = cc.sys;
      sys.LANGUAGE_ENGLISH = "en";
      sys.LANGUAGE_CHINESE = "zh";
      sys.LANGUAGE_FRENCH = "fr";
      sys.LANGUAGE_ITALIAN = "it";
      sys.LANGUAGE_GERMAN = "de";
      sys.LANGUAGE_SPANISH = "es";
      sys.LANGUAGE_DUTCH = "du";
      sys.LANGUAGE_RUSSIAN = "ru";
      sys.LANGUAGE_KOREAN = "ko";
      sys.LANGUAGE_JAPANESE = "ja";
      sys.LANGUAGE_HUNGARIAN = "hu";
      sys.LANGUAGE_PORTUGUESE = "pt";
      sys.LANGUAGE_ARABIC = "ar";
      sys.LANGUAGE_NORWEGIAN = "no";
      sys.LANGUAGE_POLISH = "pl";
      sys.LANGUAGE_TURKISH = "tr";
      sys.LANGUAGE_UKRAINIAN = "uk";
      sys.LANGUAGE_ROMANIAN = "ro";
      sys.LANGUAGE_BULGARIAN = "bg";
      sys.LANGUAGE_UNKNOWN = "unknown";
      sys.OS_IOS = "iOS";
      sys.OS_ANDROID = "Android";
      sys.OS_WINDOWS = "Windows";
      sys.OS_MARMALADE = "Marmalade";
      sys.OS_LINUX = "Linux";
      sys.OS_BADA = "Bada";
      sys.OS_BLACKBERRY = "Blackberry";
      sys.OS_OSX = "OS X";
      sys.OS_WP8 = "WP8";
      sys.OS_WINRT = "WINRT";
      sys.OS_UNKNOWN = "Unknown";
      sys.UNKNOWN = -1;
      sys.WIN32 = 0;
      sys.LINUX = 1;
      sys.MACOS = 2;
      sys.ANDROID = 3;
      sys.IPHONE = 4;
      sys.IPAD = 5;
      sys.BLACKBERRY = 6;
      sys.NACL = 7;
      sys.EMSCRIPTEN = 8;
      sys.TIZEN = 9;
      sys.WINRT = 10;
      sys.WP8 = 11;
      sys.MOBILE_BROWSER = 100;
      sys.DESKTOP_BROWSER = 101;
      sys.EDITOR_PAGE = 102;
      sys.EDITOR_CORE = 103;
      sys.WECHAT_GAME = 104;
      sys.QQ_PLAY = 105;
      sys.BROWSER_TYPE_WECHAT = "wechat";
      sys.BROWSER_TYPE_WECHAT_GAME = "wechatgame";
      sys.BROWSER_TYPE_WECHAT_GAME_SUB = "wechatgamesub";
      sys.BROWSER_TYPE_QQ_PLAY = "qqplay";
      sys.BROWSER_TYPE_ANDROID = "androidbrowser";
      sys.BROWSER_TYPE_IE = "ie";
      sys.BROWSER_TYPE_QQ = "qqbrowser";
      sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
      sys.BROWSER_TYPE_UC = "ucbrowser";
      sys.BROWSER_TYPE_360 = "360browser";
      sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
      sys.BROWSER_TYPE_BAIDU = "baidubrowser";
      sys.BROWSER_TYPE_MAXTHON = "maxthon";
      sys.BROWSER_TYPE_OPERA = "opera";
      sys.BROWSER_TYPE_OUPENG = "oupeng";
      sys.BROWSER_TYPE_MIUI = "miuibrowser";
      sys.BROWSER_TYPE_FIREFOX = "firefox";
      sys.BROWSER_TYPE_SAFARI = "safari";
      sys.BROWSER_TYPE_CHROME = "chrome";
      sys.BROWSER_TYPE_LIEBAO = "liebao";
      sys.BROWSER_TYPE_QZONE = "qzone";
      sys.BROWSER_TYPE_SOUGOU = "sogou";
      sys.BROWSER_TYPE_UNKNOWN = "unknown";
      sys.isNative = false;
      sys.isBrowser = "object" === typeof window && "object" === typeof document && true;
      false;
      var platform;
      var w;
      var h;
      var ratio;
      var capabilities;
      false;
      var env;
      var system;
      var version;
      var w;
      var h;
      var ratio;
      false;
      var env;
      var version;
      var w;
      var h;
      var ratio;
      false;
      var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement;
      var ua = nav.userAgent.toLowerCase();
      false;
      sys.isMobile = /mobile|android|iphone|ipad/.test(ua);
      sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
      var currLanguage = nav.language;
      currLanguage = currLanguage || nav.browserLanguage;
      currLanguage = currLanguage ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH;
      sys.language = currLanguage;
      var isAndroid = false, iOS = false, osVersion = "", osMainVersion = 0;
      var uaResult = /android (\d+(?:\.\d+)+)/i.exec(ua) || /android (\d+(?:\.\d+)+)/i.exec(nav.platform);
      if (uaResult) {
        isAndroid = true;
        osVersion = uaResult[1] || "";
        osMainVersion = parseInt(osVersion) || 0;
      }
      uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua);
      if (uaResult) {
        iOS = true;
        osVersion = uaResult[2] || "";
        osMainVersion = parseInt(osVersion) || 0;
      } else if (/(iPhone|iPad|iPod)/.exec(nav.platform)) {
        iOS = true;
        osVersion = "";
        osMainVersion = 0;
      }
      var osName = sys.OS_UNKNOWN;
      -1 !== nav.appVersion.indexOf("Win") ? osName = sys.OS_WINDOWS : iOS ? osName = sys.OS_IOS : -1 !== nav.appVersion.indexOf("Mac") ? osName = sys.OS_OSX : -1 !== nav.appVersion.indexOf("X11") && -1 === nav.appVersion.indexOf("Linux") ? osName = sys.OS_UNIX : isAndroid ? osName = sys.OS_ANDROID : -1 === nav.appVersion.indexOf("Linux") && -1 === ua.indexOf("ubuntu") || (osName = sys.OS_LINUX);
      sys.os = osName;
      sys.osVersion = osVersion;
      sys.osMainVersion = osMainVersion;
      sys.browserType = sys.BROWSER_TYPE_UNKNOWN;
      (function() {
        var typeReg1 = /mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i;
        var typeReg2 = /qqbrowser|chrome|safari|firefox|trident|opera|opr\/|oupeng/i;
        var browserTypes = typeReg1.exec(ua);
        browserTypes || (browserTypes = typeReg2.exec(ua));
        var browserType = browserTypes ? browserTypes[0].toLowerCase() : sys.BROWSER_TYPE_UNKNOWN;
        false;
        false;
        "micromessenger" === browserType ? browserType = sys.BROWSER_TYPE_WECHAT : "safari" === browserType && isAndroid ? browserType = sys.BROWSER_TYPE_ANDROID : "qq" === browserType && ua.match(/android.*applewebkit/i) ? browserType = sys.BROWSER_TYPE_ANDROID : "trident" === browserType ? browserType = sys.BROWSER_TYPE_IE : "360 aphone" === browserType ? browserType = sys.BROWSER_TYPE_360 : "mxbrowser" === browserType ? browserType = sys.BROWSER_TYPE_MAXTHON : "opr/" === browserType && (browserType = sys.BROWSER_TYPE_OPERA);
        sys.browserType = browserType;
      })();
      sys.browserVersion = "";
      (function() {
        var versionReg1 = /(mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|uc|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui)(mobile)?(browser)?\/?([\d.]+)/i;
        var versionReg2 = /(qqbrowser|chrome|safari|firefox|trident|opera|opr\/|oupeng)(mobile)?(browser)?\/?([\d.]+)/i;
        var tmp = ua.match(versionReg1);
        tmp || (tmp = ua.match(versionReg2));
        sys.browserVersion = tmp ? tmp[4] : "";
      })();
      var w = window.innerWidth || document.documentElement.clientWidth;
      var h = window.innerHeight || document.documentElement.clientHeight;
      var ratio = window.devicePixelRatio || 1;
      sys.windowPixelResolution = {
        width: ratio * w,
        height: ratio * h
      };
      sys._checkWebGLRenderMode = function() {
        if (cc.game.renderType !== cc.game.RENDER_TYPE_WEBGL) throw new Error("This feature supports WebGL render mode only.");
      };
      var _tmpCanvas1 = document.createElement("canvas"), _tmpCanvas2 = document.createElement("canvas");
      var create3DContext = function(canvas, opt_attribs, opt_contextType) {
        if (!opt_contextType) return create3DContext(canvas, opt_attribs, "webgl") || create3DContext(canvas, opt_attribs, "experimental-webgl") || create3DContext(canvas, opt_attribs, "webkit-3d") || create3DContext(canvas, opt_attribs, "moz-webgl") || null;
        try {
          return canvas.getContext(opt_contextType, opt_attribs);
        } catch (e) {
          return null;
        }
      };
      try {
        var localStorage = sys.localStorage = win.localStorage;
        localStorage.setItem("storage", "");
        localStorage.removeItem("storage");
        localStorage = null;
      } catch (e) {
        var warn = function() {
          cc.warnID(5200);
        };
        sys.localStorage = {
          getItem: warn,
          setItem: warn,
          removeItem: warn,
          clear: warn
        };
      }
      var _supportWebp = _tmpCanvas1.toDataURL("image/webp").startsWith("data:image/webp");
      var _supportCanvas = !!_tmpCanvas1.getContext("2d");
      var _supportWebGL = false;
      if (sys.browserType === sys.BROWSER_TYPE_WECHAT_GAME) _supportWebGL = true; else if (win.WebGLRenderingContext) {
        create3DContext(document.createElement("CANVAS")) && (_supportWebGL = true);
        if (_supportWebGL && sys.os === sys.OS_ANDROID) {
          var browserVer = parseFloat(sys.browserVersion);
          switch (sys.browserType) {
           case sys.BROWSER_TYPE_MOBILE_QQ:
           case sys.BROWSER_TYPE_BAIDU:
           case sys.BROWSER_TYPE_BAIDU_APP:
            _supportWebGL = browserVer >= 6.2;
            break;

           case sys.BROWSER_TYPE_ANDROID:
            sys.osMainVersion && sys.osMainVersion >= 5 && (_supportWebGL = true);
            break;

           case sys.BROWSER_TYPE_CHROME:
            _supportWebGL = browserVer >= 30;
            break;

           case sys.BROWSER_TYPE_UC:
            _supportWebGL = browserVer > 11;
            break;

           case sys.BROWSER_TYPE_360:
            _supportWebGL = false;
          }
        }
      }
      var capabilities = sys.capabilities = {
        canvas: _supportCanvas,
        opengl: _supportWebGL,
        webp: _supportWebp
      };
      (void 0 !== docEle["ontouchstart"] || void 0 !== doc["ontouchstart"] || nav.msPointerEnabled) && (capabilities["touches"] = true);
      void 0 !== docEle["onmouseup"] && (capabilities["mouse"] = true);
      void 0 !== docEle["onkeyup"] && (capabilities["keyboard"] = true);
      (win.DeviceMotionEvent || win.DeviceOrientationEvent) && (capabilities["accelerometer"] = true);
      var __audioSupport;
      (function() {
        var DEBUG = false;
        var version = sys.browserVersion;
        var supportWebAudio = sys.browserType !== sys.BROWSER_TYPE_WECHAT_GAME && !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
        __audioSupport = {
          ONLY_ONE: false,
          WEB_AUDIO: supportWebAudio,
          DELAY_CREATE_CTX: false
        };
        sys.os === sys.OS_IOS && (__audioSupport.USE_LOADER_EVENT = "loadedmetadata");
        if (sys.browserType === sys.BROWSER_TYPE_FIREFOX) {
          __audioSupport.DELAY_CREATE_CTX = true;
          __audioSupport.USE_LOADER_EVENT = "canplay";
        }
        sys.os === sys.OS_ANDROID && sys.browserType === sys.BROWSER_TYPE_UC && (__audioSupport.ONE_SOURCE = true);
        DEBUG && setTimeout((function() {
          cc.log("browse type: " + sys.browserType);
          cc.log("browse version: " + version);
          cc.log("MULTI_CHANNEL: " + __audioSupport.MULTI_CHANNEL);
          cc.log("WEB_AUDIO: " + __audioSupport.WEB_AUDIO);
          cc.log("AUTOPLAY: " + __audioSupport.AUTOPLAY);
        }), 0);
      })();
      try {
        if (__audioSupport.WEB_AUDIO) {
          __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
          __audioSupport.DELAY_CREATE_CTX && setTimeout((function() {
            __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
          }), 0);
        }
      } catch (error) {
        __audioSupport.WEB_AUDIO = false;
        cc.logID(5201);
      }
      var formatSupport = [];
      (function() {
        var audio = document.createElement("audio");
        if (audio.canPlayType) {
          var ogg = audio.canPlayType('audio/ogg; codecs="vorbis"');
          ogg && formatSupport.push(".ogg");
          var mp3 = audio.canPlayType("audio/mpeg");
          mp3 && formatSupport.push(".mp3");
          var wav = audio.canPlayType('audio/wav; codecs="1"');
          wav && formatSupport.push(".wav");
          var mp4 = audio.canPlayType("audio/mp4");
          mp4 && formatSupport.push(".mp4");
          var m4a = audio.canPlayType("audio/x-m4a");
          m4a && formatSupport.push(".m4a");
        }
      })();
      __audioSupport.format = formatSupport;
      sys.__audioSupport = __audioSupport;
      sys.NetworkType = {
        NONE: 0,
        LAN: 1,
        WWAN: 2
      };
      sys.getNetworkType = function() {
        return sys.NetworkType.LAN;
      };
      sys.getBatteryLevel = function() {
        return 1;
      };
      sys.garbageCollect = function() {
        false;
      };
      sys.dumpRoot = function() {
        false;
      };
      sys.restartVM = function() {
        false;
      };
      sys.cleanScript = function(jsfile) {
        false;
      };
      sys.isObjectValid = function(obj) {
        false;
        if (obj) return true;
        return false;
      };
      sys.dump = function() {
        var self = this;
        var str = "";
        str += "isMobile : " + self.isMobile + "\r\n";
        str += "language : " + self.language + "\r\n";
        str += "browserType : " + self.browserType + "\r\n";
        str += "browserVersion : " + self.browserVersion + "\r\n";
        str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
        str += "os : " + self.os + "\r\n";
        str += "osVersion : " + self.osVersion + "\r\n";
        str += "platform : " + self.platform + "\r\n";
        str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n";
        cc.log(str);
      };
      sys.openURL = function(url) {
        false;
        window.open(url);
      };
      sys.now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      return sys;
    }
    var sys = cc && cc.sys ? cc.sys : initSys();
    module.exports = sys;
  }), {} ],
  165: [ (function(require, module, exports) {
    var eventManager = require("../event-manager");
    var js = require("../platform/js");
    var renderer = require("../renderer");
    require("../platform/CCClass");
    function isWeChatGame() {
      return window["wx"];
    }
    var __BrowserGetter = {
      init: function() {
        true, true;
        this.html = document.getElementsByTagName("html")[0];
      },
      availWidth: function(frame) {
        return frame && frame !== this.html ? frame.clientWidth : window.innerWidth;
      },
      availHeight: function(frame) {
        return frame && frame !== this.html ? frame.clientHeight : window.innerHeight;
      },
      meta: {
        width: "device-width"
      },
      adaptationType: cc.sys.browserType
    };
    cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
    false;
    false;
    switch (__BrowserGetter.adaptationType) {
     case cc.sys.BROWSER_TYPE_SAFARI:
      __BrowserGetter.meta["minimal-ui"] = "true";
      __BrowserGetter.availWidth = function(frame) {
        return frame.clientWidth;
      };
      __BrowserGetter.availHeight = function(frame) {
        return frame.clientHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_SOUGOU:
     case cc.sys.BROWSER_TYPE_UC:
      __BrowserGetter.availWidth = function(frame) {
        return frame.clientWidth;
      };
      __BrowserGetter.availHeight = function(frame) {
        return frame.clientHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_WECHAT_GAME:
      __BrowserGetter.availWidth = function() {
        return window.innerWidth;
      };
      __BrowserGetter.availHeight = function() {
        return window.innerHeight;
      };
      break;

     case cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB:
      var sharedCanvas = wx.getSharedCanvas();
      __BrowserGetter.availWidth = function() {
        return sharedCanvas.width;
      };
      __BrowserGetter.availHeight = function() {
        return sharedCanvas.height;
      };
    }
    var _scissorRect = null;
    var View = function() {
      var _t = this, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
      __BrowserGetter.init(this);
      _t._frameSize = cc.size(0, 0);
      _t._initFrameSize();
      var w = cc.game.canvas.width, h = cc.game.canvas.height;
      _t._designResolutionSize = cc.size(w, h);
      _t._originalDesignResolutionSize = cc.size(w, h);
      _t._scaleX = 1;
      _t._scaleY = 1;
      _t._viewportRect = cc.rect(0, 0, w, h);
      _t._visibleRect = cc.rect(0, 0, w, h);
      cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
      _t._autoFullScreen = false;
      _t._devicePixelRatio = 1;
      _t._retinaEnabled = false;
      _t._resizeCallback = null;
      _t._resizing = false;
      _t._resizeWithBrowserSize = false;
      _t._orientationChanging = true;
      _t._isRotated = false;
      _t._orientation = cc.macro.ORIENTATION_AUTO;
      _t._isAdjustViewport = true;
      _t._antiAliasEnabled = false;
      _t._resolutionPolicy = null;
      _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
      _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.PROPORTION_TO_FRAME, _strategy.SHOW_ALL);
      _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
      _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
      _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
      _t._initialized = false;
      _t.enableAntiAlias(true);
    };
    View.prototype = {
      constructor: View,
      _resizeEvent: function() {
        var view;
        view = this.setDesignResolutionSize ? this : cc.view;
        var prevFrameW = view._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
        if (cc.sys.isMobile) {
          var containerStyle = cc.game.container.style, margin = containerStyle.margin;
          containerStyle.margin = "0";
          containerStyle.display = "none";
          view._initFrameSize();
          containerStyle.margin = margin;
          containerStyle.display = "block";
        } else view._initFrameSize();
        if (view._isRotated === prevRotated && view._frameSize.width === prevFrameW && view._frameSize.height === prevFrameH) return;
        var width = view._originalDesignResolutionSize.width;
        var height = view._originalDesignResolutionSize.height;
        view._resizing = true;
        width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy);
        view._resizing = false;
        eventManager.dispatchCustomEvent("canvas-resize");
        view._resizeCallback && view._resizeCallback.call();
      },
      _orientationChange: function() {
        cc.view._orientationChanging = true;
        cc.view._resizeEvent();
      },
      resizeWithBrowserSize: function(enabled) {
        if (enabled) {
          if (!this._resizeWithBrowserSize) {
            this._resizeWithBrowserSize = true;
            window.addEventListener("resize", this._resizeEvent);
            window.addEventListener("orientationchange", this._orientationChange);
          }
        } else if (this.__resizeWithBrowserSize) {
          this.__resizeWithBrowserSize = false;
          window.removeEventListener("resize", this._resizeEvent);
          window.removeEventListener("orientationchange", this._orientationChange);
        }
      },
      setResizeCallback: function(callback) {
        "function" !== typeof callback && null != callback || (this._resizeCallback = callback);
      },
      setOrientation: function(orientation) {
        orientation &= cc.macro.ORIENTATION_AUTO;
        if (orientation && this._orientation !== orientation) {
          this._orientation = orientation;
          var designWidth = this._originalDesignResolutionSize.width;
          var designHeight = this._originalDesignResolutionSize.height;
          this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
        }
      },
      _initFrameSize: function() {
        var locFrameSize = this._frameSize;
        var w = __BrowserGetter.availWidth(cc.game.frame);
        var h = __BrowserGetter.availHeight(cc.game.frame);
        var isLandscape = w >= h;
        if ((false, !cc.sys.isMobile) || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT) {
          locFrameSize.width = w;
          locFrameSize.height = h;
          cc.game.container.style["-webkit-transform"] = "rotate(0deg)";
          cc.game.container.style.transform = "rotate(0deg)";
          this._isRotated = false;
        } else {
          locFrameSize.width = h;
          locFrameSize.height = w;
          cc.game.container.style["-webkit-transform"] = "rotate(90deg)";
          cc.game.container.style.transform = "rotate(90deg)";
          cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px";
          cc.game.container.style.transformOrigin = "0px 0px 0px";
          this._isRotated = true;
        }
        this._orientationChanging && setTimeout((function() {
          cc.view._orientationChanging = false;
        }), 1e3);
      },
      _adjustSizeKeepCanvasSize: function() {
        var designWidth = this._originalDesignResolutionSize.width;
        var designHeight = this._originalDesignResolutionSize.height;
        designWidth > 0 && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
      },
      _setViewportMeta: function(metas, overwrite) {
        var vp = document.getElementById("cocosMetaElement");
        vp && overwrite && document.head.removeChild(vp);
        var elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null, content, key, pattern;
        content = currentVP ? currentVP.content : "";
        vp = vp || document.createElement("meta");
        vp.id = "cocosMetaElement";
        vp.name = "viewport";
        vp.content = "";
        for (key in metas) if (-1 == content.indexOf(key)) content += "," + key + "=" + metas[key]; else if (overwrite) {
          pattern = new RegExp(key + "s*=s*[^,]+");
          content.replace(pattern, key + "=" + metas[key]);
        }
        /^,/.test(content) && (content = content.substr(1));
        vp.content = content;
        currentVP && (currentVP.content = content);
        document.head.appendChild(vp);
      },
      _adjustViewportMeta: function() {
        if (this._isAdjustViewport && true) {
          this._setViewportMeta(__BrowserGetter.meta, false);
          this._isAdjustViewport = false;
        }
      },
      initialize: function() {
        this._initialized = true;
      },
      adjustViewportMeta: function(enabled) {
        this._isAdjustViewport = enabled;
      },
      enableRetina: function(enabled) {
        this._retinaEnabled = !!enabled;
      },
      isRetinaEnabled: function() {
        return this._retinaEnabled;
      },
      enableAntiAlias: function(enabled) {
        if (this._antiAliasEnabled === enabled) return;
        this._antiAliasEnabled = enabled;
        if (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL) {
          var cache = cc.loader._cache;
          for (var key in cache) {
            var item = cache[key];
            var tex = item && item.content instanceof cc.Texture2D ? item.content : null;
            if (tex) {
              var Filter = cc.Texture2D.Filter;
              enabled ? tex.setFilters(Filter.LINEAR, Filter.LINEAR) : tex.setFilters(Filter.NEAREST, Filter.NEAREST);
            }
          }
        } else if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          var ctx = cc.game.canvas.getContext("2d");
          ctx.imageSmoothingEnabled = enabled;
          ctx.mozImageSmoothingEnabled = enabled;
        }
      },
      isAntiAliasEnabled: function() {
        return this._antiAliasEnabled;
      },
      enableAutoFullScreen: function(enabled) {
        if (enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT) {
          this._autoFullScreen = true;
          cc.screen.autoFullScreen(cc.game.frame);
        } else this._autoFullScreen = false;
      },
      isAutoFullScreenEnabled: function() {
        return this._autoFullScreen;
      },
      setCanvasSize: function(width, height) {
        var canvas = cc.game.canvas;
        var container = cc.game.container;
        canvas.width = width * this._devicePixelRatio;
        canvas.height = height * this._devicePixelRatio;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        container.style.width = width + "px";
        container.style.height = height + "px";
        this._resizeEvent();
      },
      getCanvasSize: function() {
        return cc.size(cc.game.canvas.width, cc.game.canvas.height);
      },
      getFrameSize: function() {
        return cc.size(this._frameSize.width, this._frameSize.height);
      },
      setFrameSize: function(width, height) {
        this._frameSize.width = width;
        this._frameSize.height = height;
        cc.game.frame.style.width = width + "px";
        cc.game.frame.style.height = height + "px";
        this._resizeEvent();
        cc.director.setProjection(cc.director.getProjection());
      },
      getVisibleSize: function() {
        return cc.size(this._visibleRect.width, this._visibleRect.height);
      },
      getVisibleSizeInPixel: function() {
        return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
      },
      getVisibleOrigin: function() {
        return cc.v2(this._visibleRect.x, this._visibleRect.y);
      },
      getVisibleOriginInPixel: function() {
        return cc.v2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
      },
      getResolutionPolicy: function() {
        return this._resolutionPolicy;
      },
      setResolutionPolicy: function(resolutionPolicy) {
        var _t = this;
        if (resolutionPolicy instanceof cc.ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
          var _locPolicy = cc.ResolutionPolicy;
          resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit);
          resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll);
          resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder);
          resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight);
          resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
        }
      },
      setDesignResolutionSize: function(width, height, resolutionPolicy) {
        if (!(width > 0 || height > 0)) {
          cc.logID(2200);
          return;
        }
        this.setResolutionPolicy(resolutionPolicy);
        var policy = this._resolutionPolicy;
        policy && policy.preApply(this);
        cc.sys.isMobile && this._adjustViewportMeta();
        this._orientationChanging = true;
        this._resizing || this._initFrameSize();
        if (!policy) {
          cc.logID(2201);
          return;
        }
        this._originalDesignResolutionSize.width = this._designResolutionSize.width = width;
        this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
        var result = policy.apply(this, this._designResolutionSize);
        if (result.scale && 2 === result.scale.length) {
          this._scaleX = result.scale[0];
          this._scaleY = result.scale[1];
        }
        if (result.viewport) {
          var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
          vp.x = rv.x;
          vp.y = rv.y;
          vp.width = rv.width;
          vp.height = rv.height;
          vb.x = -vp.x / this._scaleX;
          vb.y = -vp.y / this._scaleY;
          vb.width = cc.game.canvas.width / this._scaleX;
          vb.height = cc.game.canvas.height / this._scaleY;
          cc.game._renderContext.setOffset && cc.game._renderContext.setOffset(vp.x, -vp.y);
        }
        var director = cc.director;
        director._winSizeInPoints.width = this._designResolutionSize.width;
        director._winSizeInPoints.height = this._designResolutionSize.height;
        policy.postApply(this);
        cc.winSize.width = director._winSizeInPoints.width;
        cc.winSize.height = director._winSizeInPoints.height;
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        renderer.updateCameraViewport();
      },
      getDesignResolutionSize: function() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
      },
      setRealPixelResolution: function(width, height, resolutionPolicy) {
        if ((true, true) && true) {
          this._setViewportMeta({
            width: width
          }, true);
          document.documentElement.style.width = width + "px";
          document.body.style.width = width + "px";
          document.body.style.left = "0px";
          document.body.style.top = "0px";
        }
        this.setDesignResolutionSize(width, height, resolutionPolicy);
      },
      setViewportInPoints: function(x, y, w, h) {
        var locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc.game._renderContext.viewport(x * locScaleX + this._viewportRect.x, y * locScaleY + this._viewportRect.y, w * locScaleX, h * locScaleY);
      },
      setScissorInPoints: function(x, y, w, h) {
        var scaleX = this._scaleX, scaleY = this._scaleY;
        var sx = Math.ceil(x * scaleX + this._viewportRect.x);
        var sy = Math.ceil(y * scaleY + this._viewportRect.y);
        var sw = Math.ceil(w * scaleX);
        var sh = Math.ceil(h * scaleY);
        var gl = cc.game._renderContext;
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        if (_scissorRect.x !== sx || _scissorRect.y !== sy || _scissorRect.width !== sw || _scissorRect.height !== sh) {
          _scissorRect.x = sx;
          _scissorRect.y = sy;
          _scissorRect.width = sw;
          _scissorRect.height = sh;
          gl.scissor(sx, sy, sw, sh);
        }
      },
      isScissorEnabled: function() {
        return cc.game._renderContext.isEnabled(gl.SCISSOR_TEST);
      },
      getScissorRect: function() {
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        var scaleXFactor = 1 / this._scaleX;
        var scaleYFactor = 1 / this._scaleY;
        return cc.rect((_scissorRect.x - this._viewportRect.x) * scaleXFactor, (_scissorRect.y - this._viewportRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
      },
      getViewportRect: function() {
        return this._viewportRect;
      },
      getScaleX: function() {
        return this._scaleX;
      },
      getScaleY: function() {
        return this._scaleY;
      },
      getDevicePixelRatio: function() {
        return this._devicePixelRatio;
      },
      convertToLocationInView: function(tx, ty, relatedPos) {
        var x = this._devicePixelRatio * (tx - relatedPos.left);
        var y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
        return this._isRotated ? {
          x: this._viewportRect.width - y,
          y: x
        } : {
          x: x,
          y: y
        };
      },
      _convertMouseToLocationInView: function(in_out_point, relatedPos) {
        var viewport = this._viewportRect, _t = this;
        in_out_point.x = (_t._devicePixelRatio * (in_out_point.x - relatedPos.left) - viewport.x) / _t._scaleX;
        in_out_point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y) - viewport.y) / _t._scaleY;
      },
      _convertPointWithScale: function(point) {
        var viewport = this._viewportRect;
        point.x = (point.x - viewport.x) / this._scaleX;
        point.y = (point.y - viewport.y) / this._scaleY;
      },
      _convertTouchesWithScale: function(touches) {
        var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, selTouch, selPoint, selPrePoint;
        for (var i = 0; i < touches.length; i++) {
          selTouch = touches[i];
          selPoint = selTouch._point;
          selPrePoint = selTouch._prevPoint;
          selPoint.x = (selPoint.x - viewport.x) / scaleX;
          selPoint.y = (selPoint.y - viewport.y) / scaleY;
          selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX;
          selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
        }
      }
    };
    View._getInstance = function() {
      if (!this._instance) {
        this._instance = this._instance || new View();
        this._instance.initialize();
      }
      return this._instance;
    };
    cc.ContainerStrategy = cc.Class({
      name: "ContainerStrategy",
      preApply: function(view) {},
      apply: function(view, designedResolution) {},
      postApply: function(view) {},
      _setupContainer: function(view, w, h) {
        var locCanvas = cc.game.canvas, locContainer = cc.game.container;
        if (cc.sys.platform !== cc.sys.WECHAT_GAME) {
          if (cc.sys.os === cc.sys.OS_ANDROID) {
            document.body.style.width = (view._isRotated ? h : w) + "px";
            document.body.style.height = (view._isRotated ? w : h) + "px";
          }
          locContainer.style.width = locCanvas.style.width = w + "px";
          locContainer.style.height = locCanvas.style.height = h + "px";
        }
        var devicePixelRatio = view._devicePixelRatio = 1;
        view.isRetinaEnabled() && (devicePixelRatio = view._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1));
        locCanvas.width = w * devicePixelRatio;
        locCanvas.height = h * devicePixelRatio;
        if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME && wx.getOpenDataContext) {
          var openDataContext = wx.getOpenDataContext();
          var sharedCanvas = openDataContext.canvas;
          if (sharedCanvas) {
            sharedCanvas.width = locCanvas.width;
            sharedCanvas.height = locCanvas.height;
          }
        }
      },
      _fixContainer: function() {
        document.body.insertBefore(cc.game.container, document.body.firstChild);
        var bs = document.body.style;
        bs.width = window.innerWidth + "px";
        bs.height = window.innerHeight + "px";
        bs.overflow = "hidden";
        var contStyle = cc.game.container.style;
        contStyle.position = "fixed";
        contStyle.left = contStyle.top = "0px";
        document.body.scrollTop = 0;
      }
    });
    cc.ContentStrategy = cc.Class({
      name: "ContentStrategy",
      ctor: function() {
        this._result = {
          scale: [ 1, 1 ],
          viewport: null
        };
      },
      _buildResult: function(containerW, containerH, contentW, contentH, scaleX, scaleY) {
        Math.abs(containerW - contentW) < 2 && (contentW = containerW);
        Math.abs(containerH - contentH) < 2 && (contentH = containerH);
        var viewport = cc.rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS;
        this._result.scale = [ scaleX, scaleY ];
        this._result.viewport = viewport;
        return this._result;
      },
      preApply: function(view) {},
      apply: function(view, designedResolution) {
        return {
          scale: [ 1, 1 ]
        };
      },
      postApply: function(view) {}
    });
    (function() {
      var EqualToFrame = cc.Class({
        name: "EqualToFrame",
        extends: cc.ContainerStrategy,
        apply: function(view) {
          var frameH = view._frameSize.height, containerStyle = cc.game.container.style;
          this._setupContainer(view, view._frameSize.width, view._frameSize.height);
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.padding = "0px";
        }
      });
      var ProportionalToFrame = cc.Class({
        name: "ProportionalToFrame",
        extends: cc.ContainerStrategy,
        apply: function(view, designedResolution) {
          var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH, containerW, containerH;
          scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
          containerH = frameH);
          var offx = Math.round((frameW - containerW) / 2);
          var offy = Math.round((frameH - containerH) / 2);
          containerW = frameW - 2 * offx;
          containerH = frameH - 2 * offy;
          this._setupContainer(view, containerW, containerH);
          true;
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.paddingLeft = offx + "px";
          containerStyle.paddingRight = offx + "px";
          containerStyle.paddingTop = offy + "px";
          containerStyle.paddingBottom = offy + "px";
        }
      });
      var EqualToWindow = cc.Class({
        name: "EqualToWindow",
        extends: EqualToFrame,
        preApply: function(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function(view) {
          this._super(view);
          this._fixContainer();
        }
      });
      var ProportionalToWindow = cc.Class({
        name: "ProportionalToWindow",
        extends: ProportionalToFrame,
        preApply: function(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function(view, designedResolution) {
          this._super(view, designedResolution);
          this._fixContainer();
        }
      });
      var OriginalContainer = cc.Class({
        name: "OriginalContainer",
        extends: cc.ContainerStrategy,
        apply: function(view) {
          this._setupContainer(view, cc.game.canvas.width, cc.game.canvas.height);
        }
      });
      cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
      cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
      cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
      var ExactFit = cc.Class({
        name: "ExactFit",
        extends: cc.ContentStrategy,
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
          return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
        }
      });
      var ShowAll = cc.Class({
        name: "ShowAll",
        extends: cc.ContentStrategy,
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0, contentW, contentH;
          scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale) : (scale = scaleY, 
          contentW = designW * scale, contentH = containerH);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var NoBorder = cc.Class({
        name: "NoBorder",
        extends: cc.ContentStrategy,
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale, contentW, contentH;
          scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH) : (scale = scaleX, 
          contentW = containerW, contentH = designH * scale);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var FixedHeight = cc.Class({
        name: "FixedHeight",
        extends: cc.ContentStrategy,
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designH = designedResolution.height, scale = containerH / designH, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function(view) {
          cc.director._winSizeInPoints = view.getVisibleSize();
        }
      });
      var FixedWidth = cc.Class({
        name: "FixedWidth",
        extends: cc.ContentStrategy,
        apply: function(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, scale = containerW / designW, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        },
        postApply: function(view) {
          cc.director._winSizeInPoints = view.getVisibleSize();
        }
      });
      cc.ContentStrategy.EXACT_FIT = new ExactFit();
      cc.ContentStrategy.SHOW_ALL = new ShowAll();
      cc.ContentStrategy.NO_BORDER = new NoBorder();
      cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
      cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
    })();
    cc.ResolutionPolicy = cc.Class({
      name: "cc.ResolutionPolicy",
      ctor: function(containerStg, contentStg) {
        this._containerStrategy = null;
        this._contentStrategy = null;
        this.setContainerStrategy(containerStg);
        this.setContentStrategy(contentStg);
      },
      preApply: function(view) {
        this._containerStrategy.preApply(view);
        this._contentStrategy.preApply(view);
      },
      apply: function(view, designedResolution) {
        this._containerStrategy.apply(view, designedResolution);
        return this._contentStrategy.apply(view, designedResolution);
      },
      postApply: function(view) {
        this._containerStrategy.postApply(view);
        this._contentStrategy.postApply(view);
      },
      setContainerStrategy: function(containerStg) {
        containerStg instanceof cc.ContainerStrategy && (this._containerStrategy = containerStg);
      },
      setContentStrategy: function(contentStg) {
        contentStg instanceof cc.ContentStrategy && (this._contentStrategy = contentStg);
      }
    });
    js.get(cc.ResolutionPolicy.prototype, "canvasSize", (function() {
      return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
    }));
    cc.ResolutionPolicy.EXACT_FIT = 0;
    cc.ResolutionPolicy.NO_BORDER = 1;
    cc.ResolutionPolicy.SHOW_ALL = 2;
    cc.ResolutionPolicy.FIXED_HEIGHT = 3;
    cc.ResolutionPolicy.FIXED_WIDTH = 4;
    cc.ResolutionPolicy.UNKNOWN = 5;
    module.exports = View;
  }), {
    "../event-manager": 98,
    "../platform/CCClass": 155,
    "../platform/js": 175,
    "../renderer": 196
  } ],
  166: [ (function(require, module, exports) {
    cc.visibleRect = {
      topLeft: cc.v2(0, 0),
      topRight: cc.v2(0, 0),
      top: cc.v2(0, 0),
      bottomLeft: cc.v2(0, 0),
      bottomRight: cc.v2(0, 0),
      bottom: cc.v2(0, 0),
      center: cc.v2(0, 0),
      left: cc.v2(0, 0),
      right: cc.v2(0, 0),
      width: 0,
      height: 0,
      init: function(visibleRect) {
        var w = this.width = visibleRect.width;
        var h = this.height = visibleRect.height;
        var l = visibleRect.x, b = visibleRect.y, t = b + h, r = l + w;
        this.topLeft.x = l;
        this.topLeft.y = t;
        this.topRight.x = r;
        this.topRight.y = t;
        this.top.x = l + w / 2;
        this.top.y = t;
        this.bottomLeft.x = l;
        this.bottomLeft.y = b;
        this.bottomRight.x = r;
        this.bottomRight.y = b;
        this.bottom.x = l + w / 2;
        this.bottom.y = b;
        this.center.x = l + w / 2;
        this.center.y = b + h / 2;
        this.left.x = l;
        this.left.y = b + h / 2;
        this.right.x = r;
        this.right.y = b + h / 2;
      }
    };
  }), {} ],
  167: [ (function(require, module, exports) {
    var js = require("./js");
    var isPlainEmptyObj = require("./utils").isPlainEmptyObj_DEV;
    var DELIMETER = "$_$";
    function createAttrsSingle(owner, ownerCtor, superAttrs) {
      var AttrsCtor;
      var ctorName;
      false;
      AttrsCtor = function() {};
      superAttrs && js.extend(AttrsCtor, superAttrs.constructor);
      var attrs = new AttrsCtor();
      js.value(owner, "__attrs__", attrs);
      return attrs;
    }
    function createAttrs(subclass) {
      var superClass;
      var chains = cc.Class.getInheritanceChain(subclass);
      for (var i = chains.length - 1; i >= 0; i--) {
        var cls = chains[i];
        var attrs = cls.hasOwnProperty("__attrs__") && cls.__attrs__;
        if (!attrs) {
          superClass = chains[i + 1];
          createAttrsSingle(cls, cls, superClass && superClass.__attrs__);
        }
      }
      superClass = chains[0];
      createAttrsSingle(subclass, subclass, superClass && superClass.__attrs__);
      return subclass.__attrs__;
    }
    function attr(ctor, propName, newAttrs) {
      var attrs, setter, key;
      if ("function" === typeof ctor) {
        attrs = getClassAttrs(ctor);
        setter = attrs.constructor.prototype;
      } else {
        var instance = ctor;
        attrs = instance.__attrs__;
        if (!attrs) {
          ctor = instance.constructor;
          var clsAttrs = getClassAttrs(ctor);
          attrs = createAttrsSingle(instance, ctor, clsAttrs);
        }
        setter = attrs;
      }
      if ("undefined" === typeof newAttrs) {
        var prefix = propName + DELIMETER;
        var ret = {};
        for (key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
        return ret;
      }
      if ("object" === typeof newAttrs) for (key in newAttrs) 95 !== key.charCodeAt(0) && (setter[propName + DELIMETER + key] = newAttrs[key]); else false;
    }
    function getClassAttrs(ctor) {
      return ctor.hasOwnProperty("__attrs__") && ctor.__attrs__ || createAttrs(ctor);
    }
    function getClassAttrsProto(ctor) {
      return getClassAttrs(ctor).constructor.prototype;
    }
    function setClassAttr(ctor, propName, key, value) {
      var proto = getClassAttrsProto(ctor);
      proto[propName + DELIMETER + key] = value;
    }
    cc.Integer = "Integer";
    cc.Float = "Float";
    false;
    cc.Boolean = "Boolean";
    cc.String = "String";
    function getTypeChecker(type, attrName) {
      false;
    }
    function ObjectType(typeCtor) {
      return {
        type: "Object",
        ctor: typeCtor,
        _onAfterProp: false
      };
    }
    module.exports = {
      attr: attr,
      getClassAttrs: getClassAttrs,
      getClassAttrsProto: getClassAttrsProto,
      setClassAttr: setClassAttr,
      DELIMETER: DELIMETER,
      getTypeChecker: getTypeChecker,
      ObjectType: ObjectType,
      ScriptUuid: {}
    };
  }), {
    "./CCClass": 155,
    "./js": 175,
    "./utils": 179
  } ],
  168: [ (function(require, module, exports) {
    var js = require("./js");
    var fastRemoveAt = js.array.fastRemoveAt;
    function CallbackList() {
      this.callbacks = [];
      this.targets = [];
      this.isInvoking = false;
      this.containCanceled = false;
    }
    var proto = CallbackList.prototype;
    proto.removeBy = function(array, value) {
      var callbacks = this.callbacks;
      var targets = this.targets;
      for (var i = 0; i < array.length; ++i) if (array[i] === value) {
        fastRemoveAt(callbacks, i);
        fastRemoveAt(targets, i);
        --i;
      }
    };
    proto.cancel = function(index) {
      this.callbacks[index] = this.targets[index] = null;
      this.containCanceled = true;
    };
    proto.cancelAll = function() {
      var callbacks = this.callbacks;
      var targets = this.targets;
      for (var i = 0; i < callbacks.length; i++) callbacks[i] = targets[i] = null;
      this.containCanceled = true;
    };
    proto.purgeCanceled = function() {
      this.removeBy(this.callbacks, null);
      this.containCanceled = false;
    };
    var MAX_SIZE = 16;
    var callbackListPool = new js.Pool(function(list) {
      list.callbacks.length = 0;
      list.targets.length = 0;
      list.isInvoking = false;
      list.containCanceled = false;
    }, MAX_SIZE);
    callbackListPool.get = function() {
      return this._get() || new CallbackList();
    };
    function CallbacksHandler() {
      this._callbackTable = js.createMap(true);
    }
    proto = CallbacksHandler.prototype;
    proto.add = function(key, callback, target) {
      var list = this._callbackTable[key];
      list || (list = this._callbackTable[key] = callbackListPool.get());
      list.callbacks.push(callback);
      list.targets.push(target || null);
    };
    proto.hasEventListener = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (!list) return false;
      var callbacks = list.callbacks;
      if (!callback) {
        if (list.isInvoking) {
          for (var i = 0; i < callbacks.length; i++) if (callbacks[i]) return true;
          return false;
        }
        return callbacks.length > 0;
      }
      target = target || null;
      var targets = list.targets;
      for (var _i = 0; _i < callbacks.length; ++_i) if (callbacks[_i] === callback && targets[_i] === target) return true;
      return false;
    };
    proto.removeAll = function(keyOrTarget) {
      if ("string" === typeof keyOrTarget) {
        var list = this._callbackTable[keyOrTarget];
        if (list) if (list.isInvoking) list.cancelAll(); else {
          callbackListPool.put(list);
          delete this._callbackTable[keyOrTarget];
        }
      } else if (keyOrTarget) for (var key in this._callbackTable) {
        var _list = this._callbackTable[key];
        if (_list.isInvoking) {
          var targets = _list.targets;
          for (var i = 0; i < targets.length; ++i) targets[i] === keyOrTarget && _list.cancel(i);
        } else _list.removeBy(_list.targets, keyOrTarget);
      }
    };
    proto.remove = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (list) {
        target = target || null;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0; i < callbacks.length; ++i) if (callbacks[i] === callback && targets[i] === target) {
          if (list.isInvoking) list.cancel(i); else {
            fastRemoveAt(callbacks, i);
            fastRemoveAt(targets, i);
          }
          break;
        }
      }
    };
    var CallbacksInvoker = function() {
      CallbacksHandler.call(this);
    };
    js.extend(CallbacksInvoker, CallbacksHandler);
    false;
    CallbacksInvoker.prototype.invoke = function(key, p1, p2, p3, p4, p5) {
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var callbacks = list.callbacks;
        var targets = list.targets;
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          var callback = callbacks[i];
          if (callback) {
            var target = targets[i];
            target ? callback.call(target, p1, p2, p3, p4, p5) : callback(p1, p2, p3, p4, p5);
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    CallbacksInvoker.CallbacksHandler = CallbacksHandler;
    module.exports = CallbacksInvoker;
  }), {
    "./js": 175
  } ],
  169: [ (function(require, module, exports) {
    function deepFlatten(strList, array) {
      for (var i = 0; i < array.length; i++) {
        var item = array[i];
        Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
      }
    }
    function flattenCodeArray(array) {
      var separator = "";
      var strList = [];
      deepFlatten(strList, array);
      return strList.join(separator);
    }
    module.exports = {
      flattenCodeArray: flattenCodeArray
    };
  }), {} ],
  170: [ (function(require, module, exports) {
    var js = require("./js");
    var CCObject = require("./CCObject");
    var Attr = require("./attribute");
    var CCClass = require("./CCClass");
    var misc = require("../utils/misc");
    var Details = function() {
      this.uuidList = [];
      this.uuidObjList = [];
      this.uuidPropList = [];
      this._stillUseUrl = js.createMap(true);
    };
    Details.prototype.reset = function() {
      this.uuidList.length = 0;
      this.uuidObjList.length = 0;
      this.uuidPropList.length = 0;
      js.clear(this._stillUseUrl);
    };
    false, false;
    Details.prototype.push = function(obj, propName, uuid, _stillUseUrl) {
      _stillUseUrl && (this._stillUseUrl[this.uuidList.length] = true);
      this.uuidList.push(uuid);
      this.uuidObjList.push(obj);
      this.uuidPropList.push(propName);
    };
    Details.pool = new js.Pool(function(obj) {
      obj.reset();
    }, 10);
    Details.pool.get = function() {
      return this._get() || new Details();
    };
    var _Deserializer = (function() {
      function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
        this.result = result;
        this.customEnv = customEnv;
        this.deserializedList = [];
        this.deserializedData = null;
        this._classFinder = classFinder;
        false;
        this._idList = [];
        this._idObjList = [];
        this._idPropList = [];
      }
      function _dereference(self) {
        var deserializedList = self.deserializedList;
        var idPropList = self._idPropList;
        var idList = self._idList;
        var idObjList = self._idObjList;
        var onDereferenced = self._classFinder && self._classFinder.onDereferenced;
        var i, propName, id;
        false;
        for (i = 0; i < idList.length; i++) {
          propName = idPropList[i];
          id = idList[i];
          idObjList[i][propName] = deserializedList[id];
        }
      }
      var prototype = _Deserializer.prototype;
      prototype.deserialize = function(jsonObj) {
        if (Array.isArray(jsonObj)) {
          var jsonArray = jsonObj;
          var refCount = jsonArray.length;
          this.deserializedList.length = refCount;
          for (var i = 0; i < refCount; i++) if (jsonArray[i]) {
            var mainTarget;
            false, false;
            this.deserializedList[i] = this._deserializeObject(jsonArray[i], false);
          }
          this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
        } else {
          this.deserializedList.length = 1;
          false, false;
          this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, false) : null;
          this.deserializedList[0] = this.deserializedData;
        }
        _dereference(this);
        return this.deserializedData;
      };
      prototype._deserializeObject = function(serialized, _stillUseUrl, target, owner, propName) {
        var prop;
        var obj = null;
        var klass = null;
        var type = serialized.__type__;
        if (type) {
          klass = this._classFinder(type, serialized, owner, propName);
          if (!klass) {
            var notReported = this._classFinder === js._getClassById;
            notReported && cc.deserialize.reportMissingClass(type);
            return null;
          }
          if ((false, false) && target) {
            target instanceof klass || cc.warnID(5300, js.getClassName(target), klass);
            obj = target;
          } else obj = new klass();
          if (obj._deserialize) {
            obj._deserialize(serialized.content, this);
            return obj;
          }
          cc.Class._isCCClass(klass) ? _deserializeFireClass(this, obj, serialized, klass, target) : this._deserializeTypedObject(obj, serialized, klass);
        } else if (Array.isArray(serialized)) {
          if ((false, false) && target) {
            target.length = serialized.length;
            obj = target;
          } else obj = new Array(serialized.length);
          for (var i = 0; i < serialized.length; i++) {
            prop = serialized[i];
            if ("object" === typeof prop && prop) {
              false, false;
              this._deserializeObjField(obj, prop, "" + i, null, _stillUseUrl);
            } else obj[i] = prop;
          }
        } else {
          obj = (false, false) && target || {};
          this._deserializePrimitiveObject(obj, serialized);
        }
        return obj;
      };
      prototype._deserializeObjField = function(obj, jsonObj, propName, target, _stillUseUrl) {
        var id = jsonObj.__id__;
        if (void 0 === id) {
          var uuid = jsonObj.__uuid__;
          if (uuid) this.result.push(obj, propName, uuid, _stillUseUrl); else {
            false, false;
            obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
          }
        } else {
          var dObj = this.deserializedList[id];
          if (dObj) obj[propName] = dObj; else {
            this._idList.push(id);
            this._idObjList.push(obj);
            this._idPropList.push(propName);
          }
        }
      };
      prototype._deserializePrimitiveObject = function(instance, serialized) {
        var self = this;
        for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
          var prop = serialized[propName];
          if ("object" !== typeof prop) "__type__" !== propName && (instance[propName] = prop); else if (prop) {
            false, false;
            self._deserializeObjField(instance, prop, propName);
          } else instance[propName] = null;
        }
      };
      prototype._deserializeTypedObject = function(instance, serialized, klass) {
        if (klass === cc.Vec2) {
          instance.x = serialized.x || 0;
          instance.y = serialized.y || 0;
          return;
        }
        if (klass === cc.Color) {
          instance.r = serialized.r || 0;
          instance.g = serialized.g || 0;
          instance.b = serialized.b || 0;
          var a = serialized.a;
          instance.a = void 0 === a ? 255 : a;
          return;
        }
        if (klass === cc.Size) {
          instance.width = serialized.width || 0;
          instance.height = serialized.height || 0;
          return;
        }
        var fastDefinedProps = klass.__props__;
        fastDefinedProps || (fastDefinedProps = Object.keys(instance));
        for (var i = 0; i < fastDefinedProps.length; i++) {
          var propName = fastDefinedProps[i];
          var prop = serialized[propName];
          if (void 0 !== prop && serialized.hasOwnProperty(propName)) if ("object" !== typeof prop) instance[propName] = prop; else if (prop) {
            false, false;
            this._deserializeObjField(instance, prop, propName);
          } else instance[propName] = null;
        }
      };
      var compileObjectType = function(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue, stillUseUrl) {
        if (defaultValue instanceof cc.ValueType) {
          assumeHavePropIfIsValue || sources.push("if(prop){");
          var ctorCode = js.getClassName(defaultValue);
          sources.push("s._deserializeTypedObject(o" + accessorToSet + ",prop," + ctorCode + ");");
          assumeHavePropIfIsValue || sources.push("}else o" + accessorToSet + "=null;");
        } else {
          sources.push("if(prop){");
          false, false;
          sources.push("s._deserializeObjField(o,prop," + propNameLiteralToSet + ",null," + !!stillUseUrl + ");");
          sources.push("}else o" + accessorToSet + "=null;");
        }
      };
      var compileDeserialize = function(self, klass) {
        var TYPE = Attr.DELIMETER + "type";
        var EDITOR_ONLY = Attr.DELIMETER + "editorOnly";
        var SERIALIZABLE = Attr.DELIMETER + "serializable";
        var DEFAULT = Attr.DELIMETER + "default";
        var SAVE_URL_AS_ASSET = Attr.DELIMETER + "saveUrlAsAsset";
        var FORMERLY_SERIALIZED_AS = Attr.DELIMETER + "formerlySerializedAs";
        var attrs = Attr.getClassAttrs(klass);
        var props = klass.__props__;
        var sources = [ "var prop;" ];
        var fastMode = misc.BUILTIN_CLASSID_RE.test(js._getClassId(klass));
        for (var p = 0; p < props.length; p++) {
          var propName = props[p];
          if ((false, false) && attrs[propName + EDITOR_ONLY]) continue;
          if (false === attrs[propName + SERIALIZABLE]) continue;
          var accessorToSet, propNameLiteralToSet;
          if (CCClass.IDENTIFIER_RE.test(propName)) {
            propNameLiteralToSet = '"' + propName + '"';
            accessorToSet = "." + propName;
          } else {
            propNameLiteralToSet = CCClass.escapeForJS(propName);
            accessorToSet = "[" + propNameLiteralToSet + "]";
          }
          var accessorToGet = accessorToSet;
          if (attrs[propName + FORMERLY_SERIALIZED_AS]) {
            var propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS];
            accessorToGet = CCClass.IDENTIFIER_RE.test(propNameToRead) ? "." + propNameToRead : "[" + CCClass.escapeForJS(propNameToRead) + "]";
          }
          sources.push("prop=d" + accessorToGet + ";");
          sources.push('if(typeof prop!=="undefined"){');
          var stillUseUrl = attrs[propName + SAVE_URL_AS_ASSET];
          var defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
          if (fastMode) {
            var isPrimitiveType;
            var userType = attrs[propName + TYPE];
            if (void 0 === defaultValue && userType) isPrimitiveType = userType === cc.String || userType === cc.Integer || userType === cc.Float || userType === cc.Boolean; else {
              var defaultType = typeof defaultValue;
              isPrimitiveType = "string" === defaultType && !stillUseUrl || "number" === defaultType || "boolean" === defaultType;
            }
            isPrimitiveType ? sources.push("o" + accessorToSet + "=prop;") : compileObjectType(sources, defaultValue, accessorToSet, propNameLiteralToSet, true, stillUseUrl);
          } else {
            sources.push('if(typeof prop!=="object"){o' + accessorToSet + "=prop;}else{");
            compileObjectType(sources, defaultValue, accessorToSet, propNameLiteralToSet, false, stillUseUrl);
            sources.push("}");
          }
          sources.push("}");
        }
        if (cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component)) {
          var mayUsedInPersistRoot;
          false, false;
          sources.push("d._id&&(o._id=d._id);");
        }
        if ("_$erialized" === props[props.length - 1]) {
          sources.push("o._$erialized=JSON.parse(JSON.stringify(d));");
          sources.push("s._deserializePrimitiveObject(o._$erialized,d);");
        }
        return Function("s", "o", "d", "k", "t", sources.join(""));
      };
      function unlinkUnusedPrefab(self, serialized, obj) {
        var uuid = serialized["asset"] && serialized["asset"].__uuid__;
        if (uuid) {
          var last = self.result.uuidList.length - 1;
          if (self.result.uuidList[last] === uuid && self.result.uuidObjList[last] === obj && "asset" === self.result.uuidPropList[last]) {
            self.result.uuidList.pop();
            self.result.uuidObjList.pop();
            self.result.uuidPropList.pop();
          } else {
            var debugEnvOnlyInfo = "Failed to skip prefab asset while deserializing PrefabInfo";
            cc.warn(debugEnvOnlyInfo);
          }
        }
      }
      function _deserializeFireClass(self, obj, serialized, klass, target) {
        var deserialize;
        if (klass.hasOwnProperty("__deserialize__")) deserialize = klass.__deserialize__; else {
          deserialize = compileDeserialize(self, klass);
          js.value(klass, "__deserialize__", deserialize, true);
        }
        deserialize(self, obj, serialized, klass, target);
        false, false;
      }
      _Deserializer.pool = new js.Pool(function(obj) {
        obj.result = null;
        obj.customEnv = null;
        obj.deserializedList.length = 0;
        obj.deserializedData = null;
        obj._classFinder = null;
        false;
        obj._idList.length = 0;
        obj._idObjList.length = 0;
        obj._idPropList.length = 0;
      }, 1);
      _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
        var cache = this._get();
        if (cache) {
          cache.result = result;
          cache.customEnv = customEnv;
          cache._classFinder = classFinder;
          false;
          return cache;
        }
        return new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
      };
      return _Deserializer;
    })();
    cc.deserialize = function(data, details, options) {
      options = options || {};
      var classFinder = options.classFinder || js._getClassById;
      var createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE;
      var target = (false, false) && options.target;
      var customEnv = options.customEnv;
      var ignoreEditorOnly = options.ignoreEditorOnly;
      false;
      "string" === typeof data && (data = JSON.parse(data));
      var tempDetails = !details;
      details = details || Details.pool.get();
      var deserializer = _Deserializer.pool.get(details, target, classFinder, customEnv, ignoreEditorOnly);
      cc.game._isCloning = true;
      var res = deserializer.deserialize(data);
      cc.game._isCloning = false;
      _Deserializer.pool.put(deserializer);
      createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset);
      tempDetails && Details.pool.put(details);
      return res;
    };
    cc.deserialize.Details = Details;
    cc.deserialize.reportMissingClass = function(id) {
      false;
      cc.warnID(5302, id);
    };
  }), {
    "../utils/misc": 233,
    "./CCClass": 155,
    "./CCObject": 161,
    "./attribute": 167,
    "./js": 175
  } ],
  171: [ (function(require, module, exports) {
    var NonUuidMark = ".";
    function IdGenerater(category) {
      this.id = 0 | 998 * Math.random();
      this.prefix = category ? category + NonUuidMark : "";
    }
    IdGenerater.prototype.getNewId = function() {
      return this.prefix + ++this.id;
    };
    IdGenerater.global = new IdGenerater("global");
    module.exports = IdGenerater;
  }), {} ],
  172: [ (function(require, module, exports) {
    require("./js");
    require("./CCClass");
    require("./CCClassDecorator");
    require("./CCEnum");
    require("./CCObject");
    require("./callbacks-invoker");
    require("./url");
    require("./deserialize");
    require("./instantiate");
    require("./instantiate-jit");
    require("./requiring-frame");
    require("./CCSys");
    require("./CCMacro");
    true;
    require("./CCAssetLibrary");
    require("./CCVisibleRect");
  }), {
    "./CCAssetLibrary": 154,
    "./CCClass": 155,
    "./CCClassDecorator": 156,
    "./CCEnum": 157,
    "./CCMacro": 160,
    "./CCObject": 161,
    "./CCSys": 164,
    "./CCVisibleRect": 166,
    "./callbacks-invoker": 168,
    "./deserialize": 170,
    "./instantiate": 174,
    "./instantiate-jit": 173,
    "./js": 175,
    "./requiring-frame": 177,
    "./url": 178
  } ],
  173: [ (function(require, module, exports) {
    var CCObject = require("./CCObject");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var Attr = require("./attribute");
    var js = require("./js");
    var CCClass = require("./CCClass");
    var Compiler = require("./compiler");
    var SERIALIZABLE = Attr.DELIMETER + "serializable";
    var DEFAULT = Attr.DELIMETER + "default";
    var IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
    var escapeForJS = CCClass.escapeForJS;
    var VAR = "var ";
    var LOCAL_OBJ = "o";
    var LOCAL_TEMP_OBJ = "t";
    var LOCAL_ARRAY = "a";
    var LINE_INDEX_OF_NEW_OBJ = 0;
    var DEFAULT_MODULE_CACHE = {
      "cc.Node": "cc.Node",
      "cc.Sprite": "cc.Sprite",
      "cc.Label": "cc.Label",
      "cc.Button": "cc.Button",
      "cc.Widget": "cc.Widget",
      "cc.Animation": "cc.Animation",
      "cc.ClickEvent": false,
      "cc.PrefabInfo": false
    };
    function Declaration(varName, expression) {
      this.varName = varName;
      this.expression = expression;
    }
    Declaration.prototype.toString = function() {
      return VAR + this.varName + "=" + this.expression + ";";
    };
    function mergeDeclaration(statement, expression) {
      return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
    }
    function writeAssignment(codeArray, statement, expression) {
      if (Array.isArray(expression)) {
        expression[0] = mergeDeclaration(statement, expression[0]);
        codeArray.push(expression);
      } else codeArray.push(mergeDeclaration(statement, expression) + ";");
    }
    function Assignments(targetExpression) {
      this._exps = [];
      this._targetExp = targetExpression;
    }
    Assignments.prototype.append = function(key, expression) {
      this._exps.push([ key, expression ]);
    };
    Assignments.prototype.writeCode = function(codeArray) {
      var targetVar;
      if (this._exps.length > 1) {
        codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
        targetVar = LOCAL_TEMP_OBJ;
      } else {
        if (1 !== this._exps.length) return;
        targetVar = this._targetExp;
      }
      for (var i = 0; i < this._exps.length; i++) {
        var pair = this._exps[i];
        writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
      }
    };
    Assignments.pool = new js.Pool(function(obj) {
      obj._exps.length = 0;
      obj._targetExp = null;
    }, 1);
    Assignments.pool.get = function(targetExpression) {
      var cache = this._get() || new Assignments();
      cache._targetExp = targetExpression;
      return cache;
    };
    function equalsToDefault(def, value) {
      if ("function" === typeof def) try {
        def = def();
      } catch (e) {
        return false;
      }
      if (def === value) return true;
      if (def && value) {
        if (def instanceof cc.ValueType && def.equals(value)) return true;
        if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) try {
          return Array.isArray(def) && Array.isArray(value) && 0 === def.length && 0 === value.length;
        } catch (e) {}
      }
      return false;
    }
    function getPropAccessor(key) {
      return IDENTIFIER_RE.test(key) ? "." + key : "[" + escapeForJS(key) + "]";
    }
    function Parser(obj, parent) {
      this.parent = parent;
      this.objsToClear_iN$t = [];
      this.codeArray = [];
      this.objs = [];
      this.funcs = [];
      this.funcModuleCache = js.createMap();
      js.mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
      this.globalVariables = [];
      this.globalVariableId = 0;
      this.localVariableId = 0;
      this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", "if(R){", LOCAL_OBJ + "=R;", "}else{", LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", "}");
      obj._iN$t = {
        globalVar: "R"
      };
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(this.codeArray, obj);
      var globalVariablesDeclaration;
      this.globalVariables.length > 0 && (globalVariablesDeclaration = VAR + this.globalVariables.join(",") + ";");
      var code = Compiler.flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
      this.result = Function("O", "F", code)(this.objs, this.funcs);
      for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
      this.objsToClear_iN$t.length = 0;
    }
    var proto = Parser.prototype;
    proto.getFuncModule = function(func, usedInNew) {
      var clsName = js.getClassName(func);
      if (clsName) {
        var cache = this.funcModuleCache[clsName];
        if (cache) return cache;
        if (void 0 === cache) {
          var clsNameIsModule = -1 !== clsName.indexOf(".");
          if (clsNameIsModule) try {
            clsNameIsModule = func === Function("return " + clsName)();
            if (clsNameIsModule) {
              this.funcModuleCache[clsName] = clsName;
              return clsName;
            }
          } catch (e) {}
        }
      }
      var index = this.funcs.indexOf(func);
      if (index < 0) {
        index = this.funcs.length;
        this.funcs.push(func);
      }
      var res = "F[" + index + "]";
      usedInNew && (res = "(" + res + ")");
      this.funcModuleCache[clsName] = res;
      return res;
    };
    proto.getObjRef = function(obj) {
      var index = this.objs.indexOf(obj);
      if (index < 0) {
        index = this.objs.length;
        this.objs.push(obj);
      }
      return "O[" + index + "]";
    };
    proto.setValueType = function(codeArray, defaultValue, srcValue, targetExpression) {
      var assignments = Assignments.pool.get(targetExpression);
      var fastDefinedProps = defaultValue.constructor.__props__;
      fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
      for (var i = 0; i < fastDefinedProps.length; i++) {
        var propName = fastDefinedProps[i];
        var prop = srcValue[propName];
        if (defaultValue[propName] === prop) continue;
        var expression = this.enumerateField(srcValue, propName, prop);
        assignments.append(propName, expression);
      }
      assignments.writeCode(codeArray);
      Assignments.pool.put(assignments);
    };
    proto.enumerateCCClass = function(codeArray, obj, klass) {
      var props = klass.__props__;
      var attrs = Attr.getClassAttrs(klass);
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        if (false !== attrs[key + SERIALIZABLE]) {
          var val = obj[key];
          var defaultValue = attrs[key + DEFAULT];
          if (equalsToDefault(defaultValue, val)) continue;
          if ("object" === typeof val && val instanceof cc.ValueType) {
            var defaultValue = CCClass.getDefault(defaultValue);
            if ((defaultValue && defaultValue.constructor) === val.constructor) {
              var targetExpression = LOCAL_OBJ + getPropAccessor(key);
              this.setValueType(codeArray, defaultValue, val, targetExpression);
              continue;
            }
          }
          this.setObjProp(codeArray, obj, key, val);
        }
      }
    };
    proto.instantiateArray = function(value) {
      if (0 === value.length) return "[]";
      var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
      var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
      var codeArray = [ declaration ];
      value._iN$t = {
        globalVar: "",
        source: codeArray
      };
      this.objsToClear_iN$t.push(value);
      for (var i = 0; i < value.length; ++i) {
        var statement = arrayVar + "[" + i + "]=";
        var expression = this.enumerateField(value, i, value[i]);
        writeAssignment(codeArray, statement, expression);
      }
      return codeArray;
    };
    proto.enumerateField = function(obj, key, value) {
      if ("object" === typeof value && value) {
        var _iN$t = value._iN$t;
        if (_iN$t) {
          var globalVar = _iN$t.globalVar;
          if (!globalVar) {
            globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
            this.globalVariables.push(globalVar);
            var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
            _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
          }
          return globalVar;
        }
        return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
      }
      if ("function" === typeof value) return this.getFuncModule(value);
      if ("string" === typeof value) return escapeForJS(value);
      "_objFlags" === key && cc.Class.isInstanceOf(obj, CCObject) && (value &= PersistentMask);
      return value;
    };
    proto.setObjProp = function(codeArray, obj, key, value) {
      var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
      var expression = this.enumerateField(obj, key, value);
      writeAssignment(codeArray, statement, expression);
    };
    proto.enumerateObject = function(codeArray, obj) {
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value && value === obj._iN$t) continue;
        this.setObjProp(codeArray, obj, key, value);
      }
    };
    proto.instantiateObj = function(obj) {
      if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
      if (cc.Class.isInstanceOf(obj, cc.Asset)) return this.getObjRef(obj);
      if (obj._objFlags & Destroyed) return null;
      var createCode;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (this.parent) if (this.parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
        } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) return this.getObjRef(obj);
        createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
      } else if (ctor === Object) createCode = new Declaration(LOCAL_OBJ, "{}"); else {
        if (ctor) return this.getObjRef(obj);
        createCode = new Declaration(LOCAL_OBJ, "Object.create(null)");
      }
      var codeArray = [ createCode ];
      obj._iN$t = {
        globalVar: "",
        source: codeArray
      };
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(codeArray, obj);
      return [ "(function(){", codeArray, "return o;})();" ];
    };
    function compile(node) {
      var root = node instanceof cc._BaseNode && node;
      var parser = new Parser(node, root);
      return parser.result;
    }
    module.exports = {
      compile: compile,
      equalsToDefault: equalsToDefault
    };
    false;
  }), {
    "./CCClass": 155,
    "./CCObject": 161,
    "./attribute": 167,
    "./compiler": 169,
    "./js": 175
  } ],
  174: [ (function(require, module, exports) {
    var CCObject = require("./CCObject");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var Attr = require("./attribute");
    var _isDomNode = require("./utils").isDomNode;
    function instantiate(original, internal_force) {
      if (!internal_force) {
        if ("object" !== typeof original || Array.isArray(original)) {
          false;
          return null;
        }
        if (!original) {
          false;
          return null;
        }
        if (!cc.isValid(original)) {
          false;
          return null;
        }
        false;
      }
      var clone;
      if (cc.Class.isInstanceOf(original, CCObject)) {
        if (original._instantiate) {
          cc.game._isCloning = true;
          clone = original._instantiate();
          cc.game._isCloning = false;
          return clone;
        }
        if (cc.Class.isInstanceOf(original, cc.Asset)) {
          false;
          return null;
        }
      }
      cc.game._isCloning = true;
      clone = doInstantiate(original);
      cc.game._isCloning = false;
      return clone;
    }
    var objsToClearTmpVar = [];
    function doInstantiate(obj, parent) {
      if (Array.isArray(obj)) {
        false;
        return null;
      }
      if (_isDomNode && _isDomNode(obj)) {
        false;
        return null;
      }
      var clone;
      if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
        var klass = obj.constructor;
        clone = new klass();
      } else clone = Object.create(null);
      enumerateObject(obj, clone, parent);
      for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
      objsToClearTmpVar.length = 0;
      return clone;
    }
    var SERIALIZABLE = Attr.DELIMETER + "serializable";
    function enumerateCCClass(klass, obj, clone, parent) {
      var props = klass.__props__;
      var attrs = Attr.getClassAttrs(klass);
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        if (false !== attrs[key + SERIALIZABLE]) {
          var value = obj[key];
          clone[key] = "object" === typeof value && value ? value._iN$t || instantiateObj(value, parent) : value;
        }
      }
    }
    function enumerateObject(obj, clone, parent) {
      obj._iN$t = clone;
      objsToClearTmpVar.push(obj);
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) enumerateCCClass(klass, obj, clone, parent); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value) {
          if (value === clone) continue;
          clone[key] = value._iN$t || instantiateObj(value, parent);
        } else clone[key] = value;
      }
      cc.Class.isInstanceOf(obj, CCObject) && (clone._objFlags &= PersistentMask);
    }
    function instantiateObj(obj, parent) {
      if (obj instanceof cc.ValueType) return obj.clone();
      if (cc.Class.isInstanceOf(obj, cc.Asset)) return obj;
      var clone;
      if (Array.isArray(obj)) {
        var len = obj.length;
        clone = new Array(len);
        obj._iN$t = clone;
        for (var i = 0; i < len; ++i) {
          var value = obj[i];
          clone[i] = "object" === typeof value && value ? value._iN$t || instantiateObj(value, parent) : value;
        }
        objsToClearTmpVar.push(obj);
        return clone;
      }
      if (obj._objFlags & Destroyed) return null;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (parent) if (parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
        } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(parent)) return obj;
        } else if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) return obj;
        clone = new ctor();
      } else if (ctor === Object) clone = {}; else {
        if (ctor) return obj;
        clone = Object.create(null);
      }
      enumerateObject(obj, clone, parent);
      return clone;
    }
    instantiate._clone = doInstantiate;
    cc.instantiate = instantiate;
    module.exports = instantiate;
  }), {
    "./CCObject": 161,
    "./attribute": 167,
    "./utils": 179
  } ],
  175: [ (function(require, module, exports) {
    var tempCIDGenerater = new (require("./id-generater"))("TmpCId.");
    function _getPropertyDescriptor(obj, name) {
      while (obj) {
        var pd = Object.getOwnPropertyDescriptor(obj, name);
        if (pd) return pd;
        obj = Object.getPrototypeOf(obj);
      }
      return null;
    }
    function _copyprop(name, source, target) {
      var pd = _getPropertyDescriptor(source, name);
      Object.defineProperty(target, name, pd);
    }
    var js = {
      isNumber: function(obj) {
        return "number" === typeof obj || obj instanceof Number;
      },
      isString: function(obj) {
        return "string" === typeof obj || obj instanceof String;
      },
      addon: function(obj) {
        "use strict";
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5402, source);
              continue;
            }
            for (var name in source) name in obj || _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      mixin: function(obj) {
        "use strict";
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5403, source);
              continue;
            }
            for (var name in source) _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      extend: function(cls, base) {
        false;
        for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
        cls.prototype = Object.create(base.prototype, {
          constructor: {
            value: cls,
            writable: true,
            configurable: true
          }
        });
        return cls;
      },
      getSuper: function(ctor) {
        var proto = ctor.prototype;
        var dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
      },
      isChildClassOf: function(subclass, superclass) {
        if (subclass && superclass) {
          if ("function" !== typeof subclass) return false;
          if ("function" !== typeof superclass) {
            false;
            return false;
          }
          if (subclass === superclass) return true;
          for (;;) {
            subclass = js.getSuper(subclass);
            if (!subclass) return false;
            if (subclass === superclass) return true;
          }
        }
        return false;
      },
      clear: function(obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) delete obj[keys[i]];
      },
      getPropertyDescriptor: _getPropertyDescriptor
    };
    var tmpValueDesc = {
      value: void 0,
      enumerable: false,
      writable: false,
      configurable: true
    };
    js.value = function(obj, prop, value, writable, enumerable) {
      tmpValueDesc.value = value;
      tmpValueDesc.writable = writable;
      tmpValueDesc.enumerable = enumerable;
      Object.defineProperty(obj, prop, tmpValueDesc);
      tmpValueDesc.value = void 0;
    };
    var tmpGetSetDesc = {
      get: null,
      set: null,
      enumerable: false
    };
    js.getset = function(obj, prop, getter, setter, enumerable) {
      if ("function" !== typeof setter) {
        enumerable = setter;
        setter = void 0;
      }
      tmpGetSetDesc.get = getter;
      tmpGetSetDesc.set = setter;
      tmpGetSetDesc.enumerable = enumerable;
      Object.defineProperty(obj, prop, tmpGetSetDesc);
      tmpGetSetDesc.get = null;
      tmpGetSetDesc.set = null;
    };
    var tmpGetDesc = {
      get: null,
      enumerable: false,
      configurable: false
    };
    js.get = function(obj, prop, getter, enumerable, configurable) {
      tmpGetDesc.get = getter;
      tmpGetDesc.enumerable = enumerable;
      tmpGetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpGetDesc);
      tmpGetDesc.get = null;
    };
    var tmpSetDesc = {
      set: null,
      enumerable: false,
      configurable: false
    };
    js.set = function(obj, prop, setter, enumerable, configurable) {
      tmpSetDesc.set = setter;
      tmpSetDesc.enumerable = enumerable;
      tmpSetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpSetDesc);
      tmpSetDesc.set = null;
    };
    js.getClassName = function(objOrCtor) {
      if ("function" === typeof objOrCtor) {
        var prototype = objOrCtor.prototype;
        if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
        var retval = "";
        objOrCtor.name && (retval = objOrCtor.name);
        if (objOrCtor.toString) {
          var arr, str = objOrCtor.toString();
          arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/);
          arr && 2 === arr.length && (retval = arr[1]);
        }
        return "Object" !== retval ? retval : "";
      }
      if (objOrCtor && objOrCtor.constructor) return js.getClassName(objOrCtor.constructor);
      return "";
    };
    function isTempClassId(id) {
      return "string" !== typeof id || id.startsWith(tempCIDGenerater.prefix);
    }
    (function() {
      var _idToClass = {};
      var _nameToClass = {};
      function getRegister(key, table) {
        return function(id, constructor) {
          constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]];
          js.value(constructor.prototype, key, id);
          if (id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
              var error = "A Class already exists with the same " + key + ' : "' + id + '".';
              false;
              cc.error(error);
            } else table[id] = constructor;
          }
        };
      }
      js._setClassId = getRegister("__cid__", _idToClass);
      var doSetClassName = getRegister("__classname__", _nameToClass);
      js.setClassName = function(className, constructor) {
        doSetClassName(className, constructor);
        if (!constructor.prototype.hasOwnProperty("__cid__")) {
          var id = className || tempCIDGenerater.getNewId();
          id && js._setClassId(id, constructor);
        }
      };
      js.unregisterClass = function() {
        for (var i = 0; i < arguments.length; i++) {
          var p = arguments[i].prototype;
          var classId = p.__cid__;
          classId && delete _idToClass[classId];
          var classname = p.__classname__;
          classname && delete _nameToClass[classname];
        }
      };
      js._getClassById = function(classId) {
        return _idToClass[classId];
      };
      js.getClassByName = function(classname) {
        return _nameToClass[classname];
      };
      js._getClassId = function(obj, allowTempId) {
        allowTempId = "undefined" === typeof allowTempId || allowTempId;
        var res;
        if ("function" === typeof obj && obj.prototype.hasOwnProperty("__cid__")) {
          res = obj.prototype.__cid__;
          if (!allowTempId && (false, false) && isTempClassId(res)) return "";
          return res;
        }
        if (obj && obj.constructor) {
          var prototype = obj.constructor.prototype;
          if (prototype && prototype.hasOwnProperty("__cid__")) {
            res = obj.__cid__;
            if (!allowTempId && (false, false) && isTempClassId(res)) return "";
            return res;
          }
        }
        return "";
      };
      false;
    })();
    js.obsolete = function(obj, obsoleted, newExpr, writable) {
      var extractPropName = /([^.]+)$/;
      var oldProp = extractPropName.exec(obsoleted)[0];
      var newProp = extractPropName.exec(newExpr)[0];
      function get() {
        false;
        return this[newProp];
      }
      writable ? js.getset(obj, oldProp, get, (function(value) {
        false;
        this[newProp] = value;
      })) : js.get(obj, oldProp, get);
    };
    js.obsoletes = function(obj, objName, props, writable) {
      for (var obsoleted in props) {
        var newName = props[obsoleted];
        js.obsolete(obj, objName + "." + obsoleted, newName, writable);
      }
    };
    var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
    var REGEXP_STR = /%s/;
    js.formatStr = function() {
      var argLen = arguments.length;
      if (0 === argLen) return "";
      var msg = arguments[0];
      if (1 === argLen) return "" + msg;
      var hasSubstitution = "string" === typeof msg && REGEXP_NUM_OR_STR.test(msg);
      if (hasSubstitution) for (var i = 1; i < argLen; ++i) {
        var arg = arguments[i];
        var regExpToTest = "number" === typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
        regExpToTest.test(msg) ? msg = msg.replace(regExpToTest, arg) : msg += " " + arg;
      } else for (var _i = 1; _i < argLen; ++_i) msg += " " + arguments[_i];
      return msg;
    };
    js.shiftArguments = function() {
      var len = arguments.length - 1;
      var args = new Array(len);
      for (var i = 0; i < len; ++i) args[i] = arguments[i + 1];
      return args;
    };
    js.createMap = function(forceDictMode) {
      var map = Object.create(null);
      if (forceDictMode) {
        var INVALID_IDENTIFIER_1 = ".";
        var INVALID_IDENTIFIER_2 = "/";
        map[INVALID_IDENTIFIER_1] = true;
        map[INVALID_IDENTIFIER_2] = true;
        delete map[INVALID_IDENTIFIER_1];
        delete map[INVALID_IDENTIFIER_2];
      }
      return map;
    };
    function removeAt(array, index) {
      array.splice(index, 1);
    }
    function fastRemoveAt(array, index) {
      var length = array.length;
      if (index < 0 || index >= length) return;
      array[index] = array[length - 1];
      array.length = length - 1;
    }
    function remove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        removeAt(array, index);
        return true;
      }
      return false;
    }
    function fastRemove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        array[index] = array[array.length - 1];
        --array.length;
      }
    }
    function verifyType(array, type) {
      if (array && array.length > 0) for (var i = 0; i < array.length; i++) if (!(array[i] instanceof type)) {
        cc.logID(1300);
        return false;
      }
      return true;
    }
    function removeArray(array, minusArr) {
      for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
    }
    function appendObjectsAt(array, addObjs, index) {
      array.splice.apply(array, [ index, 0 ].concat(addObjs));
      return array;
    }
    var indexOf = Array.prototype.indexOf;
    function contains(array, value) {
      return array.indexOf(value) >= 0;
    }
    function copy(array) {
      var i, len = array.length, arr_clone = new Array(len);
      for (i = 0; i < len; i += 1) arr_clone[i] = array[i];
      return arr_clone;
    }
    js.array = {
      remove: remove,
      fastRemove: fastRemove,
      removeAt: removeAt,
      fastRemoveAt: fastRemoveAt,
      contains: contains,
      verifyType: verifyType,
      removeArray: removeArray,
      appendObjectsAt: appendObjectsAt,
      copy: copy,
      indexOf: indexOf,
      MutableForwardIterator: require("../utils/mutable-forward-iterator")
    };
    function Pool(cleanupFunc, size) {
      if (void 0 === size) {
        size = cleanupFunc;
        cleanupFunc = null;
      }
      this.get = null;
      this.count = 0;
      this._pool = new Array(size);
      this._cleanup = cleanupFunc;
    }
    Pool.prototype._get = function() {
      if (this.count > 0) {
        --this.count;
        var cache = this._pool[this.count];
        this._pool[this.count] = null;
        return cache;
      }
      return null;
    };
    Pool.prototype.put = function(obj) {
      var pool = this._pool;
      if (this.count < pool.length) {
        if (this._cleanup && false === this._cleanup(obj)) return;
        pool[this.count] = obj;
        ++this.count;
      }
    };
    Pool.prototype.resize = function(length) {
      if (length >= 0) {
        this._pool.length = length;
        this.count > length && (this.count = length);
      }
    };
    js.Pool = Pool;
    cc.js = js;
    module.exports = js;
  }), {
    "../utils/mutable-forward-iterator": 234,
    "./id-generater": 171
  } ],
  176: [ (function(require, module, exports) {
    var js = require("./js");
    var SerializableAttrs = {
      url: {
        canUsedInGet: true
      },
      default: {},
      serializable: {},
      editorOnly: {},
      formerlySerializedAs: {}
    };
    var TYPO_TO_CORRECT_DEV = false;
    function parseNotify(val, propName, notify, properties) {
      if (val.get || val.set) {
        false;
        return;
      }
      if (val.hasOwnProperty("default")) {
        var newKey = "_N$" + propName;
        val.get = function() {
          return this[newKey];
        };
        val.set = function(value) {
          var oldValue = this[newKey];
          this[newKey] = value;
          notify.call(this, oldValue);
        };
        var newValue = {};
        properties[newKey] = newValue;
        for (var attr in SerializableAttrs) {
          var v = SerializableAttrs[attr];
          if (val.hasOwnProperty(attr)) {
            newValue[attr] = val[attr];
            v.canUsedInGet || delete val[attr];
          }
        }
      } else false;
    }
    function checkUrl(val, className, propName, url) {
      Array.isArray(url) && url.length > 0 && (url = url[0]);
      false;
      val.type = url;
    }
    function parseType(val, type, className, propName) {
      if (Array.isArray(type)) {
        var isArray;
        false;
        if (!(type.length > 0)) return cc.errorID(5508, className, propName);
        if (cc.RawAsset.isRawAssetType(type[0])) {
          val.url = type[0];
          delete val.type;
          return;
        }
        val.type = type = type[0];
      }
      false;
    }
    function postCheckType(val, type, className, propName) {
      false;
    }
    function getBaseClassWherePropertyDefined_DEV(propName, cls) {
      var res;
      false;
    }
    exports.getFullFormOfProperty = function(options, propname_dev, classname_dev) {
      var isLiteral = options && options.constructor === Object;
      if (!isLiteral) {
        if (Array.isArray(options) && options.length > 0) {
          var type = options[0];
          false;
          return {
            default: [],
            type: options,
            _short: true
          };
        }
        if ("function" === typeof options) {
          var type = options;
          if (!cc.RawAsset.isRawAssetType(type)) {
            if (!cc.RawAsset.wasRawAssetType(type)) return {
              default: js.isChildClassOf(type, cc.ValueType) ? new type() : null,
              type: type,
              _short: true
            };
            false;
          }
          return {
            default: "",
            url: type,
            _short: true
          };
        }
        return {
          default: options,
          _short: true
        };
      }
      return null;
    };
    exports.preprocessAttrs = function(properties, className, cls, es6) {
      for (var propName in properties) {
        var val = properties[propName];
        var fullForm = exports.getFullFormOfProperty(val, propName, className);
        fullForm && (val = properties[propName] = fullForm);
        if (val) {
          var maybeTypeScript;
          false;
          var baseClass;
          false;
          var notify = val.notify;
          if (notify) {
            false;
            parseNotify(val, propName, notify, properties);
          }
          "type" in val && parseType(val, val.type, className, propName);
          "url" in val && checkUrl(val, className, propName, val.url);
          "type" in val && postCheckType(val, val.type, className, propName);
        }
      }
    };
    false;
    exports.validateMethodWithProps = function(func, funcName, className, cls, base) {
      false;
      if ("function" !== typeof func && null !== func) {
        var overrided;
        var baseFuc;
        var subFuc;
        var correct;
        false;
        return false;
      }
      false;
      return true;
    };
  }), {
    "./CCClass": 155,
    "./js": 175
  } ],
  177: [ (function(require, module, exports) {
    var requiringFrames = [];
    cc._RF = {
      push: function(module, uuid, script) {
        if (void 0 === script) {
          script = uuid;
          uuid = "";
        }
        requiringFrames.push({
          uuid: uuid,
          script: script,
          module: module,
          exports: module.exports,
          beh: null
        });
      },
      pop: function() {
        var frameInfo = requiringFrames.pop();
        var module = frameInfo.module;
        var exports = module.exports;
        if (exports === frameInfo.exports) {
          for (var anyKey in exports) return;
          module.exports = exports = frameInfo.cls;
        }
      },
      peek: function() {
        return requiringFrames[requiringFrames.length - 1];
      }
    };
    false;
  }), {} ],
  178: [ (function(require, module, exports) {
    var _mounts = {};
    cc.url = {
      _rawAssets: "",
      _builtinRawAssets: "",
      normalize: function(url) {
        url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1)));
        return url;
      },
      raw: function(url) {
        false;
        url = this.normalize(url);
        if (url.startsWith("resources/")) {
          var uuid = cc.loader._getResUuid(url.slice(10), cc.Asset, true);
          if (uuid) return cc.AssetLibrary.getLibUrlNoExt(uuid) + cc.path.extname(url);
        } else {
          false;
          cc.errorID(7002, url);
        }
        return this._rawAssets + url;
      },
      builtinRaw: false,
      _init: function(mountPaths) {
        for (var dir in mountPaths) {
          var path = mountPaths[dir];
          path = cc.path.stripSep(path) + "/";
          _mounts[dir] = path;
        }
        this._rawAssets = _mounts.assets;
        this._builtinRawAssets = _mounts.internal;
      }
    };
    module.exports = cc.url;
  }), {} ],
  179: [ (function(require, module, exports) {
    module.exports = {
      contains: function(refNode, otherNode) {
        if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
        if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
        var node = otherNode.parentNode;
        if (node) do {
          if (node === refNode) return true;
          node = node.parentNode;
        } while (null !== node);
        return false;
      },
      isDomNode: "object" === typeof window && ("function" === typeof Node ? function(obj) {
        return obj instanceof Node;
      } : function(obj) {
        return obj && "object" === typeof obj && "number" === typeof obj.nodeType && "string" === typeof obj.nodeName;
      }),
      callInNextTick: function(callback, p1, p2) {
        callback && setTimeout((function() {
          callback(p1, p2);
        }), 0);
      }
    };
    false;
    false;
  }), {} ],
  180: [ (function(require, module, exports) {
    require("./platform/js");
    require("./value-types");
    require("./utils");
    require("./platform/CCInputManager");
    require("./platform/CCInputExtension");
    require("./event");
    require("./platform/CCSys");
    require("./platform/CCMacro");
    require("./load-pipeline");
    require("./CCDirector");
    require("./renderer");
    true;
    require("./platform/CCView");
    require("./platform/CCScreen");
    require("./CCScheduler");
    require("./event-manager");
  }), {
    "./CCDirector": 28,
    "./CCScheduler": 33,
    "./event": 102,
    "./event-manager": 98,
    "./load-pipeline": 116,
    "./platform/CCInputExtension": 158,
    "./platform/CCInputManager": 159,
    "./platform/CCMacro": 160,
    "./platform/CCScreen": 163,
    "./platform/CCSys": 164,
    "./platform/CCView": 165,
    "./platform/js": 175,
    "./renderer": 196,
    "./utils": 231,
    "./value-types": 243
  } ],
  181: [ (function(require, module, exports) {
    var js = require("../../platform/js");
    var renderers = require("./renderers");
    var RenderFlow = require("../render-flow");
    var RenderComponentWalker = function(device, defaultCamera) {
      this._device = device;
      this._camera = defaultCamera;
      this.worldMatDirty = 0;
      RenderFlow.init(this);
    };
    RenderComponentWalker.prototype = {
      constructor: RenderComponentWalker,
      reset: function() {},
      _commitComp: function(comp, assembler, cullingMask) {
        var ctx = this._device._ctx;
        var cam = this._camera;
        ctx.setTransform(cam.a, cam.b, cam.c, cam.d, cam.tx, cam.ty);
        assembler.draw(ctx, comp);
      },
      visit: function(scene) {
        var ctx = this._device._ctx;
        var canvas = this._device._canvas;
        var background = cc.Camera.main.backgroundColor;
        ctx.fillStyle = "rgba(" + background.r + ", " + background.g + ", " + background.b + ", " + background.a + ")";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this._device._stats.drawcalls = 0;
        RenderFlow.render(scene);
      }
    };
    module.exports = RenderComponentWalker;
  }), {
    "../../platform/js": 175,
    "../render-flow": 198,
    "./renderers": 186
  } ],
  182: [ (function(require, module, exports) {
    var ForwardRenderer = function() {};
    ForwardRenderer.prototype = {
      constructor: ForwardRenderer,
      _reset: function() {},
      render: function() {}
    };
    module.exports = ForwardRenderer;
  }), {} ],
  183: [ (function(require, module, exports) {
    module.exports = {
      ForwardRenderer: require("./forward-renderer"),
      RenderComponentWalker: require("./canvas-render-walker"),
      _renderers: require("./renderers")
    };
  }), {
    "./canvas-render-walker": 181,
    "./forward-renderer": 182,
    "./renderers": 186
  } ],
  184: [ (function(require, module, exports) {
    var Helper = require("../../../../graphics/helper");
    var Types = require("../../../../graphics/types");
    var PointFlags = Types.PointFlags;
    var LineJoin = Types.LineJoin;
    var LineCap = Types.LineCap;
    class Impl {
      constructor() {
        this.cmds = [];
        this.style = {
          strokeStyle: "black",
          fillStyle: "white",
          lineCap: "butt",
          lineJoin: "miter",
          miterLimit: 10
        };
      }
      set strokeColor(v) {
        var strokeStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
        this.cmds.push([ "strokeStyle", strokeStyle ]);
        this.style.strokeStyle = strokeStyle;
      }
      set fillColor(v) {
        var fillStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
        this.cmds.push([ "fillStyle", fillStyle ]);
        this.style.fillStyle = fillStyle;
      }
      set lineWidth(v) {
        this.cmds.push([ "lineWidth", v ]);
        this.style.lineWidth = v;
      }
      set lineCap(v) {
        var lineCap = "butt";
        v === LineCap.BUTT ? lineCap = "butt" : v === LineCap.ROUND ? lineCap = "round" : v === LineCap.SQUARE && (lineCap = "square");
        this.cmds.push([ "lineCap", lineCap ]);
        this.style.lineCap = lineCap;
      }
      set lineJoin(v) {
        var lineJoin = "bevel";
        v === LineJoin.BEVEL ? lineJoin = "bevel" : v === LineJoin.ROUND ? lineJoin = "round" : v === LineJoin.MITER && (lineJoin = "miter");
        this.cmds.push([ "lineJoin", lineJoin ]);
        this.style.lineJoin = lineJoin;
      }
      set miterLimit(v) {
        this.cmds.push([ "miterLimit", v ]);
        this.style.miterLimit = v;
      }
      moveTo(x, y) {
        this.cmds.push([ "moveTo", [ x, y ] ]);
      }
      lineTo(x, y) {
        this.cmds.push([ "lineTo", [ x, y ] ]);
      }
      bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        this.cmds.push([ "bezierCurveTo", [ c1x, c1y, c2x, c2y, x, y ] ]);
      }
      quadraticCurveTo(cx, cy, x, y) {
        this.cmds.push([ "quadraticCurveTo", [ cx, cy, x, y ] ]);
      }
      arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
      }
      ellipse(cx, cy, rx, ry) {
        Helper.ellipse(this, cx, cy, rx, ry);
      }
      circle(cx, cy, r) {
        Helper.ellipse(this, cx, cy, r, r);
      }
      rect(x, y, w, h) {
        this.moveTo(x, y);
        this.lineTo(x, y + h);
        this.lineTo(x + w, y + h);
        this.lineTo(x + w, y);
        this.close();
      }
      roundRect(x, y, w, h, r) {
        Helper.roundRect(this, x, y, w, h, r);
      }
      clear(comp, clean) {
        this.cmds.length = 0;
      }
      close() {
        this.cmds.push([ "closePath", [] ]);
      }
      stroke() {
        this.cmds.push([ "stroke", [] ]);
      }
      fill() {
        this.cmds.push([ "fill", [] ]);
      }
    }
    module.exports = Impl;
  }), {
    "../../../../graphics/helper": 105,
    "../../../../graphics/types": 107
  } ],
  185: [ (function(require, module, exports) {
    var Impl = require("./impl");
    module.exports = {
      createImpl: function() {
        return new Impl();
      },
      draw: function(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, -ty);
        ctx.save();
        ctx.scale(1, -1);
        ctx.glphaAlpha = node.opacity / 255;
        var style = comp._impl.style;
        ctx.strokeStyle = style.strokeStyle;
        ctx.fillStyle = style.fillStyle;
        ctx.lineWidth = style.lineWidth;
        ctx.lineJoin = style.lineJoin;
        ctx.miterLimit = style.miterLimit;
        var endPath = true;
        var cmds = comp._impl.cmds;
        for (var i = 0, l = cmds.length; i < l; i++) {
          var cmd = cmds[i];
          var ctxCmd = cmd[0], args = cmd[1];
          if ("moveTo" === ctxCmd && endPath) {
            ctx.beginPath();
            endPath = false;
          } else "fill" !== ctxCmd && "stroke" !== ctxCmd && "fillRect" !== ctxCmd || (endPath = true);
          "function" === typeof ctx[ctxCmd] ? ctx[ctxCmd].apply(ctx, args) : ctx[ctxCmd] = args;
        }
        ctx.restore();
        return 1;
      },
      stroke: function(comp) {
        comp._impl.stroke();
      },
      fill: function(comp) {
        comp._impl.fill();
      }
    };
  }), {
    "./impl": 184
  } ],
  186: [ (function(require, module, exports) {
    var js = require("../../../platform/js");
    var Sprite = require("../../../components/CCSprite");
    var Label = require("../../../components/CCLabel");
    var Mask = require("../../../components/CCMask");
    var RichText = require("../../../components/CCRichText");
    var Graphics = require("../../../graphics/graphics");
    var spriteRenderer = require("./sprite");
    var labelRenderer = require("./label");
    var graphicsRenderer = require("./graphics");
    var maskRenderer = require("./mask");
    var map = {};
    var postMap = {};
    function addRenderer(Component, handler, postHandler) {
      var name = js.getClassName(Component);
      map[name] = handler;
      postHandler && (postMap[name] = postHandler);
      Component._assembler = handler;
      Component._postAssembler = postHandler;
    }
    addRenderer(Sprite, spriteRenderer);
    addRenderer(Label, labelRenderer);
    addRenderer(Mask, maskRenderer.beforeHandler, maskRenderer.afterHandler);
    addRenderer(RichText, null);
    addRenderer(Graphics, graphicsRenderer);
    module.exports = {
      map: map,
      postMap: postMap,
      addRenderer: addRenderer
    };
  }), {
    "../../../components/CCLabel": 69,
    "../../../components/CCMask": 72,
    "../../../components/CCRichText": 78,
    "../../../components/CCSprite": 82,
    "../../../graphics/graphics": 104,
    "../../../platform/js": 175,
    "./graphics": 185,
    "./label": 188,
    "./mask": 190,
    "./sprite": 191
  } ],
  187: [ (function(require, module, exports) {
    var bmfontUtils = require("../../../utils/label/bmfont");
    var js = require("../../../../platform/js");
    var utils = require("../utils");
    module.exports = js.addon({
      createData: function(comp) {
        return comp.requestRenderData();
      },
      appendQuad: function(renderData, texture, rect, rotated, x, y, scale) {
        var dataOffset = renderData.dataLength;
        renderData.dataLength += 2;
        var data = renderData._data;
        var texw = texture.width, texh = texture.height;
        var rectWidth = rect.width, rectHeight = rect.height;
        var l = void 0, b = void 0, r = void 0, t = void 0;
        if (rotated) {
          l = rect.x;
          r = rect.x + rectHeight;
          b = rect.y;
          t = rect.y + rectWidth;
          data[dataOffset].u = l;
          data[dataOffset].v = t;
          data[dataOffset + 1].u = l;
          data[dataOffset + 1].v = b;
        } else {
          l = rect.x;
          r = rect.x + rectWidth;
          b = rect.y;
          t = rect.y + rectHeight;
          data[dataOffset].u = l;
          data[dataOffset].v = b;
          data[dataOffset + 1].u = r;
          data[dataOffset + 1].v = t;
        }
        data[dataOffset].x = x;
        data[dataOffset].y = y - rectHeight * scale;
        data[dataOffset + 1].x = x + rectWidth * scale;
        data[dataOffset + 1].y = y;
      },
      draw: function(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, -ty);
        ctx.glphaAlpha = node.opacity / 255;
        var tex = comp._texture, data = comp._renderData._data;
        var image = utils.getColorizedImage(tex, node.color);
        for (var i = 0, l = data.length; i < l; i += 2) {
          var x = data[i].x;
          var y = data[i].y;
          var w = data[i + 1].x - x;
          var h = data[i + 1].y - y;
          y = -y - h;
          var sx = data[i].u;
          var sy = data[i].v;
          var sw = data[i + 1].u - sx;
          var sh = data[i + 1].v - sy;
          ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
        }
        return 1;
      }
    }, bmfontUtils);
  }), {
    "../../../../platform/js": 175,
    "../../../utils/label/bmfont": 201,
    "../utils": 195
  } ],
  188: [ (function(require, module, exports) {
    var ttf = require("./ttf");
    var bmfont = require("./bmfont");
    module.exports = {
      getAssembler: function(comp) {
        var assembler = ttf;
        comp.font instanceof cc.BitmapFont && (assembler = bmfont);
        return assembler;
      },
      createData: function(comp) {
        return comp._assembler.createData(comp);
      },
      draw: function(ctx, comp) {
        if (!comp._texture) return 0;
        var assembler = comp._assembler;
        if (!assembler) return 0;
        assembler.updateRenderData(comp);
        return assembler.draw(ctx, comp);
      }
    };
  }), {
    "./bmfont": 187,
    "./ttf": 189
  } ],
  189: [ (function(require, module, exports) {
    var ttfUtils = require("../../../utils/label/ttf");
    var js = require("../../../../platform/js");
    var utils = require("../utils");
    module.exports = js.addon({
      createData: function(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 2;
        return renderData;
      },
      _updateVerts: function(comp) {
        var renderData = comp._renderData;
        var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var data = renderData._data;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = width - appx;
        data[1].y = height - appy;
      },
      _updateTexture: function(comp) {
        ttfUtils._updateTexture(comp);
        utils.dropColorizedImage(comp._texture, comp.node.color);
      },
      draw: function(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, -ty);
        ctx.glphaAlpha = node.opacity / 255;
        var tex = comp._texture, data = comp._renderData._data;
        var image = utils.getColorizedImage(tex, node.color);
        var x = data[0].x;
        var y = data[0].y;
        var w = data[1].x - x;
        var h = data[1].y - y;
        y = -y - h;
        ctx.drawImage(image, x, y, w, h);
        return 1;
      }
    }, ttfUtils);
  }), {
    "../../../../platform/js": 175,
    "../../../utils/label/ttf": 202,
    "../utils": 195
  } ],
  190: [ (function(require, module, exports) {
    var Node = require("../../../CCNode");
    var Mask = require("../../../components/CCMask");
    var Graphics = require("../../../graphics/graphics");
    var graphicsHandler = require("./graphics");
    var _graphicsPool = [];
    function getGraphics() {
      var graphics = _graphicsPool.pop();
      if (!graphics) {
        var graphicsNode = new Node();
        graphics = graphicsNode.addComponent(Graphics);
        graphics.lineWidth = 0;
      }
      return graphics;
    }
    var beforeHandler = {
      updateRenderData: function(comp) {},
      updateGraphics: function(mask) {
        var node = mask.node;
        var graphics = mask._graphics;
        graphics.clear(false);
        var width = node.width;
        var height = node.height;
        var x = -width * node.anchorX;
        var y = -height * node.anchorY;
        if (mask._type === Mask.Type.RECT) graphics.rect(x, y, width, height); else if (mask._type === Mask.Type.ELLIPSE) {
          var cx = x + width / 2, cy = y + height / 2, rx = width / 2, ry = height / 2;
          graphics.ellipse(cx, cy, rx, ry);
        }
        graphics.stroke();
      },
      draw: function(ctx, mask) {
        var node = mask.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.save();
        ctx.transform(a, b, c, d, tx, -ty);
        mask._graphics = getGraphics();
        this.updateGraphics(mask);
        graphicsHandler.draw(ctx, mask._graphics);
        ctx.clip();
      }
    };
    var afterHandler = {
      updateRenderData: function(comp) {},
      draw: function(ctx, mask) {
        ctx.restore();
      }
    };
    module.exports = {
      beforeHandler: beforeHandler,
      afterHandler: afterHandler
    };
  }), {
    "../../../CCNode": 30,
    "../../../components/CCMask": 72,
    "../../../graphics/graphics": 104,
    "./graphics": 185
  } ],
  191: [ (function(require, module, exports) {
    var Sprite = require("../../../../components/CCSprite");
    var SpriteType = Sprite.Type;
    var FillType = Sprite.FillType;
    var simple = require("./simple");
    var sliced = require("./sliced");
    var tiled = require("./tiled");
    module.exports = {
      getAssembler: function(sprite) {
        switch (sprite.type) {
         case SpriteType.SIMPLE:
          return simple;

         case SpriteType.SLICED:
          return sliced;

         case SpriteType.TILED:
          return tiled;

         case SpriteType.FILLED:
          return sprite._fillType === FillType.RADIAL, null;
        }
      },
      createData: function(sprite) {
        return sprite._assembler.createData(sprite);
      }
    };
  }), {
    "../../../../components/CCSprite": 82,
    "./simple": 192,
    "./sliced": 193,
    "./tiled": 194
  } ],
  192: [ (function(require, module, exports) {
    var utils = require("../utils");
    var renderer = {
      createData: function(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 2;
        return renderData;
      },
      updateRenderData: function(sprite) {
        sprite._material || sprite._activateMaterial();
        var renderData = sprite._renderData;
        renderData.uvDirty && this.updateUVs(sprite);
        renderData.vertDirty && this.updateVerts(sprite);
      },
      updateUVs: function(sprite) {
        var frame = sprite.spriteFrame;
        var renderData = sprite._renderData;
        var data = renderData._data;
        var rect = frame._rect;
        var texture = frame._texture;
        if (frame._rotated) {
          var l = rect.x;
          var r = rect.height;
          var b = rect.y;
          var t = rect.width;
          data[0].u = l;
          data[0].v = t;
          data[1].u = r;
          data[1].v = b;
        } else {
          var _l = rect.x;
          var _r = rect.width;
          var _b = rect.y;
          var _t = rect.height;
          data[0].u = _l;
          data[0].v = _b;
          data[1].u = _r;
          data[1].v = _t;
        }
        renderData.uvDirty = false;
      },
      updateVerts: function(sprite) {
        var renderData = sprite._renderData, node = sprite.node, data = renderData._data, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = void 0, b = void 0, r = void 0, t = void 0;
        if (sprite.trim) {
          l = -appx;
          b = -appy;
          r = cw;
          t = ch;
        } else {
          var frame = sprite.spriteFrame, ow = frame._originalSize.width, oh = frame._originalSize.height, rw = frame._rect.width, rh = frame._rect.height, offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;
          var trimLeft = offset.x + (ow - rw) / 2;
          var trimRight = offset.x - (ow - rw) / 2;
          var trimBottom = offset.y + (oh - rh) / 2;
          var trimTop = offset.y - (oh - rh) / 2;
          l = trimLeft * scaleX - appx;
          b = trimBottom * scaleY - appy;
          r = cw;
          t = ch;
        }
        data[0].x = l;
        data[0].y = b;
        data[1].x = r;
        data[1].y = t;
        renderData.vertDirty = false;
      },
      draw: function(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, -ty);
        ctx.glphaAlpha = node.opacity / 255;
        var tex = comp._spriteFrame._texture, data = comp._renderData._data;
        var image = utils.getColorizedImage(tex, node.color);
        var x = data[0].x;
        var y = data[0].y;
        var w = data[1].x;
        var h = data[1].y;
        y = -y - h;
        var sx = data[0].u;
        var sy = data[0].v;
        var sw = data[1].u;
        var sh = data[1].v;
        ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
        return 1;
      }
    };
    module.exports = renderer;
  }), {
    "../utils": 195
  } ],
  193: [ (function(require, module, exports) {
    var utils = require("../utils");
    var simple = require("./simple");
    var renderer = {
      createData: function(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 4;
        return renderData;
      },
      updateRenderData: simple.updateRenderData,
      updateUVs: function(sprite) {
        var frame = sprite.spriteFrame;
        var renderData = sprite._renderData;
        var rect = frame._rect;
        var texture = frame._texture;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var centerWidth = rect.width - leftWidth - rightWidth;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var centerHeight = rect.height - topHeight - bottomHeight;
        var data = renderData._data;
        if (frame._rotated) {
          data[0].u = rect.x;
          data[1].u = bottomHeight + rect.x;
          data[2].u = bottomHeight + centerHeight + rect.x;
          data[3].u = rect.x + rect.height;
          data[3].v = rect.y;
          data[2].v = leftWidth + rect.y;
          data[1].v = leftWidth + centerWidth + rect.y;
          data[0].v = rect.y + rect.width;
        } else {
          data[0].u = rect.x;
          data[1].u = leftWidth + rect.x;
          data[2].u = leftWidth + centerWidth + rect.x;
          data[3].u = rect.x + rect.width;
          data[3].v = rect.y;
          data[2].v = topHeight + rect.y;
          data[1].v = topHeight + centerHeight + rect.y;
          data[0].v = rect.y + rect.height;
        }
        renderData.uvDirty = false;
      },
      updateVerts: function(sprite) {
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var frame = sprite.spriteFrame;
        var rect = frame._rect;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var sizableWidth = width - leftWidth - rightWidth;
        var sizableHeight = height - topHeight - bottomHeight;
        var xScale = width / (leftWidth + rightWidth);
        var yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
        yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = leftWidth * xScale - appx;
        data[1].y = bottomHeight * yScale - appy;
        data[2].x = data[1].x + sizableWidth;
        data[2].y = data[1].y + sizableHeight;
        data[3].x = width - appx;
        data[3].y = height - appy;
        renderData.vertDirty = false;
      },
      draw: function(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, -ty);
        ctx.glphaAlpha = node.opacity / 255;
        var tex = comp._spriteFrame._texture, data = comp._renderData._data;
        var image = utils.getColorizedImage(tex, node.color);
        var drawCall = 0;
        var off = void 0, ld = void 0, rd = void 0, td = void 0, bd = void 0, x = void 0, y = void 0, w = void 0, h = void 0, sx = void 0, sy = void 0, sw = void 0, sh = void 0;
        for (var r = 0; r < 3; ++r) {
          bd = data[r];
          td = data[r + 1];
          for (var _c = 0; _c < 3; ++_c) {
            ld = data[_c];
            rd = data[_c + 1];
            x = ld.x;
            y = bd.y;
            w = rd.x - x;
            h = td.y - y;
            y = -y - h;
            sx = ld.u;
            sy = td.v;
            sw = rd.u - sx;
            sh = bd.v - sy;
            if (sw > 0 && sh > 0 && w > 0 && h > 0) {
              ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
              drawCall++;
            }
          }
        }
        return drawCall;
      }
    };
    module.exports = renderer;
  }), {
    "../utils": 195,
    "./simple": 192
  } ],
  194: [ (function(require, module, exports) {
    var utils = require("../utils");
    var simple = require("./simple");
    var renderer = {
      createData: function(sprite) {
        var renderData = sprite.requestRenderData();
        return renderData;
      },
      updateRenderData: function(sprite) {
        sprite._material || sprite._activateMaterial();
      },
      draw: function(ctx, sprite) {
        var node = sprite.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        ctx.transform(a, b, c, d, tx, -ty);
        ctx.glphaAlpha = node.opacity / 255;
        var frame = sprite.spriteFrame;
        var rect = frame._rect;
        var tex = frame._texture;
        var sx = rect.x;
        var sy = rect.y;
        var sw = frame._rotated ? rect.height : rect.width;
        var sh = frame._rotated ? rect.width : rect.height;
        var image = utils.getFrameCache(tex, node.color, sx, sy, sw, sh);
        var w = node.width, h = node.height, x = -node.anchorX * w, y = -node.anchorY * h;
        y = -y - h;
        ctx.translate(x, y);
        ctx.fillStyle = ctx.createPattern(image, "repeat");
        ctx.fillRect(0, 0, w, h);
        return 1;
      }
    };
    module.exports = renderer;
  }), {
    "../utils": 195,
    "./simple": 192
  } ],
  195: [ (function(require, module, exports) {
    var WHITE = 16777215;
    var MAX_CANVAS_COUNT = 32;
    function colorizedFrame(canvas, texture, color, sx, sy, sw, sh) {
      if (cc.sys.browserType === cc.sys.BROWSER_TYPE_WECHAT_GAME_SUB) return canvas;
      var image = texture._image;
      var ctx = canvas.getContext("2d");
      canvas.width = sw;
      canvas.height = sh;
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
      ctx.fillRect(0, 0, sw, sh);
      ctx.globalCompositeOperation = "multiply";
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);
      ctx.globalCompositeOperation = "destination-atop";
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);
      return canvas;
    }
    var canvasMgr = {
      canvasMap: {},
      canvasUsed: {},
      canvasPool: [],
      checking: false,
      check: function() {
        var exist = false;
        for (var key in this.canvasUsed) {
          exist = true;
          if (this.canvasUsed[key]) this.canvasUsed[key] = false; else {
            var canvas = this.canvasMap[key];
            canvas.width = 0;
            canvas.height = 0;
            this.canvasPool.length < 32 && this.canvasPool.push(canvas);
            delete this.canvasMap[key];
            delete this.canvasUsed[key];
          }
        }
        if (!exist) {
          cc.director.off(cc.Director.EVENT_AFTER_DRAW, this.check, this);
          this.checking = false;
        }
      },
      startCheck: function() {
        cc.director.on(cc.Director.EVENT_AFTER_DRAW, this.check, this);
        this.checking = true;
      },
      getCanvas: function(key) {
        this.canvasUsed[key] = true;
        return this.canvasMap[key];
      },
      cacheCanvas: function(canvas, key) {
        this.canvasMap[key] = canvas;
        this.canvasUsed[key] = true;
        this.checking || this.startCheck();
      },
      dropImage: function(key) {
        this.canvasMap[key] && delete this.canvasMap[key];
      }
    };
    module.exports = {
      getColorizedImage: function(texture, color) {
        if (!texture || !texture.url) return null;
        var cval = 16777215 & color._val;
        if (cval === WHITE) return texture._image;
        var key = texture.url + cval;
        var cache = canvasMgr.getCanvas(key);
        if (!cache) {
          cache = canvasMgr.canvasPool.pop() || document.createElement("canvas");
          colorizedFrame(cache, texture, color, 0, 0, texture.width, texture.height);
          canvasMgr.cacheCanvas(cache, key);
        }
        return cache;
      },
      getFrameCache: function(texture, color, sx, sy, sw, sh) {
        if (!texture || !texture.url || sx < 0 || sy < 0 || sw <= 0 || sh <= 0) return null;
        var key = texture.url;
        var generate = false;
        var cval = 16777215 & color._val;
        if (cval !== WHITE) {
          key += cval;
          generate = true;
        }
        if (0 !== sx || 0 !== sy && sw !== texture.width && sh !== texture.height) {
          key += "_" + sx + "_" + sy + "_" + sw + "_" + sh;
          generate = true;
        }
        if (!generate) return texture._image;
        var cache = canvasMgr.getCanvas(key);
        if (!cache) {
          cache = canvasMgr.canvasPool.pop() || document.createElement("canvas");
          colorizedFrame(cache, texture, color, sx, sy, sw, sh);
          canvasMgr.cacheCanvas(cache, key);
        }
        return cache;
      },
      dropColorizedImage: function(texture, color) {
        var key = texture.url + (16777215 & color._val);
        canvasMgr.dropImage(key);
      }
    };
  }), {} ],
  196: [ (function(require, module, exports) {
    var renderEngine = require("./render-engine");
    var math = renderEngine.math;
    var _pos = math.vec3.create();
    function _initBuiltins(device) {
      var defaultTexture = new renderEngine.Texture2D(device, {
        images: [],
        width: 128,
        height: 128,
        wrapS: renderEngine.gfx.WRAP_REPEAT,
        wrapT: renderEngine.gfx.WRAP_REPEAT,
        format: renderEngine.gfx.TEXTURE_FMT_RGB8,
        mipmap: false
      });
      return {
        defaultTexture: defaultTexture,
        programTemplates: renderEngine.shaders.templates,
        programChunks: renderEngine.shaders.chunks
      };
    }
    module.exports = {
      renderEngine: renderEngine,
      Texture2D: null,
      canvas: null,
      device: null,
      scene: null,
      drawCalls: 0,
      _walker: null,
      _cameraNode: null,
      _camera: null,
      _forward: null,
      initWebGL: function(canvas, opts) {
        require("./webgl/assemblers");
        var RenderComponentWalker = require("./webgl/render-component-walker");
        this.Texture2D = renderEngine.Texture2D;
        this.canvas = canvas;
        false;
        this.device = new renderEngine.Device(canvas, opts);
        this.scene = new renderEngine.Scene();
        this._walker = new RenderComponentWalker(this.device, this.scene);
        var view;
        false;
        var builtins = _initBuiltins(this.device);
        this._forward = new renderEngine.ForwardRenderer(this.device, builtins);
      },
      initCanvas: function(canvas) {
        var canvasRenderer = require("./canvas");
        this.Texture2D = renderEngine.canvas.Texture2D;
        this.canvas = canvas;
        this.device = new renderEngine.canvas.Device(canvas);
        this._camera = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          tx: 0,
          ty: 0
        };
        this._walker = new canvasRenderer.RenderComponentWalker(this.device, this._camera);
        this._forward = new canvasRenderer.ForwardRenderer();
      },
      updateCameraViewport: function() {
        if (true, cc.director) {
          var ecScene = cc.director.getScene();
          ecScene.scaleX = ecScene.scaleY = 1;
        }
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          var vp = cc.view.getViewportRect();
          this.device.setViewport(vp.x, vp.y, vp.width, vp.height);
          this._camera.a = cc.view.getScaleX();
          this._camera.d = cc.view.getScaleY();
          this._camera.tx = vp.x;
          this._camera.ty = vp.y + vp.height;
        } else {
          var canvas;
          var scaleX;
          var scaleY;
          var node;
          false;
        }
      },
      render: function(ecScene) {
        this.device._stats.drawcalls = 0;
        if (ecScene) {
          this._walker.visit(ecScene);
          this._forward.render(this.scene);
          this.drawCalls = this.device._stats.drawcalls;
        }
      },
      clear: function() {
        this._walker.reset();
        this._forward._reset();
      }
    };
  }), {
    "./canvas": 183,
    "./render-engine": 197,
    "./webgl/assemblers": 206,
    "./webgl/render-component-walker": 221
  } ],
  197: [ (function(require, module, exports) {
    "use strict";
    var _d2r = Math.PI / 180;
    var _r2d = 180 / Math.PI;
    var EPSILON = 1e-6;
    function equals(a, b) {
      return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    function approx(a, b, maxDiff) {
      maxDiff = maxDiff || EPSILON;
      return Math.abs(a - b) <= maxDiff;
    }
    function clamp(val, min, max) {
      return val < min ? min : val > max ? max : val;
    }
    function clamp01(val) {
      return val < 0 ? 0 : val > 1 ? 1 : val;
    }
    function lerp(from, to, ratio) {
      return from + (to - from) * ratio;
    }
    function toRadian(a) {
      return a * _d2r;
    }
    function toDegree(a) {
      return a * _r2d;
    }
    var random = Math.random;
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }
    function randomRangeInt(min, max) {
      return Math.floor(randomRange(min, max));
    }
    function nextPow2(val) {
      --val;
      val |= val >> 1;
      val |= val >> 2;
      val |= val >> 4;
      val |= val >> 8;
      val |= val >> 16;
      ++val;
      return val;
    }
    var INT_BITS = 32;
    var INT_MAX = 2147483647;
    var INT_MIN = -1 << INT_BITS - 1;
    function sign(v) {
      return (v > 0) - (v < 0);
    }
    function abs(v) {
      var mask = v >> INT_BITS - 1;
      return (v ^ mask) - mask;
    }
    function min(x, y) {
      return y ^ (x ^ y) & -(x < y);
    }
    function max(x, y) {
      return x ^ (x ^ y) & -(x < y);
    }
    function isPow2(v) {
      return !(v & v - 1) && !!v;
    }
    function log2(v) {
      var r, shift;
      r = (v > 65535) << 4;
      v >>>= r;
      shift = (v > 255) << 3;
      v >>>= shift;
      r |= shift;
      shift = (v > 15) << 2;
      v >>>= shift;
      r |= shift;
      shift = (v > 3) << 1;
      v >>>= shift;
      r |= shift;
      return r | v >> 1;
    }
    function log10(v) {
      return v >= 1e9 ? 9 : v >= 1e8 ? 8 : v >= 1e7 ? 7 : v >= 1e6 ? 6 : v >= 1e5 ? 5 : v >= 1e4 ? 4 : v >= 1e3 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
    }
    function popCount(v) {
      v -= v >>> 1 & 1431655765;
      v = (858993459 & v) + (v >>> 2 & 858993459);
      return 16843009 * (v + (v >>> 4) & 252645135) >>> 24;
    }
    function countTrailingZeros(v) {
      var c = 32;
      v &= -v;
      v && c--;
      65535 & v && (c -= 16);
      16711935 & v && (c -= 8);
      252645135 & v && (c -= 4);
      858993459 & v && (c -= 2);
      1431655765 & v && (c -= 1);
      return c;
    }
    function nextPow2$1(v) {
      v += 0 === v;
      --v;
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v + 1;
    }
    function prevPow2(v) {
      v |= v >>> 1;
      v |= v >>> 2;
      v |= v >>> 4;
      v |= v >>> 8;
      v |= v >>> 16;
      return v - (v >>> 1);
    }
    function parity(v) {
      v ^= v >>> 16;
      v ^= v >>> 8;
      v ^= v >>> 4;
      v &= 15;
      return 27030 >>> v & 1;
    }
    var REVERSE_TABLE = new Array(256);
    (function(tab) {
      for (var i = 0; i < 256; ++i) {
        var v = i, r = i, s = 7;
        for (v >>>= 1; v; v >>>= 1) {
          r <<= 1;
          r |= 1 & v;
          --s;
        }
        tab[i] = r << s & 255;
      }
    })(REVERSE_TABLE);
    function reverse(v) {
      return REVERSE_TABLE[255 & v] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
    }
    function interleave2(x, y) {
      x &= 65535;
      x = 16711935 & (x | x << 8);
      x = 252645135 & (x | x << 4);
      x = 858993459 & (x | x << 2);
      x = 1431655765 & (x | x << 1);
      y &= 65535;
      y = 16711935 & (y | y << 8);
      y = 252645135 & (y | y << 4);
      y = 858993459 & (y | y << 2);
      y = 1431655765 & (y | y << 1);
      return x | y << 1;
    }
    function deinterleave2(v, n) {
      v = v >>> n & 1431655765;
      v = 858993459 & (v | v >>> 1);
      v = 252645135 & (v | v >>> 2);
      v = 16711935 & (v | v >>> 4);
      v = 65535 & (v | v >>> 16);
      return v << 16 >> 16;
    }
    function interleave3(x, y, z) {
      x &= 1023;
      x = 4278190335 & (x | x << 16);
      x = 251719695 & (x | x << 8);
      x = 3272356035 & (x | x << 4);
      x = 1227133513 & (x | x << 2);
      y &= 1023;
      y = 4278190335 & (y | y << 16);
      y = 251719695 & (y | y << 8);
      y = 3272356035 & (y | y << 4);
      y = 1227133513 & (y | y << 2);
      x |= y << 1;
      z &= 1023;
      z = 4278190335 & (z | z << 16);
      z = 251719695 & (z | z << 8);
      z = 3272356035 & (z | z << 4);
      z = 1227133513 & (z | z << 2);
      return x | z << 2;
    }
    function deinterleave3(v, n) {
      v = v >>> n & 1227133513;
      v = 3272356035 & (v | v >>> 2);
      v = 251719695 & (v | v >>> 4);
      v = 4278190335 & (v | v >>> 8);
      v = 1023 & (v | v >>> 16);
      return v << 22 >> 22;
    }
    function nextCombination(v) {
      var t = v | v - 1;
      return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
    }
    var bits_ = Object.freeze({
      INT_BITS: INT_BITS,
      INT_MAX: INT_MAX,
      INT_MIN: INT_MIN,
      sign: sign,
      abs: abs,
      min: min,
      max: max,
      isPow2: isPow2,
      log2: log2,
      log10: log10,
      popCount: popCount,
      countTrailingZeros: countTrailingZeros,
      nextPow2: nextPow2$1,
      prevPow2: prevPow2,
      parity: parity,
      reverse: reverse,
      interleave2: interleave2,
      deinterleave2: deinterleave2,
      interleave3: interleave3,
      deinterleave3: deinterleave3,
      nextCombination: nextCombination
    });
    var _tmp = new Array(2);
    var _vec2 = function _vec2(x, y) {
      this.x = x;
      this.y = y;
    };
    _vec2.prototype.toJSON = function toJSON() {
      _tmp[0] = this.x;
      _tmp[1] = this.y;
      return _tmp;
    };
    var vec2 = {};
    vec2.create = function() {
      return new _vec2(0, 0);
    };
    vec2.new = function(x, y) {
      return new _vec2(x, y);
    };
    vec2.clone = function(a) {
      return new _vec2(a.x, a.y);
    };
    vec2.copy = function(out, a) {
      out.x = a.x;
      out.y = a.y;
      return out;
    };
    vec2.set = function(out, x, y) {
      out.x = x;
      out.y = y;
      return out;
    };
    vec2.add = function(out, a, b) {
      out.x = a.x + b.x;
      out.y = a.y + b.y;
      return out;
    };
    vec2.subtract = function(out, a, b) {
      out.x = a.x - b.x;
      out.y = a.y - b.y;
      return out;
    };
    vec2.sub = vec2.subtract;
    vec2.multiply = function(out, a, b) {
      out.x = a.x * b.x;
      out.y = a.y * b.y;
      return out;
    };
    vec2.mul = vec2.multiply;
    vec2.divide = function(out, a, b) {
      out.x = a.x / b.x;
      out.y = a.y / b.y;
      return out;
    };
    vec2.div = vec2.divide;
    vec2.ceil = function(out, a) {
      out.x = Math.ceil(a.x);
      out.y = Math.ceil(a.y);
      return out;
    };
    vec2.floor = function(out, a) {
      out.x = Math.floor(a.x);
      out.y = Math.floor(a.y);
      return out;
    };
    vec2.min = function(out, a, b) {
      out.x = Math.min(a.x, b.x);
      out.y = Math.min(a.y, b.y);
      return out;
    };
    vec2.max = function(out, a, b) {
      out.x = Math.max(a.x, b.x);
      out.y = Math.max(a.y, b.y);
      return out;
    };
    vec2.round = function(out, a) {
      out.x = Math.round(a.x);
      out.y = Math.round(a.y);
      return out;
    };
    vec2.scale = function(out, a, b) {
      out.x = a.x * b;
      out.y = a.y * b;
      return out;
    };
    vec2.scaleAndAdd = function(out, a, b, scale) {
      out.x = a.x + b.x * scale;
      out.y = a.y + b.y * scale;
      return out;
    };
    vec2.distance = function(a, b) {
      var x = b.x - a.x, y = b.y - a.y;
      return Math.sqrt(x * x + y * y);
    };
    vec2.dist = vec2.distance;
    vec2.squaredDistance = function(a, b) {
      var x = b.x - a.x, y = b.y - a.y;
      return x * x + y * y;
    };
    vec2.sqrDist = vec2.squaredDistance;
    vec2.length = function(a) {
      var x = a.x, y = a.y;
      return Math.sqrt(x * x + y * y);
    };
    vec2.len = vec2.length;
    vec2.squaredLength = function(a) {
      var x = a.x, y = a.y;
      return x * x + y * y;
    };
    vec2.sqrLen = vec2.squaredLength;
    vec2.negate = function(out, a) {
      out.x = -a.x;
      out.y = -a.y;
      return out;
    };
    vec2.inverse = function(out, a) {
      out.x = 1 / a.x;
      out.y = 1 / a.y;
      return out;
    };
    vec2.inverseSafe = function(out, a) {
      var x = a.x, y = a.y;
      Math.abs(x) < EPSILON ? out.x = 0 : out.x = 1 / x;
      Math.abs(y) < EPSILON ? out.y = 0 : out.y = 1 / a.y;
      return out;
    };
    vec2.normalize = function(out, a) {
      var x = a.x, y = a.y;
      var len = x * x + y * y;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        out.x = a.x * len;
        out.y = a.y * len;
      }
      return out;
    };
    vec2.dot = function(a, b) {
      return a.x * b.x + a.y * b.y;
    };
    vec2.cross = function(out, a, b) {
      var z = a.x * b.y - a.y * b.x;
      out.x = out.y = 0;
      out.z = z;
      return out;
    };
    vec2.lerp = function(out, a, b, t) {
      var ax = a.x, ay = a.y;
      out.x = ax + t * (b.x - ax);
      out.y = ay + t * (b.y - ay);
      return out;
    };
    vec2.random = function(out, scale) {
      scale = scale || 1;
      var r = 2 * random() * Math.PI;
      out.x = Math.cos(r) * scale;
      out.y = Math.sin(r) * scale;
      return out;
    };
    vec2.transformMat2 = function(out, a, m) {
      var x = a.x, y = a.y;
      out.x = m.m00 * x + m.m02 * y;
      out.y = m.m01 * x + m.m03 * y;
      return out;
    };
    vec2.transformMat23 = function(out, a, m) {
      var x = a.x, y = a.y;
      out.x = m.m00 * x + m.m02 * y + m.m04;
      out.y = m.m01 * x + m.m03 * y + m.m05;
      return out;
    };
    vec2.transformMat3 = function(out, a, m) {
      var x = a.x, y = a.y;
      out.x = m.m00 * x + m.m03 * y + m.m06;
      out.y = m.m01 * x + m.m04 * y + m.m07;
      return out;
    };
    vec2.transformMat4 = function(out, a, m) {
      var x = a.x, y = a.y;
      out.x = m.m00 * x + m.m04 * y + m.m12;
      out.y = m.m01 * x + m.m05 * y + m.m13;
      return out;
    };
    vec2.forEach = (function() {
      var vec = vec2.create();
      return function(a, stride, offset, count, fn, arg) {
        var i, l;
        stride || (stride = 2);
        offset || (offset = 0);
        l = count ? Math.min(count * stride + offset, a.length) : a.length;
        for (i = offset; i < l; i += stride) {
          vec.x = a[i];
          vec.y = a[i + 1];
          fn(vec, vec, arg);
          a[i] = vec.x;
          a[i + 1] = vec.y;
        }
        return a;
      };
    })();
    vec2.str = function(a) {
      return "vec2(" + a.x + ", " + a.y + ")";
    };
    vec2.array = function(out, v) {
      out[0] = v.x;
      out[1] = v.y;
      return out;
    };
    vec2.exactEquals = function(a, b) {
      return a.x === b.x && a.y === b.y;
    };
    vec2.equals = function(a, b) {
      var a0 = a.x, a1 = a.y;
      var b0 = b.x, b1 = b.y;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
    };
    var _tmp$1 = new Array(3);
    var _vec3 = function _vec3(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    };
    _vec3.prototype.toJSON = function toJSON() {
      _tmp$1[0] = this.x;
      _tmp$1[1] = this.y;
      _tmp$1[2] = this.z;
      return _tmp$1;
    };
    var vec3 = {};
    vec3.create = function() {
      return new _vec3(0, 0, 0);
    };
    vec3.new = function(x, y, z) {
      return new _vec3(x, y, z);
    };
    vec3.clone = function(a) {
      return new _vec3(a.x, a.y, a.z);
    };
    vec3.copy = function(out, a) {
      out.x = a.x;
      out.y = a.y;
      out.z = a.z;
      return out;
    };
    vec3.set = function(out, x, y, z) {
      out.x = x;
      out.y = y;
      out.z = z;
      return out;
    };
    vec3.add = function(out, a, b) {
      out.x = a.x + b.x;
      out.y = a.y + b.y;
      out.z = a.z + b.z;
      return out;
    };
    vec3.subtract = function(out, a, b) {
      out.x = a.x - b.x;
      out.y = a.y - b.y;
      out.z = a.z - b.z;
      return out;
    };
    vec3.sub = vec3.subtract;
    vec3.multiply = function(out, a, b) {
      out.x = a.x * b.x;
      out.y = a.y * b.y;
      out.z = a.z * b.z;
      return out;
    };
    vec3.mul = vec3.multiply;
    vec3.divide = function(out, a, b) {
      out.x = a.x / b.x;
      out.y = a.y / b.y;
      out.z = a.z / b.z;
      return out;
    };
    vec3.div = vec3.divide;
    vec3.ceil = function(out, a) {
      out.x = Math.ceil(a.x);
      out.y = Math.ceil(a.y);
      out.z = Math.ceil(a.z);
      return out;
    };
    vec3.floor = function(out, a) {
      out.x = Math.floor(a.x);
      out.y = Math.floor(a.y);
      out.z = Math.floor(a.z);
      return out;
    };
    vec3.min = function(out, a, b) {
      out.x = Math.min(a.x, b.x);
      out.y = Math.min(a.y, b.y);
      out.z = Math.min(a.z, b.z);
      return out;
    };
    vec3.max = function(out, a, b) {
      out.x = Math.max(a.x, b.x);
      out.y = Math.max(a.y, b.y);
      out.z = Math.max(a.z, b.z);
      return out;
    };
    vec3.round = function(out, a) {
      out.x = Math.round(a.x);
      out.y = Math.round(a.y);
      out.z = Math.round(a.z);
      return out;
    };
    vec3.scale = function(out, a, b) {
      out.x = a.x * b;
      out.y = a.y * b;
      out.z = a.z * b;
      return out;
    };
    vec3.scaleAndAdd = function(out, a, b, scale) {
      out.x = a.x + b.x * scale;
      out.y = a.y + b.y * scale;
      out.z = a.z + b.z * scale;
      return out;
    };
    vec3.distance = function(a, b) {
      var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
      return Math.sqrt(x * x + y * y + z * z);
    };
    vec3.dist = vec3.distance;
    vec3.squaredDistance = function(a, b) {
      var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z;
      return x * x + y * y + z * z;
    };
    vec3.sqrDist = vec3.squaredDistance;
    vec3.length = function(a) {
      var x = a.x, y = a.y, z = a.z;
      return Math.sqrt(x * x + y * y + z * z);
    };
    vec3.len = vec3.length;
    vec3.squaredLength = function(a) {
      var x = a.x, y = a.y, z = a.z;
      return x * x + y * y + z * z;
    };
    vec3.sqrLen = vec3.squaredLength;
    vec3.negate = function(out, a) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
      return out;
    };
    vec3.inverse = function(out, a) {
      out.x = 1 / a.x;
      out.y = 1 / a.y;
      out.z = 1 / a.z;
      return out;
    };
    vec3.inverseSafe = function(out, a) {
      var x = a.x, y = a.y, z = a.z;
      Math.abs(x) < EPSILON ? out.x = 0 : out.x = 1 / x;
      Math.abs(y) < EPSILON ? out.y = 0 : out.y = 1 / y;
      Math.abs(z) < EPSILON ? out.z = 0 : out.z = 1 / z;
      return out;
    };
    vec3.normalize = function(out, a) {
      var x = a.x, y = a.y, z = a.z;
      var len = x * x + y * y + z * z;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
      }
      return out;
    };
    vec3.dot = function(a, b) {
      return a.x * b.x + a.y * b.y + a.z * b.z;
    };
    vec3.cross = function(out, a, b) {
      var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
      out.x = ay * bz - az * by;
      out.y = az * bx - ax * bz;
      out.z = ax * by - ay * bx;
      return out;
    };
    vec3.lerp = function(out, a, b, t) {
      var ax = a.x, ay = a.y, az = a.z;
      out.x = ax + t * (b.x - ax);
      out.y = ay + t * (b.y - ay);
      out.z = az + t * (b.z - az);
      return out;
    };
    vec3.hermite = function(out, a, b, c, d, t) {
      var factorTimes2 = t * t, factor1 = factorTimes2 * (2 * t - 3) + 1, factor2 = factorTimes2 * (t - 2) + t, factor3 = factorTimes2 * (t - 1), factor4 = factorTimes2 * (3 - 2 * t);
      out.x = a.x * factor1 + b.x * factor2 + c.x * factor3 + d.x * factor4;
      out.y = a.y * factor1 + b.y * factor2 + c.y * factor3 + d.y * factor4;
      out.z = a.z * factor1 + b.z * factor2 + c.z * factor3 + d.z * factor4;
      return out;
    };
    vec3.bezier = function(out, a, b, c, d, t) {
      var inverseFactor = 1 - t, inverseFactorTimesTwo = inverseFactor * inverseFactor, factorTimes2 = t * t, factor1 = inverseFactorTimesTwo * inverseFactor, factor2 = 3 * t * inverseFactorTimesTwo, factor3 = 3 * factorTimes2 * inverseFactor, factor4 = factorTimes2 * t;
      out.x = a.x * factor1 + b.x * factor2 + c.x * factor3 + d.x * factor4;
      out.y = a.y * factor1 + b.y * factor2 + c.y * factor3 + d.y * factor4;
      out.z = a.z * factor1 + b.z * factor2 + c.z * factor3 + d.z * factor4;
      return out;
    };
    vec3.random = function(out, scale) {
      scale = scale || 1;
      var r = 2 * random() * Math.PI;
      var z = 2 * random() - 1;
      var zScale = Math.sqrt(1 - z * z) * scale;
      out.x = Math.cos(r) * zScale;
      out.y = Math.sin(r) * zScale;
      out.z = z * scale;
      return out;
    };
    vec3.transformMat4 = function(out, a, m) {
      var x = a.x, y = a.y, z = a.z, w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15;
      w = w || 1;
      out.x = (m.m00 * x + m.m04 * y + m.m08 * z + m.m12) / w;
      out.y = (m.m01 * x + m.m05 * y + m.m09 * z + m.m13) / w;
      out.z = (m.m02 * x + m.m06 * y + m.m10 * z + m.m14) / w;
      return out;
    };
    vec3.transformMat3 = function(out, a, m) {
      var x = a.x, y = a.y, z = a.z;
      out.x = x * m.m00 + y * m.m03 + z * m.m06;
      out.y = x * m.m01 + y * m.m04 + z * m.m07;
      out.z = x * m.m02 + y * m.m05 + z * m.m08;
      return out;
    };
    vec3.transformQuat = function(out, a, q) {
      var x = a.x, y = a.y, z = a.z;
      var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return out;
    };
    vec3.rotateX = function(out, a, b, c) {
      var p = [], r = [];
      p.x = a.x - b.x;
      p.y = a.y - b.y;
      p.z = a.z - b.z;
      r.x = p.x;
      r.y = p.y * Math.cos(c) - p.z * Math.sin(c);
      r.z = p.y * Math.sin(c) + p.z * Math.cos(c);
      out.x = r.x + b.x;
      out.y = r.y + b.y;
      out.z = r.z + b.z;
      return out;
    };
    vec3.rotateY = function(out, a, b, c) {
      var p = [], r = [];
      p.x = a.x - b.x;
      p.y = a.y - b.y;
      p.z = a.z - b.z;
      r.x = p.z * Math.sin(c) + p.x * Math.cos(c);
      r.y = p.y;
      r.z = p.z * Math.cos(c) - p.x * Math.sin(c);
      out.x = r.x + b.x;
      out.y = r.y + b.y;
      out.z = r.z + b.z;
      return out;
    };
    vec3.rotateZ = function(out, a, b, c) {
      var p = [], r = [];
      p.x = a.x - b.x;
      p.y = a.y - b.y;
      p.z = a.z - b.z;
      r.x = p.x * Math.cos(c) - p.y * Math.sin(c);
      r.y = p.x * Math.sin(c) + p.y * Math.cos(c);
      r.z = p.z;
      out.x = r.x + b.x;
      out.y = r.y + b.y;
      out.z = r.z + b.z;
      return out;
    };
    vec3.forEach = (function() {
      var vec = vec3.create();
      return function(a, stride, offset, count, fn, arg) {
        var i, l;
        stride || (stride = 3);
        offset || (offset = 0);
        l = count ? Math.min(count * stride + offset, a.length) : a.length;
        for (i = offset; i < l; i += stride) {
          vec.x = a[i];
          vec.y = a[i + 1];
          vec.z = a[i + 2];
          fn(vec, vec, arg);
          a[i] = vec.x;
          a[i + 1] = vec.y;
          a[i + 2] = vec.z;
        }
        return a;
      };
    })();
    vec3.angle = (function() {
      var tempA = vec3.create();
      var tempB = vec3.create();
      return function(a, b) {
        vec3.copy(tempA, a);
        vec3.copy(tempB, b);
        vec3.normalize(tempA, tempA);
        vec3.normalize(tempB, tempB);
        var cosine = vec3.dot(tempA, tempB);
        if (cosine > 1) return 0;
        if (cosine < -1) return Math.PI;
        return Math.acos(cosine);
      };
    })();
    vec3.str = function(a) {
      return "vec3(" + a.x + ", " + a.y + ", " + a.z + ")";
    };
    vec3.array = function(out, v) {
      out[0] = v.x;
      out[1] = v.y;
      out[2] = v.z;
      return out;
    };
    vec3.exactEquals = function(a, b) {
      return a.x === b.x && a.y === b.y && a.z === b.z;
    };
    vec3.equals = function(a, b) {
      var a0 = a.x, a1 = a.y, a2 = a.z;
      var b0 = b.x, b1 = b.y, b2 = b.z;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
    };
    var _tmp$2 = new Array(4);
    var _vec4 = function _vec4(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    };
    _vec4.prototype.toJSON = function toJSON() {
      _tmp$2[0] = this.x;
      _tmp$2[1] = this.y;
      _tmp$2[2] = this.z;
      _tmp$2[3] = this.w;
      return _tmp$2;
    };
    var vec4 = {};
    vec4.create = function() {
      return new _vec4(0, 0, 0, 0);
    };
    vec4.new = function(x, y, z, w) {
      return new _vec4(x, y, z, w);
    };
    vec4.clone = function(a) {
      return new _vec4(a.x, a.y, a.z, a.w);
    };
    vec4.copy = function(out, a) {
      out.x = a.x;
      out.y = a.y;
      out.z = a.z;
      out.w = a.w;
      return out;
    };
    vec4.set = function(out, x, y, z, w) {
      out.x = x;
      out.y = y;
      out.z = z;
      out.w = w;
      return out;
    };
    vec4.add = function(out, a, b) {
      out.x = a.x + b.x;
      out.y = a.y + b.y;
      out.z = a.z + b.z;
      out.w = a.w + b.w;
      return out;
    };
    vec4.subtract = function(out, a, b) {
      out.x = a.x - b.x;
      out.y = a.y - b.y;
      out.z = a.z - b.z;
      out.w = a.w - b.w;
      return out;
    };
    vec4.sub = vec4.subtract;
    vec4.multiply = function(out, a, b) {
      out.x = a.x * b.x;
      out.y = a.y * b.y;
      out.z = a.z * b.z;
      out.w = a.w * b.w;
      return out;
    };
    vec4.mul = vec4.multiply;
    vec4.divide = function(out, a, b) {
      out.x = a.x / b.x;
      out.y = a.y / b.y;
      out.z = a.z / b.z;
      out.w = a.w / b.w;
      return out;
    };
    vec4.div = vec4.divide;
    vec4.ceil = function(out, a) {
      out.x = Math.ceil(a.x);
      out.y = Math.ceil(a.y);
      out.z = Math.ceil(a.z);
      out.w = Math.ceil(a.w);
      return out;
    };
    vec4.floor = function(out, a) {
      out.x = Math.floor(a.x);
      out.y = Math.floor(a.y);
      out.z = Math.floor(a.z);
      out.w = Math.floor(a.w);
      return out;
    };
    vec4.min = function(out, a, b) {
      out.x = Math.min(a.x, b.x);
      out.y = Math.min(a.y, b.y);
      out.z = Math.min(a.z, b.z);
      out.w = Math.min(a.w, b.w);
      return out;
    };
    vec4.max = function(out, a, b) {
      out.x = Math.max(a.x, b.x);
      out.y = Math.max(a.y, b.y);
      out.z = Math.max(a.z, b.z);
      out.w = Math.max(a.w, b.w);
      return out;
    };
    vec4.round = function(out, a) {
      out.x = Math.round(a.x);
      out.y = Math.round(a.y);
      out.z = Math.round(a.z);
      out.w = Math.round(a.w);
      return out;
    };
    vec4.scale = function(out, a, b) {
      out.x = a.x * b;
      out.y = a.y * b;
      out.z = a.z * b;
      out.w = a.w * b;
      return out;
    };
    vec4.scaleAndAdd = function(out, a, b, scale) {
      out.x = a.x + b.x * scale;
      out.y = a.y + b.y * scale;
      out.z = a.z + b.z * scale;
      out.w = a.w + b.w * scale;
      return out;
    };
    vec4.distance = function(a, b) {
      var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    };
    vec4.dist = vec4.distance;
    vec4.squaredDistance = function(a, b) {
      var x = b.x - a.x, y = b.y - a.y, z = b.z - a.z, w = b.w - a.w;
      return x * x + y * y + z * z + w * w;
    };
    vec4.sqrDist = vec4.squaredDistance;
    vec4.length = function(a) {
      var x = a.x, y = a.y, z = a.z, w = a.w;
      return Math.sqrt(x * x + y * y + z * z + w * w);
    };
    vec4.len = vec4.length;
    vec4.squaredLength = function(a) {
      var x = a.x, y = a.y, z = a.z, w = a.w;
      return x * x + y * y + z * z + w * w;
    };
    vec4.sqrLen = vec4.squaredLength;
    vec4.negate = function(out, a) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
      out.w = -a.w;
      return out;
    };
    vec4.inverse = function(out, a) {
      out.x = 1 / a.x;
      out.y = 1 / a.y;
      out.z = 1 / a.z;
      out.w = 1 / a.w;
      return out;
    };
    vec4.inverseSafe = function(out, a) {
      var x = a.x, y = a.y, z = a.z, w = a.w;
      Math.abs(x) < EPSILON ? out.x = 0 : out.x = 1 / x;
      Math.abs(y) < EPSILON ? out.y = 0 : out.y = 1 / y;
      Math.abs(z) < EPSILON ? out.z = 0 : out.z = 1 / z;
      Math.abs(w) < EPSILON ? out.w = 0 : out.w = 1 / w;
      return out;
    };
    vec4.normalize = function(out, a) {
      var x = a.x, y = a.y, z = a.z, w = a.w;
      var len = x * x + y * y + z * z + w * w;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
        out.x = x * len;
        out.y = y * len;
        out.z = z * len;
        out.w = w * len;
      }
      return out;
    };
    vec4.dot = function(a, b) {
      return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
    };
    vec4.lerp = function(out, a, b, t) {
      var ax = a.x, ay = a.y, az = a.z, aw = a.w;
      out.x = ax + t * (b.x - ax);
      out.y = ay + t * (b.y - ay);
      out.z = az + t * (b.z - az);
      out.w = aw + t * (b.w - aw);
      return out;
    };
    vec4.random = function(out, scale) {
      scale = scale || 1;
      out.x = random();
      out.y = random();
      out.z = random();
      out.w = random();
      vec4.normalize(out, out);
      vec4.scale(out, out, scale);
      return out;
    };
    vec4.transformMat4 = function(out, a, m) {
      var x = a.x, y = a.y, z = a.z, w = a.w;
      out.x = m.m00 * x + m.m04 * y + m.m08 * z + m.m12 * w;
      out.y = m.m01 * x + m.m05 * y + m.m09 * z + m.m13 * w;
      out.z = m.m02 * x + m.m06 * y + m.m10 * z + m.m14 * w;
      out.w = m.m03 * x + m.m07 * y + m.m11 * z + m.m15 * w;
      return out;
    };
    vec4.transformQuat = function(out, a, q) {
      var x = a.x, y = a.y, z = a.z;
      var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      out.w = a.w;
      return out;
    };
    vec4.forEach = (function() {
      var vec = vec4.create();
      return function(a, stride, offset, count, fn, arg) {
        var i, l;
        stride || (stride = 4);
        offset || (offset = 0);
        l = count ? Math.min(count * stride + offset, a.length) : a.length;
        for (i = offset; i < l; i += stride) {
          vec.x = a[i];
          vec.y = a[i + 1];
          vec.z = a[i + 2];
          vec.w = a[i + 3];
          fn(vec, vec, arg);
          a[i] = vec.x;
          a[i + 1] = vec.y;
          a[i + 2] = vec.z;
          a[i + 3] = vec.w;
        }
        return a;
      };
    })();
    vec4.str = function(a) {
      return "vec4(" + a.x + ", " + a.y + ", " + a.z + ", " + a.w + ")";
    };
    vec4.array = function(out, v) {
      out[0] = v.x;
      out[1] = v.y;
      out[2] = v.z;
      out[3] = v.w;
      return out;
    };
    vec4.exactEquals = function(a, b) {
      return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
    };
    vec4.equals = function(a, b) {
      var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w;
      var b0 = b.x, b1 = b.y, b2 = b.z, b3 = b.w;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
    };
    var _tmp$3 = new Array(9);
    var _mat3 = function _mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
      this.m00 = m00;
      this.m01 = m01;
      this.m02 = m02;
      this.m03 = m03;
      this.m04 = m04;
      this.m05 = m05;
      this.m06 = m06;
      this.m07 = m07;
      this.m08 = m08;
    };
    _mat3.prototype.toJSON = function toJSON() {
      _tmp$3[0] = this.m00;
      _tmp$3[1] = this.m01;
      _tmp$3[2] = this.m02;
      _tmp$3[3] = this.m03;
      _tmp$3[4] = this.m04;
      _tmp$3[5] = this.m05;
      _tmp$3[6] = this.m06;
      _tmp$3[7] = this.m07;
      _tmp$3[8] = this.m08;
      return _tmp$3;
    };
    var mat3 = {};
    mat3.create = function() {
      return new _mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);
    };
    mat3.new = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      return new _mat3(m00, m01, m02, m10, m11, m12, m20, m21, m22);
    };
    mat3.clone = function(a) {
      return new _mat3(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08);
    };
    mat3.copy = function(out, a) {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = a.m02;
      out.m03 = a.m03;
      out.m04 = a.m04;
      out.m05 = a.m05;
      out.m06 = a.m06;
      out.m07 = a.m07;
      out.m08 = a.m08;
      return out;
    };
    mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      out.m00 = m00;
      out.m01 = m01;
      out.m02 = m02;
      out.m03 = m10;
      out.m04 = m11;
      out.m05 = m12;
      out.m06 = m20;
      out.m07 = m21;
      out.m08 = m22;
      return out;
    };
    mat3.identity = function(out) {
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 1;
      out.m05 = 0;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 1;
      return out;
    };
    mat3.transpose = function(out, a) {
      if (out === a) {
        var a01 = a.m01, a02 = a.m02, a12 = a.m05;
        out.m01 = a.m03;
        out.m02 = a.m06;
        out.m03 = a01;
        out.m05 = a.m07;
        out.m06 = a02;
        out.m07 = a12;
      } else {
        out.m00 = a.m00;
        out.m01 = a.m03;
        out.m02 = a.m06;
        out.m03 = a.m01;
        out.m04 = a.m04;
        out.m05 = a.m07;
        out.m06 = a.m02;
        out.m07 = a.m05;
        out.m08 = a.m08;
      }
      return out;
    };
    mat3.invert = function(out, a) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
      var b01 = a22 * a11 - a12 * a21;
      var b11 = -a22 * a10 + a12 * a20;
      var b21 = a21 * a10 - a11 * a20;
      var det = a00 * b01 + a01 * b11 + a02 * b21;
      if (!det) return null;
      det = 1 / det;
      out.m00 = b01 * det;
      out.m01 = (-a22 * a01 + a02 * a21) * det;
      out.m02 = (a12 * a01 - a02 * a11) * det;
      out.m03 = b11 * det;
      out.m04 = (a22 * a00 - a02 * a20) * det;
      out.m05 = (-a12 * a00 + a02 * a10) * det;
      out.m06 = b21 * det;
      out.m07 = (-a21 * a00 + a01 * a20) * det;
      out.m08 = (a11 * a00 - a01 * a10) * det;
      return out;
    };
    mat3.adjoint = function(out, a) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
      out.m00 = a11 * a22 - a12 * a21;
      out.m01 = a02 * a21 - a01 * a22;
      out.m02 = a01 * a12 - a02 * a11;
      out.m03 = a12 * a20 - a10 * a22;
      out.m04 = a00 * a22 - a02 * a20;
      out.m05 = a02 * a10 - a00 * a12;
      out.m06 = a10 * a21 - a11 * a20;
      out.m07 = a01 * a20 - a00 * a21;
      out.m08 = a00 * a11 - a01 * a10;
      return out;
    };
    mat3.determinant = function(a) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
      return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
    };
    mat3.multiply = function(out, a, b) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
      var b00 = b.m00, b01 = b.m01, b02 = b.m02;
      var b10 = b.m03, b11 = b.m04, b12 = b.m05;
      var b20 = b.m06, b21 = b.m07, b22 = b.m08;
      out.m00 = b00 * a00 + b01 * a10 + b02 * a20;
      out.m01 = b00 * a01 + b01 * a11 + b02 * a21;
      out.m02 = b00 * a02 + b01 * a12 + b02 * a22;
      out.m03 = b10 * a00 + b11 * a10 + b12 * a20;
      out.m04 = b10 * a01 + b11 * a11 + b12 * a21;
      out.m05 = b10 * a02 + b11 * a12 + b12 * a22;
      out.m06 = b20 * a00 + b21 * a10 + b22 * a20;
      out.m07 = b20 * a01 + b21 * a11 + b22 * a21;
      out.m08 = b20 * a02 + b21 * a12 + b22 * a22;
      return out;
    };
    mat3.mul = mat3.multiply;
    mat3.translate = function(out, a, v) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
      var x = v.x, y = v.y;
      out.m00 = a00;
      out.m01 = a01;
      out.m02 = a02;
      out.m03 = a10;
      out.m04 = a11;
      out.m05 = a12;
      out.m06 = x * a00 + y * a10 + a20;
      out.m07 = x * a01 + y * a11 + a21;
      out.m08 = x * a02 + y * a12 + a22;
      return out;
    };
    mat3.rotate = function(out, a, rad) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a10 = a.m03, a11 = a.m04, a12 = a.m05, a20 = a.m06, a21 = a.m07, a22 = a.m08;
      var s = Math.sin(rad);
      var c = Math.cos(rad);
      out.m00 = c * a00 + s * a10;
      out.m01 = c * a01 + s * a11;
      out.m02 = c * a02 + s * a12;
      out.m03 = c * a10 - s * a00;
      out.m04 = c * a11 - s * a01;
      out.m05 = c * a12 - s * a02;
      out.m06 = a20;
      out.m07 = a21;
      out.m08 = a22;
      return out;
    };
    mat3.scale = function(out, a, v) {
      var x = v.x, y = v.y;
      out.m00 = x * a.m00;
      out.m01 = x * a.m01;
      out.m02 = x * a.m02;
      out.m03 = y * a.m03;
      out.m04 = y * a.m04;
      out.m05 = y * a.m05;
      out.m06 = a.m06;
      out.m07 = a.m07;
      out.m08 = a.m08;
      return out;
    };
    mat3.fromMat4 = function(out, a) {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = a.m02;
      out.m03 = a.m04;
      out.m04 = a.m05;
      out.m05 = a.m06;
      out.m06 = a.m08;
      out.m07 = a.m09;
      out.m08 = a.m10;
      return out;
    };
    mat3.fromTranslation = function(out, v) {
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 1;
      out.m05 = 0;
      out.m06 = v.x;
      out.m07 = v.y;
      out.m08 = 1;
      return out;
    };
    mat3.fromRotation = function(out, rad) {
      var s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = c;
      out.m01 = s;
      out.m02 = 0;
      out.m03 = -s;
      out.m04 = c;
      out.m05 = 0;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 1;
      return out;
    };
    mat3.fromScaling = function(out, v) {
      out.m00 = v.x;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = v.y;
      out.m05 = 0;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 1;
      return out;
    };
    mat3.fromMat2d = function(out, a) {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = 0;
      out.m03 = a.m02;
      out.m04 = a.m03;
      out.m05 = 0;
      out.m06 = a.m04;
      out.m07 = a.m05;
      out.m08 = 1;
      return out;
    };
    mat3.fromQuat = function(out, q) {
      var x = q.x, y = q.y, z = q.z, w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      out.m00 = 1 - yy - zz;
      out.m03 = yx - wz;
      out.m06 = zx + wy;
      out.m01 = yx + wz;
      out.m04 = 1 - xx - zz;
      out.m07 = zy - wx;
      out.m02 = zx - wy;
      out.m05 = zy + wx;
      out.m08 = 1 - xx - yy;
      return out;
    };
    mat3.fromViewUp = (function() {
      var default_up = vec3.new(0, 1, 0);
      var x = vec3.create();
      var y = vec3.create();
      return function(out, view, up) {
        if (vec3.sqrLen(view) < EPSILON * EPSILON) {
          mat3.identity(out);
          return out;
        }
        up = up || default_up;
        vec3.cross(x, up, view);
        if (vec3.sqrLen(x) < EPSILON * EPSILON) {
          mat3.identity(out);
          return out;
        }
        vec3.cross(y, view, x);
        mat3.set(out, x.x, x.y, x.z, y.x, y.y, y.z, view.x, view.y, view.z);
        return out;
      };
    })();
    mat3.normalFromMat4 = function(out, a) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
      var b00 = a00 * a11 - a01 * a10;
      var b01 = a00 * a12 - a02 * a10;
      var b02 = a00 * a13 - a03 * a10;
      var b03 = a01 * a12 - a02 * a11;
      var b04 = a01 * a13 - a03 * a11;
      var b05 = a02 * a13 - a03 * a12;
      var b06 = a20 * a31 - a21 * a30;
      var b07 = a20 * a32 - a22 * a30;
      var b08 = a20 * a33 - a23 * a30;
      var b09 = a21 * a32 - a22 * a31;
      var b10 = a21 * a33 - a23 * a31;
      var b11 = a22 * a33 - a23 * a32;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) return null;
      det = 1 / det;
      out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out.m01 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out.m02 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out.m03 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out.m04 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out.m05 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out.m06 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out.m07 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out.m08 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      return out;
    };
    mat3.str = function(a) {
      return "mat3(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ", " + a.m04 + ", " + a.m05 + ", " + a.m06 + ", " + a.m07 + ", " + a.m08 + ")";
    };
    mat3.array = function(out, m) {
      out[0] = m.m00;
      out[1] = m.m01;
      out[2] = m.m02;
      out[3] = m.m03;
      out[4] = m.m04;
      out[5] = m.m05;
      out[6] = m.m06;
      out[7] = m.m07;
      out[8] = m.m08;
      return out;
    };
    mat3.frob = function(a) {
      return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + Math.pow(a.m06, 2) + Math.pow(a.m07, 2) + Math.pow(a.m08, 2));
    };
    mat3.add = function(out, a, b) {
      out.m00 = a.m00 + b.m00;
      out.m01 = a.m01 + b.m01;
      out.m02 = a.m02 + b.m02;
      out.m03 = a.m03 + b.m03;
      out.m04 = a.m04 + b.m04;
      out.m05 = a.m05 + b.m05;
      out.m06 = a.m06 + b.m06;
      out.m07 = a.m07 + b.m07;
      out.m08 = a.m08 + b.m08;
      return out;
    };
    mat3.subtract = function(out, a, b) {
      out.m00 = a.m00 - b.m00;
      out.m01 = a.m01 - b.m01;
      out.m02 = a.m02 - b.m02;
      out.m03 = a.m03 - b.m03;
      out.m04 = a.m04 - b.m04;
      out.m05 = a.m05 - b.m05;
      out.m06 = a.m06 - b.m06;
      out.m07 = a.m07 - b.m07;
      out.m08 = a.m08 - b.m08;
      return out;
    };
    mat3.sub = mat3.subtract;
    mat3.multiplyScalar = function(out, a, b) {
      out.m00 = a.m00 * b;
      out.m01 = a.m01 * b;
      out.m02 = a.m02 * b;
      out.m03 = a.m03 * b;
      out.m04 = a.m04 * b;
      out.m05 = a.m05 * b;
      out.m06 = a.m06 * b;
      out.m07 = a.m07 * b;
      out.m08 = a.m08 * b;
      return out;
    };
    mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
      out.m00 = a.m00 + b.m00 * scale;
      out.m01 = a.m01 + b.m01 * scale;
      out.m02 = a.m02 + b.m02 * scale;
      out.m03 = a.m03 + b.m03 * scale;
      out.m04 = a.m04 + b.m04 * scale;
      out.m05 = a.m05 + b.m05 * scale;
      out.m06 = a.m06 + b.m06 * scale;
      out.m07 = a.m07 + b.m07 * scale;
      out.m08 = a.m08 + b.m08 * scale;
      return out;
    };
    mat3.exactEquals = function(a, b) {
      return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08;
    };
    mat3.equals = function(a, b) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07, a8 = a.m08;
      var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07, b8 = b.m08;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
    };
    var _tmp$4 = new Array(4);
    var _quat = function _quat(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    };
    _quat.prototype.toJSON = function toJSON() {
      _tmp$4[0] = this.x;
      _tmp$4[1] = this.y;
      _tmp$4[2] = this.z;
      _tmp$4[3] = this.w;
      return _tmp$4;
    };
    var quat = {};
    quat.create = function() {
      return new _quat(0, 0, 0, 1);
    };
    quat.new = function(x, y, z, w) {
      return new _quat(x, y, z, w);
    };
    quat.clone = function(a) {
      return new _quat(a.x, a.y, a.z, a.w);
    };
    quat.copy = vec4.copy;
    quat.set = vec4.set;
    quat.identity = function(out) {
      out.x = 0;
      out.y = 0;
      out.z = 0;
      out.w = 1;
      return out;
    };
    quat.rotationTo = (function() {
      var tmpvec3 = vec3.create();
      var xUnitVec3 = vec3.new(1, 0, 0);
      var yUnitVec3 = vec3.new(0, 1, 0);
      return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -.999999) {
          vec3.cross(tmpvec3, xUnitVec3, a);
          vec3.length(tmpvec3) < 1e-6 && vec3.cross(tmpvec3, yUnitVec3, a);
          vec3.normalize(tmpvec3, tmpvec3);
          quat.fromAxisAngle(out, tmpvec3, Math.PI);
          return out;
        }
        if (dot > .999999) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          out.w = 1;
          return out;
        }
        vec3.cross(tmpvec3, a, b);
        out.x = tmpvec3.x;
        out.y = tmpvec3.y;
        out.z = tmpvec3.z;
        out.w = 1 + dot;
        return quat.normalize(out, out);
      };
    })();
    quat.getAxisAngle = function(out_axis, q) {
      var rad = 2 * Math.acos(q.w);
      var s = Math.sin(rad / 2);
      if (0 != s) {
        out_axis.x = q.x / s;
        out_axis.y = q.y / s;
        out_axis.z = q.z / s;
      } else {
        out_axis.x = 1;
        out_axis.y = 0;
        out_axis.z = 0;
      }
      return rad;
    };
    quat.multiply = function(out, a, b) {
      var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = b.x, by = b.y, bz = b.z, bw = b.w;
      out.x = ax * bw + aw * bx + ay * bz - az * by;
      out.y = ay * bw + aw * by + az * bx - ax * bz;
      out.z = az * bw + aw * bz + ax * by - ay * bx;
      out.w = aw * bw - ax * bx - ay * by - az * bz;
      return out;
    };
    quat.mul = quat.multiply;
    quat.scale = vec4.scale;
    quat.rotateX = function(out, a, rad) {
      rad *= .5;
      var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = Math.sin(rad), bw = Math.cos(rad);
      out.x = ax * bw + aw * bx;
      out.y = ay * bw + az * bx;
      out.z = az * bw - ay * bx;
      out.w = aw * bw - ax * bx;
      return out;
    };
    quat.rotateY = function(out, a, rad) {
      rad *= .5;
      var ax = a.x, ay = a.y, az = a.z, aw = a.w, by = Math.sin(rad), bw = Math.cos(rad);
      out.x = ax * bw - az * by;
      out.y = ay * bw + aw * by;
      out.z = az * bw + ax * by;
      out.w = aw * bw - ay * by;
      return out;
    };
    quat.rotateZ = function(out, a, rad) {
      rad *= .5;
      var ax = a.x, ay = a.y, az = a.z, aw = a.w, bz = Math.sin(rad), bw = Math.cos(rad);
      out.x = ax * bw + ay * bz;
      out.y = ay * bw - ax * bz;
      out.z = az * bw + aw * bz;
      out.w = aw * bw - az * bz;
      return out;
    };
    quat.rotateAround = (function() {
      var v3_tmp = vec3.create();
      var q_tmp = quat.create();
      return function(out, rot, axis, rad) {
        quat.invert(q_tmp, rot);
        vec3.transformQuat(v3_tmp, axis, q_tmp);
        quat.fromAxisAngle(q_tmp, v3_tmp, rad);
        quat.mul(out, rot, q_tmp);
        return out;
      };
    })();
    quat.rotateAroundLocal = (function() {
      var q_tmp = quat.create();
      return function(out, rot, axis, rad) {
        quat.fromAxisAngle(q_tmp, axis, rad);
        quat.mul(out, rot, q_tmp);
        return out;
      };
    })();
    quat.calculateW = function(out, a) {
      var x = a.x, y = a.y, z = a.z;
      out.x = x;
      out.y = y;
      out.z = z;
      out.w = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
      return out;
    };
    quat.dot = vec4.dot;
    quat.lerp = vec4.lerp;
    quat.slerp = function(out, a, b, t) {
      var ax = a.x, ay = a.y, az = a.z, aw = a.w, bx = b.x, by = b.y, bz = b.z, bw = b.w;
      var omega, cosom, sinom, scale0, scale1;
      cosom = ax * bx + ay * by + az * bz + aw * bw;
      if (cosom < 0) {
        cosom = -cosom;
        bx = -bx;
        by = -by;
        bz = -bz;
        bw = -bw;
      }
      if (1 - cosom > 1e-6) {
        omega = Math.acos(cosom);
        sinom = Math.sin(omega);
        scale0 = Math.sin((1 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
      } else {
        scale0 = 1 - t;
        scale1 = t;
      }
      out.x = scale0 * ax + scale1 * bx;
      out.y = scale0 * ay + scale1 * by;
      out.z = scale0 * az + scale1 * bz;
      out.w = scale0 * aw + scale1 * bw;
      return out;
    };
    quat.sqlerp = (function() {
      var temp1 = quat.create();
      var temp2 = quat.create();
      return function(out, a, b, c, d, t) {
        quat.slerp(temp1, a, d, t);
        quat.slerp(temp2, b, c, t);
        quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
        return out;
      };
    })();
    quat.invert = function(out, a) {
      var a0 = a.x, a1 = a.y, a2 = a.z, a3 = a.w;
      var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
      var invDot = dot ? 1 / dot : 0;
      out.x = -a0 * invDot;
      out.y = -a1 * invDot;
      out.z = -a2 * invDot;
      out.w = a3 * invDot;
      return out;
    };
    quat.conjugate = function(out, a) {
      out.x = -a.x;
      out.y = -a.y;
      out.z = -a.z;
      out.w = a.w;
      return out;
    };
    quat.length = vec4.length;
    quat.len = quat.length;
    quat.squaredLength = vec4.squaredLength;
    quat.sqrLen = quat.squaredLength;
    quat.normalize = vec4.normalize;
    quat.fromAxes = (function() {
      var matr = mat3.create();
      return function(out, xAxis, yAxis, zAxis) {
        mat3.set(matr, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
        return quat.normalize(out, quat.fromMat3(out, matr));
      };
    })();
    quat.fromViewUp = (function() {
      var matr = mat3.create();
      return function(out, view, up) {
        mat3.fromViewUp(matr, view, up);
        if (!matr) return null;
        return quat.normalize(out, quat.fromMat3(out, matr));
      };
    })();
    quat.fromAxisAngle = function(out, axis, rad) {
      rad *= .5;
      var s = Math.sin(rad);
      out.x = s * axis.x;
      out.y = s * axis.y;
      out.z = s * axis.z;
      out.w = Math.cos(rad);
      return out;
    };
    quat.fromMat3 = function(out, m) {
      var m00 = m.m00, m01 = m.m03, m02 = m.m06, m10 = m.m01, m11 = m.m04, m12 = m.m07, m20 = m.m02, m21 = m.m05, m22 = m.m08;
      var trace = m00 + m11 + m22;
      if (trace > 0) {
        var s = .5 / Math.sqrt(trace + 1);
        out.w = .25 / s;
        out.x = (m21 - m12) * s;
        out.y = (m02 - m20) * s;
        out.z = (m10 - m01) * s;
      } else if (m00 > m11 && m00 > m22) {
        var s$1 = 2 * Math.sqrt(1 + m00 - m11 - m22);
        out.w = (m21 - m12) / s$1;
        out.x = .25 * s$1;
        out.y = (m01 + m10) / s$1;
        out.z = (m02 + m20) / s$1;
      } else if (m11 > m22) {
        var s$2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
        out.w = (m02 - m20) / s$2;
        out.x = (m01 + m10) / s$2;
        out.y = .25 * s$2;
        out.z = (m12 + m21) / s$2;
      } else {
        var s$3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
        out.w = (m10 - m01) / s$3;
        out.x = (m02 + m20) / s$3;
        out.y = (m12 + m21) / s$3;
        out.z = .25 * s$3;
      }
      return out;
    };
    quat.fromEuler = function(out, x, y, z) {
      var halfToRad = .5 * Math.PI / 180;
      x *= halfToRad;
      y *= halfToRad;
      z *= halfToRad;
      var sx = Math.sin(x);
      var cx = Math.cos(x);
      var sy = Math.sin(y);
      var cy = Math.cos(y);
      var sz = Math.sin(z);
      var cz = Math.cos(z);
      out.x = sx * cy * cz - cx * sy * sz;
      out.y = cx * sy * cz + sx * cy * sz;
      out.z = cx * cy * sz - sx * sy * cz;
      out.w = cx * cy * cz + sx * sy * sz;
      return out;
    };
    quat.str = function(a) {
      return "quat(" + a.x + ", " + a.y + ", " + a.z + ", " + a.w + ")";
    };
    quat.array = function(out, q) {
      out[0] = q.x;
      out[1] = q.y;
      out[2] = q.z;
      out[3] = q.w;
      return out;
    };
    quat.exactEquals = vec4.exactEquals;
    quat.equals = vec4.equals;
    var _tmp$5 = new Array(4);
    var _mat2 = function _mat2(m00, m01, m02, m03) {
      this.m00 = m00;
      this.m01 = m01;
      this.m02 = m02;
      this.m03 = m03;
    };
    _mat2.prototype.toJSON = function toJSON() {
      _tmp$5[0] = this.m00;
      _tmp$5[1] = this.m01;
      _tmp$5[2] = this.m02;
      _tmp$5[3] = this.m03;
      return _tmp$5;
    };
    var mat2 = {};
    mat2.create = function() {
      return new _mat2(1, 0, 0, 1);
    };
    mat2.new = function(m00, m01, m10, m11) {
      return new _mat2(m00, m01, m10, m11);
    };
    mat2.clone = function(a) {
      return new _mat2(a.m00, a.m01, a.m02, a.m03);
    };
    mat2.copy = function(out, a) {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = a.m02;
      out.m03 = a.m03;
      return out;
    };
    mat2.identity = function(out) {
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 1;
      return out;
    };
    mat2.set = function(out, m00, m01, m10, m11) {
      out.m00 = m00;
      out.m01 = m01;
      out.m02 = m10;
      out.m03 = m11;
      return out;
    };
    mat2.transpose = function(out, a) {
      if (out === a) {
        var a1 = a.m01;
        out.m01 = a.m02;
        out.m02 = a1;
      } else {
        out.m00 = a.m00;
        out.m01 = a.m02;
        out.m02 = a.m01;
        out.m03 = a.m03;
      }
      return out;
    };
    mat2.invert = function(out, a) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
      var det = a0 * a3 - a2 * a1;
      if (!det) return null;
      det = 1 / det;
      out.m00 = a3 * det;
      out.m01 = -a1 * det;
      out.m02 = -a2 * det;
      out.m03 = a0 * det;
      return out;
    };
    mat2.adjoint = function(out, a) {
      var a0 = a.m00;
      out.m00 = a.m03;
      out.m01 = -a.m01;
      out.m02 = -a.m02;
      out.m03 = a0;
      return out;
    };
    mat2.determinant = function(a) {
      return a.m00 * a.m03 - a.m02 * a.m01;
    };
    mat2.multiply = function(out, a, b) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
      var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
      out.m00 = a0 * b0 + a2 * b1;
      out.m01 = a1 * b0 + a3 * b1;
      out.m02 = a0 * b2 + a2 * b3;
      out.m03 = a1 * b2 + a3 * b3;
      return out;
    };
    mat2.mul = mat2.multiply;
    mat2.rotate = function(out, a, rad) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = a0 * c + a2 * s;
      out.m01 = a1 * c + a3 * s;
      out.m02 = a0 * -s + a2 * c;
      out.m03 = a1 * -s + a3 * c;
      return out;
    };
    mat2.scale = function(out, a, v) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, v0 = v.x, v1 = v.y;
      out.m00 = a0 * v0;
      out.m01 = a1 * v0;
      out.m02 = a2 * v1;
      out.m03 = a3 * v1;
      return out;
    };
    mat2.fromRotation = function(out, rad) {
      var s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = c;
      out.m01 = s;
      out.m02 = -s;
      out.m03 = c;
      return out;
    };
    mat2.fromScaling = function(out, v) {
      out.m00 = v.x;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = v.y;
      return out;
    };
    mat2.str = function(a) {
      return "mat2(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ")";
    };
    mat2.array = function(out, m) {
      out[0] = m.m00;
      out[1] = m.m01;
      out[2] = m.m02;
      out[3] = m.m03;
      return out;
    };
    mat2.frob = function(a) {
      return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2));
    };
    mat2.LDU = function(L, D, U, a) {
      L.m02 = a.m02 / a.m00;
      U.m00 = a.m00;
      U.m01 = a.m01;
      U.m03 = a.m03 - L.m02 * U.m01;
    };
    mat2.add = function(out, a, b) {
      out.m00 = a.m00 + b.m00;
      out.m01 = a.m01 + b.m01;
      out.m02 = a.m02 + b.m02;
      out.m03 = a.m03 + b.m03;
      return out;
    };
    mat2.subtract = function(out, a, b) {
      out.m00 = a.m00 - b.m00;
      out.m01 = a.m01 - b.m01;
      out.m02 = a.m02 - b.m02;
      out.m03 = a.m03 - b.m03;
      return out;
    };
    mat2.sub = mat2.subtract;
    mat2.exactEquals = function(a, b) {
      return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03;
    };
    mat2.equals = function(a, b) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03;
      var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
    };
    mat2.multiplyScalar = function(out, a, b) {
      out.m00 = a.m00 * b;
      out.m01 = a.m01 * b;
      out.m02 = a.m02 * b;
      out.m03 = a.m03 * b;
      return out;
    };
    mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
      out.m00 = a.m00 + b.m00 * scale;
      out.m01 = a.m01 + b.m01 * scale;
      out.m02 = a.m02 + b.m02 * scale;
      out.m03 = a.m03 + b.m03 * scale;
      return out;
    };
    var _tmp$6 = new Array(6);
    var _mat23 = function _mat23(m00, m01, m02, m03, m04, m05) {
      this.m00 = m00;
      this.m01 = m01;
      this.m02 = m02;
      this.m03 = m03;
      this.m04 = m04;
      this.m05 = m05;
    };
    _mat23.prototype.toJSON = function toJSON() {
      _tmp$6[0] = this.m00;
      _tmp$6[1] = this.m01;
      _tmp$6[2] = this.m02;
      _tmp$6[3] = this.m03;
      _tmp$6[4] = this.m04;
      _tmp$6[5] = this.m05;
      return _tmp$6;
    };
    var mat23 = {};
    mat23.create = function() {
      return new _mat23(1, 0, 0, 1, 0, 0);
    };
    mat23.new = function(a, b, c, d, tx, ty) {
      return new _mat23(a, b, c, d, tx, ty);
    };
    mat23.clone = function(a) {
      return new _mat23(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05);
    };
    mat23.copy = function(out, a) {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = a.m02;
      out.m03 = a.m03;
      out.m04 = a.m04;
      out.m05 = a.m05;
      return out;
    };
    mat23.identity = function(out) {
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 1;
      out.m04 = 0;
      out.m05 = 0;
      return out;
    };
    mat23.set = function(out, a, b, c, d, tx, ty) {
      out.m00 = a;
      out.m01 = b;
      out.m02 = c;
      out.m03 = d;
      out.m04 = tx;
      out.m05 = ty;
      return out;
    };
    mat23.invert = function(out, a) {
      var aa = a.m00, ab = a.m01, ac = a.m02, ad = a.m03, atx = a.m04, aty = a.m05;
      var det = aa * ad - ab * ac;
      if (!det) return null;
      det = 1 / det;
      out.m00 = ad * det;
      out.m01 = -ab * det;
      out.m02 = -ac * det;
      out.m03 = aa * det;
      out.m04 = (ac * aty - ad * atx) * det;
      out.m05 = (ab * atx - aa * aty) * det;
      return out;
    };
    mat23.determinant = function(a) {
      return a.m00 * a.m03 - a.m01 * a.m02;
    };
    mat23.multiply = function(out, a, b) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05;
      out.m00 = a0 * b0 + a2 * b1;
      out.m01 = a1 * b0 + a3 * b1;
      out.m02 = a0 * b2 + a2 * b3;
      out.m03 = a1 * b2 + a3 * b3;
      out.m04 = a0 * b4 + a2 * b5 + a4;
      out.m05 = a1 * b4 + a3 * b5 + a5;
      return out;
    };
    mat23.mul = mat23.multiply;
    mat23.rotate = function(out, a, rad) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = a0 * c + a2 * s;
      out.m01 = a1 * c + a3 * s;
      out.m02 = a0 * -s + a2 * c;
      out.m03 = a1 * -s + a3 * c;
      out.m04 = a4;
      out.m05 = a5;
      return out;
    };
    mat23.scale = function(out, a, v) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, v0 = v.x, v1 = v.y;
      out.m00 = a0 * v0;
      out.m01 = a1 * v0;
      out.m02 = a2 * v1;
      out.m03 = a3 * v1;
      out.m04 = a4;
      out.m05 = a5;
      return out;
    };
    mat23.translate = function(out, a, v) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, v0 = v.x, v1 = v.y;
      out.m00 = a0;
      out.m01 = a1;
      out.m02 = a2;
      out.m03 = a3;
      out.m04 = a0 * v0 + a2 * v1 + a4;
      out.m05 = a1 * v0 + a3 * v1 + a5;
      return out;
    };
    mat23.fromRotation = function(out, rad) {
      var s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = c;
      out.m01 = s;
      out.m02 = -s;
      out.m03 = c;
      out.m04 = 0;
      out.m05 = 0;
      return out;
    };
    mat23.fromScaling = function(out, v) {
      out.m00 = v.m00;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = v.m01;
      out.m04 = 0;
      out.m05 = 0;
      return out;
    };
    mat23.fromTranslation = function(out, v) {
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 1;
      out.m04 = v.x;
      out.m05 = v.y;
      return out;
    };
    mat23.str = function(a) {
      return "mat23(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ", " + a.m04 + ", " + a.m05 + ")";
    };
    mat23.array = function(out, m) {
      out[0] = m.m00;
      out[1] = m.m01;
      out[2] = m.m02;
      out[3] = m.m03;
      out[4] = m.m04;
      out[5] = m.m05;
      return out;
    };
    mat23.array4x4 = function(out, m) {
      out[0] = m.m00;
      out[1] = m.m01;
      out[2] = 0;
      out[3] = 0;
      out[4] = m.m02;
      out[5] = m.m03;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = m.m04;
      out[13] = m.m05;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    mat23.frob = function(a) {
      return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + 1);
    };
    mat23.add = function(out, a, b) {
      out.m00 = a.m00 + b.m00;
      out.m01 = a.m01 + b.m01;
      out.m02 = a.m02 + b.m02;
      out.m03 = a.m03 + b.m03;
      out.m04 = a.m04 + b.m04;
      out.m05 = a.m05 + b.m05;
      return out;
    };
    mat23.subtract = function(out, a, b) {
      out.m00 = a.m00 - b.m00;
      out.m01 = a.m01 - b.m01;
      out.m02 = a.m02 - b.m02;
      out.m03 = a.m03 - b.m03;
      out.m04 = a.m04 - b.m04;
      out.m05 = a.m05 - b.m05;
      return out;
    };
    mat23.sub = mat23.subtract;
    mat23.multiplyScalar = function(out, a, b) {
      out.m00 = a.m00 * b;
      out.m01 = a.m01 * b;
      out.m02 = a.m02 * b;
      out.m03 = a.m03 * b;
      out.m04 = a.m04 * b;
      out.m05 = a.m05 * b;
      return out;
    };
    mat23.multiplyScalarAndAdd = function(out, a, b, scale) {
      out.m00 = a.m00 + b.m00 * scale;
      out.m01 = a.m01 + b.m01 * scale;
      out.m02 = a.m02 + b.m02 * scale;
      out.m03 = a.m03 + b.m03 * scale;
      out.m04 = a.m04 + b.m04 * scale;
      out.m05 = a.m05 + b.m05 * scale;
      return out;
    };
    mat23.exactEquals = function(a, b) {
      return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05;
    };
    mat23.equals = function(a, b) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05;
      var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5));
    };
    var _tmp$7 = new Array(16);
    var _mat4 = function _mat4(m00, m01, m02, m03, m04, m05, m06, m07, m08, m09, m10, m11, m12, m13, m14, m15) {
      this.m00 = m00;
      this.m01 = m01;
      this.m02 = m02;
      this.m03 = m03;
      this.m04 = m04;
      this.m05 = m05;
      this.m06 = m06;
      this.m07 = m07;
      this.m08 = m08;
      this.m09 = m09;
      this.m10 = m10;
      this.m11 = m11;
      this.m12 = m12;
      this.m13 = m13;
      this.m14 = m14;
      this.m15 = m15;
    };
    _mat4.prototype.toJSON = function toJSON() {
      _tmp$7[0] = this.m00;
      _tmp$7[1] = this.m01;
      _tmp$7[2] = this.m02;
      _tmp$7[3] = this.m03;
      _tmp$7[4] = this.m04;
      _tmp$7[5] = this.m05;
      _tmp$7[6] = this.m06;
      _tmp$7[7] = this.m07;
      _tmp$7[8] = this.m08;
      _tmp$7[9] = this.m09;
      _tmp$7[10] = this.m10;
      _tmp$7[11] = this.m11;
      _tmp$7[12] = this.m12;
      _tmp$7[13] = this.m13;
      _tmp$7[14] = this.m14;
      _tmp$7[15] = this.m15;
      return _tmp$7;
    };
    var mat4 = {};
    mat4.create = function() {
      return new _mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    };
    mat4.new = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      return new _mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
    };
    mat4.clone = function(a) {
      return new _mat4(a.m00, a.m01, a.m02, a.m03, a.m04, a.m05, a.m06, a.m07, a.m08, a.m09, a.m10, a.m11, a.m12, a.m13, a.m14, a.m15);
    };
    mat4.copy = function(out, a) {
      out.m00 = a.m00;
      out.m01 = a.m01;
      out.m02 = a.m02;
      out.m03 = a.m03;
      out.m04 = a.m04;
      out.m05 = a.m05;
      out.m06 = a.m06;
      out.m07 = a.m07;
      out.m08 = a.m08;
      out.m09 = a.m09;
      out.m10 = a.m10;
      out.m11 = a.m11;
      out.m12 = a.m12;
      out.m13 = a.m13;
      out.m14 = a.m14;
      out.m15 = a.m15;
      return out;
    };
    mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      out.m00 = m00;
      out.m01 = m01;
      out.m02 = m02;
      out.m03 = m03;
      out.m04 = m10;
      out.m05 = m11;
      out.m06 = m12;
      out.m07 = m13;
      out.m08 = m20;
      out.m09 = m21;
      out.m10 = m22;
      out.m11 = m23;
      out.m12 = m30;
      out.m13 = m31;
      out.m14 = m32;
      out.m15 = m33;
      return out;
    };
    mat4.identity = function(out) {
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = 1;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = 0;
      out.m10 = 1;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 1;
      return out;
    };
    mat4.transpose = function(out, a) {
      if (out === a) {
        var a01 = a.m01, a02 = a.m02, a03 = a.m03, a12 = a.m06, a13 = a.m07, a23 = a.m11;
        out.m01 = a.m04;
        out.m02 = a.m08;
        out.m03 = a.m12;
        out.m04 = a01;
        out.m06 = a.m09;
        out.m07 = a.m13;
        out.m08 = a02;
        out.m09 = a12;
        out.m11 = a.m14;
        out.m12 = a03;
        out.m13 = a13;
        out.m14 = a23;
      } else {
        out.m00 = a.m00;
        out.m01 = a.m04;
        out.m02 = a.m08;
        out.m03 = a.m12;
        out.m04 = a.m01;
        out.m05 = a.m05;
        out.m06 = a.m09;
        out.m07 = a.m13;
        out.m08 = a.m02;
        out.m09 = a.m06;
        out.m10 = a.m10;
        out.m11 = a.m14;
        out.m12 = a.m03;
        out.m13 = a.m07;
        out.m14 = a.m11;
        out.m15 = a.m15;
      }
      return out;
    };
    mat4.invert = function(out, a) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
      var b00 = a00 * a11 - a01 * a10;
      var b01 = a00 * a12 - a02 * a10;
      var b02 = a00 * a13 - a03 * a10;
      var b03 = a01 * a12 - a02 * a11;
      var b04 = a01 * a13 - a03 * a11;
      var b05 = a02 * a13 - a03 * a12;
      var b06 = a20 * a31 - a21 * a30;
      var b07 = a20 * a32 - a22 * a30;
      var b08 = a20 * a33 - a23 * a30;
      var b09 = a21 * a32 - a22 * a31;
      var b10 = a21 * a33 - a23 * a31;
      var b11 = a22 * a33 - a23 * a32;
      var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) return null;
      det = 1 / det;
      out.m00 = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out.m01 = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out.m02 = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out.m03 = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out.m04 = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out.m05 = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out.m06 = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out.m07 = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out.m08 = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out.m09 = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out.m10 = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out.m11 = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out.m12 = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out.m13 = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out.m14 = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out.m15 = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    };
    mat4.adjoint = function(out, a) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
      out.m00 = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
      out.m01 = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
      out.m02 = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
      out.m03 = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
      out.m04 = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
      out.m05 = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
      out.m06 = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
      out.m07 = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
      out.m08 = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
      out.m09 = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
      out.m10 = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
      out.m11 = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
      out.m12 = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
      out.m13 = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
      out.m14 = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
      out.m15 = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
      return out;
    };
    mat4.determinant = function(a) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
      var b00 = a00 * a11 - a01 * a10;
      var b01 = a00 * a12 - a02 * a10;
      var b02 = a00 * a13 - a03 * a10;
      var b03 = a01 * a12 - a02 * a11;
      var b04 = a01 * a13 - a03 * a11;
      var b05 = a02 * a13 - a03 * a12;
      var b06 = a20 * a31 - a21 * a30;
      var b07 = a20 * a32 - a22 * a30;
      var b08 = a20 * a33 - a23 * a30;
      var b09 = a21 * a32 - a22 * a31;
      var b10 = a21 * a33 - a23 * a31;
      var b11 = a22 * a33 - a23 * a32;
      return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    };
    mat4.multiply = function(out, a, b) {
      var a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11, a30 = a.m12, a31 = a.m13, a32 = a.m14, a33 = a.m15;
      var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03;
      out.m00 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out.m01 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out.m02 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out.m03 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b.m04;
      b1 = b.m05;
      b2 = b.m06;
      b3 = b.m07;
      out.m04 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out.m05 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out.m06 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out.m07 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b.m08;
      b1 = b.m09;
      b2 = b.m10;
      b3 = b.m11;
      out.m08 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out.m09 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out.m10 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out.m11 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b.m12;
      b1 = b.m13;
      b2 = b.m14;
      b3 = b.m15;
      out.m12 = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out.m13 = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out.m14 = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out.m15 = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    };
    mat4.mul = mat4.multiply;
    mat4.translate = function(out, a, v) {
      var x = v.x, y = v.y, z = v.z, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
      if (a === out) {
        out.m12 = a.m00 * x + a.m04 * y + a.m08 * z + a.m12;
        out.m13 = a.m01 * x + a.m05 * y + a.m09 * z + a.m13;
        out.m14 = a.m02 * x + a.m06 * y + a.m10 * z + a.m14;
        out.m15 = a.m03 * x + a.m07 * y + a.m11 * z + a.m15;
      } else {
        a00 = a.m00;
        a01 = a.m01;
        a02 = a.m02;
        a03 = a.m03;
        a10 = a.m04;
        a11 = a.m05;
        a12 = a.m06;
        a13 = a.m07;
        a20 = a.m08;
        a21 = a.m09;
        a22 = a.m10;
        a23 = a.m11;
        out.m00 = a00;
        out.m01 = a01;
        out.m02 = a02;
        out.m03 = a03;
        out.m04 = a10;
        out.m05 = a11;
        out.m06 = a12;
        out.m07 = a13;
        out.m08 = a20;
        out.m09 = a21;
        out.m10 = a22;
        out.m11 = a23;
        out.m12 = a00 * x + a10 * y + a20 * z + a.m12;
        out.m13 = a01 * x + a11 * y + a21 * z + a.m13;
        out.m14 = a02 * x + a12 * y + a22 * z + a.m14;
        out.m15 = a03 * x + a13 * y + a23 * z + a.m15;
      }
      return out;
    };
    mat4.scale = function(out, a, v) {
      var x = v.x, y = v.y, z = v.z;
      out.m00 = a.m00 * x;
      out.m01 = a.m01 * x;
      out.m02 = a.m02 * x;
      out.m03 = a.m03 * x;
      out.m04 = a.m04 * y;
      out.m05 = a.m05 * y;
      out.m06 = a.m06 * y;
      out.m07 = a.m07 * y;
      out.m08 = a.m08 * z;
      out.m09 = a.m09 * z;
      out.m10 = a.m10 * z;
      out.m11 = a.m11 * z;
      out.m12 = a.m12;
      out.m13 = a.m13;
      out.m14 = a.m14;
      out.m15 = a.m15;
      return out;
    };
    mat4.rotate = function(out, a, rad, axis) {
      var x = axis.x, y = axis.y, z = axis.z;
      var s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
      var len = Math.sqrt(x * x + y * y + z * z);
      if (Math.abs(len) < EPSILON) return null;
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c;
      a00 = a.m00;
      a01 = a.m01;
      a02 = a.m02;
      a03 = a.m03;
      a10 = a.m04;
      a11 = a.m05;
      a12 = a.m06;
      a13 = a.m07;
      a20 = a.m08;
      a21 = a.m09;
      a22 = a.m10;
      a23 = a.m11;
      b00 = x * x * t + c;
      b01 = y * x * t + z * s;
      b02 = z * x * t - y * s;
      b10 = x * y * t - z * s;
      b11 = y * y * t + c;
      b12 = z * y * t + x * s;
      b20 = x * z * t + y * s;
      b21 = y * z * t - x * s;
      b22 = z * z * t + c;
      out.m00 = a00 * b00 + a10 * b01 + a20 * b02;
      out.m01 = a01 * b00 + a11 * b01 + a21 * b02;
      out.m02 = a02 * b00 + a12 * b01 + a22 * b02;
      out.m03 = a03 * b00 + a13 * b01 + a23 * b02;
      out.m04 = a00 * b10 + a10 * b11 + a20 * b12;
      out.m05 = a01 * b10 + a11 * b11 + a21 * b12;
      out.m06 = a02 * b10 + a12 * b11 + a22 * b12;
      out.m07 = a03 * b10 + a13 * b11 + a23 * b12;
      out.m08 = a00 * b20 + a10 * b21 + a20 * b22;
      out.m09 = a01 * b20 + a11 * b21 + a21 * b22;
      out.m10 = a02 * b20 + a12 * b21 + a22 * b22;
      out.m11 = a03 * b20 + a13 * b21 + a23 * b22;
      if (a !== out) {
        out.m12 = a.m12;
        out.m13 = a.m13;
        out.m14 = a.m14;
        out.m15 = a.m15;
      }
      return out;
    };
    mat4.rotateX = function(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
      if (a !== out) {
        out.m00 = a.m00;
        out.m01 = a.m01;
        out.m02 = a.m02;
        out.m03 = a.m03;
        out.m12 = a.m12;
        out.m13 = a.m13;
        out.m14 = a.m14;
        out.m15 = a.m15;
      }
      out.m04 = a10 * c + a20 * s;
      out.m05 = a11 * c + a21 * s;
      out.m06 = a12 * c + a22 * s;
      out.m07 = a13 * c + a23 * s;
      out.m08 = a20 * c - a10 * s;
      out.m09 = a21 * c - a11 * s;
      out.m10 = a22 * c - a12 * s;
      out.m11 = a23 * c - a13 * s;
      return out;
    };
    mat4.rotateY = function(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a20 = a.m08, a21 = a.m09, a22 = a.m10, a23 = a.m11;
      if (a !== out) {
        out.m04 = a.m04;
        out.m05 = a.m05;
        out.m06 = a.m06;
        out.m07 = a.m07;
        out.m12 = a.m12;
        out.m13 = a.m13;
        out.m14 = a.m14;
        out.m15 = a.m15;
      }
      out.m00 = a00 * c - a20 * s;
      out.m01 = a01 * c - a21 * s;
      out.m02 = a02 * c - a22 * s;
      out.m03 = a03 * c - a23 * s;
      out.m08 = a00 * s + a20 * c;
      out.m09 = a01 * s + a21 * c;
      out.m10 = a02 * s + a22 * c;
      out.m11 = a03 * s + a23 * c;
      return out;
    };
    mat4.rotateZ = function(out, a, rad) {
      var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m00, a01 = a.m01, a02 = a.m02, a03 = a.m03, a10 = a.m04, a11 = a.m05, a12 = a.m06, a13 = a.m07;
      if (a !== out) {
        out.m08 = a.m08;
        out.m09 = a.m09;
        out.m10 = a.m10;
        out.m11 = a.m11;
        out.m12 = a.m12;
        out.m13 = a.m13;
        out.m14 = a.m14;
        out.m15 = a.m15;
      }
      out.m00 = a00 * c + a10 * s;
      out.m01 = a01 * c + a11 * s;
      out.m02 = a02 * c + a12 * s;
      out.m03 = a03 * c + a13 * s;
      out.m04 = a10 * c - a00 * s;
      out.m05 = a11 * c - a01 * s;
      out.m06 = a12 * c - a02 * s;
      out.m07 = a13 * c - a03 * s;
      return out;
    };
    mat4.fromTranslation = function(out, v) {
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = 1;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = 0;
      out.m10 = 1;
      out.m11 = 0;
      out.m12 = v.x;
      out.m13 = v.y;
      out.m14 = v.z;
      out.m15 = 1;
      return out;
    };
    mat4.fromScaling = function(out, v) {
      out.m00 = v.x;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = v.y;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = 0;
      out.m10 = v.z;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 1;
      return out;
    };
    mat4.fromRotation = function(out, rad, axis) {
      var x = axis.x, y = axis.y, z = axis.z;
      var len = Math.sqrt(x * x + y * y + z * z);
      var s, c, t;
      if (Math.abs(len) < EPSILON) return null;
      len = 1 / len;
      x *= len;
      y *= len;
      z *= len;
      s = Math.sin(rad);
      c = Math.cos(rad);
      t = 1 - c;
      out.m00 = x * x * t + c;
      out.m01 = y * x * t + z * s;
      out.m02 = z * x * t - y * s;
      out.m03 = 0;
      out.m04 = x * y * t - z * s;
      out.m05 = y * y * t + c;
      out.m06 = z * y * t + x * s;
      out.m07 = 0;
      out.m08 = x * z * t + y * s;
      out.m09 = y * z * t - x * s;
      out.m10 = z * z * t + c;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 1;
      return out;
    };
    mat4.fromXRotation = function(out, rad) {
      var s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = 1;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = c;
      out.m06 = s;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = -s;
      out.m10 = c;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 1;
      return out;
    };
    mat4.fromYRotation = function(out, rad) {
      var s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = c;
      out.m01 = 0;
      out.m02 = -s;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = 1;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = s;
      out.m09 = 0;
      out.m10 = c;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 1;
      return out;
    };
    mat4.fromZRotation = function(out, rad) {
      var s = Math.sin(rad), c = Math.cos(rad);
      out.m00 = c;
      out.m01 = s;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = -s;
      out.m05 = c;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = 0;
      out.m10 = 1;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 1;
      return out;
    };
    mat4.fromRT = function(out, q, v) {
      var x = q.x, y = q.y, z = q.z, w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      out.m00 = 1 - (yy + zz);
      out.m01 = xy + wz;
      out.m02 = xz - wy;
      out.m03 = 0;
      out.m04 = xy - wz;
      out.m05 = 1 - (xx + zz);
      out.m06 = yz + wx;
      out.m07 = 0;
      out.m08 = xz + wy;
      out.m09 = yz - wx;
      out.m10 = 1 - (xx + yy);
      out.m11 = 0;
      out.m12 = v.x;
      out.m13 = v.y;
      out.m14 = v.z;
      out.m15 = 1;
      return out;
    };
    mat4.getTranslation = function(out, mat) {
      out.x = mat.m12;
      out.y = mat.m13;
      out.z = mat.m14;
      return out;
    };
    mat4.getScaling = function(out, mat) {
      var m11 = mat.m00, m12 = mat.m01, m13 = mat.m02, m21 = mat.m04, m22 = mat.m05, m23 = mat.m06, m31 = mat.m08, m32 = mat.m09, m33 = mat.m10;
      out.x = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
      out.y = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
      out.z = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
      return out;
    };
    mat4.getRotation = function(out, mat) {
      var trace = mat.m00 + mat.m05 + mat.m10;
      var S = 0;
      if (trace > 0) {
        S = 2 * Math.sqrt(trace + 1);
        out.w = .25 * S;
        out.x = (mat.m06 - mat.m09) / S;
        out.y = (mat.m08 - mat.m02) / S;
        out.z = (mat.m01 - mat.m04) / S;
      } else if (mat.m00 > mat.m05 & mat.m00 > mat.m10) {
        S = 2 * Math.sqrt(1 + mat.m00 - mat.m05 - mat.m10);
        out.w = (mat.m06 - mat.m09) / S;
        out.x = .25 * S;
        out.y = (mat.m01 + mat.m04) / S;
        out.z = (mat.m08 + mat.m02) / S;
      } else if (mat.m05 > mat.m10) {
        S = 2 * Math.sqrt(1 + mat.m05 - mat.m00 - mat.m10);
        out.w = (mat.m08 - mat.m02) / S;
        out.x = (mat.m01 + mat.m04) / S;
        out.y = .25 * S;
        out.z = (mat.m06 + mat.m09) / S;
      } else {
        S = 2 * Math.sqrt(1 + mat.m10 - mat.m00 - mat.m05);
        out.w = (mat.m01 - mat.m04) / S;
        out.x = (mat.m08 + mat.m02) / S;
        out.y = (mat.m06 + mat.m09) / S;
        out.z = .25 * S;
      }
      return out;
    };
    mat4.fromRTS = function(out, q, v, s) {
      var x = q.x, y = q.y, z = q.z, w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      var sx = s.x;
      var sy = s.y;
      var sz = s.z;
      out.m00 = (1 - (yy + zz)) * sx;
      out.m01 = (xy + wz) * sx;
      out.m02 = (xz - wy) * sx;
      out.m03 = 0;
      out.m04 = (xy - wz) * sy;
      out.m05 = (1 - (xx + zz)) * sy;
      out.m06 = (yz + wx) * sy;
      out.m07 = 0;
      out.m08 = (xz + wy) * sz;
      out.m09 = (yz - wx) * sz;
      out.m10 = (1 - (xx + yy)) * sz;
      out.m11 = 0;
      out.m12 = v.x;
      out.m13 = v.y;
      out.m14 = v.z;
      out.m15 = 1;
      return out;
    };
    mat4.fromRTSOrigin = function(out, q, v, s, o) {
      var x = q.x, y = q.y, z = q.z, w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var xy = x * y2;
      var xz = x * z2;
      var yy = y * y2;
      var yz = y * z2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      var sx = s.x;
      var sy = s.y;
      var sz = s.z;
      var ox = o.x;
      var oy = o.y;
      var oz = o.z;
      out.m00 = (1 - (yy + zz)) * sx;
      out.m01 = (xy + wz) * sx;
      out.m02 = (xz - wy) * sx;
      out.m03 = 0;
      out.m04 = (xy - wz) * sy;
      out.m05 = (1 - (xx + zz)) * sy;
      out.m06 = (yz + wx) * sy;
      out.m07 = 0;
      out.m08 = (xz + wy) * sz;
      out.m09 = (yz - wx) * sz;
      out.m10 = (1 - (xx + yy)) * sz;
      out.m11 = 0;
      out.m12 = v.x + ox - (out.m00 * ox + out.m04 * oy + out.m08 * oz);
      out.m13 = v.y + oy - (out.m01 * ox + out.m05 * oy + out.m09 * oz);
      out.m14 = v.z + oz - (out.m02 * ox + out.m06 * oy + out.m10 * oz);
      out.m15 = 1;
      return out;
    };
    mat4.fromQuat = function(out, q) {
      var x = q.x, y = q.y, z = q.z, w = q.w;
      var x2 = x + x;
      var y2 = y + y;
      var z2 = z + z;
      var xx = x * x2;
      var yx = y * x2;
      var yy = y * y2;
      var zx = z * x2;
      var zy = z * y2;
      var zz = z * z2;
      var wx = w * x2;
      var wy = w * y2;
      var wz = w * z2;
      out.m00 = 1 - yy - zz;
      out.m01 = yx + wz;
      out.m02 = zx - wy;
      out.m03 = 0;
      out.m04 = yx - wz;
      out.m05 = 1 - xx - zz;
      out.m06 = zy + wx;
      out.m07 = 0;
      out.m08 = zx + wy;
      out.m09 = zy - wx;
      out.m10 = 1 - xx - yy;
      out.m11 = 0;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 0;
      out.m15 = 1;
      return out;
    };
    mat4.frustum = function(out, left, right, bottom, top, near, far) {
      var rl = 1 / (right - left);
      var tb = 1 / (top - bottom);
      var nf = 1 / (near - far);
      out.m00 = 2 * near * rl;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = 2 * near * tb;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = (right + left) * rl;
      out.m09 = (top + bottom) * tb;
      out.m10 = (far + near) * nf;
      out.m11 = -1;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = far * near * 2 * nf;
      out.m15 = 0;
      return out;
    };
    mat4.perspective = function(out, fovy, aspect, near, far) {
      var f = 1 / Math.tan(fovy / 2);
      var nf = 1 / (near - far);
      out.m00 = f / aspect;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = f;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = 0;
      out.m10 = (far + near) * nf;
      out.m11 = -1;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = 2 * far * near * nf;
      out.m15 = 0;
      return out;
    };
    mat4.perspectiveFromFieldOfView = function(out, fov, near, far) {
      var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
      var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
      var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
      var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
      var xScale = 2 / (leftTan + rightTan);
      var yScale = 2 / (upTan + downTan);
      out.m00 = xScale;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = yScale;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = -(leftTan - rightTan) * xScale * .5;
      out.m09 = (upTan - downTan) * yScale * .5;
      out.m10 = far / (near - far);
      out.m11 = -1;
      out.m12 = 0;
      out.m13 = 0;
      out.m14 = far * near / (near - far);
      out.m15 = 0;
      return out;
    };
    mat4.ortho = function(out, left, right, bottom, top, near, far) {
      var lr = 1 / (left - right);
      var bt = 1 / (bottom - top);
      var nf = 1 / (near - far);
      out.m00 = -2 * lr;
      out.m01 = 0;
      out.m02 = 0;
      out.m03 = 0;
      out.m04 = 0;
      out.m05 = -2 * bt;
      out.m06 = 0;
      out.m07 = 0;
      out.m08 = 0;
      out.m09 = 0;
      out.m10 = 2 * nf;
      out.m11 = 0;
      out.m12 = (left + right) * lr;
      out.m13 = (top + bottom) * bt;
      out.m14 = (far + near) * nf;
      out.m15 = 1;
      return out;
    };
    mat4.lookAt = function(out, eye, center, up) {
      var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
      var eyex = eye.x;
      var eyey = eye.y;
      var eyez = eye.z;
      var upx = up.x;
      var upy = up.y;
      var upz = up.z;
      var centerx = center.x;
      var centery = center.y;
      var centerz = center.z;
      if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) return mat4.identity(out);
      z0 = eyex - centerx;
      z1 = eyey - centery;
      z2 = eyez - centerz;
      len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
      z0 *= len;
      z1 *= len;
      z2 *= len;
      x0 = upy * z2 - upz * z1;
      x1 = upz * z0 - upx * z2;
      x2 = upx * z1 - upy * z0;
      len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
      if (len) {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
      } else {
        x0 = 0;
        x1 = 0;
        x2 = 0;
      }
      y0 = z1 * x2 - z2 * x1;
      y1 = z2 * x0 - z0 * x2;
      y2 = z0 * x1 - z1 * x0;
      len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
      if (len) {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
      } else {
        y0 = 0;
        y1 = 0;
        y2 = 0;
      }
      out.m00 = x0;
      out.m01 = y0;
      out.m02 = z0;
      out.m03 = 0;
      out.m04 = x1;
      out.m05 = y1;
      out.m06 = z1;
      out.m07 = 0;
      out.m08 = x2;
      out.m09 = y2;
      out.m10 = z2;
      out.m11 = 0;
      out.m12 = -(x0 * eyex + x1 * eyey + x2 * eyez);
      out.m13 = -(y0 * eyex + y1 * eyey + y2 * eyez);
      out.m14 = -(z0 * eyex + z1 * eyey + z2 * eyez);
      out.m15 = 1;
      return out;
    };
    mat4.str = function(a) {
      return "mat4(" + a.m00 + ", " + a.m01 + ", " + a.m02 + ", " + a.m03 + ", " + a.m04 + ", " + a.m05 + ", " + a.m06 + ", " + a.m07 + ", " + a.m08 + ", " + a.m09 + ", " + a.m10 + ", " + a.m11 + ", " + a.m12 + ", " + a.m13 + ", " + a.m14 + ", " + a.m15 + ")";
    };
    mat4.array = function(out, m) {
      out[0] = m.m00;
      out[1] = m.m01;
      out[2] = m.m02;
      out[3] = m.m03;
      out[4] = m.m04;
      out[5] = m.m05;
      out[6] = m.m06;
      out[7] = m.m07;
      out[8] = m.m08;
      out[9] = m.m09;
      out[10] = m.m10;
      out[11] = m.m11;
      out[12] = m.m12;
      out[13] = m.m13;
      out[14] = m.m14;
      out[15] = m.m15;
      return out;
    };
    mat4.frob = function(a) {
      return Math.sqrt(Math.pow(a.m00, 2) + Math.pow(a.m01, 2) + Math.pow(a.m02, 2) + Math.pow(a.m03, 2) + Math.pow(a.m04, 2) + Math.pow(a.m05, 2) + Math.pow(a.m06, 2) + Math.pow(a.m07, 2) + Math.pow(a.m08, 2) + Math.pow(a.m09, 2) + Math.pow(a.m10, 2) + Math.pow(a.m11, 2) + Math.pow(a.m12, 2) + Math.pow(a.m13, 2) + Math.pow(a.m14, 2) + Math.pow(a.m15, 2));
    };
    mat4.add = function(out, a, b) {
      out.m00 = a.m00 + b.m00;
      out.m01 = a.m01 + b.m01;
      out.m02 = a.m02 + b.m02;
      out.m03 = a.m03 + b.m03;
      out.m04 = a.m04 + b.m04;
      out.m05 = a.m05 + b.m05;
      out.m06 = a.m06 + b.m06;
      out.m07 = a.m07 + b.m07;
      out.m08 = a.m08 + b.m08;
      out.m09 = a.m09 + b.m09;
      out.m10 = a.m10 + b.m10;
      out.m11 = a.m11 + b.m11;
      out.m12 = a.m12 + b.m12;
      out.m13 = a.m13 + b.m13;
      out.m14 = a.m14 + b.m14;
      out.m15 = a.m15 + b.m15;
      return out;
    };
    mat4.subtract = function(out, a, b) {
      out.m00 = a.m00 - b.m00;
      out.m01 = a.m01 - b.m01;
      out.m02 = a.m02 - b.m02;
      out.m03 = a.m03 - b.m03;
      out.m04 = a.m04 - b.m04;
      out.m05 = a.m05 - b.m05;
      out.m06 = a.m06 - b.m06;
      out.m07 = a.m07 - b.m07;
      out.m08 = a.m08 - b.m08;
      out.m09 = a.m09 - b.m09;
      out.m10 = a.m10 - b.m10;
      out.m11 = a.m11 - b.m11;
      out.m12 = a.m12 - b.m12;
      out.m13 = a.m13 - b.m13;
      out.m14 = a.m14 - b.m14;
      out.m15 = a.m15 - b.m15;
      return out;
    };
    mat4.sub = mat4.subtract;
    mat4.multiplyScalar = function(out, a, b) {
      out.m00 = a.m00 * b;
      out.m01 = a.m01 * b;
      out.m02 = a.m02 * b;
      out.m03 = a.m03 * b;
      out.m04 = a.m04 * b;
      out.m05 = a.m05 * b;
      out.m06 = a.m06 * b;
      out.m07 = a.m07 * b;
      out.m08 = a.m08 * b;
      out.m09 = a.m09 * b;
      out.m10 = a.m10 * b;
      out.m11 = a.m11 * b;
      out.m12 = a.m12 * b;
      out.m13 = a.m13 * b;
      out.m14 = a.m14 * b;
      out.m15 = a.m15 * b;
      return out;
    };
    mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
      out.m00 = a.m00 + b.m00 * scale;
      out.m01 = a.m01 + b.m01 * scale;
      out.m02 = a.m02 + b.m02 * scale;
      out.m03 = a.m03 + b.m03 * scale;
      out.m04 = a.m04 + b.m04 * scale;
      out.m05 = a.m05 + b.m05 * scale;
      out.m06 = a.m06 + b.m06 * scale;
      out.m07 = a.m07 + b.m07 * scale;
      out.m08 = a.m08 + b.m08 * scale;
      out.m09 = a.m09 + b.m09 * scale;
      out.m10 = a.m10 + b.m10 * scale;
      out.m11 = a.m11 + b.m11 * scale;
      out.m12 = a.m12 + b.m12 * scale;
      out.m13 = a.m13 + b.m13 * scale;
      out.m14 = a.m14 + b.m14 * scale;
      out.m15 = a.m15 + b.m15 * scale;
      return out;
    };
    mat4.exactEquals = function(a, b) {
      return a.m00 === b.m00 && a.m01 === b.m01 && a.m02 === b.m02 && a.m03 === b.m03 && a.m04 === b.m04 && a.m05 === b.m05 && a.m06 === b.m06 && a.m07 === b.m07 && a.m08 === b.m08 && a.m09 === b.m09 && a.m10 === b.m10 && a.m11 === b.m11 && a.m12 === b.m12 && a.m13 === b.m13 && a.m14 === b.m14 && a.m15 === b.m15;
    };
    mat4.equals = function(a, b) {
      var a0 = a.m00, a1 = a.m01, a2 = a.m02, a3 = a.m03, a4 = a.m04, a5 = a.m05, a6 = a.m06, a7 = a.m07, a8 = a.m08, a9 = a.m09, a10 = a.m10, a11 = a.m11, a12 = a.m12, a13 = a.m13, a14 = a.m14, a15 = a.m15;
      var b0 = b.m00, b1 = b.m01, b2 = b.m02, b3 = b.m03, b4 = b.m04, b5 = b.m05, b6 = b.m06, b7 = b.m07, b8 = b.m08, b9 = b.m09, b10 = b.m10, b11 = b.m11, b12 = b.m12, b13 = b.m13, b14 = b.m14, b15 = b.m15;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
    };
    var _tmp$8 = new Array(3);
    var _color3 = function _color3(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    };
    _color3.prototype.toJSON = function toJSON() {
      _tmp$8[0] = this.r;
      _tmp$8[1] = this.g;
      _tmp$8[2] = this.b;
      return _tmp$8;
    };
    var color3 = {};
    color3.create = function() {
      return new _color3(1, 1, 1);
    };
    color3.new = function(r, g, b) {
      return new _color3(r, g, b);
    };
    color3.clone = function(a) {
      return new _color3(a.r, a.g, a.b, a.a);
    };
    color3.copy = function(out, a) {
      out.r = a.r;
      out.g = a.g;
      out.b = a.b;
      return out;
    };
    color3.set = function(out, r, g, b) {
      out.r = r;
      out.g = g;
      out.b = b;
      return out;
    };
    color3.fromHex = function(out, hex) {
      var r = (hex >> 16) / 255;
      var g = (hex >> 8 & 255) / 255;
      var b = (255 & hex) / 255;
      out.r = r;
      out.g = g;
      out.b = b;
      return out;
    };
    color3.add = function(out, a, b) {
      out.r = a.r + b.r;
      out.g = a.g + b.g;
      out.b = a.b + b.b;
      return out;
    };
    color3.subtract = function(out, a, b) {
      out.r = a.r - b.r;
      out.g = a.g - b.g;
      out.b = a.b - b.b;
      return out;
    };
    color3.sub = color3.subtract;
    color3.multiply = function(out, a, b) {
      out.r = a.r * b.r;
      out.g = a.g * b.g;
      out.b = a.b * b.b;
      return out;
    };
    color3.mul = color3.multiply;
    color3.divide = function(out, a, b) {
      out.r = a.r / b.r;
      out.g = a.g / b.g;
      out.b = a.b / b.b;
      return out;
    };
    color3.div = color3.divide;
    color3.scale = function(out, a, b) {
      out.r = a.r * b;
      out.g = a.g * b;
      out.b = a.b * b;
      return out;
    };
    color3.lerp = function(out, a, b, t) {
      var ar = a.r, ag = a.g, ab = a.b;
      out.r = ar + t * (b.r - ar);
      out.g = ag + t * (b.g - ag);
      out.b = ab + t * (b.b - ab);
      return out;
    };
    color3.str = function(a) {
      return "color3(" + a.r + ", " + a.g + ", " + a.b + ")";
    };
    color3.array = function(out, a) {
      out[0] = a.r;
      out[1] = a.g;
      out[2] = a.b;
      return out;
    };
    color3.exactEquals = function(a, b) {
      return a.r === b.r && a.g === b.g && a.b === b.b;
    };
    color3.equals = function(a, b) {
      var a0 = a.r, a1 = a.g, a2 = a.b;
      var b0 = b.r, b1 = b.g, b2 = b.b;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
    };
    color3.hex = function(a) {
      return 255 * a.r << 16 | 255 * a.g << 8 | 255 * a.b;
    };
    var _tmp$9 = new Array(4);
    var _color4 = function _color4(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    };
    _color4.prototype.toJSON = function toJSON() {
      _tmp$9[0] = this.r;
      _tmp$9[1] = this.g;
      _tmp$9[2] = this.b;
      _tmp$9[3] = this.a;
      return _tmp$9;
    };
    var color4 = {};
    color4.create = function() {
      return new _color4(1, 1, 1, 1);
    };
    color4.new = function(r, g, b, a) {
      return new _color4(r, g, b, a);
    };
    color4.clone = function(a) {
      return new _color4(a.r, a.g, a.b, a.a);
    };
    color4.copy = function(out, a) {
      out.r = a.r;
      out.g = a.g;
      out.b = a.b;
      out.a = a.a;
      return out;
    };
    color4.set = function(out, r, g, b, a) {
      out.r = r;
      out.g = g;
      out.b = b;
      out.a = a;
      return out;
    };
    color4.fromHex = function(out, hex) {
      var r = (hex >> 24) / 255;
      var g = (hex >> 16 & 255) / 255;
      var b = (hex >> 8 & 255) / 255;
      var a = (255 & hex) / 255;
      out.r = r;
      out.g = g;
      out.b = b;
      out.a = a;
      return out;
    };
    color4.add = function(out, a, b) {
      out.r = a.r + b.r;
      out.g = a.g + b.g;
      out.b = a.b + b.b;
      out.a = a.a + b.a;
      return out;
    };
    color4.subtract = function(out, a, b) {
      out.r = a.r - b.r;
      out.g = a.g - b.g;
      out.b = a.b - b.b;
      out.a = a.a - b.a;
      return out;
    };
    color4.sub = color4.subtract;
    color4.multiply = function(out, a, b) {
      out.r = a.r * b.r;
      out.g = a.g * b.g;
      out.b = a.b * b.b;
      out.a = a.a * b.a;
      return out;
    };
    color4.mul = color4.multiply;
    color4.divide = function(out, a, b) {
      out.r = a.r / b.r;
      out.g = a.g / b.g;
      out.b = a.b / b.b;
      out.a = a.a / b.a;
      return out;
    };
    color4.div = color4.divide;
    color4.scale = function(out, a, b) {
      out.r = a.r * b;
      out.g = a.g * b;
      out.b = a.b * b;
      out.a = a.a * b;
      return out;
    };
    color4.lerp = function(out, a, b, t) {
      var ar = a.r, ag = a.g, ab = a.b, aa = a.a;
      out.r = ar + t * (b.r - ar);
      out.g = ag + t * (b.g - ag);
      out.b = ab + t * (b.b - ab);
      out.a = aa + t * (b.a - aa);
      return out;
    };
    color4.str = function(a) {
      return "color4(" + a.r + ", " + a.g + ", " + a.b + ", " + a.a + ")";
    };
    color4.array = function(out, a) {
      out[0] = a.r;
      out[1] = a.g;
      out[2] = a.b;
      out[3] = a.a;
      return out;
    };
    color4.exactEquals = function(a, b) {
      return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
    };
    color4.equals = function(a, b) {
      var a0 = a.r, a1 = a.g, a2 = a.b, a3 = a.a;
      var b0 = b.r, b1 = b.g, b2 = b.b, b3 = b.a;
      return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
    };
    color4.hex = function(a) {
      return (255 * a.r << 24 | 255 * a.g << 16 | 255 * a.b << 8 | 255 * a.a) >>> 0;
    };
    var bits = bits_;
    var math = Object.freeze({
      bits: bits,
      vec2: vec2,
      vec3: vec3,
      vec4: vec4,
      quat: quat,
      mat2: mat2,
      mat23: mat23,
      mat3: mat3,
      mat4: mat4,
      color3: color3,
      color4: color4,
      EPSILON: EPSILON,
      equals: equals,
      approx: approx,
      clamp: clamp,
      clamp01: clamp01,
      lerp: lerp,
      toRadian: toRadian,
      toDegree: toDegree,
      random: random,
      randomRange: randomRange,
      randomRangeInt: randomRangeInt,
      nextPow2: nextPow2
    });
    var enums = {
      PROJ_PERSPECTIVE: 0,
      PROJ_ORTHO: 1,
      LIGHT_DIRECTIONAL: 0,
      LIGHT_POINT: 1,
      LIGHT_SPOT: 2,
      SHADOW_NONE: 0,
      SHADOW_HARD: 1,
      SHADOW_SOFT: 2,
      PARAM_INT: 0,
      PARAM_INT2: 1,
      PARAM_INT3: 2,
      PARAM_INT4: 3,
      PARAM_FLOAT: 4,
      PARAM_FLOAT2: 5,
      PARAM_FLOAT3: 6,
      PARAM_FLOAT4: 7,
      PARAM_COLOR3: 8,
      PARAM_COLOR4: 9,
      PARAM_MAT2: 10,
      PARAM_MAT3: 11,
      PARAM_MAT4: 12,
      PARAM_TEXTURE_2D: 13,
      PARAM_TEXTURE_CUBE: 14,
      CLEAR_COLOR: 1,
      CLEAR_DEPTH: 2,
      CLEAR_STENCIL: 4
    };
    var GL_NEAREST = 9728;
    var GL_LINEAR = 9729;
    var GL_NEAREST_MIPMAP_NEAREST = 9984;
    var GL_LINEAR_MIPMAP_NEAREST = 9985;
    var GL_NEAREST_MIPMAP_LINEAR = 9986;
    var GL_LINEAR_MIPMAP_LINEAR = 9987;
    var GL_UNSIGNED_BYTE = 5121;
    var GL_UNSIGNED_SHORT = 5123;
    var GL_UNSIGNED_INT = 5125;
    var GL_FLOAT = 5126;
    var GL_UNSIGNED_SHORT_5_6_5 = 33635;
    var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
    var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
    var GL_HALF_FLOAT_OES = 36193;
    var GL_DEPTH_COMPONENT = 6402;
    var GL_ALPHA = 6406;
    var GL_RGB = 6407;
    var GL_RGBA = 6408;
    var GL_LUMINANCE = 6409;
    var GL_LUMINANCE_ALPHA = 6410;
    var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
    var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
    var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
    var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
    var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
    var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
    var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
    var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
    var GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
    var _filterGL = [ [ GL_NEAREST, GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST_MIPMAP_LINEAR ], [ GL_LINEAR, GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR_MIPMAP_LINEAR ] ];
    var _textureFmtGL = [ {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_S3TC_DXT5_EXT,
      pixelType: null
    }, {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_ETC1_WEBGL,
      pixelType: null
    }, {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_RGB,
      internalFormat: GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_RGBA,
      internalFormat: GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
      pixelType: null
    }, {
      format: GL_ALPHA,
      internalFormat: GL_ALPHA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_LUMINANCE,
      internalFormat: GL_LUMINANCE,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_LUMINANCE_ALPHA,
      internalFormat: GL_LUMINANCE_ALPHA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_UNSIGNED_SHORT_5_6_5
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_SHORT_5_5_5_1
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_SHORT_4_4_4_4
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_UNSIGNED_BYTE
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_HALF_FLOAT_OES
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_HALF_FLOAT_OES
    }, {
      format: GL_RGB,
      internalFormat: GL_RGB,
      pixelType: GL_FLOAT
    }, {
      format: GL_RGBA,
      internalFormat: GL_RGBA,
      pixelType: GL_FLOAT
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    }, {
      format: GL_DEPTH_COMPONENT,
      internalFormat: GL_DEPTH_COMPONENT,
      pixelType: GL_UNSIGNED_SHORT
    }, {
      format: GL_DEPTH_COMPONENT,
      internalFormat: GL_DEPTH_COMPONENT,
      pixelType: GL_UNSIGNED_INT
    }, {
      format: null,
      internalFormat: null,
      pixelType: null
    } ];
    var enums$1 = {
      USAGE_STATIC: 35044,
      USAGE_DYNAMIC: 35048,
      USAGE_STREAM: 35040,
      INDEX_FMT_UINT8: 5121,
      INDEX_FMT_UINT16: 5123,
      INDEX_FMT_UINT32: 5125,
      ATTR_POSITION: "a_position",
      ATTR_NORMAL: "a_normal",
      ATTR_TANGENT: "a_tangent",
      ATTR_BITANGENT: "a_bitangent",
      ATTR_WEIGHTS: "a_weights",
      ATTR_JOINTS: "a_joints",
      ATTR_COLOR: "a_color",
      ATTR_COLOR0: "a_color0",
      ATTR_COLOR1: "a_color1",
      ATTR_UV: "a_uv",
      ATTR_UV0: "a_uv0",
      ATTR_UV1: "a_uv1",
      ATTR_UV2: "a_uv2",
      ATTR_UV3: "a_uv3",
      ATTR_UV4: "a_uv4",
      ATTR_UV5: "a_uv5",
      ATTR_UV6: "a_uv6",
      ATTR_UV7: "a_uv7",
      ATTR_TYPE_INT8: 5120,
      ATTR_TYPE_UINT8: 5121,
      ATTR_TYPE_INT16: 5122,
      ATTR_TYPE_UINT16: 5123,
      ATTR_TYPE_INT32: 5124,
      ATTR_TYPE_UINT32: 5125,
      ATTR_TYPE_FLOAT32: 5126,
      FILTER_NEAREST: 0,
      FILTER_LINEAR: 1,
      WRAP_REPEAT: 10497,
      WRAP_CLAMP: 33071,
      WRAP_MIRROR: 33648,
      TEXTURE_FMT_RGB_DXT1: 0,
      TEXTURE_FMT_RGBA_DXT1: 1,
      TEXTURE_FMT_RGBA_DXT3: 2,
      TEXTURE_FMT_RGBA_DXT5: 3,
      TEXTURE_FMT_RGB_ETC1: 4,
      TEXTURE_FMT_RGB_PVRTC_2BPPV1: 5,
      TEXTURE_FMT_RGBA_PVRTC_2BPPV1: 6,
      TEXTURE_FMT_RGB_PVRTC_4BPPV1: 7,
      TEXTURE_FMT_RGBA_PVRTC_4BPPV1: 8,
      TEXTURE_FMT_A8: 9,
      TEXTURE_FMT_L8: 10,
      TEXTURE_FMT_L8_A8: 11,
      TEXTURE_FMT_R5_G6_B5: 12,
      TEXTURE_FMT_R5_G5_B5_A1: 13,
      TEXTURE_FMT_R4_G4_B4_A4: 14,
      TEXTURE_FMT_RGB8: 15,
      TEXTURE_FMT_RGBA8: 16,
      TEXTURE_FMT_RGB16F: 17,
      TEXTURE_FMT_RGBA16F: 18,
      TEXTURE_FMT_RGB32F: 19,
      TEXTURE_FMT_RGBA32F: 20,
      TEXTURE_FMT_R32F: 21,
      TEXTURE_FMT_111110F: 22,
      TEXTURE_FMT_SRGB: 23,
      TEXTURE_FMT_SRGBA: 24,
      TEXTURE_FMT_D16: 25,
      TEXTURE_FMT_D32: 26,
      TEXTURE_FMT_D24S8: 27,
      DS_FUNC_NEVER: 512,
      DS_FUNC_LESS: 513,
      DS_FUNC_EQUAL: 514,
      DS_FUNC_LEQUAL: 515,
      DS_FUNC_GREATER: 516,
      DS_FUNC_NOTEQUAL: 517,
      DS_FUNC_GEQUAL: 518,
      DS_FUNC_ALWAYS: 519,
      RB_FMT_RGBA4: 32854,
      RB_FMT_RGB5_A1: 32855,
      RB_FMT_RGB565: 36194,
      RB_FMT_D16: 33189,
      RB_FMT_S8: 36168,
      RB_FMT_D24S8: 34041,
      BLEND_FUNC_ADD: 32774,
      BLEND_FUNC_SUBTRACT: 32778,
      BLEND_FUNC_REVERSE_SUBTRACT: 32779,
      BLEND_ZERO: 0,
      BLEND_ONE: 1,
      BLEND_SRC_COLOR: 768,
      BLEND_ONE_MINUS_SRC_COLOR: 769,
      BLEND_DST_COLOR: 774,
      BLEND_ONE_MINUS_DST_COLOR: 775,
      BLEND_SRC_ALPHA: 770,
      BLEND_ONE_MINUS_SRC_ALPHA: 771,
      BLEND_DST_ALPHA: 772,
      BLEND_ONE_MINUS_DST_ALPHA: 773,
      BLEND_CONSTANT_COLOR: 32769,
      BLEND_ONE_MINUS_CONSTANT_COLOR: 32770,
      BLEND_CONSTANT_ALPHA: 32771,
      BLEND_ONE_MINUS_CONSTANT_ALPHA: 32772,
      BLEND_SRC_ALPHA_SATURATE: 776,
      STENCIL_OP_KEEP: 7680,
      STENCIL_OP_ZERO: 0,
      STENCIL_OP_REPLACE: 7681,
      STENCIL_OP_INCR: 7682,
      STENCIL_OP_INCR_WRAP: 34055,
      STENCIL_OP_DECR: 7683,
      STENCIL_OP_DECR_WRAP: 34056,
      STENCIL_OP_INVERT: 5386,
      CULL_NONE: 0,
      CULL_FRONT: 1028,
      CULL_BACK: 1029,
      CULL_FRONT_AND_BACK: 1032,
      PT_POINTS: 0,
      PT_LINES: 1,
      PT_LINE_LOOP: 2,
      PT_LINE_STRIP: 3,
      PT_TRIANGLES: 4,
      PT_TRIANGLE_STRIP: 5,
      PT_TRIANGLE_FAN: 6
    };
    function attrTypeBytes(attrType) {
      if (attrType === enums$1.ATTR_TYPE_INT8) return 1;
      if (attrType === enums$1.ATTR_TYPE_UINT8) return 1;
      if (attrType === enums$1.ATTR_TYPE_INT16) return 2;
      if (attrType === enums$1.ATTR_TYPE_UINT16) return 2;
      if (attrType === enums$1.ATTR_TYPE_INT32) return 4;
      if (attrType === enums$1.ATTR_TYPE_UINT32) return 4;
      if (attrType === enums$1.ATTR_TYPE_FLOAT32) return 4;
      console.warn("Unknown ATTR_TYPE: " + attrType);
      return 0;
    }
    function glFilter(gl, filter, mipFilter) {
      void 0 === mipFilter && (mipFilter = -1);
      var result = _filterGL[filter][mipFilter + 1];
      if (void 0 === result) {
        console.warn("Unknown FILTER: " + filter);
        return -1 === mipFilter ? gl.LINEAR : gl.LINEAR_MIPMAP_LINEAR;
      }
      return result;
    }
    function glTextureFmt(fmt) {
      var result = _textureFmtGL[fmt];
      if (void 0 === result) {
        console.warn("Unknown TEXTURE_FMT: " + fmt);
        return _textureFmtGL[enums$1.TEXTURE_FMT_RGBA8];
      }
      return result;
    }
    var VertexFormat = function VertexFormat(infos) {
      var this$1 = this;
      this._attr2el = {};
      this._elements = [];
      this._bytes = 0;
      var offset = 0;
      for (var i = 0, len = infos.length; i < len; ++i) {
        var info = infos[i];
        var el = {
          name: info.name,
          offset: offset,
          stride: 0,
          stream: -1,
          type: info.type,
          num: info.num,
          normalize: void 0 !== info.normalize && info.normalize,
          bytes: info.num * attrTypeBytes(info.type)
        };
        this$1._attr2el[el.name] = el;
        this$1._elements.push(el);
        this$1._bytes += el.bytes;
        offset += el.bytes;
      }
      for (var i$1 = 0, len$1 = this._elements.length; i$1 < len$1; ++i$1) {
        var el$1 = this$1._elements[i$1];
        el$1.stride = this$1._bytes;
      }
    };
    VertexFormat.prototype.element = function element(attrName) {
      return this._attr2el[attrName];
    };
    var IndexBuffer = function IndexBuffer(device, format, usage, data, numIndices) {
      this._device = device;
      this._format = format;
      this._usage = usage;
      this._numIndices = numIndices;
      this._bytesPerIndex = 0;
      format === enums$1.INDEX_FMT_UINT8 ? this._bytesPerIndex = 1 : format === enums$1.INDEX_FMT_UINT16 ? this._bytesPerIndex = 2 : format === enums$1.INDEX_FMT_UINT32 && (this._bytesPerIndex = 4);
      this._bytes = this._bytesPerIndex * numIndices;
      this._glID = device._gl.createBuffer();
      this.update(0, data);
      device._stats.ib += this._bytes;
    };
    var prototypeAccessors = {
      count: {
        configurable: true
      }
    };
    IndexBuffer.prototype.destroy = function destroy() {
      if (-1 === this._glID) {
        console.error("The buffer already destroyed");
        return;
      }
      var gl = this._device._gl;
      gl.deleteBuffer(this._glID);
      this._device._stats.ib -= this.bytes;
      this._glID = -1;
    };
    IndexBuffer.prototype.update = function update(offset, data) {
      if (-1 === this._glID) {
        console.error("The buffer is destroyed");
        return;
      }
      if (data && data.byteLength + offset > this._bytes) {
        console.error("Failed to update data, bytes exceed.");
        return;
      }
      var gl = this._device._gl;
      var glUsage = this._usage;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glID);
      data ? offset ? gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, data) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, glUsage) : this._bytes ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._bytes, glUsage) : console.warn("bufferData should not submit 0 bytes data");
      this._device._restoreIndexBuffer();
    };
    prototypeAccessors.count.get = function() {
      return this._numIndices;
    };
    Object.defineProperties(IndexBuffer.prototype, prototypeAccessors);
    var VertexBuffer = function VertexBuffer(device, format, usage, data, numVertices) {
      this._device = device;
      this._format = format;
      this._usage = usage;
      this._numVertices = numVertices;
      this._bytes = this._format._bytes * numVertices;
      this._glID = device._gl.createBuffer();
      this.update(0, data);
      device._stats.vb += this._bytes;
    };
    var prototypeAccessors$1 = {
      count: {
        configurable: true
      }
    };
    VertexBuffer.prototype.destroy = function destroy() {
      if (-1 === this._glID) {
        console.error("The buffer already destroyed");
        return;
      }
      var gl = this._device._gl;
      gl.deleteBuffer(this._glID);
      this._device._stats.vb -= this.bytes;
      this._glID = -1;
    };
    VertexBuffer.prototype.update = function update(offset, data) {
      if (-1 === this._glID) {
        console.error("The buffer is destroyed");
        return;
      }
      if (data && data.byteLength + offset > this._bytes) {
        console.error("Failed to update data, bytes exceed.");
        return;
      }
      var gl = this._device._gl;
      var glUsage = this._usage;
      gl.bindBuffer(gl.ARRAY_BUFFER, this._glID);
      data ? offset ? gl.bufferSubData(gl.ARRAY_BUFFER, offset, data) : gl.bufferData(gl.ARRAY_BUFFER, data, glUsage) : this._bytes ? gl.bufferData(gl.ARRAY_BUFFER, this._bytes, glUsage) : console.warn("bufferData should not submit 0 bytes data");
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    };
    prototypeAccessors$1.count.get = function() {
      return this._numVertices;
    };
    Object.defineProperties(VertexBuffer.prototype, prototypeAccessors$1);
    var _genID = 0;
    function _parseError(out, type, errorLog) {
      errorLog.split("\n").forEach((function(msg) {
        if (msg.length < 5) return;
        var parts = /^ERROR\:\s+(\d+)\:(\d+)\:\s*(.*)$/.exec(msg);
        parts ? out.push({
          type: type,
          fileID: 0 | parts[1],
          line: 0 | parts[2],
          message: parts[3].trim()
        }) : msg.length > 0 && out.push({
          type: type,
          fileID: -1,
          line: 0,
          message: msg
        });
      }));
    }
    var Program = function Program(device, options) {
      this._device = device;
      this._attributes = [];
      this._uniforms = [];
      this._samplers = [];
      this._errors = [];
      this._linked = false;
      this._vertSource = options.vert;
      this._fragSource = options.frag;
      this._glID = null;
      this._id = _genID++;
    };
    var prototypeAccessors$2 = {
      id: {
        configurable: true
      }
    };
    prototypeAccessors$2.id.get = function() {
      return this._id;
    };
    Program.prototype.link = function link() {
      var this$1 = this;
      if (this._linked) return;
      var gl = this._device._gl;
      var vertShader = _createShader(gl, gl.VERTEX_SHADER, this._vertSource);
      var fragShader = _createShader(gl, gl.FRAGMENT_SHADER, this._fragSource);
      var program = gl.createProgram();
      gl.attachShader(program, vertShader);
      gl.attachShader(program, fragShader);
      gl.linkProgram(program);
      var failed = false;
      var errors = this._errors;
      if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
        _parseError(errors, "vs", gl.getShaderInfoLog(vertShader));
        failed = true;
      }
      if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
        _parseError(errors, "fs", gl.getShaderInfoLog(fragShader));
        failed = true;
      }
      gl.deleteShader(vertShader);
      gl.deleteShader(fragShader);
      if (failed) {
        errors.forEach((function(err) {
          console.error("Failed to compile " + err.type + " " + err.fileID + " (ln " + err.line + "): " + err.message);
        }));
        return;
      }
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Failed to link shader program: " + gl.getProgramInfoLog(program));
        failed = true;
      }
      if (failed) return;
      this._glID = program;
      var numAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
      for (var i = 0; i < numAttributes; ++i) {
        var info = gl.getActiveAttrib(program, i);
        var location = gl.getAttribLocation(program, info.name);
        this$1._attributes.push({
          name: info.name,
          location: location,
          type: info.type
        });
      }
      var numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      for (var i$1 = 0; i$1 < numUniforms; ++i$1) {
        var info$1 = gl.getActiveUniform(program, i$1);
        var name = info$1.name;
        var location$1 = gl.getUniformLocation(program, name);
        var isArray = "[0]" === name.substr(name.length - 3);
        isArray && (name = name.substr(0, name.length - 3));
        this$1._uniforms.push({
          name: name,
          location: location$1,
          type: info$1.type,
          size: isArray ? info$1.size : void 0
        });
      }
      this._linked = true;
    };
    Program.prototype.destroy = function destroy() {
      var gl = this._device._gl;
      gl.deleteProgram(this._glID);
      this._linked = false;
      this._glID = null;
      this._attributes = [];
      this._uniforms = [];
      this._samplers = [];
    };
    Object.defineProperties(Program.prototype, prototypeAccessors$2);
    function _createShader(gl, type, src) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      return shader;
    }
    var Texture = function Texture(device) {
      this._device = device;
      this._width = 4;
      this._height = 4;
      this._hasMipmap = false;
      this._compressed = false;
      this._anisotropy = 1;
      this._minFilter = enums$1.FILTER_LINEAR;
      this._magFilter = enums$1.FILTER_LINEAR;
      this._mipFilter = enums$1.FILTER_LINEAR;
      this._wrapS = enums$1.WRAP_REPEAT;
      this._wrapT = enums$1.WRAP_REPEAT;
      this._format = enums$1.TEXTURE_FMT_RGBA8;
      this._target = -1;
    };
    Texture.prototype.destroy = function destroy() {
      if (-1 === this._glID) {
        console.error("The texture already destroyed");
        return;
      }
      var gl = this._device._gl;
      gl.deleteTexture(this._glID);
      this._device._stats.tex -= this.bytes;
      this._glID = -1;
    };
    function isPow2$1(v) {
      return !(v & v - 1) && !!v;
    }
    var Texture2D = (function(Texture$$1) {
      function Texture2D(device, options) {
        Texture$$1.call(this, device);
        var gl = this._device._gl;
        this._target = gl.TEXTURE_2D;
        this._glID = gl.createTexture();
        options.images = options.images || [ null ];
        this.update(options);
      }
      Texture$$1 && (Texture2D.__proto__ = Texture$$1);
      Texture2D.prototype = Object.create(Texture$$1 && Texture$$1.prototype);
      Texture2D.prototype.constructor = Texture2D;
      Texture2D.prototype.update = function update(options) {
        var gl = this._device._gl;
        var genMipmap = this._hasMipmap;
        if (options) {
          void 0 !== options.width && (this._width = options.width);
          void 0 !== options.height && (this._height = options.height);
          void 0 !== options.anisotropy && (this._anisotropy = options.anisotropy);
          void 0 !== options.minFilter && (this._minFilter = options.minFilter);
          void 0 !== options.magFilter && (this._magFilter = options.magFilter);
          void 0 !== options.mipFilter && (this._mipFilter = options.mipFilter);
          void 0 !== options.wrapS && (this._wrapS = options.wrapS);
          void 0 !== options.wrapT && (this._wrapT = options.wrapT);
          if (void 0 !== options.format) {
            this._format = options.format;
            this._compressed = this._format >= enums$1.TEXTURE_FMT_RGB_DXT1 && this._format <= enums$1.TEXTURE_FMT_RGBA_PVRTC_4BPPV1;
          }
          if (void 0 !== options.mipmap) {
            this._hasMipmap = options.mipmap;
            genMipmap = options.mipmap;
          }
          if (void 0 !== options.images && options.images.length > 1) {
            genMipmap = false;
            var maxLength = options.width > options.height ? options.width : options.height;
            maxLength >> options.images.length - 1 !== 1 && console.error("texture-2d mipmap is invalid, should have a 1x1 mipmap.");
          }
        }
        var pot = isPow2$1(this._width) && isPow2$1(this._height);
        pot || (genMipmap = false);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._glID);
        void 0 !== options.images && options.images.length > 0 && this._setMipmap(options.images, options.flipY, options.premultiplyAlpha);
        this._setTexInfo();
        if (genMipmap) {
          gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
          gl.generateMipmap(gl.TEXTURE_2D);
        }
        this._device._restoreTexture(0);
      };
      Texture2D.prototype.updateSubImage = function updateSubImage(options) {
        var gl = this._device._gl;
        var glFmt = glTextureFmt(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._glID);
        this._setSubImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      Texture2D.prototype.updateImage = function updateImage(options) {
        var gl = this._device._gl;
        var glFmt = glTextureFmt(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this._glID);
        this._setImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      Texture2D.prototype._setSubImage = function _setSubImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var img = options.image;
        if (img instanceof HTMLCanvasElement || img instanceof HTMLImageElement || img instanceof HTMLVideoElement) {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          gl.texSubImage2D(gl.TEXTURE_2D, options.level, options.x, options.y, glFmt.format, glFmt.pixelType, img);
        } else {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          this._compressed ? gl.compressedTexSubImage2D(gl.TEXTURE_2D, options.level, options.x, options.y, options.width, options.height, glFmt.format, img) : gl.texSubImage2D(gl.TEXTURE_2D, options.level, options.x, options.y, options.width, options.height, glFmt.format, glFmt.pixelType, img);
        }
      };
      Texture2D.prototype._setImage = function _setImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var img = options.image;
        if (img instanceof HTMLCanvasElement || img instanceof HTMLImageElement || img instanceof HTMLVideoElement) {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          gl.texImage2D(gl.TEXTURE_2D, options.level, glFmt.internalFormat, glFmt.format, glFmt.pixelType, img);
        } else {
          void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
          void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
          this._compressed ? gl.compressedTexImage2D(gl.TEXTURE_2D, options.level, glFmt.internalFormat, options.width, options.height, 0, img) : gl.texImage2D(gl.TEXTURE_2D, options.level, glFmt.internalFormat, options.width, options.height, 0, glFmt.format, glFmt.pixelType, img);
        }
      };
      Texture2D.prototype._setMipmap = function _setMipmap(images, flipY, premultiplyAlpha) {
        var this$1 = this;
        var glFmt = glTextureFmt(this._format);
        var options = {
          width: this._width,
          height: this._height,
          flipY: flipY,
          premultiplyAlpha: premultiplyAlpha,
          level: 0,
          image: null
        };
        for (var i = 0; i < images.length; ++i) {
          options.level = i;
          options.width = this$1._width >> i;
          options.height = this$1._height >> i;
          options.image = images[i];
          this$1._setImage(glFmt, options);
        }
      };
      Texture2D.prototype._setTexInfo = function _setTexInfo() {
        var gl = this._device._gl;
        var pot = isPow2$1(this._width) && isPow2$1(this._height);
        if (!pot && (this._wrapS !== enums$1.WRAP_CLAMP || this._wrapT !== enums$1.WRAP_CLAMP)) {
          console.warn("WebGL1 doesn't support all wrap modes with NPOT textures");
          this._wrapS = enums$1.WRAP_CLAMP;
          this._wrapT = enums$1.WRAP_CLAMP;
        }
        var mipFilter = this._hasMipmap ? this._mipFilter : -1;
        if (!pot && -1 !== mipFilter) {
          console.warn("NPOT textures do not support mipmap filter");
          mipFilter = -1;
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter(gl, this._minFilter, mipFilter));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter(gl, this._magFilter, -1));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT);
        var ext = this._device.ext("EXT_texture_filter_anisotropic");
        ext && gl.texParameteri(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisotropy);
      };
      return Texture2D;
    })(Texture);
    var TextureCube = (function(Texture$$1) {
      function TextureCube(device, options) {
        Texture$$1.call(this, device);
        var gl = this._device._gl;
        this._target = gl.TEXTURE_CUBE_MAP;
        this._glID = gl.createTexture();
        this.update(options);
      }
      Texture$$1 && (TextureCube.__proto__ = Texture$$1);
      TextureCube.prototype = Object.create(Texture$$1 && Texture$$1.prototype);
      TextureCube.prototype.constructor = TextureCube;
      TextureCube.prototype.update = function update(options) {
        var gl = this._device._gl;
        var genMipmap = this._hasMipmap;
        if (options) {
          void 0 !== options.width && (this._width = options.width);
          void 0 !== options.height && (this._height = options.height);
          void 0 !== options.anisotropy && (this._anisotropy = options.anisotropy);
          void 0 !== options.minFilter && (this._minFilter = options.minFilter);
          void 0 !== options.magFilter && (this._magFilter = options.magFilter);
          void 0 !== options.mipFilter && (this._mipFilter = options.mipFilter);
          void 0 !== options.wrapS && (this._wrapS = options.wrapS);
          void 0 !== options.wrapT && (this._wrapT = options.wrapT);
          if (void 0 !== options.format) {
            this._format = options.format;
            this._compressed = this._format >= enums$1.TEXTURE_FMT_RGB_DXT1 && this._format <= enums$1.TEXTURE_FMT_RGBA_PVRTC_4BPPV1;
          }
          if (void 0 !== options.mipmap) {
            this._hasMipmap = options.mipmap;
            genMipmap = options.mipmap;
          }
          if (void 0 !== options.images && options.images.length > 1) {
            genMipmap = false;
            options.width !== options.height && console.warn("texture-cube width and height should be identical.");
            options.width >> options.images.length - 1 !== 1 && console.error("texture-cube mipmap is invalid. please set mipmap as 1x1, 2x2, 4x4 ... nxn");
          }
        }
        var pot = isPow2$1(this._width) && isPow2$1(this._height);
        pot || (genMipmap = false);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
        void 0 !== options.images && options.images.length > 0 && this._setMipmap(options.images, options.flipY, options.premultiplyAlpha);
        this._setTexInfo();
        if (genMipmap) {
          gl.hint(gl.GENERATE_MIPMAP_HINT, gl.NICEST);
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
        this._device._restoreTexture(0);
      };
      TextureCube.prototype.updateSubImage = function updateSubImage(options) {
        var gl = this._device._gl;
        var glFmt = glTextureFmt(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
        this._setSubImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      TextureCube.prototype.updateImage = function updateImage(options) {
        var gl = this._device._gl;
        var glFmt = glTextureFmt(this._format);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this._glID);
        this._setImage(glFmt, options);
        this._device._restoreTexture(0);
      };
      TextureCube.prototype._setSubImage = function _setSubImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var faceIndex = options.faceIndex;
        var img = options.image;
        void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
        img instanceof HTMLCanvasElement || img instanceof HTMLImageElement || img instanceof HTMLVideoElement ? gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, options.x, options.y, glFmt.format, glFmt.pixelType, img) : this._compressed ? gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, options.x, options.y, options.width, options.height, glFmt.format, img) : gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, options.x, options.y, options.width, options.height, glFmt.format, glFmt.pixelType, img);
      };
      TextureCube.prototype._setImage = function _setImage(glFmt, options) {
        var gl = this._device._gl;
        var flipY = options.flipY;
        var premultiplyAlpha = options.premultiplyAlpha;
        var faceIndex = options.faceIndex;
        var img = options.image;
        void 0 === flipY ? gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false) : gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
        void 0 === premultiplyAlpha ? gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false) : gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
        img instanceof HTMLCanvasElement || img instanceof HTMLImageElement || img instanceof HTMLVideoElement ? gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, glFmt.internalFormat, glFmt.format, glFmt.pixelType, img) : this._compressed ? gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, glFmt.internalFormat, options.width, options.height, 0, img) : gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, options.level, glFmt.internalFormat, options.width, options.height, 0, glFmt.format, glFmt.pixelType, img);
      };
      TextureCube.prototype._setMipmap = function _setMipmap(images, flipY, premultiplyAlpha) {
        var this$1 = this;
        var glFmt = glTextureFmt(this._format);
        var options = {
          width: this._width,
          height: this._height,
          faceIndex: 0,
          flipY: flipY,
          premultiplyAlpha: premultiplyAlpha,
          level: 0,
          image: null
        };
        for (var i = 0; i < images.length; ++i) {
          var levelImages = images[i];
          options.level = i;
          options.width = this$1._width >> i;
          options.height = this$1._height >> i;
          for (var face = 0; face < 6; ++face) {
            options.faceIndex = face;
            options.image = levelImages[face];
            this$1._setImage(glFmt, options);
          }
        }
      };
      TextureCube.prototype._setTexInfo = function _setTexInfo() {
        var gl = this._device._gl;
        var pot = isPow2$1(this._width) && isPow2$1(this._height);
        if (!pot && (this._wrapS !== enums$1.WRAP_CLAMP || this._wrapT !== enums$1.WRAP_CLAMP)) {
          console.warn("WebGL1 doesn't support all wrap modes with NPOT textures");
          this._wrapS = enums$1.WRAP_CLAMP;
          this._wrapT = enums$1.WRAP_CLAMP;
        }
        var mipFilter = this._hasMipmap ? this._mipFilter : -1;
        if (!pot && -1 !== mipFilter) {
          console.warn("NPOT textures do not support mipmap filter");
          mipFilter = -1;
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, glFilter(gl, this._minFilter, mipFilter));
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, glFilter(gl, this._magFilter, -1));
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, this._wrapS);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, this._wrapT);
        var ext = this._device.ext("EXT_texture_filter_anisotropic");
        ext && gl.texParameteri(gl.TEXTURE_CUBE_MAP, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisotropy);
      };
      return TextureCube;
    })(Texture);
    var RenderBuffer = function RenderBuffer(device, format, width, height) {
      this._device = device;
      this._format = format;
      this._width = width;
      this._height = height;
      var gl = device._gl;
      this._glID = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, this._glID);
      gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };
    RenderBuffer.prototype.destroy = function destroy() {
      if (null === this._glID) {
        console.error("The render-buffer already destroyed");
        return;
      }
      var gl = this._device._gl;
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.deleteRenderbuffer(this._glID);
      this._glID = null;
    };
    var FrameBuffer = function FrameBuffer(device, width, height, options) {
      this._device = device;
      this._width = width;
      this._height = height;
      this._colors = options.colors || [];
      this._depth = options.depth || null;
      this._stencil = options.stencil || null;
      this._depthStencil = options.depthStencil || null;
      this._glID = device._gl.createFramebuffer();
    };
    FrameBuffer.prototype.destroy = function destroy() {
      if (null === this._glID) {
        console.error("The frame-buffer already destroyed");
        return;
      }
      var gl = this._device._gl;
      gl.deleteFramebuffer(this._glID);
      this._glID = null;
    };
    var _default = {
      blend: false,
      blendSep: false,
      blendColor: 4294967295,
      blendEq: enums$1.BLEND_FUNC_ADD,
      blendAlphaEq: enums$1.BLEND_FUNC_ADD,
      blendSrc: enums$1.BLEND_ONE,
      blendDst: enums$1.BLEND_ZERO,
      blendSrcAlpha: enums$1.BLEND_ONE,
      blendDstAlpha: enums$1.BLEND_ZERO,
      depthTest: false,
      depthWrite: false,
      depthFunc: enums$1.DS_FUNC_LESS,
      stencilTest: false,
      stencilSep: false,
      stencilFuncFront: enums$1.DS_FUNC_ALWAYS,
      stencilRefFront: 0,
      stencilMaskFront: 255,
      stencilFailOpFront: enums$1.STENCIL_OP_KEEP,
      stencilZFailOpFront: enums$1.STENCIL_OP_KEEP,
      stencilZPassOpFront: enums$1.STENCIL_OP_KEEP,
      stencilWriteMaskFront: 255,
      stencilFuncBack: enums$1.DS_FUNC_ALWAYS,
      stencilRefBack: 0,
      stencilMaskBack: 255,
      stencilFailOpBack: enums$1.STENCIL_OP_KEEP,
      stencilZFailOpBack: enums$1.STENCIL_OP_KEEP,
      stencilZPassOpBack: enums$1.STENCIL_OP_KEEP,
      stencilWriteMaskBack: 255,
      cullMode: enums$1.CULL_BACK,
      primitiveType: enums$1.PT_TRIANGLES,
      maxStream: -1,
      vertexBuffers: [],
      vertexBufferOffsets: [],
      indexBuffer: null,
      maxTextureSlot: -1,
      textureUnits: [],
      program: null
    };
    var State = function State(device) {
      this.vertexBuffers = new Array(device._caps.maxVertexStreams);
      this.vertexBufferOffsets = new Array(device._caps.maxVertexStreams);
      this.textureUnits = new Array(device._caps.maxTextureUnits);
      this.set(_default);
    };
    State.initDefault = function initDefault(device) {
      _default.vertexBuffers = new Array(device._caps.maxVertexStreams);
      _default.vertexBufferOffsets = new Array(device._caps.maxVertexStreams);
      _default.textureUnits = new Array(device._caps.maxTextureUnits);
    };
    State.prototype.reset = function reset() {
      this.set(_default);
    };
    State.prototype.set = function set(cpy) {
      var this$1 = this;
      this.blend = cpy.blend;
      this.blendSep = cpy.blendSep;
      this.blendColor = cpy.blendColor;
      this.blendEq = cpy.blendEq;
      this.blendAlphaEq = cpy.blendAlphaEq;
      this.blendSrc = cpy.blendSrc;
      this.blendDst = cpy.blendDst;
      this.blendSrcAlpha = cpy.blendSrcAlpha;
      this.blendDstAlpha = cpy.blendDstAlpha;
      this.depthTest = cpy.depthTest;
      this.depthWrite = cpy.depthWrite;
      this.depthFunc = cpy.depthFunc;
      this.stencilTest = cpy.stencilTest;
      this.stencilSep = cpy.stencilSep;
      this.stencilFuncFront = cpy.stencilFuncFront;
      this.stencilRefFront = cpy.stencilRefFront;
      this.stencilMaskFront = cpy.stencilMaskFront;
      this.stencilFailOpFront = cpy.stencilFailOpFront;
      this.stencilZFailOpFront = cpy.stencilZFailOpFront;
      this.stencilZPassOpFront = cpy.stencilZPassOpFront;
      this.stencilWriteMaskFront = cpy.stencilWriteMaskFront;
      this.stencilFuncBack = cpy.stencilFuncBack;
      this.stencilRefBack = cpy.stencilRefBack;
      this.stencilMaskBack = cpy.stencilMaskBack;
      this.stencilFailOpBack = cpy.stencilFailOpBack;
      this.stencilZFailOpBack = cpy.stencilZFailOpBack;
      this.stencilZPassOpBack = cpy.stencilZPassOpBack;
      this.stencilWriteMaskBack = cpy.stencilWriteMaskBack;
      this.cullMode = cpy.cullMode;
      this.primitiveType = cpy.primitiveType;
      this.maxStream = cpy.maxStream;
      for (var i = 0; i < cpy.vertexBuffers.length; ++i) this$1.vertexBuffers[i] = cpy.vertexBuffers[i];
      for (var i$1 = 0; i$1 < cpy.vertexBufferOffsets.length; ++i$1) this$1.vertexBufferOffsets[i$1] = cpy.vertexBufferOffsets[i$1];
      this.indexBuffer = cpy.indexBuffer;
      this.maxTextureSlot = cpy.maxTextureSlot;
      for (var i$2 = 0; i$2 < cpy.textureUnits.length; ++i$2) this$1.textureUnits[i$2] = cpy.textureUnits[i$2];
      this.program = cpy.program;
    };
    var GL_INT = 5124;
    var GL_FLOAT$1 = 5126;
    var GL_FLOAT_VEC2 = 35664;
    var GL_FLOAT_VEC3 = 35665;
    var GL_FLOAT_VEC4 = 35666;
    var GL_INT_VEC2 = 35667;
    var GL_INT_VEC3 = 35668;
    var GL_INT_VEC4 = 35669;
    var GL_BOOL = 35670;
    var GL_BOOL_VEC2 = 35671;
    var GL_BOOL_VEC3 = 35672;
    var GL_BOOL_VEC4 = 35673;
    var GL_FLOAT_MAT2 = 35674;
    var GL_FLOAT_MAT3 = 35675;
    var GL_FLOAT_MAT4 = 35676;
    var GL_SAMPLER_2D = 35678;
    var GL_SAMPLER_CUBE = 35680;
    var _type2uniformCommit = {};
    _type2uniformCommit[GL_INT] = function(gl, id, value) {
      gl.uniform1i(id, value);
    };
    _type2uniformCommit[GL_FLOAT$1] = function(gl, id, value) {
      gl.uniform1f(id, value);
    };
    _type2uniformCommit[GL_FLOAT_VEC2] = function(gl, id, value) {
      gl.uniform2fv(id, value);
    };
    _type2uniformCommit[GL_FLOAT_VEC3] = function(gl, id, value) {
      gl.uniform3fv(id, value);
    };
    _type2uniformCommit[GL_FLOAT_VEC4] = function(gl, id, value) {
      gl.uniform4fv(id, value);
    };
    _type2uniformCommit[GL_INT_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    };
    _type2uniformCommit[GL_INT_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    };
    _type2uniformCommit[GL_INT_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    };
    _type2uniformCommit[GL_BOOL] = function(gl, id, value) {
      gl.uniform1i(id, value);
    };
    _type2uniformCommit[GL_BOOL_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    };
    _type2uniformCommit[GL_BOOL_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    };
    _type2uniformCommit[GL_BOOL_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    };
    _type2uniformCommit[GL_FLOAT_MAT2] = function(gl, id, value) {
      gl.uniformMatrix2fv(id, false, value);
    };
    _type2uniformCommit[GL_FLOAT_MAT3] = function(gl, id, value) {
      gl.uniformMatrix3fv(id, false, value);
    };
    _type2uniformCommit[GL_FLOAT_MAT4] = function(gl, id, value) {
      gl.uniformMatrix4fv(id, false, value);
    };
    _type2uniformCommit[GL_SAMPLER_2D] = function(gl, id, value) {
      gl.uniform1i(id, value);
    };
    _type2uniformCommit[GL_SAMPLER_CUBE] = function(gl, id, value) {
      gl.uniform1i(id, value);
    };
    var _type2uniformArrayCommit = {};
    _type2uniformArrayCommit[GL_INT] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    };
    _type2uniformArrayCommit[GL_FLOAT$1] = function(gl, id, value) {
      gl.uniform1fv(id, value);
    };
    _type2uniformArrayCommit[GL_FLOAT_VEC2] = function(gl, id, value) {
      gl.uniform2fv(id, value);
    };
    _type2uniformArrayCommit[GL_FLOAT_VEC3] = function(gl, id, value) {
      gl.uniform3fv(id, value);
    };
    _type2uniformArrayCommit[GL_FLOAT_VEC4] = function(gl, id, value) {
      gl.uniform4fv(id, value);
    };
    _type2uniformArrayCommit[GL_INT_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    };
    _type2uniformArrayCommit[GL_INT_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    };
    _type2uniformArrayCommit[GL_INT_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    };
    _type2uniformArrayCommit[GL_BOOL] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    };
    _type2uniformArrayCommit[GL_BOOL_VEC2] = function(gl, id, value) {
      gl.uniform2iv(id, value);
    };
    _type2uniformArrayCommit[GL_BOOL_VEC3] = function(gl, id, value) {
      gl.uniform3iv(id, value);
    };
    _type2uniformArrayCommit[GL_BOOL_VEC4] = function(gl, id, value) {
      gl.uniform4iv(id, value);
    };
    _type2uniformArrayCommit[GL_FLOAT_MAT2] = function(gl, id, value) {
      gl.uniformMatrix2fv(id, false, value);
    };
    _type2uniformArrayCommit[GL_FLOAT_MAT3] = function(gl, id, value) {
      gl.uniformMatrix3fv(id, false, value);
    };
    _type2uniformArrayCommit[GL_FLOAT_MAT4] = function(gl, id, value) {
      gl.uniformMatrix4fv(id, false, value);
    };
    _type2uniformArrayCommit[GL_SAMPLER_2D] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    };
    _type2uniformArrayCommit[GL_SAMPLER_CUBE] = function(gl, id, value) {
      gl.uniform1iv(id, value);
    };
    function _commitBlendStates(gl, cur, next) {
      if (cur.blend !== next.blend) {
        if (!next.blend) {
          gl.disable(gl.BLEND);
          return;
        }
        gl.enable(gl.BLEND);
        next.blendSrc !== enums$1.BLEND_CONSTANT_COLOR && next.blendSrc !== enums$1.BLEND_ONE_MINUS_CONSTANT_COLOR && next.blendDst !== enums$1.BLEND_CONSTANT_COLOR && next.blendDst !== enums$1.BLEND_ONE_MINUS_CONSTANT_COLOR || gl.blendColor((next.blendColor >> 24) / 255, (next.blendColor >> 16 & 255) / 255, (next.blendColor >> 8 & 255) / 255, (255 & next.blendColor) / 255);
        if (next.blendSep) {
          gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
          gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
        } else {
          gl.blendFunc(next.blendSrc, next.blendDst);
          gl.blendEquation(next.blendEq);
        }
        return;
      }
      if (false === next.blend) return;
      cur.blendColor !== next.blendColor && gl.blendColor((next.blendColor >> 24) / 255, (next.blendColor >> 16 & 255) / 255, (next.blendColor >> 8 & 255) / 255, (255 & next.blendColor) / 255);
      if (cur.blendSep !== next.blendSep) {
        if (next.blendSep) {
          gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
          gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
        } else {
          gl.blendFunc(next.blendSrc, next.blendDst);
          gl.blendEquation(next.blendEq);
        }
        return;
      }
      if (next.blendSep) {
        cur.blendSrc === next.blendSrc && cur.blendDst === next.blendDst && cur.blendSrcAlpha === next.blendSrcAlpha && cur.blendDstAlpha === next.blendDstAlpha || gl.blendFuncSeparate(next.blendSrc, next.blendDst, next.blendSrcAlpha, next.blendDstAlpha);
        cur.blendEq === next.blendEq && cur.blendAlphaEq === next.blendAlphaEq || gl.blendEquationSeparate(next.blendEq, next.blendAlphaEq);
      } else {
        cur.blendSrc === next.blendSrc && cur.blendDst === next.blendDst || gl.blendFunc(next.blendSrc, next.blendDst);
        cur.blendEq !== next.blendEq && gl.blendEquation(next.blendEq);
      }
    }
    function _commitDepthStates(gl, cur, next) {
      if (cur.depthTest !== next.depthTest) {
        if (!next.depthTest) {
          gl.disable(gl.DEPTH_TEST);
          return;
        }
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(next.depthFunc);
        gl.depthMask(next.depthWrite);
        return;
      }
      cur.depthWrite !== next.depthWrite && gl.depthMask(next.depthWrite);
      if (false === next.depthTest) {
        if (next.depthWrite) {
          next.depthTest = true;
          next.depthFunc = enums$1.DS_FUNC_ALWAYS;
          gl.enable(gl.DEPTH_TEST);
          gl.depthFunc(next.depthFunc);
        }
        return;
      }
      cur.depthFunc !== next.depthFunc && gl.depthFunc(next.depthFunc);
    }
    function _commitStencilStates(gl, cur, next) {
      if (next.stencilTest !== cur.stencilTest) {
        if (!next.stencilTest) {
          gl.disable(gl.STENCIL_TEST);
          return;
        }
        gl.enable(gl.STENCIL_TEST);
        if (next.stencilSep) {
          gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
          gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
          gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
          gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
          gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
        } else {
          gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMask(next.stencilWriteMaskFront);
          gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
        }
        return;
      }
      if (!next.stencilTest) return;
      if (cur.stencilSep !== next.stencilSep) {
        if (next.stencilSep) {
          gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
          gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
          gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
          gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
          gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
        } else {
          gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
          gl.stencilMask(next.stencilWriteMaskFront);
          gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
        }
        return;
      }
      if (next.stencilSep) {
        cur.stencilFuncFront === next.stencilFuncFront && cur.stencilRefFront === next.stencilRefFront && cur.stencilMaskFront === next.stencilMaskFront || gl.stencilFuncSeparate(gl.FRONT, next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
        cur.stencilWriteMaskFront !== next.stencilWriteMaskFront && gl.stencilMaskSeparate(gl.FRONT, next.stencilWriteMaskFront);
        cur.stencilFailOpFront === next.stencilFailOpFront && cur.stencilZFailOpFront === next.stencilZFailOpFront && cur.stencilZPassOpFront === next.stencilZPassOpFront || gl.stencilOpSeparate(gl.FRONT, next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
        cur.stencilFuncBack === next.stencilFuncBack && cur.stencilRefBack === next.stencilRefBack && cur.stencilMaskBack === next.stencilMaskBack || gl.stencilFuncSeparate(gl.BACK, next.stencilFuncBack, next.stencilRefBack, next.stencilMaskBack);
        cur.stencilWriteMaskBack !== next.stencilWriteMaskBack && gl.stencilMaskSeparate(gl.BACK, next.stencilWriteMaskBack);
        cur.stencilFailOpBack === next.stencilFailOpBack && cur.stencilZFailOpBack === next.stencilZFailOpBack && cur.stencilZPassOpBack === next.stencilZPassOpBack || gl.stencilOpSeparate(gl.BACK, next.stencilFailOpBack, next.stencilZFailOpBack, next.stencilZPassOpBack);
      } else {
        cur.stencilFuncFront === next.stencilFuncFront && cur.stencilRefFront === next.stencilRefFront && cur.stencilMaskFront === next.stencilMaskFront || gl.stencilFunc(next.stencilFuncFront, next.stencilRefFront, next.stencilMaskFront);
        cur.stencilWriteMaskFront !== next.stencilWriteMaskFront && gl.stencilMask(next.stencilWriteMaskFront);
        cur.stencilFailOpFront === next.stencilFailOpFront && cur.stencilZFailOpFront === next.stencilZFailOpFront && cur.stencilZPassOpFront === next.stencilZPassOpFront || gl.stencilOp(next.stencilFailOpFront, next.stencilZFailOpFront, next.stencilZPassOpFront);
      }
    }
    function _commitCullMode(gl, cur, next) {
      if (cur.cullMode === next.cullMode) return;
      if (next.cullMode === enums$1.CULL_NONE) {
        gl.disable(gl.CULL_FACE);
        return;
      }
      gl.enable(gl.CULL_FACE);
      gl.cullFace(next.cullMode);
    }
    function _commitVertexBuffers(device, gl, cur, next) {
      var attrsDirty = false;
      if (-1 === next.maxStream) {
        console.warn("VertexBuffer not assigned, please call setVertexBuffer before every draw.");
        return;
      }
      if (cur.maxStream !== next.maxStream) attrsDirty = true; else if (cur.program !== next.program) attrsDirty = true; else for (var i = 0; i < next.maxStream + 1; ++i) if (cur.vertexBuffers[i] !== next.vertexBuffers[i] || cur.vertexBufferOffsets[i] !== next.vertexBufferOffsets[i]) {
        attrsDirty = true;
        break;
      }
      if (attrsDirty) {
        for (var i$1 = 0; i$1 < device._caps.maxVertexAttribs; ++i$1) device._newAttributes[i$1] = 0;
        for (var i$2 = 0; i$2 < next.maxStream + 1; ++i$2) {
          var vb = next.vertexBuffers[i$2];
          var vbOffset = next.vertexBufferOffsets[i$2];
          if (!vb) continue;
          gl.bindBuffer(gl.ARRAY_BUFFER, vb._glID);
          for (var j = 0; j < next.program._attributes.length; ++j) {
            var attr = next.program._attributes[j];
            var el = vb._format.element(attr.name);
            if (!el) {
              console.warn("Can not find vertex attribute: " + attr.name);
              continue;
            }
            if (0 === device._enabledAttributes[attr.location]) {
              gl.enableVertexAttribArray(attr.location);
              device._enabledAttributes[attr.location] = 1;
            }
            device._newAttributes[attr.location] = 1;
            gl.vertexAttribPointer(attr.location, el.num, el.type, el.normalize, el.stride, el.offset + vbOffset * el.stride);
          }
        }
        for (var i$3 = 0; i$3 < device._caps.maxVertexAttribs; ++i$3) if (device._enabledAttributes[i$3] !== device._newAttributes[i$3]) {
          gl.disableVertexAttribArray(i$3);
          device._enabledAttributes[i$3] = 0;
        }
      }
    }
    function _commitTextures(gl, cur, next) {
      for (var i = 0; i < next.maxTextureSlot + 1; ++i) if (cur.textureUnits[i] !== next.textureUnits[i]) {
        var texture = next.textureUnits[i];
        if (void 0 !== texture && -1 !== texture._glID) {
          gl.activeTexture(gl.TEXTURE0 + i);
          gl.bindTexture(texture._target, texture._glID);
        }
      }
    }
    function _attach(gl, location, attachment, face) {
      void 0 === face && (face = 0);
      attachment instanceof Texture2D ? gl.framebufferTexture2D(gl.FRAMEBUFFER, location, gl.TEXTURE_2D, attachment._glID, 0) : attachment instanceof TextureCube ? gl.framebufferTexture2D(gl.FRAMEBUFFER, location, gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, attachment._glID, 0) : gl.framebufferRenderbuffer(gl.FRAMEBUFFER, location, gl.RENDERBUFFER, attachment._glID);
    }
    var Device = function Device(canvasEL, opts) {
      var this$1 = this;
      var gl;
      opts = opts || {};
      void 0 === opts.alpha && (opts.alpha = false);
      void 0 === opts.stencil && (opts.stencil = true);
      void 0 === opts.depth && (opts.depth = true);
      void 0 === opts.antialias && (opts.antialias = false);
      void 0 === opts.preserveDrawingBuffer && (opts.preserveDrawingBuffer = false);
      try {
        gl = canvasEL.getContext("webgl", opts);
      } catch (err) {
        console.error(err);
        return;
      }
      this._gl = gl;
      this._extensions = {};
      this._caps = {};
      this._stats = {
        texture: 0,
        vb: 0,
        ib: 0,
        drawcalls: 0
      };
      this._initExtensions([ "EXT_texture_filter_anisotropic", "EXT_shader_texture_lod", "OES_standard_derivatives", "OES_texture_float", "OES_texture_float_linear", "OES_texture_half_float", "OES_texture_half_float_linear", "OES_vertex_array_object", "WEBGL_compressed_texture_atc", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_s3tc", "WEBGL_depth_texture", "WEBGL_draw_buffers" ]);
      this._initCaps();
      this._initStates();
      State.initDefault(this);
      this._current = new State(this);
      this._next = new State(this);
      this._uniforms = {};
      this._vx = this._vy = this._vw = this._vh = 0;
      this._sx = this._sy = this._sw = this._sh = 0;
      this._framebuffer = null;
      this._enabledAttributes = new Array(this._caps.maxVertexAttribs);
      this._newAttributes = new Array(this._caps.maxVertexAttribs);
      for (var i = 0; i < this._caps.maxVertexAttribs; ++i) {
        this$1._enabledAttributes[i] = 0;
        this$1._newAttributes[i] = 0;
      }
    };
    Device.prototype._initExtensions = function _initExtensions(extensions) {
      var this$1 = this;
      var gl = this._gl;
      for (var i = 0; i < extensions.length; ++i) {
        var name = extensions[i];
        try {
          var ext = gl.getExtension(name);
          ext && (this$1._extensions[name] = ext);
        } catch (e) {
          console.error(e);
        }
      }
    };
    Device.prototype._initCaps = function _initCaps() {
      var gl = this._gl;
      var extDrawBuffers = this.ext("WEBGL_draw_buffers");
      this._caps.maxVertexStreams = 4;
      this._caps.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
      this._caps.maxFragUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
      this._caps.maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this._caps.maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
      this._caps.maxDrawBuffers = extDrawBuffers ? gl.getParameter(extDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
      this._caps.maxColorAttachments = extDrawBuffers ? gl.getParameter(extDrawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
    };
    Device.prototype._initStates = function _initStates() {
      var gl = this._gl;
      gl.disable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ZERO);
      gl.blendEquation(gl.FUNC_ADD);
      gl.blendColor(1, 1, 1, 1);
      gl.colorMask(true, true, true, true);
      gl.enable(gl.CULL_FACE);
      gl.cullFace(gl.BACK);
      gl.disable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LESS);
      gl.depthMask(false);
      gl.disable(gl.POLYGON_OFFSET_FILL);
      gl.depthRange(0, 1);
      gl.disable(gl.STENCIL_TEST);
      gl.stencilFunc(gl.ALWAYS, 0, 255);
      gl.stencilMask(255);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      gl.clearDepth(1);
      gl.clearColor(0, 0, 0, 0);
      gl.clearStencil(0);
      gl.disable(gl.SCISSOR_TEST);
    };
    Device.prototype._restoreTexture = function _restoreTexture(unit) {
      var gl = this._gl;
      var texture = this._current.textureUnits[unit];
      texture && -1 !== texture._glID ? gl.bindTexture(texture._target, texture._glID) : gl.bindTexture(gl.TEXTURE_2D, null);
    };
    Device.prototype._restoreIndexBuffer = function _restoreIndexBuffer() {
      var gl = this._gl;
      var ib = this._current.indexBuffer;
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib ? ib._glID : null);
    };
    Device.prototype.ext = function ext(name) {
      return this._extensions[name];
    };
    Device.prototype.setFrameBuffer = function setFrameBuffer(fb) {
      var this$1 = this;
      if (this._framebuffer === fb) return;
      this._framebuffer = fb;
      var gl = this._gl;
      if (null === fb) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        return;
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb._glID);
      var numColors = this._framebuffer._colors.length;
      for (var i = 0; i < numColors; ++i) {
        var colorBuffer = this$1._framebuffer._colors[i];
        _attach(gl, gl.COLOR_ATTACHMENT0 + i, colorBuffer);
      }
      for (var i$1 = numColors; i$1 < this._caps.maxColorAttachments; ++i$1) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i$1, gl.TEXTURE_2D, null, 0);
      this._framebuffer._depth && _attach(gl, gl.DEPTH_ATTACHMENT, this._framebuffer._depth);
      this._framebuffer._stencil && _attach(gl, gl.STENCIL_ATTACHMENT, fb._stencil);
      this._framebuffer._depthStencil && _attach(gl, gl.DEPTH_STENCIL_ATTACHMENT, fb._depthStencil);
    };
    Device.prototype.setViewport = function setViewport(x, y, w, h) {
      if (this._vx !== x || this._vy !== y || this._vw !== w || this._vh !== h) {
        this._gl.viewport(x, y, w, h);
        this._vx = x;
        this._vy = y;
        this._vw = w;
        this._vh = h;
      }
    };
    Device.prototype.setScissor = function setScissor(x, y, w, h) {
      if (this._sx !== x || this._sy !== y || this._sw !== w || this._sh !== h) {
        this._gl.scissor(x, y, w, h);
        this._sx = x;
        this._sy = y;
        this._sw = w;
        this._sh = h;
      }
    };
    Device.prototype.clear = function clear(opts) {
      var gl = this._gl;
      var flags = 0;
      if (void 0 !== opts.color) {
        flags |= gl.COLOR_BUFFER_BIT;
        gl.clearColor(opts.color[0], opts.color[1], opts.color[2], opts.color[3]);
      }
      if (void 0 !== opts.depth) {
        flags |= gl.DEPTH_BUFFER_BIT;
        gl.clearDepth(opts.depth);
        gl.enable(gl.DEPTH_TEST);
        gl.depthMask(true);
        gl.depthFunc(gl.ALWAYS);
      }
      if (void 0 !== opts.stencil) {
        flags |= gl.STENCIL_BUFFER_BIT;
        gl.clearStencil(opts.stencil);
      }
      gl.clear(flags);
      if (void 0 !== opts.depth) if (false === this._current.depthTest) gl.disable(gl.DEPTH_TEST); else {
        false === this._current.depthWrite && gl.depthMask(false);
        this._current.depthFunc !== enums$1.DS_FUNC_ALWAYS && gl.depthFunc(this._current.depthFunc);
      }
    };
    Device.prototype.enableBlend = function enableBlend() {
      this._next.blend = true;
    };
    Device.prototype.enableDepthTest = function enableDepthTest() {
      this._next.depthTest = true;
    };
    Device.prototype.enableDepthWrite = function enableDepthWrite() {
      this._next.depthWrite = true;
    };
    Device.prototype.enableStencilTest = function enableStencilTest() {
      this._next.stencilTest = true;
    };
    Device.prototype.setStencilFunc = function setStencilFunc(func, ref, mask) {
      this._next.stencilSep = false;
      this._next.stencilFuncFront = this._next.stencilFuncBack = func;
      this._next.stencilRefFront = this._next.stencilRefBack = ref;
      this._next.stencilMaskFront = this._next.stencilMaskBack = mask;
    };
    Device.prototype.setStencilFuncFront = function setStencilFuncFront(func, ref, mask) {
      this._next.stencilSep = true;
      this._next.stencilFuncFront = func;
      this._next.stencilRefFront = ref;
      this._next.stencilMaskFront = mask;
    };
    Device.prototype.setStencilFuncBack = function setStencilFuncBack(func, ref, mask) {
      this._next.stencilSep = true;
      this._next.stencilFuncBack = func;
      this._next.stencilRefBack = ref;
      this._next.stencilMaskBack = mask;
    };
    Device.prototype.setStencilOp = function setStencilOp(failOp, zFailOp, zPassOp, writeMask) {
      this._next.stencilFailOpFront = this._next.stencilFailOpBack = failOp;
      this._next.stencilZFailOpFront = this._next.stencilZFailOpBack = zFailOp;
      this._next.stencilZPassOpFront = this._next.stencilZPassOpBack = zPassOp;
      this._next.stencilWriteMaskFront = this._next.stencilWriteMaskBack = writeMask;
    };
    Device.prototype.setStencilOpFront = function setStencilOpFront(failOp, zFailOp, zPassOp, writeMask) {
      this._next.stencilSep = true;
      this._next.stencilFailOpFront = failOp;
      this._next.stencilZFailOpFront = zFailOp;
      this._next.stencilZPassOpFront = zPassOp;
      this._next.stencilWriteMaskFront = writeMask;
    };
    Device.prototype.setStencilOpBack = function setStencilOpBack(failOp, zFailOp, zPassOp, writeMask) {
      this._next.stencilSep = true;
      this._next.stencilFailOpBack = failOp;
      this._next.stencilZFailOpBack = zFailOp;
      this._next.stencilZPassOpBack = zPassOp;
      this._next.stencilWriteMaskBack = writeMask;
    };
    Device.prototype.setDepthFunc = function setDepthFunc(depthFunc) {
      this._next.depthFunc = depthFunc;
    };
    Device.prototype.setBlendColor32 = function setBlendColor32(rgba) {
      this._next.blendColor = rgba;
    };
    Device.prototype.setBlendColor = function setBlendColor(r, g, b, a) {
      this._next.blendColor = (255 * r << 24 | 255 * g << 16 | 255 * b << 8 | 255 * a) >>> 0;
    };
    Device.prototype.setBlendFunc = function setBlendFunc(src, dst) {
      this._next.blendSep = false;
      this._next.blendSrc = src;
      this._next.blendDst = dst;
    };
    Device.prototype.setBlendFuncSep = function setBlendFuncSep(src, dst, srcAlpha, dstAlpha) {
      this._next.blendSep = true;
      this._next.blendSrc = src;
      this._next.blendDst = dst;
      this._next.blendSrcAlpha = srcAlpha;
      this._next.blendDstAlpha = dstAlpha;
    };
    Device.prototype.setBlendEq = function setBlendEq(eq) {
      this._next.blendSep = false;
      this._next.blendEq = eq;
    };
    Device.prototype.setBlendEqSep = function setBlendEqSep(eq, alphaEq) {
      this._next.blendSep = true;
      this._next.blendEq = eq;
      this._next.blendAlphaEq = alphaEq;
    };
    Device.prototype.setCullMode = function setCullMode(mode) {
      this._next.cullMode = mode;
    };
    Device.prototype.setVertexBuffer = function setVertexBuffer(stream, buffer, start) {
      void 0 === start && (start = 0);
      this._next.vertexBuffers[stream] = buffer;
      this._next.vertexBufferOffsets[stream] = start;
      this._next.maxStream < stream && (this._next.maxStream = stream);
    };
    Device.prototype.setIndexBuffer = function setIndexBuffer(buffer) {
      this._next.indexBuffer = buffer;
    };
    Device.prototype.setProgram = function setProgram(program) {
      this._next.program = program;
    };
    Device.prototype.setTexture = function setTexture(name, texture, slot) {
      if (slot >= this._caps.maxTextureUnits) {
        console.warn("Can not set texture " + name + " at stage " + slot + ", max texture exceed: " + this._caps.maxTextureUnits);
        return;
      }
      this._next.textureUnits[slot] = texture;
      this.setUniform(name, slot);
      this._next.maxTextureSlot < slot && (this._next.maxTextureSlot = slot);
    };
    Device.prototype.setTextureArray = function setTextureArray(name, textures, slots) {
      var this$1 = this;
      var len = textures.length;
      if (len >= this._caps.maxTextureUnits) {
        console.warn("Can not set " + len + " textures for " + name + ", max texture exceed: " + this._caps.maxTextureUnits);
        return;
      }
      for (var i = 0; i < len; ++i) {
        var slot = slots[i];
        this$1._next.textureUnits[slot] = textures[i];
      }
      this.setUniform(name, slots);
    };
    Device.prototype.setUniform = function setUniform(name, value) {
      var uniform = this._uniforms[name];
      if (uniform) {
        var oldValue = uniform.value;
        var dirty = false;
        if (uniform.isArray) {
          for (var i = 0, l = oldValue.length; i < l; i++) if (oldValue[i] !== value[i]) {
            dirty = true;
            oldValue[i] = value[i];
          }
        } else if (oldValue !== value) {
          dirty = true;
          uniform.value = value;
        }
        dirty && (uniform.dirty = true);
      } else {
        var newValue = value;
        var isArray = false;
        if (value instanceof Float32Array || Array.isArray(value)) {
          newValue = new Float32Array(value);
          isArray = true;
        } else if (value instanceof Int32Array) {
          newValue = new Int32Array(value);
          isArray = true;
        }
        uniform = {
          dirty: true,
          value: newValue,
          isArray: isArray
        };
      }
      this._uniforms[name] = uniform;
    };
    Device.prototype.setPrimitiveType = function setPrimitiveType(type) {
      this._next.primitiveType = type;
    };
    Device.prototype.draw = function draw(base, count) {
      var this$1 = this;
      var gl = this._gl;
      var cur = this._current;
      var next = this._next;
      _commitBlendStates(gl, cur, next);
      _commitDepthStates(gl, cur, next);
      _commitStencilStates(gl, cur, next);
      _commitCullMode(gl, cur, next);
      _commitVertexBuffers(this, gl, cur, next);
      cur.indexBuffer !== next.indexBuffer && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, next.indexBuffer ? next.indexBuffer._glID : null);
      var programDirty = false;
      if (cur.program !== next.program) {
        next.program._linked ? gl.useProgram(next.program._glID) : console.warn("Failed to use program: has not linked yet.");
        programDirty = true;
      }
      _commitTextures(gl, cur, next);
      for (var i = 0; i < next.program._uniforms.length; ++i) {
        var uniformInfo = next.program._uniforms[i];
        var uniform = this$1._uniforms[uniformInfo.name];
        if (!uniform) continue;
        if (!programDirty && !uniform.dirty) continue;
        uniform.dirty = false;
        var commitFunc = void 0 === uniformInfo.size ? _type2uniformCommit[uniformInfo.type] : _type2uniformArrayCommit[uniformInfo.type];
        if (!commitFunc) {
          console.warn("Can not find commit function for uniform " + uniformInfo.name);
          continue;
        }
        commitFunc(gl, uniformInfo.location, uniform.value);
      }
      next.indexBuffer ? gl.drawElements(this._next.primitiveType, count, next.indexBuffer._format, base * next.indexBuffer._bytesPerIndex) : gl.drawArrays(this._next.primitiveType, base, count);
      this._stats.drawcalls += 1;
      cur.set(next);
      next.reset();
    };
    var gfx = {
      VertexFormat: VertexFormat,
      IndexBuffer: IndexBuffer,
      VertexBuffer: VertexBuffer,
      Program: Program,
      Texture: Texture,
      Texture2D: Texture2D,
      TextureCube: TextureCube,
      RenderBuffer: RenderBuffer,
      FrameBuffer: FrameBuffer,
      Device: Device,
      attrTypeBytes: attrTypeBytes,
      glFilter: glFilter,
      glTextureFmt: glTextureFmt
    };
    Object.assign(gfx, enums$1);
    var InputAssembler = function InputAssembler(vb, ib, pt) {
      void 0 === pt && (pt = gfx.PT_TRIANGLES);
      this._vertexBuffer = vb;
      this._indexBuffer = ib;
      this._primitiveType = pt;
      this._start = 0;
      this._count = -1;
    };
    InputAssembler.prototype.getPrimitiveCount = function getPrimitiveCount() {
      if (-1 !== this._count) return this._count;
      if (this._indexBuffer) return this._indexBuffer.count;
      return this._vertexBuffer.count;
    };
    var Pass = function Pass(name) {
      this._programName = name;
      this._cullMode = gfx.CULL_BACK;
      this._blend = false;
      this._blendEq = gfx.BLEND_FUNC_ADD;
      this._blendAlphaEq = gfx.BLEND_FUNC_ADD;
      this._blendSrc = gfx.BLEND_ONE;
      this._blendDst = gfx.BLEND_ZERO;
      this._blendSrcAlpha = gfx.BLEND_ONE;
      this._blendDstAlpha = gfx.BLEND_ZERO;
      this._blendColor = 4294967295;
      this._depthTest = false;
      this._depthWrite = false;
      this._depthFunc = gfx.DS_FUNC_LESS, this._stencilTest = false;
      this._stencilFuncFront = gfx.DS_FUNC_ALWAYS;
      this._stencilRefFront = 0;
      this._stencilMaskFront = 255;
      this._stencilFailOpFront = gfx.STENCIL_OP_KEEP;
      this._stencilZFailOpFront = gfx.STENCIL_OP_KEEP;
      this._stencilZPassOpFront = gfx.STENCIL_OP_KEEP;
      this._stencilWriteMaskFront = 255;
      this._stencilFuncBack = gfx.DS_FUNC_ALWAYS;
      this._stencilRefBack = 0;
      this._stencilMaskBack = 255;
      this._stencilFailOpBack = gfx.STENCIL_OP_KEEP;
      this._stencilZFailOpBack = gfx.STENCIL_OP_KEEP;
      this._stencilZPassOpBack = gfx.STENCIL_OP_KEEP;
      this._stencilWriteMaskBack = 255;
    };
    Pass.prototype.setCullMode = function setCullMode(cullMode) {
      this._cullMode = cullMode;
    };
    Pass.prototype.setBlend = function setBlend(blendEq, blendSrc, blendDst, blendAlphaEq, blendSrcAlpha, blendDstAlpha, blendColor) {
      void 0 === blendEq && (blendEq = gfx.BLEND_FUNC_ADD);
      void 0 === blendSrc && (blendSrc = gfx.BLEND_ONE);
      void 0 === blendDst && (blendDst = gfx.BLEND_ZERO);
      void 0 === blendAlphaEq && (blendAlphaEq = gfx.BLEND_FUNC_ADD);
      void 0 === blendSrcAlpha && (blendSrcAlpha = gfx.BLEND_ONE);
      void 0 === blendDstAlpha && (blendDstAlpha = gfx.BLEND_ZERO);
      void 0 === blendColor && (blendColor = 4294967295);
      this._blend = true;
      this._blendEq = blendEq;
      this._blendSrc = blendSrc;
      this._blendDst = blendDst;
      this._blendAlphaEq = blendAlphaEq;
      this._blendSrcAlpha = blendSrcAlpha;
      this._blendDstAlpha = blendDstAlpha;
      this._blendColor = blendColor;
    };
    Pass.prototype.setDepth = function setDepth(depthTest, depthWrite, depthFunc) {
      void 0 === depthTest && (depthTest = false);
      void 0 === depthWrite && (depthWrite = false);
      void 0 === depthFunc && (depthFunc = gfx.DS_FUNC_LESS);
      this._depthTest = depthTest;
      this._depthWrite = depthWrite;
      this._depthFunc = depthFunc;
    };
    Pass.prototype.setStencilFront = function setStencilFront(stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask) {
      void 0 === stencilFunc && (stencilFunc = gfx.DS_FUNC_ALWAYS);
      void 0 === stencilRef && (stencilRef = 0);
      void 0 === stencilMask && (stencilMask = 255);
      void 0 === stencilFailOp && (stencilFailOp = gfx.STENCIL_OP_KEEP);
      void 0 === stencilZFailOp && (stencilZFailOp = gfx.STENCIL_OP_KEEP);
      void 0 === stencilZPassOp && (stencilZPassOp = gfx.STENCIL_OP_KEEP);
      void 0 === stencilWriteMask && (stencilWriteMask = 255);
      this._stencilTest = true;
      this._stencilFuncFront = stencilFunc;
      this._stencilRefFront = stencilRef;
      this._stencilMaskFront = stencilMask;
      this._stencilFailOpFront = stencilFailOp;
      this._stencilZFailOpFront = stencilZFailOp;
      this._stencilZPassOpFront = stencilZPassOp;
      this._stencilWriteMaskFront = stencilWriteMask;
    };
    Pass.prototype.setStencilBack = function setStencilBack(stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask) {
      void 0 === stencilFunc && (stencilFunc = gfx.DS_FUNC_ALWAYS);
      void 0 === stencilRef && (stencilRef = 0);
      void 0 === stencilMask && (stencilMask = 255);
      void 0 === stencilFailOp && (stencilFailOp = gfx.STENCIL_OP_KEEP);
      void 0 === stencilZFailOp && (stencilZFailOp = gfx.STENCIL_OP_KEEP);
      void 0 === stencilZPassOp && (stencilZPassOp = gfx.STENCIL_OP_KEEP);
      void 0 === stencilWriteMask && (stencilWriteMask = 255);
      this._stencilTest = true;
      this._stencilFuncBack = stencilFunc;
      this._stencilRefBack = stencilRef;
      this._stencilMaskBack = stencilMask;
      this._stencilFailOpBack = stencilFailOp;
      this._stencilZFailOpBack = stencilZFailOp;
      this._stencilZPassOpBack = stencilZPassOp;
      this._stencilWriteMaskBack = stencilWriteMask;
    };
    Pass.prototype.disableStencilTest = function disableStencilTest() {
      this._stencilTest = false;
    };
    var _stageOffset = 0;
    var _name2stageID = {};
    var config = {
      addStage: function(name) {
        if (void 0 !== _name2stageID[name]) return;
        var stageID = 1 << _stageOffset;
        _name2stageID[name] = stageID;
        _stageOffset += 1;
      },
      stageID: function(name) {
        var id = _name2stageID[name];
        if (void 0 === id) return -1;
        return id;
      },
      stageIDs: function(nameList) {
        var key = 0;
        for (var i = 0; i < nameList.length; ++i) {
          var id = _name2stageID[nameList[i]];
          void 0 !== id && (key |= id);
        }
        return key;
      }
    };
    var _genID$1 = 0;
    var Technique = function Technique(stages, parameters, passes, layer) {
      void 0 === layer && (layer = 0);
      this._id = _genID$1++;
      this._stageIDs = config.stageIDs(stages);
      this._parameters = parameters;
      this._passes = passes;
      this._layer = layer;
    };
    var prototypeAccessors$3 = {
      passes: {
        configurable: true
      },
      stageIDs: {
        configurable: true
      }
    };
    Technique.prototype.setStages = function setStages(stages) {
      this._stageIDs = config.stageIDs(stages);
    };
    prototypeAccessors$3.passes.get = function() {
      return this._passes;
    };
    prototypeAccessors$3.stageIDs.get = function() {
      return this._stageIDs;
    };
    Object.defineProperties(Technique.prototype, prototypeAccessors$3);
    var Effect = function Effect(techniques, properties, defines) {
      void 0 === properties && (properties = {});
      void 0 === defines && (defines = []);
      this._techniques = techniques;
      this._properties = properties;
      this._defines = defines;
    };
    Effect.prototype.clear = function clear() {
      this._techniques.length = 0;
      this._properties = null;
      this._defines.length = 0;
    };
    Effect.prototype.getTechnique = function getTechnique(stage) {
      var this$1 = this;
      var stageID = config.stageID(stage);
      for (var i = 0; i < this._techniques.length; ++i) {
        var tech = this$1._techniques[i];
        if (tech.stageIDs & stageID) return tech;
      }
      return null;
    };
    Effect.prototype.getProperty = function getProperty(name) {
      return this._properties[name];
    };
    Effect.prototype.setProperty = function setProperty(name, value) {
      this._properties[name] = value;
    };
    Effect.prototype.getDefine = function getDefine(name) {
      var this$1 = this;
      for (var i = 0; i < this._defines.length; ++i) {
        var def = this$1._defines[i];
        if (def.name === name) return def.value;
      }
      console.warn("Failed to get define " + name + ", define not found.");
      return null;
    };
    Effect.prototype.define = function define(name, value) {
      var this$1 = this;
      for (var i = 0; i < this._defines.length; ++i) {
        var def = this$1._defines[i];
        if (def.name === name) {
          def.value = value;
          return;
        }
      }
      console.warn("Failed to set define " + name + ", define not found.");
    };
    Effect.prototype.extractDefines = function extractDefines(out) {
      var this$1 = this;
      void 0 === out && (out = {});
      for (var i = 0; i < this._defines.length; ++i) {
        var def = this$1._defines[i];
        out[def.name] = def.value;
      }
      return out;
    };
    function createIA(device, data) {
      if (!data.positions) {
        console.error("The data must have positions field");
        return null;
      }
      var verts = [];
      var vcount = data.positions.length / 3;
      for (var i = 0; i < vcount; ++i) {
        verts.push(data.positions[3 * i], data.positions[3 * i + 1], data.positions[3 * i + 2]);
        data.normals && verts.push(data.normals[3 * i], data.normals[3 * i + 1], data.normals[3 * i + 2]);
        data.uvs && verts.push(data.uvs[2 * i], data.uvs[2 * i + 1]);
      }
      var vfmt = [];
      vfmt.push({
        name: gfx.ATTR_POSITION,
        type: gfx.ATTR_TYPE_FLOAT32,
        num: 3
      });
      data.normals && vfmt.push({
        name: gfx.ATTR_NORMAL,
        type: gfx.ATTR_TYPE_FLOAT32,
        num: 3
      });
      data.uvs && vfmt.push({
        name: gfx.ATTR_UV0,
        type: gfx.ATTR_TYPE_FLOAT32,
        num: 2
      });
      var vb = new gfx.VertexBuffer(device, new gfx.VertexFormat(vfmt), gfx.USAGE_STATIC, new Float32Array(verts), vcount);
      var ib = null;
      data.indices && (ib = new gfx.IndexBuffer(device, gfx.INDEX_FMT_UINT16, gfx.USAGE_STATIC, new Uint16Array(data.indices), data.indices.length));
      return new InputAssembler(vb, ib);
    }
    var _m4_tmp = mat4.create();
    var _genID$2 = 0;
    var View = function View() {
      this._id = _genID$2++;
      this._rect = {
        x: 0,
        y: 0,
        w: 1,
        h: 1
      };
      this._color = color4.new(.3, .3, .3, 1);
      this._depth = 1;
      this._stencil = 1;
      this._clearFlags = enums.CLEAR_COLOR | enums.CLEAR_DEPTH;
      this._matView = mat4.create();
      this._matProj = mat4.create();
      this._matViewProj = mat4.create();
      this._matInvViewProj = mat4.create();
      this._stages = [];
      this._cullingMask = 1;
      this._framebuffer = null;
      this._shadowLight = null;
    };
    View.prototype.getForward = function getForward(out) {
      return vec3.set(out, -this._matView.m02, -this._matView.m06, -this._matView.m10);
    };
    View.prototype.getPosition = function getPosition(out) {
      mat4.invert(_m4_tmp, this._matView);
      return mat4.getTranslation(out, _m4_tmp);
    };
    var _forward = vec3.new(0, 0, -1);
    var _m4_tmp$1 = mat4.create();
    var _m3_tmp = mat3.create();
    var _transformedLightDirection = vec3.create();
    function _computeSpotLightViewProjMatrix(light, outView, outProj) {
      light._node.getWorldRT(outView);
      mat4.invert(outView, outView);
      mat4.perspective(outProj, light._spotAngle * light._spotAngleScale, 1, light._shadowMinDepth, light._shadowMaxDepth);
    }
    function _computeDirectionalLightViewProjMatrix(light, outView, outProj) {
      light._node.getWorldRT(outView);
      mat4.invert(outView, outView);
      var halfSize = light._shadowFustumSize / 2;
      mat4.ortho(outProj, -halfSize, halfSize, -halfSize, halfSize, light._shadowMinDepth, light._shadowMaxDepth);
    }
    function _computePointLightViewProjMatrix(light, outView, outProj) {}
    var Light = function Light() {
      this._poolID = -1;
      this._node = null;
      this._type = enums.LIGHT_DIRECTIONAL;
      this._color = color3.new(1, 1, 1);
      this._intensity = 1;
      this._range = 1;
      this._spotAngle = toRadian(60);
      this._spotExp = 1;
      this._directionUniform = new Float32Array(3);
      this._positionUniform = new Float32Array(3);
      this._colorUniform = new Float32Array([ this._color.r * this._intensity, this._color.g * this._intensity, this._color.b * this._intensity ]);
      this._spotUniform = new Float32Array([ Math.cos(.5 * this._spotAngle), this._spotExp ]);
      this._shadowType = enums.SHADOW_NONE;
      this._shadowFrameBuffer = null;
      this._shadowMap = null;
      this._shadowMapDirty = false;
      this._shadowDepthBuffer = null;
      this._shadowResolution = 1024;
      this._shadowBias = 5e-5;
      this._shadowDarkness = 1;
      this._shadowMinDepth = 1;
      this._shadowMaxDepth = 1e3;
      this._shadowDepthScale = 50;
      this._frustumEdgeFalloff = 0;
      this._viewProjMatrix = mat4.create();
      this._spotAngleScale = 1;
      this._shadowFustumSize = 80;
    };
    var prototypeAccessors$4 = {
      color: {
        configurable: true
      },
      intensity: {
        configurable: true
      },
      type: {
        configurable: true
      },
      spotAngle: {
        configurable: true
      },
      spotExp: {
        configurable: true
      },
      range: {
        configurable: true
      },
      shadowType: {
        configurable: true
      },
      shadowMap: {
        configurable: true
      },
      viewProjMatrix: {
        configurable: true
      },
      shadowResolution: {
        configurable: true
      },
      shadowBias: {
        configurable: true
      },
      shadowDarkness: {
        configurable: true
      },
      shadowMinDepth: {
        configurable: true
      },
      shadowMaxDepth: {
        configurable: true
      },
      shadowDepthScale: {
        configurable: true
      },
      frustumEdgeFalloff: {
        configurable: true
      }
    };
    Light.prototype.setNode = function setNode(node) {
      this._node = node;
    };
    Light.prototype.setColor = function setColor(r, g, b) {
      color3.set(this._color, r, g, b);
      this._colorUniform[0] = r * this._intensity;
      this._colorUniform[1] = g * this._intensity;
      this._colorUniform[2] = b * this._intensity;
    };
    prototypeAccessors$4.color.get = function() {
      return this._color;
    };
    Light.prototype.setIntensity = function setIntensity(val) {
      this._intensity = val;
      this._colorUniform[0] = val * this._color.r;
      this._colorUniform[1] = val * this._color.g;
      this._colorUniform[2] = val * this._color.b;
    };
    prototypeAccessors$4.intensity.get = function() {
      return this._intensity;
    };
    Light.prototype.setType = function setType(tpe) {
      this._type = tpe;
    };
    prototypeAccessors$4.type.get = function() {
      return this._type;
    };
    Light.prototype.setSpotAngle = function setSpotAngle(val) {
      this._spotAngle = val;
      this._spotUniform[0] = Math.cos(.5 * this._spotAngle);
    };
    prototypeAccessors$4.spotAngle.get = function() {
      return this._spotAngle;
    };
    Light.prototype.setSpotExp = function setSpotExp(val) {
      this._spotExp = val;
      this._spotUniform[1] = val;
    };
    prototypeAccessors$4.spotExp.get = function() {
      return this._spotExp;
    };
    Light.prototype.setRange = function setRange(tpe) {
      this._range = tpe;
    };
    prototypeAccessors$4.range.get = function() {
      return this._range;
    };
    Light.prototype.setShadowType = function setShadowType(type) {
      this._shadowType === enums.SHADOW_NONE && type !== enums.SHADOW_NONE && (this._shadowMapDirty = true);
      this._shadowType = type;
    };
    prototypeAccessors$4.shadowType.get = function() {
      return this._shadowType;
    };
    prototypeAccessors$4.shadowMap.get = function() {
      return this._shadowMap;
    };
    prototypeAccessors$4.viewProjMatrix.get = function() {
      return this._viewProjMatrix;
    };
    Light.prototype.setShadowResolution = function setShadowResolution(val) {
      this._shadowResolution !== val && (this._shadowMapDirty = true);
      this._shadowResolution = val;
    };
    prototypeAccessors$4.shadowResolution.get = function() {
      return this._shadowResolution;
    };
    Light.prototype.setShadowBias = function setShadowBias(val) {
      this._shadowBias = val;
    };
    prototypeAccessors$4.shadowBias.get = function() {
      return this._shadowBias;
    };
    Light.prototype.setShadowDarkness = function setShadowDarkness(val) {
      this._shadowDarkness = val;
    };
    prototypeAccessors$4.shadowDarkness.get = function() {
      return this._shadowDarkness;
    };
    Light.prototype.setShadowMinDepth = function setShadowMinDepth(val) {
      this._shadowMinDepth = val;
    };
    prototypeAccessors$4.shadowMinDepth.get = function() {
      if (this._type === enums.LIGHT_DIRECTIONAL) return 1;
      return this._shadowMinDepth;
    };
    Light.prototype.setShadowMaxDepth = function setShadowMaxDepth(val) {
      this._shadowMaxDepth = val;
    };
    prototypeAccessors$4.shadowMaxDepth.get = function() {
      if (this._type === enums.LIGHT_DIRECTIONAL) return 1;
      return this._shadowMaxDepth;
    };
    Light.prototype.setShadowDepthScale = function setShadowDepthScale(val) {
      this._shadowDepthScale = val;
    };
    prototypeAccessors$4.shadowDepthScale.get = function() {
      return this._shadowDepthScale;
    };
    Light.prototype.setFrustumEdgeFalloff = function setFrustumEdgeFalloff(val) {
      this._frustumEdgeFalloff = val;
    };
    prototypeAccessors$4.frustumEdgeFalloff.get = function() {
      return this._frustumEdgeFalloff;
    };
    Light.prototype.extractView = function extractView(out, stages) {
      out._shadowLight = this;
      out._rect.x = 0;
      out._rect.y = 0;
      out._rect.w = this._shadowResolution;
      out._rect.h = this._shadowResolution;
      color4.set(out._color, 1, 1, 1, 1);
      out._depth = 1;
      out._stencil = 1;
      out._clearFlags = enums.CLEAR_COLOR | enums.CLEAR_DEPTH;
      out._stages = stages;
      out._framebuffer = this._shadowFrameBuffer;
      switch (this._type) {
       case enums.LIGHT_SPOT:
        _computeSpotLightViewProjMatrix(this, out._matView, out._matProj);
        break;

       case enums.LIGHT_DIRECTIONAL:
        _computeDirectionalLightViewProjMatrix(this, out._matView, out._matProj);
        break;

       case enums.LIGHT_POINT:
        _computePointLightViewProjMatrix(this, out._matView, out._matProj);
        break;

       default:
        console.warn("shadow of this light type is not supported");
      }
      mat4.mul(out._matViewProj, out._matProj, out._matView);
      this._viewProjMatrix = out._matViewProj;
      mat4.invert(out._matInvViewProj, out._matViewProj);
    };
    Light.prototype._updateLightPositionAndDirection = function _updateLightPositionAndDirection() {
      this._node.getWorldMatrix(_m4_tmp$1);
      mat3.fromMat4(_m3_tmp, _m4_tmp$1);
      vec3.transformMat3(_transformedLightDirection, _forward, _m3_tmp);
      vec3.array(this._directionUniform, _transformedLightDirection);
      var pos = this._positionUniform;
      pos[0] = _m4_tmp$1.m12;
      pos[1] = _m4_tmp$1.m13;
      pos[2] = _m4_tmp$1.m14;
    };
    Light.prototype._generateShadowMap = function _generateShadowMap(device) {
      this._shadowMap = new gfx.Texture2D(device, {
        width: this._shadowResolution,
        height: this._shadowResolution,
        format: gfx.TEXTURE_FMT_RGBA8,
        wrapS: gfx.WRAP_CLAMP,
        wrapT: gfx.WRAP_CLAMP
      });
      this._shadowDepthBuffer = new gfx.RenderBuffer(device, gfx.RB_FMT_D16, this._shadowResolution, this._shadowResolution);
      this._shadowFrameBuffer = new gfx.FrameBuffer(device, this._shadowResolution, this._shadowResolution, {
        colors: [ this._shadowMap ],
        depth: this._shadowDepthBuffer
      });
    };
    Light.prototype._destroyShadowMap = function _destroyShadowMap() {
      if (this._shadowMap) {
        this._shadowMap.destroy();
        this._shadowDepthBuffer.destroy();
        this._shadowFrameBuffer.destroy();
        this._shadowMap = null;
        this._shadowDepthBuffer = null;
        this._shadowFrameBuffer = null;
      }
    };
    Light.prototype.update = function update(device) {
      this._updateLightPositionAndDirection();
      if (this._shadowType === enums.SHADOW_NONE) this._destroyShadowMap(); else if (this._shadowMapDirty) {
        this._destroyShadowMap();
        this._generateShadowMap(device);
        this._shadowMapDirty = false;
      }
    };
    Object.defineProperties(Light.prototype, prototypeAccessors$4);
    var _matView = mat4.create();
    var _matProj = mat4.create();
    var _matViewProj = mat4.create();
    var _matInvViewProj = mat4.create();
    var _tmp_v3 = vec3.create();
    var Camera = function Camera() {
      this._poolID = -1;
      this._node = null;
      this._projection = enums.PROJ_PERSPECTIVE;
      this._color = color4.new(.2, .3, .47, 1);
      this._depth = 1;
      this._stencil = 1;
      this._clearFlags = enums.CLEAR_COLOR | enums.CLEAR_DEPTH;
      this._cullingMask = 1;
      this._stages = [];
      this._framebuffer = null;
      this._near = .01;
      this._far = 1e3;
      this._fov = Math.PI / 4;
      this._rect = {
        x: 0,
        y: 0,
        w: 1,
        h: 1
      };
      this._orthoHeight = 10;
    };
    var prototypeAccessors$5 = {
      cullingMask: {
        configurable: true
      }
    };
    prototypeAccessors$5.cullingMask.get = function() {
      return this._cullingMask;
    };
    prototypeAccessors$5.cullingMask.set = function(mask) {
      this._cullingMask = mask;
    };
    Camera.prototype.getNode = function getNode() {
      return this._node;
    };
    Camera.prototype.setNode = function setNode(node) {
      this._node = node;
    };
    Camera.prototype.getType = function getType() {
      return this._projection;
    };
    Camera.prototype.setType = function setType(type) {
      this._projection = type;
    };
    Camera.prototype.getOrthoHeight = function getOrthoHeight() {
      return this._orthoHeight;
    };
    Camera.prototype.setOrthoHeight = function setOrthoHeight(val) {
      this._orthoHeight = val;
    };
    Camera.prototype.getFov = function getFov() {
      return this._fov;
    };
    Camera.prototype.setFov = function setFov(fov) {
      this._fov = fov;
    };
    Camera.prototype.getNear = function getNear() {
      return this._near;
    };
    Camera.prototype.setNear = function setNear(near) {
      this._near = near;
    };
    Camera.prototype.getFar = function getFar() {
      return this._far;
    };
    Camera.prototype.setFar = function setFar(far) {
      this._far = far;
    };
    Camera.prototype.getColor = function getColor(out) {
      return color4.copy(out, this._color);
    };
    Camera.prototype.setColor = function setColor(r, g, b, a) {
      color4.set(this._color, r, g, b, a);
    };
    Camera.prototype.getDepth = function getDepth() {
      return this._depth;
    };
    Camera.prototype.setDepth = function setDepth(depth) {
      this._depth = depth;
    };
    Camera.prototype.getStencil = function getStencil() {
      return this._stencil;
    };
    Camera.prototype.setStencil = function setStencil(stencil) {
      this._stencil = stencil;
    };
    Camera.prototype.getClearFlags = function getClearFlags() {
      return this._clearFlags;
    };
    Camera.prototype.setClearFlags = function setClearFlags(flags) {
      this._clearFlags = flags;
    };
    Camera.prototype.getRect = function getRect(out) {
      out.x = this._rect.x;
      out.y = this._rect.y;
      out.w = this._rect.w;
      out.h = this._rect.h;
      return out;
    };
    Camera.prototype.setRect = function setRect(x, y, w, h) {
      this._rect.x = x;
      this._rect.y = y;
      this._rect.w = w;
      this._rect.h = h;
    };
    Camera.prototype.getStages = function getStages() {
      return this._stages;
    };
    Camera.prototype.setStages = function setStages(stages) {
      this._stages = stages;
    };
    Camera.prototype.getFramebuffer = function getFramebuffer() {
      return this._framebuffer;
    };
    Camera.prototype.setFramebuffer = function setFramebuffer(framebuffer) {
      this._framebuffer = framebuffer;
    };
    Camera.prototype.extractView = function extractView(out, width, height) {
      out._rect.x = this._rect.x * width;
      out._rect.y = this._rect.y * height;
      out._rect.w = this._rect.w * width;
      out._rect.h = this._rect.h * height;
      out._color = this._color;
      out._depth = this._depth;
      out._stencil = this._stencil;
      out._clearFlags = this._clearFlags;
      out._cullingMask = this._cullingMask;
      out._stages = this._stages;
      out._framebuffer = this._framebuffer;
      this._node.getWorldRT(out._matView);
      mat4.invert(out._matView, out._matView);
      var aspect = width / height;
      if (this._projection === enums.PROJ_PERSPECTIVE) mat4.perspective(out._matProj, this._fov, aspect, this._near, this._far); else {
        var x = this._orthoHeight * aspect;
        var y = this._orthoHeight;
        mat4.ortho(out._matProj, -x, x, -y, y, this._near, this._far);
      }
      mat4.mul(out._matViewProj, out._matProj, out._matView);
      mat4.invert(out._matInvViewProj, out._matViewProj);
    };
    Camera.prototype.screenToWorld = function screenToWorld(out, screenPos, width, height) {
      var aspect = width / height;
      var cx = this._rect.x * width;
      var cy = this._rect.y * height;
      var cw = this._rect.w * width;
      var ch = this._rect.h * height;
      this._node.getWorldRT(_matView);
      mat4.invert(_matView, _matView);
      if (this._projection === enums.PROJ_PERSPECTIVE) mat4.perspective(_matProj, this._fov, aspect, this._near, this._far); else {
        var x = this._orthoHeight * aspect;
        var y = this._orthoHeight;
        mat4.ortho(_matProj, -x, x, -y, y, this._near, this._far);
      }
      mat4.mul(_matViewProj, _matProj, _matView);
      mat4.invert(_matInvViewProj, _matViewProj);
      if (this._projection === enums.PROJ_PERSPECTIVE) {
        vec3.set(out, 2 * (screenPos.x - cx) / cw - 1, 2 * (screenPos.y - cy) / ch - 1, 1);
        vec3.transformMat4(out, out, _matInvViewProj);
        this._node.getWorldPos(_tmp_v3);
        vec3.lerp(out, _tmp_v3, out, screenPos.z / this._far);
      } else {
        var range = this._farClip - this._nearClip;
        vec3.set(out, 2 * (screenPos.x - cx) / cw - 1, 2 * (screenPos.y - cy) / ch - 1, (this._far - screenPos.z) / range * 2 - 1);
        vec3.transformMat4(out, out, _matInvViewProj);
      }
      return out;
    };
    Camera.prototype.worldToScreen = function worldToScreen(out, worldPos, width, height) {
      var aspect = width / height;
      var cx = this._rect.x * width;
      var cy = this._rect.y * height;
      var cw = this._rect.w * width;
      var ch = this._rect.h * height;
      this._node.getWorldRT(_matView);
      mat4.invert(_matView, _matView);
      if (this._projection === enums.PROJ_PERSPECTIVE) mat4.perspective(_matProj, this._fov, aspect, this._near, this._far); else {
        var x = this._orthoHeight * aspect;
        var y = this._orthoHeight;
        mat4.ortho(_matProj, -x, x, -y, y, this._near, this._far);
      }
      mat4.mul(_matViewProj, _matProj, _matView);
      var w = worldPos.x * _matViewProj.m03 + worldPos.y * _matViewProj.m07 + worldPos.z * _matViewProj.m11 + _matViewProj.m15;
      vec3.transformMat4(out, worldPos, _matViewProj);
      out.x = cx + .5 * (out.x / w + 1) * cw;
      out.y = cy + .5 * (out.y / w + 1) * ch;
      return out;
    };
    Object.defineProperties(Camera.prototype, prototypeAccessors$5);
    var Model = function Model() {
      this._poolID = -1;
      this._node = null;
      this._inputAssemblers = [];
      this._effects = [];
      this._defines = [];
      this._dynamicIA = false;
      this._cullingMask = -1;
    };
    var prototypeAccessors$6 = {
      inputAssemblerCount: {
        configurable: true
      },
      dynamicIA: {
        configurable: true
      },
      drawItemCount: {
        configurable: true
      },
      cullingMask: {
        configurable: true
      }
    };
    prototypeAccessors$6.inputAssemblerCount.get = function() {
      return this._inputAssemblers.length;
    };
    prototypeAccessors$6.dynamicIA.get = function() {
      return this._dynamicIA;
    };
    prototypeAccessors$6.drawItemCount.get = function() {
      return this._dynamicIA ? 1 : this._inputAssemblers.length;
    };
    prototypeAccessors$6.cullingMask.get = function() {
      return this._cullingMask;
    };
    prototypeAccessors$6.cullingMask.set = function(mask) {
      this._cullingMask = mask;
    };
    Model.prototype.setNode = function setNode(node) {
      this._node = node;
    };
    Model.prototype.setDynamicIA = function setDynamicIA(enabled) {
      this._dynamicIA = enabled;
    };
    Model.prototype.addInputAssembler = function addInputAssembler(ia) {
      if (-1 !== this._inputAssemblers.indexOf(ia)) return;
      this._inputAssemblers.push(ia);
    };
    Model.prototype.clearInputAssemblers = function clearInputAssemblers() {
      this._inputAssemblers.length = 0;
    };
    Model.prototype.addEffect = function addEffect(effect) {
      if (-1 !== this._effects.indexOf(effect)) return;
      this._effects.push(effect);
      var defs = Object.create(null);
      effect.extractDefines(defs);
      this._defines.push(defs);
    };
    Model.prototype.clearEffects = function clearEffects() {
      this._effects.length = 0;
      this._defines.length = 0;
    };
    Model.prototype.extractDrawItem = function extractDrawItem(out, index) {
      if (this._dynamicIA) {
        out.model = this;
        out.node = this._node;
        out.ia = null;
        out.effect = this._effects[0];
        out.defines = out.effect.extractDefines(this._defines[0]);
        return;
      }
      if (index >= this._inputAssemblers.length) {
        out.model = null;
        out.node = null;
        out.ia = null;
        out.effect = null;
        out.defines = null;
        return;
      }
      out.model = this;
      out.node = this._node;
      out.ia = this._inputAssemblers[index];
      var effect, defines;
      if (index < this._effects.length) {
        effect = this._effects[index];
        defines = this._defines[index];
      } else {
        effect = this._effects[this._effects.length - 1];
        defines = this._defines[this._effects.length - 1];
      }
      out.effect = effect;
      out.defines = effect.extractDefines(defines);
    };
    Object.defineProperties(Model.prototype, prototypeAccessors$6);
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 ];
    function log10$1(x) {
      if (x < 1e5) {
        if (x < 100) return x < 10 ? 0 : 1;
        if (x < 1e4) return x < 1e3 ? 2 : 3;
        return 4;
      }
      if (x < 1e7) return x < 1e6 ? 5 : 6;
      if (x < 1e9) return x < 1e8 ? 7 : 8;
      return 9;
    }
    function alphabeticalCompare(a, b) {
      if (a === b) return 0;
      if (~~a === a && ~~b === b) {
        if (0 === a || 0 === b) return a < b ? -1 : 1;
        if (a < 0 || b < 0) {
          if (b >= 0) return -1;
          if (a >= 0) return 1;
          a = -a;
          b = -b;
        }
        var al = log10$1(a);
        var bl = log10$1(b);
        var t = 0;
        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }
        if (a === b) return t;
        return a < b ? -1 : 1;
      }
      var aStr = String(a);
      var bStr = String(b);
      if (aStr === bStr) return 0;
      return aStr < bStr ? -1 : 1;
    }
    function minRunLength(n) {
      var r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= 1 & n;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;
      if (runHi === hi) return 1;
      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) runHi++;
        reverseRun(array, lo, runHi);
      } else while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) runHi++;
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare) {
      start === lo && start++;
      for (;start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        while (left < right) {
          var mid = left + right >>> 1;
          compare(pivot, array[mid]) < 0 ? right = mid : left = mid + 1;
        }
        var n = start - left;
        switch (n) {
         case 3:
          array[left + 3] = array[left + 2];

         case 2:
          array[left + 2] = array[left + 1];

         case 1:
          array[left + 1] = array[left];
          break;

         default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
        }
        array[left] = pivot;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) > 0 ? lastOffset = m + 1 : offset = m;
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) < 0 ? offset = m : lastOffset = m + 1;
      }
      return offset;
    }
    var TimSort = function TimSort(array, compare) {
      this.array = array;
      this.compare = compare;
      this.minGallop = DEFAULT_MIN_GALLOPING;
      this.length = array.length;
      this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
      this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH && (this.tmpStorageLength = this.length >>> 1);
      this.tmp = new Array(this.tmpStorageLength);
      this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
      this.runStart = new Array(this.stackLength);
      this.runLength = new Array(this.stackLength);
      this.stackSize = 0;
    };
    TimSort.prototype.pushRun = function pushRun(runStart, runLength) {
      this.runStart[this.stackSize] = runStart;
      this.runLength[this.stackSize] = runLength;
      this.stackSize += 1;
    };
    TimSort.prototype.mergeRuns = function mergeRuns() {
      var this$1 = this;
      while (this.stackSize > 1) {
        var n = this$1.stackSize - 2;
        if (n >= 1 && this$1.runLength[n - 1] <= this$1.runLength[n] + this$1.runLength[n + 1] || n >= 2 && this$1.runLength[n - 2] <= this$1.runLength[n] + this$1.runLength[n - 1]) this$1.runLength[n - 1] < this$1.runLength[n + 1] && n--; else if (this$1.runLength[n] > this$1.runLength[n + 1]) break;
        this$1.mergeAt(n);
      }
    };
    TimSort.prototype.forceMergeRuns = function forceMergeRuns() {
      var this$1 = this;
      while (this.stackSize > 1) {
        var n = this$1.stackSize - 2;
        n > 0 && this$1.runLength[n - 1] < this$1.runLength[n + 1] && n--;
        this$1.mergeAt(n);
      }
    };
    TimSort.prototype.mergeAt = function mergeAt(i) {
      var compare = this.compare;
      var array = this.array;
      var start1 = this.runStart[i];
      var length1 = this.runLength[i];
      var start2 = this.runStart[i + 1];
      var length2 = this.runLength[i + 1];
      this.runLength[i] = length1 + length2;
      if (i === this.stackSize - 3) {
        this.runStart[i + 1] = this.runStart[i + 2];
        this.runLength[i + 1] = this.runLength[i + 2];
      }
      this.stackSize--;
      var k = gallopRight(array[start2], array, start1, length1, 0, compare);
      start1 += k;
      length1 -= k;
      if (0 === length1) return;
      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
      if (0 === length2) return;
      length1 <= length2 ? this.mergeLow(start1, length1, start2, length2) : this.mergeHigh(start1, length1, start2, length2);
    };
    TimSort.prototype.mergeLow = function mergeLow(start1, length1, start2, length2) {
      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;
      for (i = 0; i < length1; i++) tmp[i] = array[start1 + i];
      var cursor1 = 0;
      var cursor2 = start2;
      var dest = start1;
      array[dest++] = array[cursor2++];
      if (0 === --length2) {
        for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
        return;
      }
      if (1 === length1) {
        for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
        array[dest + length2] = tmp[cursor1];
        return;
      }
      var minGallop = this.minGallop;
      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;
        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++];
            count2++;
            count1 = 0;
            if (0 === --length2) {
              exit = true;
              break;
            }
          } else {
            array[dest++] = tmp[cursor1++];
            count1++;
            count2 = 0;
            if (1 === --length1) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);
        if (exit) break;
        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
          if (0 !== count1) {
            for (i = 0; i < count1; i++) array[dest + i] = tmp[cursor1 + i];
            dest += count1;
            cursor1 += count1;
            length1 -= count1;
            if (length1 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest++] = array[cursor2++];
          if (0 === --length2) {
            exit = true;
            break;
          }
          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
          if (0 !== count2) {
            for (i = 0; i < count2; i++) array[dest + i] = array[cursor2 + i];
            dest += count2;
            cursor2 += count2;
            length2 -= count2;
            if (0 === length2) {
              exit = true;
              break;
            }
          }
          array[dest++] = tmp[cursor1++];
          if (1 === --length1) {
            exit = true;
            break;
          }
          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) break;
        minGallop < 0 && (minGallop = 0);
        minGallop += 2;
      }
      this.minGallop = minGallop;
      minGallop < 1 && (this.minGallop = 1);
      if (1 === length1) {
        for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
        array[dest + length2] = tmp[cursor1];
      } else {
        if (0 === length1) throw new Error("mergeLow preconditions were not respected");
        for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
      }
    };
    TimSort.prototype.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
      var compare = this.compare;
      var array = this.array;
      var tmp = this.tmp;
      var i = 0;
      for (i = 0; i < length2; i++) tmp[i] = array[start2 + i];
      var cursor1 = start1 + length1 - 1;
      var cursor2 = length2 - 1;
      var dest = start2 + length2 - 1;
      var customCursor = 0;
      var customDest = 0;
      array[dest--] = array[cursor1--];
      if (0 === --length1) {
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
        return;
      }
      if (1 === length2) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
        array[dest] = tmp[cursor2];
        return;
      }
      var minGallop = this.minGallop;
      while (true) {
        var count1 = 0;
        var count2 = 0;
        var exit = false;
        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--];
            count1++;
            count2 = 0;
            if (0 === --length1) {
              exit = true;
              break;
            }
          } else {
            array[dest--] = tmp[cursor2--];
            count2++;
            count1 = 0;
            if (1 === --length2) {
              exit = true;
              break;
            }
          }
        } while ((count1 | count2) < minGallop);
        if (exit) break;
        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
          if (0 !== count1) {
            dest -= count1;
            cursor1 -= count1;
            length1 -= count1;
            customDest = dest + 1;
            customCursor = cursor1 + 1;
            for (i = count1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
            if (0 === length1) {
              exit = true;
              break;
            }
          }
          array[dest--] = tmp[cursor2--];
          if (1 === --length2) {
            exit = true;
            break;
          }
          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
          if (0 !== count2) {
            dest -= count2;
            cursor2 -= count2;
            length2 -= count2;
            customDest = dest + 1;
            customCursor = cursor2 + 1;
            for (i = 0; i < count2; i++) array[customDest + i] = tmp[customCursor + i];
            if (length2 <= 1) {
              exit = true;
              break;
            }
          }
          array[dest--] = array[cursor1--];
          if (0 === --length1) {
            exit = true;
            break;
          }
          minGallop--;
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
        if (exit) break;
        minGallop < 0 && (minGallop = 0);
        minGallop += 2;
      }
      this.minGallop = minGallop;
      minGallop < 1 && (this.minGallop = 1);
      if (1 === length2) {
        dest -= length1;
        cursor1 -= length1;
        customDest = dest + 1;
        customCursor = cursor1 + 1;
        for (i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
        array[dest] = tmp[cursor2];
      } else {
        if (0 === length2) throw new Error("mergeHigh preconditions were not respected");
        customCursor = dest - (length2 - 1);
        for (i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
      }
    };
    function sort(array, lo, hi, compare) {
      if (!Array.isArray(array)) throw new TypeError("Can only sort arrays");
      void 0 === lo && (lo = 0);
      void 0 === hi && (hi = array.length);
      void 0 === compare && (compare = alphabeticalCompare);
      var remaining = hi - lo;
      if (remaining < 2) return;
      var runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }
      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
          var force = remaining;
          force > minRun && (force = minRun);
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (0 !== remaining);
      ts.forceMergeRuns();
    }
    var FixedArray = function FixedArray(size) {
      this._count = 0;
      this._data = new Array(size);
    };
    var prototypeAccessors$7 = {
      length: {
        configurable: true
      },
      data: {
        configurable: true
      }
    };
    FixedArray.prototype._resize = function _resize(size) {
      var this$1 = this;
      if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this$1._data[i] = void 0;
    };
    prototypeAccessors$7.length.get = function() {
      return this._count;
    };
    prototypeAccessors$7.data.get = function() {
      return this._data;
    };
    FixedArray.prototype.reset = function reset() {
      var this$1 = this;
      for (var i = 0; i < this._count; ++i) this$1._data[i] = void 0;
      this._count = 0;
    };
    FixedArray.prototype.push = function push(val) {
      this._count >= this._data.length && this._resize(2 * this._data.length);
      this._data[this._count] = val;
      ++this._count;
    };
    FixedArray.prototype.pop = function pop() {
      --this._count;
      this._count < 0 && (this._count = 0);
      var ret = this._data[this._count];
      this._data[this._count] = void 0;
      return ret;
    };
    FixedArray.prototype.fastRemove = function fastRemove(idx) {
      if (idx >= this._count) return;
      var last = this._count - 1;
      this._data[idx] = this._data[last];
      this._data[last] = void 0;
      this._count -= 1;
    };
    FixedArray.prototype.indexOf = function indexOf(val) {
      var idx = this._data.indexOf(val);
      if (idx >= this._count) return -1;
      return idx;
    };
    FixedArray.prototype.sort = function sort$1(cmp) {
      return sort(this._data, 0, this._count, cmp);
    };
    Object.defineProperties(FixedArray.prototype, prototypeAccessors$7);
    var Pool = function Pool(fn, size) {
      var this$1 = this;
      this._fn = fn;
      this._idx = size - 1;
      this._frees = new Array(size);
      for (var i = 0; i < size; ++i) this$1._frees[i] = fn();
    };
    Pool.prototype._expand = function _expand(size) {
      var this$1 = this;
      var old = this._frees;
      this._frees = new Array(size);
      var len = size - old.length;
      for (var i = 0; i < len; ++i) this$1._frees[i] = this$1._fn();
      for (var i$1 = len, j = 0; i$1 < size; ++i$1, ++j) this$1._frees[i$1] = old[j];
      this._idx += len;
    };
    Pool.prototype.alloc = function alloc() {
      this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
      var ret = this._frees[this._idx];
      this._frees[this._idx] = null;
      --this._idx;
      return ret;
    };
    Pool.prototype.free = function free(obj) {
      ++this._idx;
      this._frees[this._idx] = obj;
    };
    var LinkedArray = function LinkedArray(fn, size) {
      this._fn = fn;
      this._count = 0;
      this._head = null;
      this._tail = null;
      this._pool = new Pool(fn, size);
    };
    var prototypeAccessors$8 = {
      head: {
        configurable: true
      },
      tail: {
        configurable: true
      },
      length: {
        configurable: true
      }
    };
    prototypeAccessors$8.head.get = function() {
      return this._head;
    };
    prototypeAccessors$8.tail.get = function() {
      return this._tail;
    };
    prototypeAccessors$8.length.get = function() {
      return this._count;
    };
    LinkedArray.prototype.add = function add() {
      var node = this._pool.alloc();
      if (this._tail) {
        this._tail._next = node;
        node._prev = this._tail;
      } else this._head = node;
      this._tail = node;
      this._count += 1;
      return node;
    };
    LinkedArray.prototype.remove = function remove(node) {
      node._prev ? node._prev._next = node._next : this._head = node._next;
      node._next ? node._next._prev = node._prev : this._tail = node._prev;
      node._next = null;
      node._prev = null;
      this._pool.free(node);
      this._count -= 1;
    };
    LinkedArray.prototype.forEach = function forEach(fn, binder) {
      var this$1 = this;
      var cursor = this._head;
      if (!cursor) return;
      binder && (fn = fn.bind(binder));
      var idx = 0;
      var next = cursor;
      while (cursor) {
        next = cursor._next;
        fn(cursor, idx, this$1);
        cursor = next;
        ++idx;
      }
    };
    Object.defineProperties(LinkedArray.prototype, prototypeAccessors$8);
    var RecyclePool = function RecyclePool(fn, size) {
      var this$1 = this;
      this._fn = fn;
      this._count = 0;
      this._data = new Array(size);
      for (var i = 0; i < size; ++i) this$1._data[i] = fn();
    };
    var prototypeAccessors$9 = {
      length: {
        configurable: true
      },
      data: {
        configurable: true
      }
    };
    prototypeAccessors$9.length.get = function() {
      return this._count;
    };
    prototypeAccessors$9.data.get = function() {
      return this._data;
    };
    RecyclePool.prototype.reset = function reset() {
      this._count = 0;
    };
    RecyclePool.prototype.resize = function resize(size) {
      var this$1 = this;
      if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this$1._data[i] = this$1._fn();
    };
    RecyclePool.prototype.add = function add() {
      this._count >= this._data.length && this.resize(2 * this._data.length);
      return this._data[this._count++];
    };
    RecyclePool.prototype.remove = function remove(idx) {
      if (idx >= this._count) return;
      var last = this._count - 1;
      var tmp = this._data[idx];
      this._data[idx] = this._data[last];
      this._data[last] = tmp;
      this._count -= 1;
    };
    RecyclePool.prototype.sort = function sort$1(cmp) {
      return sort(this._data, 0, this._count, cmp);
    };
    Object.defineProperties(RecyclePool.prototype, prototypeAccessors$9);
    var _bufferPools = Array(8);
    for (var i = 0; i < 8; ++i) _bufferPools[i] = [];
    var Scene = function Scene() {
      this._lights = new FixedArray(16);
      this._models = new FixedArray(16);
      this._cameras = new FixedArray(16);
      this._debugCamera = null;
      this._views = [];
    };
    Scene.prototype._add = function _add(pool, item) {
      if (-1 !== item._poolID) return;
      pool.push(item);
      item._poolID = pool.length - 1;
    };
    Scene.prototype._remove = function _remove(pool, item) {
      if (-1 === item._poolID) return;
      pool.data[pool.length - 1]._poolID = item._poolID;
      pool.fastRemove(item._poolID);
      item._poolID = -1;
    };
    Scene.prototype.reset = function reset() {
      var this$1 = this;
      for (var i = 0; i < this._models.length; ++i) {
        var model = this$1._models.data[i];
        model._cullingMask = -1;
      }
    };
    Scene.prototype.setDebugCamera = function setDebugCamera(cam) {
      this._debugCamera = cam;
    };
    Scene.prototype.getCameraCount = function getCameraCount() {
      return this._cameras.length;
    };
    Scene.prototype.getCamera = function getCamera(idx) {
      return this._cameras.data[idx];
    };
    Scene.prototype.addCamera = function addCamera(camera) {
      this._add(this._cameras, camera);
    };
    Scene.prototype.removeCamera = function removeCamera(camera) {
      this._remove(this._cameras, camera);
    };
    Scene.prototype.getModelCount = function getModelCount() {
      return this._models.length;
    };
    Scene.prototype.getModel = function getModel(idx) {
      return this._models.data[idx];
    };
    Scene.prototype.addModel = function addModel(model) {
      this._add(this._models, model);
    };
    Scene.prototype.removeModel = function removeModel(model) {
      this._remove(this._models, model);
    };
    Scene.prototype.getLightCount = function getLightCount() {
      return this._lights.length;
    };
    Scene.prototype.getLight = function getLight(idx) {
      return this._lights.data[idx];
    };
    Scene.prototype.addLight = function addLight(light) {
      this._add(this._lights, light);
    };
    Scene.prototype.removeLight = function removeLight(light) {
      this._remove(this._lights, light);
    };
    Scene.prototype.addView = function addView(view) {
      -1 === this._views.indexOf(view) && this._views.push(view);
    };
    Scene.prototype.removeView = function removeView(view) {
      var idx = this._views.indexOf(view);
      -1 !== idx && this._views.splice(idx, 1);
    };
    var _shdID = 0;
    function _generateDefines(defs) {
      var defines = [];
      for (var def in defs) true === defs[def] && defines.push("#define " + def);
      return defines.join("\n");
    }
    function _replaceMacroNums(string, defs) {
      var cache = {};
      var tmp = string;
      for (var def in defs) Number.isInteger(defs[def]) && (cache[def] = defs[def]);
      for (var def$1 in cache) {
        var reg = new RegExp(def$1, "g");
        tmp = tmp.replace(reg, cache[def$1]);
      }
      return tmp;
    }
    function _unrollLoops(string) {
      var pattern = /#pragma for (\w+) in range\(\s*(\d+)\s*,\s*(\d+)\s*\)([\s\S]+?)#pragma endFor/g;
      function replace(match, index, begin, end, snippet) {
        var unroll = "";
        var parsedBegin = parseInt(begin);
        var parsedEnd = parseInt(end);
        (parsedBegin.isNaN || parsedEnd.isNaN) && console.error("Unroll For Loops Error: begin and end of range must be an int num.");
        for (var i = parsedBegin; i < parsedEnd; ++i) unroll += snippet.replace(new RegExp("{" + index + "}", "g"), i);
        return unroll;
      }
      return string.replace(pattern, replace);
    }
    var ProgramLib = function ProgramLib(device, templates, chunks) {
      var this$1 = this;
      void 0 === templates && (templates = []);
      void 0 === chunks && (chunks = {});
      this._device = device;
      this._precision = "precision highp float;\n";
      this._templates = {};
      for (var i = 0; i < templates.length; ++i) {
        var tmpl = templates[i];
        this$1.define(tmpl.name, tmpl.vert, tmpl.frag, tmpl.defines);
      }
      this._chunks = {};
      Object.assign(this._chunks, chunks);
      this._cache = {};
    };
    ProgramLib.prototype.define = function define(name, vert, frag, defines) {
      if (this._templates[name]) {
        console.warn("Failed to define shader " + name + ": already exists.");
        return;
      }
      var id = ++_shdID;
      var offset = 0;
      var loop = function(i) {
        var def = defines[i];
        def._offset = offset;
        var cnt = 1;
        if (void 0 !== def.min && void 0 !== def.max) {
          cnt = Math.ceil(.5 * (def.max - def.min));
          def._map = function(value) {
            return value - this._min << def._offset;
          }.bind(def);
        } else def._map = function(value) {
          if (value) return 1 << def._offset;
          return 0;
        }.bind(def);
        offset += cnt;
        def._offset = offset;
      };
      for (var i = 0; i < defines.length; ++i) loop(i);
      vert = this._precision + vert;
      frag = this._precision + frag;
      this._templates[name] = {
        id: id,
        name: name,
        vert: vert,
        frag: frag,
        defines: defines
      };
    };
    ProgramLib.prototype.getKey = function getKey(name, defines) {
      var tmpl = this._templates[name];
      var key = 0;
      for (var i = 0; i < tmpl.defines.length; ++i) {
        var tmplDefs = tmpl.defines[i];
        var value = defines[tmplDefs.name];
        if (void 0 === value) continue;
        key |= tmplDefs._map(value);
      }
      return key << 8 | tmpl.id;
    };
    ProgramLib.prototype.getProgram = function getProgram(name, defines) {
      var key = this.getKey(name, defines);
      var program = this._cache[key];
      if (program) return program;
      var tmpl = this._templates[name];
      var customDef = _generateDefines(defines) + "\n";
      var vert = _replaceMacroNums(tmpl.vert, defines);
      vert = customDef + _unrollLoops(vert);
      var frag = _replaceMacroNums(tmpl.frag, defines);
      frag = customDef + _unrollLoops(frag);
      program = new gfx.Program(this._device, {
        vert: vert,
        frag: frag
      });
      program.link();
      this._cache[key] = program;
      return program;
    };
    var _m3_tmp$1 = mat3.create();
    var _m4_tmp$2 = mat4.create();
    var _stageInfos = new RecyclePool(function() {
      return {
        stage: null,
        items: null
      };
    }, 8);
    var _float2_pool = new RecyclePool(function() {
      return new Float32Array(2);
    }, 8);
    var _float3_pool = new RecyclePool(function() {
      return new Float32Array(3);
    }, 8);
    var _float4_pool = new RecyclePool(function() {
      return new Float32Array(4);
    }, 8);
    var _float9_pool = new RecyclePool(function() {
      return new Float32Array(9);
    }, 8);
    var _float16_pool = new RecyclePool(function() {
      return new Float32Array(16);
    }, 8);
    var _float64_pool = new RecyclePool(function() {
      return new Float32Array(64);
    }, 8);
    var _int2_pool = new RecyclePool(function() {
      return new Int32Array(2);
    }, 8);
    var _int3_pool = new RecyclePool(function() {
      return new Int32Array(3);
    }, 8);
    var _int4_pool = new RecyclePool(function() {
      return new Int32Array(4);
    }, 8);
    var _int64_pool = new RecyclePool(function() {
      return new Int32Array(64);
    }, 8);
    var _type2uniformValue = {};
    _type2uniformValue[enums.PARAM_INT] = function(value) {
      return value;
    };
    _type2uniformValue[enums.PARAM_INT2] = function(value) {
      return vec2.array(_int2_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_INT3] = function(value) {
      return vec3.array(_int3_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_INT4] = function(value) {
      return vec4.array(_int4_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_FLOAT] = function(value) {
      return value;
    };
    _type2uniformValue[enums.PARAM_FLOAT2] = function(value) {
      return vec2.array(_float2_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_FLOAT3] = function(value) {
      return vec3.array(_float3_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_FLOAT4] = function(value) {
      return vec4.array(_float4_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_COLOR3] = function(value) {
      return color3.array(_float3_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_COLOR4] = function(value) {
      return color4.array(_float4_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_MAT2] = function(value) {
      return mat2.array(_float4_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_MAT3] = function(value) {
      return mat3.array(_float9_pool.add(), value);
    };
    _type2uniformValue[enums.PARAM_MAT4] = function(value) {
      return mat4.array(_float16_pool.add(), value);
    };
    var _type2uniformArrayValue = {};
    _type2uniformArrayValue[enums.PARAM_INT] = {
      func: function func(values) {
        var result = _int64_pool.add();
        for (var i = 0; i < values.length; ++i) result[i] = values[i];
        return result;
      },
      size: 1
    };
    _type2uniformArrayValue[enums.PARAM_INT2] = {
      func: function func(values) {
        var result = _int64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          result[2 * i] = values[i].x;
          result[2 * i + 1] = values[i].y;
        }
        return result;
      },
      size: 2
    };
    _type2uniformArrayValue[enums.PARAM_INT3] = {
      func: void 0,
      size: 3
    };
    _type2uniformArrayValue[enums.PARAM_INT4] = {
      func: function func(values) {
        var result = _int64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.x;
          result[4 * i + 1] = v.y;
          result[4 * i + 2] = v.z;
          result[4 * i + 3] = v.w;
        }
        return result;
      },
      size: 4
    };
    _type2uniformArrayValue[enums.PARAM_FLOAT] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) result[i] = values[i];
        return result;
      },
      size: 1
    };
    _type2uniformArrayValue[enums.PARAM_FLOAT2] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          result[2 * i] = values[i].x;
          result[2 * i + 1] = values[i].y;
        }
        return result;
      },
      size: 2
    };
    _type2uniformArrayValue[enums.PARAM_FLOAT3] = {
      func: void 0,
      size: 3
    };
    _type2uniformArrayValue[enums.PARAM_FLOAT4] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.x;
          result[4 * i + 1] = v.y;
          result[4 * i + 2] = v.z;
          result[4 * i + 3] = v.w;
        }
        return result;
      },
      size: 4
    };
    _type2uniformArrayValue[enums.PARAM_COLOR3] = {
      func: void 0,
      size: 3
    };
    _type2uniformArrayValue[enums.PARAM_COLOR4] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.r;
          result[4 * i + 1] = v.g;
          result[4 * i + 2] = v.b;
          result[4 * i + 3] = v.a;
        }
        return result;
      },
      size: 4
    };
    _type2uniformArrayValue[enums.PARAM_MAT2] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[4 * i] = v.m00;
          result[4 * i + 1] = v.m01;
          result[4 * i + 2] = v.m02;
          result[4 * i + 3] = v.m03;
        }
        return result;
      },
      size: 4
    };
    _type2uniformArrayValue[enums.PARAM_MAT3] = {
      func: void 0,
      size: 9
    };
    _type2uniformArrayValue[enums.PARAM_MAT4] = {
      func: function func(values) {
        var result = _float64_pool.add();
        for (var i = 0; i < values.length; ++i) {
          var v = values[i];
          result[16 * i] = v.m00;
          result[16 * i + 1] = v.m01;
          result[16 * i + 2] = v.m02;
          result[16 * i + 3] = v.m03;
          result[16 * i + 4] = v.m04;
          result[16 * i + 5] = v.m05;
          result[16 * i + 6] = v.m06;
          result[16 * i + 7] = v.m07;
          result[16 * i + 8] = v.m08;
          result[16 * i + 9] = v.m09;
          result[16 * i + 10] = v.m10;
          result[16 * i + 11] = v.m11;
          result[16 * i + 12] = v.m12;
          result[16 * i + 13] = v.m13;
          result[16 * i + 14] = v.m14;
          result[16 * i + 15] = v.m15;
        }
        return result;
      },
      size: 16
    };
    var Base = function Base(device, opts) {
      var obj;
      this._device = device;
      this._programLib = new ProgramLib(device, opts.programTemplates, opts.programChunks);
      this._opts = opts;
      this._type2defaultValue = (obj = {}, obj[enums.PARAM_INT] = 0, obj[enums.PARAM_INT2] = vec2.new(0, 0), 
      obj[enums.PARAM_INT3] = vec3.new(0, 0, 0), obj[enums.PARAM_INT4] = vec4.new(0, 0, 0, 0), 
      obj[enums.PARAM_FLOAT] = 0, obj[enums.PARAM_FLOAT2] = vec2.new(0, 0), obj[enums.PARAM_FLOAT3] = vec3.new(0, 0, 0), 
      obj[enums.PARAM_FLOAT4] = vec4.new(0, 0, 0, 0), obj[enums.PARAM_COLOR3] = color3.new(0, 0, 0), 
      obj[enums.PARAM_COLOR4] = color4.new(0, 0, 0, 1), obj[enums.PARAM_MAT2] = mat2.create(), 
      obj[enums.PARAM_MAT3] = mat3.create(), obj[enums.PARAM_MAT4] = mat4.create(), obj[enums.PARAM_TEXTURE_2D] = opts.defaultTexture, 
      obj[enums.PARAM_TEXTURE_CUBE] = opts.defaultTextureCube, obj);
      this._stage2fn = {};
      this._usedTextureUnits = 0;
      this._viewPools = new RecyclePool(function() {
        return new View();
      }, 8);
      this._drawItemsPools = new RecyclePool(function() {
        return {
          model: null,
          node: null,
          ia: null,
          effect: null,
          defines: null
        };
      }, 100);
      this._stageItemsPools = new RecyclePool(function() {
        return new RecyclePool(function() {
          return {
            model: null,
            node: null,
            ia: null,
            effect: null,
            defines: null,
            technique: null,
            sortKey: -1
          };
        }, 100);
      }, 16);
    };
    Base.prototype._resetTextuerUnit = function _resetTextuerUnit() {
      this._usedTextureUnits = 0;
    };
    Base.prototype._allocTextuerUnit = function _allocTextuerUnit() {
      var device = this._device;
      var unit = this._usedTextureUnits;
      unit >= device._caps.maxTextureUnits && console.warn("Trying to use " + unit + " texture units while this GPU supports only " + device._caps.maxTextureUnits);
      this._usedTextureUnits += 1;
      return unit;
    };
    Base.prototype._registerStage = function _registerStage(name, fn) {
      this._stage2fn[name] = fn;
    };
    Base.prototype._reset = function _reset() {
      this._viewPools.reset();
      this._stageItemsPools.reset();
    };
    Base.prototype._requestView = function _requestView() {
      return this._viewPools.add();
    };
    Base.prototype._render = function _render(view, scene) {
      var this$1 = this;
      var device = this._device;
      device.setFrameBuffer(view._framebuffer);
      device.setViewport(view._rect.x, view._rect.y, view._rect.w, view._rect.h);
      var clearOpts = {};
      view._clearFlags & enums.CLEAR_COLOR && (clearOpts.color = [ view._color.r, view._color.g, view._color.b, view._color.a ]);
      view._clearFlags & enums.CLEAR_DEPTH && (clearOpts.depth = view._depth);
      view._clearFlags & enums.CLEAR_STENCIL && (clearOpts.stencil = view._stencil);
      device.clear(clearOpts);
      this._drawItemsPools.reset();
      for (var i = 0; i < scene._models.length; ++i) {
        var model = scene._models.data[i];
        if (0 === (model._cullingMask & view._cullingMask)) continue;
        for (var m = 0; m < model.drawItemCount; ++m) {
          var drawItem = this$1._drawItemsPools.add();
          model.extractDrawItem(drawItem, m);
        }
      }
      _stageInfos.reset();
      for (var i$1 = 0; i$1 < view._stages.length; ++i$1) {
        var stage = view._stages[i$1];
        var stageItems = this$1._stageItemsPools.add();
        stageItems.reset();
        for (var j = 0; j < this._drawItemsPools.length; ++j) {
          var drawItem$1 = this$1._drawItemsPools.data[j];
          var tech = drawItem$1.effect.getTechnique(stage);
          if (tech) {
            var stageItem = stageItems.add();
            stageItem.model = drawItem$1.model;
            stageItem.node = drawItem$1.node;
            stageItem.ia = drawItem$1.ia;
            stageItem.effect = drawItem$1.effect;
            stageItem.defines = drawItem$1.defines;
            stageItem.technique = tech;
            stageItem.sortKey = -1;
          }
        }
        var stageInfo = _stageInfos.add();
        stageInfo.stage = stage;
        stageInfo.items = stageItems;
      }
      for (var i$2 = 0; i$2 < _stageInfos.length; ++i$2) {
        var info = _stageInfos.data[i$2];
        var fn = this$1._stage2fn[info.stage];
        fn(view, info.items);
      }
    };
    Base.prototype._draw = function _draw(item) {
      var this$1 = this;
      var device = this._device;
      var programLib = this._programLib;
      var node = item.node;
      var ia = item.ia;
      var effect = item.effect;
      var technique = item.technique;
      var defines = item.defines;
      _float2_pool.reset();
      _float3_pool.reset();
      _float4_pool.reset();
      _float9_pool.reset();
      _float16_pool.reset();
      _float64_pool.reset();
      _int2_pool.reset();
      _int3_pool.reset();
      _int4_pool.reset();
      _int64_pool.reset();
      node.getWorldMatrix(_m4_tmp$2);
      device.setUniform("model", mat4.array(_float16_pool.add(), _m4_tmp$2));
      mat3.transpose(_m3_tmp$1, mat3.invert(_m3_tmp$1, mat3.fromMat4(_m3_tmp$1, _m4_tmp$2)));
      device.setUniform("normalMatrix", mat3.array(_float9_pool.add(), _m3_tmp$1));
      for (var i = 0; i < technique._parameters.length; ++i) {
        var prop = technique._parameters[i];
        var param = effect.getProperty(prop.name);
        void 0 === param && (param = prop.val);
        void 0 === param && (param = this$1._type2defaultValue[prop.type]);
        if (void 0 === param) {
          console.warn("Failed to set technique property " + prop.name + ", value not found.");
          continue;
        }
        if (prop.type === enums.PARAM_TEXTURE_2D || prop.type === enums.PARAM_TEXTURE_CUBE) if (void 0 !== prop.size) {
          if (prop.size !== param.length) {
            console.error("The length of texture array (" + param.length + ") is not corrent(expect " + prop.size + ").");
            continue;
          }
          var slots = _int64_pool.add();
          for (var index = 0; index < param.length; ++index) slots[index] = this$1._allocTextuerUnit();
          device.setTextureArray(prop.name, param, slots);
        } else device.setTexture(prop.name, param, this$1._allocTextuerUnit()); else {
          var convertedValue = void 0;
          if (void 0 !== prop.size) {
            var convertArray = _type2uniformArrayValue[prop.type];
            if (void 0 === convertArray.func) {
              console.error("Uniform array of color3/int3/float3/mat3 can not be supportted!");
              continue;
            }
            if (prop.size * convertArray.size > 64) {
              console.error("Uniform array is too long!");
              continue;
            }
            convertedValue = convertArray.func(param);
          } else {
            var convertFn = _type2uniformValue[prop.type];
            convertedValue = convertFn(param);
          }
          device.setUniform(prop.name, convertedValue);
        }
      }
      for (var i$1 = 0; i$1 < technique._passes.length; ++i$1) {
        var pass = technique._passes[i$1];
        var count = ia.getPrimitiveCount();
        device.setVertexBuffer(0, ia._vertexBuffer);
        ia._indexBuffer && device.setIndexBuffer(ia._indexBuffer);
        device.setPrimitiveType(ia._primitiveType);
        var program = programLib.getProgram(pass._programName, defines);
        device.setProgram(program);
        device.setCullMode(pass._cullMode);
        if (pass._blend) {
          device.enableBlend();
          device.setBlendFuncSep(pass._blendSrc, pass._blendDst, pass._blendSrcAlpha, pass._blendDstAlpha);
          device.setBlendEqSep(pass._blendEq, pass._blendAlphaEq);
          device.setBlendColor32(pass._blendColor);
        }
        if (pass._depthTest) {
          device.enableDepthTest();
          device.setDepthFunc(pass._depthFunc);
        }
        pass._depthWrite && device.enableDepthWrite();
        if (pass._stencilTest) {
          device.enableStencilTest();
          device.setStencilFuncFront(pass._stencilFuncFront, pass._stencilRefFront, pass._stencilMaskFront);
          device.setStencilOpFront(pass._stencilFailOpFront, pass._stencilZFailOpFront, pass._stencilZPassOpFront, pass._stencilWriteMaskFront);
          device.setStencilFuncBack(pass._stencilFuncBack, pass._stencilRefBack, pass._stencilMaskBack);
          device.setStencilOpBack(pass._stencilFailOpBack, pass._stencilZFailOpBack, pass._stencilZPassOpBack, pass._stencilWriteMaskBack);
        }
        device.draw(ia._start, count);
        this$1._resetTextuerUnit();
      }
    };
    var renderer = {
      addStage: config.addStage,
      createIA: createIA,
      Pass: Pass,
      Technique: Technique,
      Effect: Effect,
      InputAssembler: InputAssembler,
      View: View,
      Light: Light,
      Camera: Camera,
      Model: Model,
      Scene: Scene,
      Base: Base,
      ProgramLib: ProgramLib
    };
    Object.assign(renderer, enums);
    var _a16_view = new Float32Array(16);
    var _a16_proj = new Float32Array(16);
    var _a16_viewProj = new Float32Array(16);
    var ForwardRenderer = (function(superclass) {
      function ForwardRenderer(device, builtin) {
        superclass.call(this, device, builtin);
        this._registerStage("transparent", this._transparentStage.bind(this));
      }
      superclass && (ForwardRenderer.__proto__ = superclass);
      ForwardRenderer.prototype = Object.create(superclass && superclass.prototype);
      ForwardRenderer.prototype.constructor = ForwardRenderer;
      ForwardRenderer.prototype.reset = function reset() {
        this._reset();
      };
      ForwardRenderer.prototype.render = function render(scene) {
        var this$1 = this;
        this._reset();
        scene._cameras.sort((function(a, b) {
          return a._depth > b._depth ? 1 : a._depth < b._depth ? -1 : 0;
        }));
        for (var i = 0; i < scene._cameras.length; ++i) {
          var camera = scene._cameras.data[i];
          camera._poolID = i;
          this$1.renderCamera(camera, scene);
        }
      };
      ForwardRenderer.prototype.renderCamera = function renderCamera(camera, scene) {
        var canvas = this._device._gl.canvas;
        var view = camera.view;
        var dirty = camera.dirty;
        if (!view) {
          view = this._requestView();
          dirty = true;
        }
        if (dirty) {
          var width = canvas.width;
          var height = canvas.height;
          if (camera._framebuffer) {
            width = camera._framebuffer._width;
            height = camera._framebuffer._height;
          }
          camera.extractView(view, width, height);
        }
        this._render(view, scene);
      };
      ForwardRenderer.prototype._transparentStage = function _transparentStage(view, items) {
        var this$1 = this;
        this._device.setUniform("view", mat4.array(_a16_view, view._matView));
        this._device.setUniform("proj", mat4.array(_a16_proj, view._matProj));
        this._device.setUniform("viewProj", mat4.array(_a16_viewProj, view._matViewProj));
        for (var i = 0; i < items.length; ++i) {
          var item = items.data[i];
          this$1._draw(item);
        }
      };
      return ForwardRenderer;
    })(renderer.Base);
    var chunks = {};
    var templates = [ {
      name: "gray_sprite",
      vert: "\n \nuniform mat4 viewProj;\nattribute vec3 a_position;\nattribute vec2 a_uv0;\nvarying vec2 uv0;\nvoid main () {\n  vec4 pos = viewProj * vec4(a_position, 1);\n  gl_Position = pos;\n  uv0 = a_uv0;\n}",
      frag: "\n \nuniform sampler2D texture;\nvarying vec2 uv0;\nuniform vec4 color;\nvoid main () {\n  vec4 c = color * texture2D(texture, uv0);\n  float gray = 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n  gl_FragColor = vec4(gray, gray, gray, c.a);\n}",
      defines: []
    }, {
      name: "sprite",
      vert: "\n \nuniform mat4 viewProj;\n#ifdef use2DPos\nattribute vec2 a_position;\n#else\nattribute vec3 a_position;\n#endif\nattribute vec4 a_color;\n#ifdef useModel\n  uniform mat4 model;\n#endif\n#ifdef useTexture\n  attribute vec2 a_uv0;\n  varying vec2 uv0;\n#endif\n#ifndef useColor\nvarying lowp vec4 v_fragmentColor;\n#endif\nvoid main () {\n  mat4 mvp;\n  #ifdef useModel\n    mvp = viewProj * model;\n  #else\n    mvp = viewProj;\n  #endif\n  #ifdef use2DPos\n  vec4 pos = mvp * vec4(a_position, 0, 1);\n  #else\n  vec4 pos = mvp * vec4(a_position, 1);\n  #endif\n  #ifndef useColor\n  v_fragmentColor = a_color;\n  #endif\n  #ifdef useTexture\n    uv0 = a_uv0;\n  #endif\n  gl_Position = pos;\n}",
      frag: "\n \n#ifdef useTexture\n  uniform sampler2D texture;\n  varying vec2 uv0;\n#endif\n#ifdef alphaTest\n  uniform float alphaThreshold;\n#endif\n#ifdef useColor\n  uniform vec4 color;\n#else\n  varying vec4 v_fragmentColor;\n#endif\nvoid main () {\n  #ifdef useColor\n    vec4 o = color;\n  #else\n    vec4 o = v_fragmentColor;\n  #endif\n  #ifdef useTexture\n    o *= texture2D(texture, uv0);\n  #endif\n  #ifdef alphaTest\n    if (o.a <= alphaThreshold)\n      discard;\n  #endif\n  gl_FragColor = o;\n}",
      defines: [ {
        name: "useTexture"
      }, {
        name: "useModel"
      }, {
        name: "alphaTest"
      }, {
        name: "use2DPos"
      }, {
        name: "useColor"
      } ]
    } ];
    var shaders = {
      chunks: chunks,
      templates: templates
    };
    var BaseRenderData = function BaseRenderData() {
      this.material = null;
      this.vertexCount = 0;
      this.indiceCount = 0;
    };
    var _pool;
    var _dataPool = new Pool(function() {
      return {
        x: 0,
        y: 0,
        u: 0,
        v: 0,
        color: 0
      };
    }, 128);
    var RenderData = (function(BaseRenderData$$1) {
      function RenderData() {
        BaseRenderData$$1.call(this);
        this._data = [];
        this._indices = [];
        this._pivotX = 0;
        this._pivotY = 0;
        this._width = 0;
        this._height = 0;
        this.uvDirty = true;
        this.vertDirty = true;
      }
      BaseRenderData$$1 && (RenderData.__proto__ = BaseRenderData$$1);
      RenderData.prototype = Object.create(BaseRenderData$$1 && BaseRenderData$$1.prototype);
      RenderData.prototype.constructor = RenderData;
      var prototypeAccessors = {
        type: {
          configurable: true
        },
        dataLength: {
          configurable: true
        }
      };
      prototypeAccessors.type.get = function() {
        return RenderData.type;
      };
      prototypeAccessors.dataLength.get = function() {
        return this._data.length;
      };
      prototypeAccessors.dataLength.set = function(length) {
        var data = this._data;
        if (data.length !== length) {
          for (var i = length; i < data.length; i++) _dataPool.free(data[i]);
          for (var i$1 = data.length; i$1 < length; i$1++) data[i$1] = _dataPool.alloc();
          data.length = length;
        }
      };
      RenderData.prototype.updateSizeNPivot = function updateSizeNPivot(width, height, pivotX, pivotY) {
        if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
          this._width = width;
          this._height = height;
          this._pivotX = pivotX;
          this._pivotY = pivotY;
          this.vertDirty = true;
        }
      };
      RenderData.alloc = function alloc() {
        return _pool.alloc();
      };
      RenderData.free = function free(data) {
        if (data instanceof RenderData) {
          for (var i = data.length - 1; i > 0; i--) _dataPool.free(data._data[i]);
          data._data.length = 0;
          data._indices.length = 0;
          data.material = null;
          data.uvDirty = true;
          data.vertDirty = true;
          data.vertexCount = 0;
          data.indiceCount = 0;
          _pool.free(data);
        }
      };
      Object.defineProperties(RenderData.prototype, prototypeAccessors);
      return RenderData;
    })(BaseRenderData);
    RenderData.type = "RenderData";
    _pool = new Pool(function() {
      return new RenderData();
    }, 32);
    var IARenderData = (function(BaseRenderData$$1) {
      function IARenderData() {
        BaseRenderData$$1.call(this);
        this.ia = null;
      }
      BaseRenderData$$1 && (IARenderData.__proto__ = BaseRenderData$$1);
      IARenderData.prototype = Object.create(BaseRenderData$$1 && BaseRenderData$$1.prototype);
      IARenderData.prototype.constructor = IARenderData;
      var prototypeAccessors = {
        type: {
          configurable: true
        }
      };
      prototypeAccessors.type.get = function() {
        return IARenderData.type;
      };
      Object.defineProperties(IARenderData.prototype, prototypeAccessors);
      return IARenderData;
    })(BaseRenderData);
    IARenderData.type = "IARenderData";
    var Asset = function Asset(persist) {
      void 0 === persist && (persist = true);
      this._loaded = false;
      this._persist = persist;
    };
    Asset.prototype.unload = function unload() {
      this._loaded = false;
    };
    Asset.prototype.reload = function reload() {};
    var Texture$2 = (function(Asset$$1) {
      function Texture(persist) {
        void 0 === persist && (persist = true);
        Asset$$1.call(this, persist);
        this._texture = null;
      }
      Asset$$1 && (Texture.__proto__ = Asset$$1);
      Texture.prototype = Object.create(Asset$$1 && Asset$$1.prototype);
      Texture.prototype.constructor = Texture;
      Texture.prototype.getImpl = function getImpl() {
        return this._texture;
      };
      Texture.prototype.getId = function getId() {};
      Texture.prototype.destroy = function destroy() {
        this._texture && this._texture.destroy();
      };
      return Texture;
    })(Asset);
    function murmurhash2_32_gc(str, seed) {
      var l = str.length, h = seed ^ l, i = 0, k;
      while (l >= 4) {
        k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        k ^= k >>> 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ k;
        l -= 4;
        ++i;
      }
      switch (l) {
       case 3:
        h ^= (255 & str.charCodeAt(i + 2)) << 16;

       case 2:
        h ^= (255 & str.charCodeAt(i + 1)) << 8;

       case 1:
        h ^= 255 & str.charCodeAt(i);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      }
      h ^= h >>> 13;
      h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      h ^= h >>> 15;
      return h >>> 0;
    }
    function serializeDefines(defines) {
      var str = "";
      for (var i = 0; i < defines.length; i++) str += defines[i].name + defines[i].value;
      return str;
    }
    function serializePass(pass) {
      var str = pass._programName + pass._cullMode;
      pass._blend && (str += pass._blendEq + pass._blendAlphaEq + pass._blendSrc + pass._blendDst + pass._blendSrcAlpha + pass._blendDstAlpha + pass._blendColor);
      pass._depthTest && (str += pass._depthWrite + pass._depthFunc);
      pass._stencilTest && (str += pass._stencilFuncFront + pass._stencilRefFront + pass._stencilMaskFront + pass._stencilFailOpFront + pass._stencilZFailOpFront + pass._stencilZPassOpFront + pass._stencilWriteMaskFront + pass._stencilFuncBack + pass._stencilRefBack + pass._stencilMaskBack + pass._stencilFailOpBack + pass._stencilZFailOpBack + pass._stencilZPassOpBack + pass._stencilWriteMaskBack);
      return str;
    }
    function computeHash(material) {
      var effect = material._effect;
      var hashData = "";
      if (effect) {
        var i, j, techData, param, prop, propKey;
        hashData += serializeDefines(effect._defines);
        for (i = 0; i < effect._techniques.length; i++) {
          techData = effect._techniques[i];
          hashData += techData.stageIDs;
          for (j = 0; j < techData.passes.length; j++) hashData += serializePass(techData.passes[j]);
          for (j = 0; j < techData._parameters.length; j++) {
            param = techData._parameters[j];
            propKey = param.name;
            prop = effect._properties[propKey];
            if (!prop) continue;
            switch (param.type) {
             case renderer.PARAM_INT:
             case renderer.PARAM_FLOAT:
              hashData += prop + ";";
              break;

             case renderer.PARAM_INT2:
             case renderer.PARAM_FLOAT2:
              hashData += prop.x + "," + prop.y + ";";
              break;

             case renderer.PARAM_INT4:
             case renderer.PARAM_FLOAT4:
              hashData += prop.x + "," + prop.y + "," + prop.z + "," + prop.w + ";";
              break;

             case renderer.PARAM_COLOR4:
              hashData += prop.r + "," + prop.g + "," + prop.b + "," + prop.a + ";";
              break;

             case renderer.PARAM_MAT2:
              hashData += prop.m00 + "," + prop.m01 + "," + prop.m02 + "," + prop.m03 + ";";
              break;

             case renderer.PARAM_TEXTURE_2D:
             case renderer.PARAM_TEXTURE_CUBE:
              hashData += material._texIds[propKey] + ";";
              break;

             case renderer.PARAM_INT3:
             case renderer.PARAM_FLOAT3:
             case renderer.PARAM_COLOR3:
             case renderer.PARAM_MAT3:
             case renderer.PARAM_MAT4:
              hashData += JSON.stringify(prop) + ";";
            }
          }
        }
      }
      return hashData ? murmurhash2_32_gc(hashData, 666) : hashData;
    }
    var Material = (function(Asset$$1) {
      function Material(persist) {
        void 0 === persist && (persist = false);
        Asset$$1.call(this, persist);
        this._effect = null;
        this._texIds = {};
        this._hash = "";
      }
      Asset$$1 && (Material.__proto__ = Asset$$1);
      Material.prototype = Object.create(Asset$$1 && Asset$$1.prototype);
      Material.prototype.constructor = Material;
      var prototypeAccessors = {
        hash: {
          configurable: true
        }
      };
      prototypeAccessors.hash.get = function() {
        return this._hash;
      };
      Material.prototype.updateHash = function updateHash(value) {
        this._hash = value || computeHash(this);
      };
      Object.defineProperties(Material.prototype, prototypeAccessors);
      return Material;
    })(Asset);
    var SpriteMaterial = (function(Material$$1) {
      function SpriteMaterial() {
        Material$$1.call(this, false);
        var pass = new renderer.Pass("sprite");
        pass.setDepth(false, false);
        pass.setCullMode(gfx.CULL_NONE);
        pass.setBlend(gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA, gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA);
        var mainTech = new renderer.Technique([ "transparent" ], [ {
          name: "texture",
          type: renderer.PARAM_TEXTURE_2D
        }, {
          name: "color",
          type: renderer.PARAM_COLOR4
        } ], [ pass ]);
        this._color = {
          r: 1,
          g: 1,
          b: 1,
          a: 1
        };
        this._effect = new renderer.Effect([ mainTech ], {
          color: this._color
        }, [ {
          name: "useTexture",
          value: true
        }, {
          name: "useModel",
          value: false
        }, {
          name: "alphaTest",
          value: false
        }, {
          name: "use2DPos",
          value: true
        }, {
          name: "useColor",
          value: true
        } ]);
        this._mainTech = mainTech;
        this._texture = null;
      }
      Material$$1 && (SpriteMaterial.__proto__ = Material$$1);
      SpriteMaterial.prototype = Object.create(Material$$1 && Material$$1.prototype);
      SpriteMaterial.prototype.constructor = SpriteMaterial;
      var prototypeAccessors = {
        effect: {
          configurable: true
        },
        useTexture: {
          configurable: true
        },
        useModel: {
          configurable: true
        },
        use2DPos: {
          configurable: true
        },
        useColor: {
          configurable: true
        },
        texture: {
          configurable: true
        },
        color: {
          configurable: true
        }
      };
      prototypeAccessors.effect.get = function() {
        return this._effect;
      };
      prototypeAccessors.useTexture.get = function() {
        this._effect.getDefine("useTexture");
      };
      prototypeAccessors.useTexture.set = function(val) {
        this._effect.define("useTexture", val);
      };
      prototypeAccessors.useModel.get = function() {
        this._effect.getDefine("useModel");
      };
      prototypeAccessors.useModel.set = function(val) {
        this._effect.define("useModel", val);
      };
      prototypeAccessors.use2DPos.get = function() {
        this._effect.getDefine("use2DPos");
      };
      prototypeAccessors.use2DPos.set = function(val) {
        this._effect.define("use2DPos", val);
      };
      prototypeAccessors.useColor.get = function() {
        this._effect.getDefine("useColor");
      };
      prototypeAccessors.useColor.set = function(val) {
        this._effect.define("useColor", val);
      };
      prototypeAccessors.texture.get = function() {
        return this._texture;
      };
      prototypeAccessors.texture.set = function(val) {
        if (this._texture !== val) {
          this._texture = val;
          this._effect.setProperty("texture", val.getImpl());
          this._texIds["texture"] = val.getId();
        }
      };
      prototypeAccessors.color.get = function() {
        return this._color;
      };
      prototypeAccessors.color.set = function(val) {
        var color = this._color;
        color.r = val.r / 255;
        color.g = val.g / 255;
        color.b = val.b / 255;
        color.a = val.a / 255;
        this._effect.setProperty("color", color);
      };
      SpriteMaterial.prototype.clone = function clone() {
        var copy = new SpriteMaterial();
        copy.texture = this.texture;
        copy.useTexture = this.useTexture;
        copy.useModel = this.useModel;
        copy.use2DPos = this.use2DPos;
        copy.useColor = this.useColor;
        copy.updateHash();
        return copy;
      };
      Object.defineProperties(SpriteMaterial.prototype, prototypeAccessors);
      return SpriteMaterial;
    })(Material);
    var GraySpriteMaterial = (function(Material$$1) {
      function GraySpriteMaterial() {
        Material$$1.call(this, false);
        var pass = new renderer.Pass("gray_sprite");
        pass.setDepth(false, false);
        pass.setCullMode(gfx.CULL_NONE);
        pass.setBlend(gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA, gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA);
        var mainTech = new renderer.Technique([ "transparent" ], [ {
          name: "texture",
          type: renderer.PARAM_TEXTURE_2D
        }, {
          name: "color",
          type: renderer.PARAM_COLOR4
        } ], [ pass ]);
        this._color = {
          r: 1,
          g: 1,
          b: 1,
          a: 1
        };
        this._effect = new renderer.Effect([ mainTech ], {
          color: this._color
        }, []);
        this._mainTech = mainTech;
        this._texture = null;
      }
      Material$$1 && (GraySpriteMaterial.__proto__ = Material$$1);
      GraySpriteMaterial.prototype = Object.create(Material$$1 && Material$$1.prototype);
      GraySpriteMaterial.prototype.constructor = GraySpriteMaterial;
      var prototypeAccessors = {
        effect: {
          configurable: true
        },
        texture: {
          configurable: true
        },
        color: {
          configurable: true
        }
      };
      prototypeAccessors.effect.get = function() {
        return this._effect;
      };
      prototypeAccessors.texture.get = function() {
        return this._texture;
      };
      prototypeAccessors.texture.set = function(val) {
        if (this._texture !== val) {
          this._texture = val;
          this._effect.setProperty("texture", val.getImpl());
          this._texIds["texture"] = val.getId();
        }
      };
      prototypeAccessors.color.get = function() {
        return this._color;
      };
      prototypeAccessors.color.set = function(val) {
        var color = this._color;
        color.r = val.r / 255;
        color.g = val.g / 255;
        color.b = val.b / 255;
        color.a = val.a / 255;
        this._effect.setProperty("color", color);
      };
      GraySpriteMaterial.prototype.clone = function clone() {
        var copy = new GraySpriteMaterial();
        copy.texture = this.texture;
        copy.updateHash();
        return copy;
      };
      Object.defineProperties(GraySpriteMaterial.prototype, prototypeAccessors);
      return GraySpriteMaterial;
    })(Material);
    var StencilMaterial = (function(Material$$1) {
      function StencilMaterial() {
        Material$$1.call(this, false);
        this._pass = new renderer.Pass("sprite");
        this._pass.setDepth(false, false);
        this._pass.setCullMode(gfx.CULL_NONE);
        this._pass.setBlend(gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA, gfx.BLEND_FUNC_ADD, gfx.BLEND_SRC_ALPHA, gfx.BLEND_ONE_MINUS_SRC_ALPHA);
        var mainTech = new renderer.Technique([ "transparent" ], [ {
          name: "texture",
          type: renderer.PARAM_TEXTURE_2D
        }, {
          name: "alphaThreshold",
          type: renderer.PARAM_FLOAT
        }, {
          name: "color",
          type: renderer.PARAM_COLOR4
        } ], [ this._pass ]);
        this._effect = new renderer.Effect([ mainTech ], {
          color: {
            r: 1,
            g: 1,
            b: 1,
            a: 1
          }
        }, [ {
          name: "useTexture",
          value: true
        }, {
          name: "useModel",
          value: false
        }, {
          name: "alphaTest",
          value: true
        }, {
          name: "use2DPos",
          value: true
        }, {
          name: "useColor",
          value: true
        } ]);
        this._mainTech = mainTech;
        this._texture = null;
      }
      Material$$1 && (StencilMaterial.__proto__ = Material$$1);
      StencilMaterial.prototype = Object.create(Material$$1 && Material$$1.prototype);
      StencilMaterial.prototype.constructor = StencilMaterial;
      var prototypeAccessors = {
        effect: {
          configurable: true
        },
        useTexture: {
          configurable: true
        },
        useColor: {
          configurable: true
        },
        texture: {
          configurable: true
        },
        alphaThreshold: {
          configurable: true
        }
      };
      prototypeAccessors.effect.get = function() {
        return this._effect;
      };
      prototypeAccessors.useTexture.get = function() {
        this._effect.getDefine("useTexture");
      };
      prototypeAccessors.useTexture.set = function(val) {
        this._effect.define("useTexture", val);
      };
      prototypeAccessors.useColor.get = function() {
        this._effect.getDefine("useColor");
      };
      prototypeAccessors.useColor.set = function(val) {
        this._effect.define("useColor", val);
      };
      prototypeAccessors.texture.get = function() {
        return this._texture;
      };
      prototypeAccessors.texture.set = function(val) {
        if (this._texture !== val) {
          this._texture = val;
          this._effect.setProperty("texture", val.getImpl());
          this._texIds["texture"] = val.getId();
        }
      };
      prototypeAccessors.alphaThreshold.get = function() {
        return this._effect.getProperty("alphaThreshold");
      };
      prototypeAccessors.alphaThreshold.set = function(val) {
        this._effect.setProperty("alphaThreshold", val);
      };
      StencilMaterial.prototype.clone = function clone() {
        var copy = new StencilMaterial();
        copy.useTexture = this.useTexture;
        copy.useColor = this.useColor;
        copy.texture = this.texture;
        copy.alphaThreshold = this.alphaThreshold;
        copy.updateHash();
        return copy;
      };
      Object.defineProperties(StencilMaterial.prototype, prototypeAccessors);
      return StencilMaterial;
    })(Material);
    var Device$2 = function Device(canvasEL) {
      var ctx;
      try {
        ctx = canvasEL.getContext("2d");
      } catch (err) {
        console.error(err);
        return;
      }
      this._canvas = canvasEL;
      this._ctx = ctx;
      this._caps = {};
      this._stats = {
        drawcalls: 0
      };
      this._vx = this._vy = this._vw = this._vh = 0;
      this._sx = this._sy = this._sw = this._sh = 0;
    };
    Device$2.prototype._restoreTexture = function _restoreTexture(unit) {};
    Device$2.prototype.setViewport = function setViewport(x, y, w, h) {
      if (this._vx !== x || this._vy !== y || this._vw !== w || this._vh !== h) {
        this._vx = x;
        this._vy = y;
        this._vw = w;
        this._vh = h;
      }
    };
    Device$2.prototype.setScissor = function setScissor(x, y, w, h) {
      if (this._sx !== x || this._sy !== y || this._sw !== w || this._sh !== h) {
        this._sx = x;
        this._sy = y;
        this._sw = w;
        this._sh = h;
      }
    };
    Device$2.prototype.clear = function clear(color) {
      var ctx = this._ctx;
      ctx.clearRect(this._vx, this._vy, this._vw, this._vh);
      if (color && (0 !== color[0] || 0 !== color[1] || 0 !== color[2])) {
        ctx.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
        ctx.globalAlpha = color[3];
        ctx.fillRect(this._vx, this._vy, this._vw, this._vh);
      }
    };
    var Texture2D$2 = function Texture2D(device, options) {
      this._device = device;
      this._width = 4;
      this._height = 4;
      this._image = null;
      if (options) {
        void 0 !== options.width && (this._width = options.width);
        void 0 !== options.height && (this._height = options.height);
        this.updateImage(options);
      }
    };
    Texture2D$2.prototype.update = function update(options) {
      this.updateImage(options);
    };
    Texture2D$2.prototype.updateImage = function updateImage(options) {
      if (options.images && options.images[0]) {
        var image = options.images[0];
        image && image !== this._image && (this._image = image);
      }
    };
    Texture2D$2.prototype.destroy = function destroy() {
      this._image = null;
    };
    var canvas = {
      Device: Device$2,
      Texture2D: Texture2D$2
    };
    var Scene$2 = renderer.Scene;
    var Camera$2 = renderer.Camera;
    var View$2 = renderer.View;
    var Texture2D$4 = gfx.Texture2D;
    var Device$4 = gfx.Device;
    var Model$2 = renderer.Model;
    var InputAssembler$2 = renderer.InputAssembler;
    renderer.config ? renderer.config.addStage("transparent") : renderer.addStage("transparent");
    var renderEngine = {
      Device: Device$4,
      ForwardRenderer: ForwardRenderer,
      Texture2D: Texture2D$4,
      canvas: canvas,
      Scene: Scene$2,
      Camera: Camera$2,
      View: View$2,
      Model: Model$2,
      RenderData: RenderData,
      IARenderData: IARenderData,
      InputAssembler: InputAssembler$2,
      Asset: Asset,
      TextureAsset: Texture$2,
      Material: Material,
      SpriteMaterial: SpriteMaterial,
      GraySpriteMaterial: GraySpriteMaterial,
      StencilMaterial: StencilMaterial,
      shaders: shaders,
      RecyclePool: RecyclePool,
      Pool: Pool,
      math: math,
      renderer: renderer,
      gfx: gfx
    };
    module.exports = renderEngine;
  }), {} ],
  198: [ (function(require, module, exports) {
    var mat4 = cc.vmath.mat4;
    var ONE_DEGREE = Math.PI / 180;
    var DONOTHING = 0;
    var LOCAL_TRANSFORM = 1;
    var WORLD_TRANSFORM = 2;
    var TRANSFORM = LOCAL_TRANSFORM | WORLD_TRANSFORM;
    var UPDATE_RENDER_DATA = 4;
    var COLOR = 8;
    var RENDER = 16;
    var CUSTOM_IA_RENDER = 32;
    var CHILDREN = 64;
    var POST_UPDATE_RENDER_DATA = 128;
    var POST_RENDER = 256;
    var FINAL = 512;
    var _walker = null;
    var _cullingMask = 0;
    function RenderFlow() {
      this._func = init;
      this._next = null;
    }
    var _proto = RenderFlow.prototype;
    _proto._doNothing = function() {};
    _proto._localTransform = function(node) {
      node._updateLocalMatrix();
      node._renderFlag &= ~LOCAL_TRANSFORM;
      this._next._func(node);
    };
    function mul(out, a, b) {
      var aa = a.m00, ab = a.m01, ac = a.m04, ad = a.m05, atx = a.m12, aty = a.m13;
      var ba = b.m00, bb = b.m01, bc = b.m04, bd = b.m05, btx = b.m12, bty = b.m13;
      if (0 !== bb || 0 !== bc) {
        out.m00 = aa * ba + ab * bc;
        out.m01 = aa * bb + ab * bd;
        out.m04 = ac * ba + ad * bc;
        out.m05 = ac * bb + ad * bd;
        out.m12 = ba * atx + bc * aty + btx;
        out.m13 = bb * atx + bd * aty + bty;
      } else {
        out.m00 = aa * ba;
        out.m01 = ab * bd;
        out.m04 = ac * ba;
        out.m05 = ad * bd;
        out.m12 = ba * atx + btx;
        out.m13 = bd * aty + bty;
      }
    }
    _proto._worldTransform = function(node) {
      _walker.worldMatDirty++;
      var t = node._matrix;
      var position = node._position;
      t.m12 = position.x;
      t.m13 = position.y;
      mul(node._worldMatrix, t, node._parent._worldMatrix);
      node._renderFlag &= ~WORLD_TRANSFORM;
      this._next._func(node);
      _walker.worldMatDirty--;
    };
    _proto._color = function(node) {
      var opacityLevel = node._opacity < 255 ? 1 : 0;
      _walker.parentOpacityDirty += opacityLevel;
      var comp = node._renderComponent;
      comp ? comp._updateColor() : node._renderFlag &= ~COLOR;
      this._next._func(node);
      _walker.parentOpacityDirty -= opacityLevel;
    };
    _proto._updateRenderData = function(node) {
      var comp = node._renderComponent;
      comp._assembler.updateRenderData(comp);
      node._renderFlag &= ~UPDATE_RENDER_DATA;
      this._next._func(node);
    };
    _proto._render = function(node) {
      var comp = node._renderComponent;
      _walker._commitComp(comp, comp._assembler, node._cullingMask);
      this._next._func(node);
    };
    _proto._customIARender = function(node) {
      var comp = node._renderComponent;
      _walker._commitIA(comp, comp._assembler, node._cullingMask);
      this._next._func(node);
    };
    _proto._children = function(node) {
      var cullingMask = _cullingMask;
      var parentOpacity = _walker.parentOpacity;
      _walker.parentOpacity *= node._opacity / 255;
      var worldTransformFlag = _walker.worldMatDirty ? WORLD_TRANSFORM : 0;
      var worldOpacityFlag = _walker.parentOpacityDirty ? COLOR : 0;
      var children = node._children;
      for (var i = 0, l = children.length; i < l; i++) {
        var c = children[i];
        if (!c.activeInHierarchy) continue;
        _cullingMask = c._cullingMask = 0 === c.groupIndex ? cullingMask : 1 << c.groupIndex;
        c._renderFlag |= worldTransformFlag | worldOpacityFlag;
        var a = c._color.a;
        c._color.a = a * c._opacity * _walker.parentOpacity;
        flows[c._renderFlag]._func(c);
        c._color.a = a;
      }
      _walker.parentOpacity = parentOpacity;
      this._next._func(node);
      _cullingMask = cullingMask;
    };
    _proto._postUpdateRenderData = function(node) {
      var comp = node._renderComponent;
      comp._postAssembler && comp._postAssembler.updateRenderData(comp);
      node._renderFlag &= ~POST_UPDATE_RENDER_DATA;
      this._next._func(node);
    };
    _proto._postRender = function(node) {
      var comp = node._renderComponent;
      _walker._commitComp(comp, comp._postAssembler, node._cullingMask);
      this._next._func(node);
    };
    var EMPTY_FLOW = new RenderFlow();
    EMPTY_FLOW._func = EMPTY_FLOW._doNothing;
    EMPTY_FLOW._next = EMPTY_FLOW;
    var flows = {};
    function createFlow(flag, next) {
      var flow = new RenderFlow();
      flow._next = next || EMPTY_FLOW;
      switch (flag) {
       case DONOTHING:
        flow._func = flow._doNothing;
        break;

       case LOCAL_TRANSFORM:
        flow._func = flow._localTransform;
        break;

       case WORLD_TRANSFORM:
        flow._func = flow._worldTransform;
        break;

       case COLOR:
        flow._func = flow._color;
        break;

       case UPDATE_RENDER_DATA:
        flow._func = flow._updateRenderData;
        break;

       case RENDER:
        flow._func = flow._render;
        break;

       case CUSTOM_IA_RENDER:
        flow._func = flow._customIARender;
        break;

       case CHILDREN:
        flow._func = flow._children;
        break;

       case POST_UPDATE_RENDER_DATA:
        flow._func = flow._postUpdateRenderData;
        break;

       case POST_RENDER:
        flow._func = flow._postRender;
      }
      return flow;
    }
    function getFlow(flag) {
      var flow = null;
      var tFlag = FINAL;
      while (tFlag > 0) {
        tFlag & flag && (flow = createFlow(tFlag, flow));
        tFlag >>= 1;
      }
      return flow;
    }
    function render(scene) {
      _cullingMask = 1 << scene.groupIndex;
      if (scene._renderFlag & WORLD_TRANSFORM) {
        _walker.worldMatDirty++;
        scene._calculWorldMatrix();
        scene._renderFlag &= ~WORLD_TRANSFORM;
        flows[scene._renderFlag]._func(scene);
        _walker.worldMatDirty--;
      } else flows[scene._renderFlag]._func(scene);
    }
    function init(node) {
      var flag = node._renderFlag;
      var r = flows[flag] = getFlow(flag);
      r._func(node);
    }
    RenderFlow.flows = flows;
    RenderFlow.createFlow = createFlow;
    RenderFlow.render = render;
    RenderFlow.init = function(walker) {
      _walker = walker;
      flows[0] = EMPTY_FLOW;
      for (var i = 1; i < FINAL; i++) flows[i] = new RenderFlow();
    };
    RenderFlow.FLAG_DONOTHING = DONOTHING;
    RenderFlow.FLAG_LOCAL_TRANSFORM = LOCAL_TRANSFORM;
    RenderFlow.FLAG_WORLD_TRANSFORM = WORLD_TRANSFORM;
    RenderFlow.FLAG_TRANSFORM = TRANSFORM;
    RenderFlow.FLAG_COLOR = COLOR;
    RenderFlow.FLAG_UPDATE_RENDER_DATA = UPDATE_RENDER_DATA;
    RenderFlow.FLAG_RENDER = RENDER;
    RenderFlow.FLAG_CUSTOM_IA_RENDER = CUSTOM_IA_RENDER;
    RenderFlow.FLAG_CHILDREN = CHILDREN;
    RenderFlow.FLAG_POST_UPDATE_RENDER_DATA = POST_UPDATE_RENDER_DATA;
    RenderFlow.FLAG_POST_RENDER = POST_RENDER;
    RenderFlow.FLAG_FINAL = FINAL;
    module.exports = cc.RenderFlow = RenderFlow;
  }), {} ],
  199: [ (function(require, module, exports) {
    var space = 2;
    class Atlas {
      constructor(width, height) {
        var texture = new cc.RenderTexture();
        texture.initWithSize(width, height);
        texture.update();
        this._texture = texture;
        this._x = space;
        this._y = space;
        this._nexty = space;
        this._width = width;
        this._height = height;
        this._innerTextureInfos = {};
        this._innerSpriteFrames = [];
      }
      insertSpriteFrame(spriteFrame) {
        var rect = spriteFrame._rect, texture = spriteFrame._texture, info = this._innerTextureInfos[texture._id];
        var sx = rect.x, sy = rect.y;
        if (info) {
          rect.x += info.x;
          rect.y += info.y;
        } else {
          var width = texture.width, height = texture.height;
          if (this._x + width + space > this._width) {
            this._x = space;
            this._y = this._nexty;
          }
          this._y + height > this._nexty && (this._nexty = this._y + height + space);
          if (this._nexty > this._height) return false;
          this._texture.drawTextureAt(texture, this._x - 1, this._y);
          this._texture.drawTextureAt(texture, this._x + 1, this._y);
          this._texture.drawTextureAt(texture, this._x, this._y - 1);
          this._texture.drawTextureAt(texture, this._x, this._y + 1);
          this._texture.drawTextureAt(texture, this._x, this._y);
          this._innerTextureInfos[texture._id] = {
            x: this._x,
            y: this._y,
            texture: texture
          };
          rect.x += this._x;
          rect.y += this._y;
          this._x += width + space;
          this._dirty = true;
        }
        spriteFrame._original = {
          x: sx,
          y: sy,
          texture: spriteFrame._texture
        };
        spriteFrame._texture = this._texture;
        spriteFrame._calculateUV();
        this._innerSpriteFrames.push(spriteFrame);
        return true;
      }
      update() {
        if (!this._dirty) return;
        this._texture.update();
        this._dirty = false;
      }
      reset() {
        this._x = space;
        this._y = space;
        this._nexty = space;
        var frames = this._innerSpriteFrames;
        for (var i = 0, l = frames.length; i < l; i++) {
          var frame = frames[i];
          if (!frame.isValid) continue;
          var oriInfo = frame._original;
          frame._rect.x = oriInfo.x;
          frame._rect.y = oriInfo.y;
          frame._texture = oriInfo.texture;
          frame._calculateUV();
          frame._original = null;
        }
        this._innerSpriteFrames.length = 0;
        this._innerTextureInfos = {};
      }
      destroy() {
        this.reset();
        this._texture.destroy();
      }
    }
    module.exports = Atlas;
  }), {} ],
  200: [ (function(require, module, exports) {
    var Atlas = require("./atlas");
    var _atlases = [];
    var _atlasIndex = -1;
    var _maxAtlasCount = 5;
    var _textureSize = 2048;
    var _minFrameSize = 8;
    var _maxFrameSize = 512;
    var _debugNode = null;
    function newAtlas() {
      var atlas = _atlases[++_atlasIndex];
      if (!atlas) {
        atlas = new Atlas(_textureSize, _textureSize);
        _atlases.push(atlas);
      }
      return atlas;
    }
    function beforeSceneLoad() {
      dynamicAtlasManager.reset();
    }
    var _enabled = false;
    var dynamicAtlasManager = {
      get enabled() {
        return _enabled;
      },
      set enabled(value) {
        if (_enabled === value) return;
        if (value) {
          this.reset();
          cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, beforeSceneLoad);
        } else cc.director.off(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, beforeSceneLoad);
        _enabled = value;
      },
      get maxAtlasCount() {
        return _maxAtlasCount;
      },
      set maxAtlasCount(value) {
        _maxAtlasCount = value;
      },
      get textureSize() {
        return _textureSize;
      },
      set textureSize(value) {
        _textureSize = value;
      },
      get maxFrameSize() {
        return _maxFrameSize;
      },
      set maxFrameSize(value) {
        _maxFrameSize = value;
      },
      insertSpriteFrame: function(spriteFrame) {
        false;
        if (!_enabled || _atlasIndex === _maxAtlasCount || !spriteFrame || spriteFrame._original) return;
        var texture = spriteFrame._texture;
        var w = texture.width, h = texture.height;
        var min = texture._minFilter, mag = texture._magFilter;
        var LINEAR = cc.Texture2D.Filter.LINEAR;
        if (w > _maxFrameSize || h > _maxFrameSize || w <= _minFrameSize || h <= _minFrameSize || (min & mag) !== LINEAR) return;
        var atlas = _atlases[_atlasIndex];
        atlas || (atlas = newAtlas());
        if (!atlas.insertSpriteFrame(spriteFrame) && _atlasIndex !== _maxAtlasCount) {
          atlas = newAtlas();
          atlas.insertSpriteFrame(spriteFrame);
        }
      },
      reset: function() {
        for (var i = 0, l = _atlases.length; i < l; i++) _atlases[i].destroy();
        _atlases.length = 0;
        _atlasIndex = -1;
      },
      showDebug: false,
      update: function() {
        if (!this.enabled) return;
        for (var i = 0; i <= _atlasIndex; i++) _atlases[i].update();
      }
    };
    module.exports = cc.dynamicAtlasManager = dynamicAtlasManager;
  }), {
    "./atlas": 199
  } ],
  201: [ (function(require, module, exports) {
    var macro = require("../../../platform/CCMacro");
    var renderEngine = require("../../render-engine");
    var Label = require("../../../components/CCLabel");
    var Overflow = Label.Overflow;
    var TextUtils = require("../../../utils/text-utils").TextUtils;
    var FontLetterDefinition = function() {
      this._u = 0;
      this._v = 0;
      this._width = 0;
      this._height = 0;
      this._offsetX = 0;
      this._offsetY = 0;
      this._textureID = 0;
      this._validDefinition = false;
      this._xAdvance = 0;
    };
    cc.FontAtlas = function(fntConfig) {
      this._letterDefinitions = {};
    };
    cc.FontAtlas.prototype = {
      constructor: cc.FontAtlas,
      addLetterDefinitions: function(letter, letterDefinition) {
        this._letterDefinitions[letter] = letterDefinition;
      },
      cloneLetterDefinition: function() {
        var copyLetterDefinitions = {};
        for (var key in this._letterDefinitions) {
          var value = new FontLetterDefinition();
          cc.js.mixin(value, this._letterDefinitions[key]);
          copyLetterDefinitions[key] = value;
        }
        return copyLetterDefinitions;
      },
      assignLetterDefinitions: function(letterDefinition) {
        for (var key in this._letterDefinitions) {
          var newValue = letterDefinition[key];
          var oldValue = this._letterDefinitions[key];
          cc.js.mixin(oldValue, newValue);
        }
      },
      scaleFontLetterDefinition: function(scaleFactor) {
        for (var fontDefinition in this._letterDefinitions) {
          var letterDefinitions = this._letterDefinitions[fontDefinition];
          letterDefinitions._width *= scaleFactor;
          letterDefinitions._height *= scaleFactor;
          letterDefinitions._offsetX *= scaleFactor;
          letterDefinitions._offsetY *= scaleFactor;
          letterDefinitions._xAdvance *= scaleFactor;
        }
      },
      getLetterDefinitionForChar: function(char) {
        var hasKey = this._letterDefinitions.hasOwnProperty(char.charCodeAt(0));
        var letterDefinition = void 0;
        letterDefinition = hasKey ? this._letterDefinitions[char.charCodeAt(0)] : null;
        return letterDefinition;
      }
    };
    var LetterInfo = function() {
      this._char = "";
      this._valid = true;
      this._positionX = 0;
      this._positionY = 0;
      this._lineIndex = 0;
    };
    var _tmpRect = cc.rect();
    var _comp = null;
    var _horizontalKernings = [];
    var _lettersInfo = [];
    var _linesWidth = [];
    var _linesOffsetX = [];
    var _labelDimensions = cc.size();
    var _fontAtlas = null;
    var _fntConfig = null;
    var _numberOfLines = 0;
    var _textDesiredHeight = 0;
    var _letterOffsetY = 0;
    var _tailoredTopY = 0;
    var _tailoredBottomY = 0;
    var _bmfontScale = 1;
    var _lineBreakWithoutSpaces = false;
    var _spriteFrame = null;
    var _lineSpacing = 0;
    var _string = "";
    var _fontSize = 0;
    var _originFontSize = 0;
    var _contentSize = cc.size();
    var _hAlign = 0;
    var _vAlign = 0;
    var _spacingX = 0;
    var _lineHeight = 0;
    var _overflow = 0;
    var _isWrapText = false;
    var _labelWidth = 0;
    var _labelHeight = 0;
    var _maxLineWidth = 0;
    module.exports = {
      updateRenderData: function(comp) {
        if (!comp._renderData.vertDirty) return;
        _comp = comp;
        this._updateProperties();
        this._updateContent();
        _comp._actualFontSize = _fontSize;
        _comp.node.setContentSize(_contentSize);
        _comp._renderData.vertDirty = _comp._renderData.uvDirty = false;
        _comp = null;
        this._resetProperties();
      },
      _updateFontScale: function() {
        _bmfontScale = _fontSize / _originFontSize;
      },
      _updateProperties: function() {
        var fontAsset = _comp.font;
        _spriteFrame = fontAsset.spriteFrame;
        _fntConfig = fontAsset._fntConfig;
        _fontAtlas = _comp._fontAtlas;
        if (!_fontAtlas) {
          _fontAtlas = new cc.FontAtlas(_fntConfig);
          var fontDict = _fntConfig.fontDefDictionary;
          for (var fontDef in fontDict) {
            var letterDefinition = new FontLetterDefinition();
            var rect = fontDict[fontDef].rect;
            letterDefinition._offsetX = fontDict[fontDef].xOffset;
            letterDefinition._offsetY = fontDict[fontDef].yOffset;
            letterDefinition._width = rect.width;
            letterDefinition._height = rect.height;
            letterDefinition._u = rect.x;
            letterDefinition._v = rect.y;
            letterDefinition._textureID = 0;
            letterDefinition._validDefinition = true;
            letterDefinition._xAdvance = fontDict[fontDef].xAdvance;
            _fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
          }
          _comp._fontAtlas = _fontAtlas;
        }
        _string = _comp.string.toString();
        _fontSize = _comp.fontSize;
        _originFontSize = _fntConfig.fontSize;
        _contentSize = _comp.node._contentSize;
        _hAlign = _comp.horizontalAlign;
        _vAlign = _comp.verticalAlign;
        _spacingX = _comp.spacingX;
        _overflow = _comp.overflow;
        _lineHeight = _comp._lineHeight;
        _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || _comp.enableWrapText);
        this._setupBMFontOverflowMetrics();
      },
      _resetProperties: function() {
        _fontAtlas = null;
        _fntConfig = null;
        _spriteFrame = null;
      },
      _updateContent: function() {
        this._updateFontScale();
        this._computeHorizontalKerningForText();
        this._alignText();
      },
      _computeHorizontalKerningForText: function() {
        var string = _string;
        var stringLen = string.length;
        var kerningDict = _fntConfig.kerningDict;
        var horizontalKernings = _horizontalKernings;
        var prev = -1;
        for (var i = 0; i < stringLen; ++i) {
          var key = string.charCodeAt(i);
          var kerningAmount = kerningDict[prev << 16 | 65535 & key] || 0;
          horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0;
          prev = key;
        }
      },
      _multilineTextWrap: function(nextTokenFunc) {
        var textLen = _string.length;
        var lineIndex = 0;
        var nextTokenX = 0;
        var nextTokenY = 0;
        var longestLine = 0;
        var letterRight = 0;
        var highestY = 0;
        var lowestY = 0;
        var letterDef = null;
        var letterPosition = cc.v2(0, 0);
        this._updateFontScale();
        var letterDefinitions = _fontAtlas._letterDefinitions;
        for (var index = 0; index < textLen; ) {
          var character = _string.charAt(index);
          if ("\n" === character) {
            _linesWidth.push(letterRight);
            letterRight = 0;
            lineIndex++;
            nextTokenX = 0;
            nextTokenY -= _lineHeight * _bmfontScale + _lineSpacing;
            this._recordPlaceholderInfo(index, character);
            index++;
            continue;
          }
          var tokenLen = nextTokenFunc(_string, index, textLen);
          var tokenHighestY = highestY;
          var tokenLowestY = lowestY;
          var tokenRight = letterRight;
          var nextLetterX = nextTokenX;
          var newLine = false;
          for (var tmp = 0; tmp < tokenLen; ++tmp) {
            var letterIndex = index + tmp;
            character = _string.charAt(letterIndex);
            if ("\r" === character) {
              this._recordPlaceholderInfo(letterIndex, character);
              continue;
            }
            letterDef = _fontAtlas.getLetterDefinitionForChar(character);
            if (!letterDef) {
              this._recordPlaceholderInfo(letterIndex, character);
              console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character);
              continue;
            }
            var letterX = nextLetterX + letterDef._offsetX * _bmfontScale;
            if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef._width * _bmfontScale > _maxLineWidth && !TextUtils.isUnicodeSpace(character)) {
              _linesWidth.push(letterRight);
              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= _lineHeight * _bmfontScale + _lineSpacing;
              newLine = true;
              break;
            }
            letterPosition.x = letterX;
            letterPosition.y = nextTokenY - letterDef._offsetY * _bmfontScale;
            this._recordLetterInfo(letterDefinitions, letterPosition, character, letterIndex, lineIndex);
            letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]);
            nextLetterX += letterDef._xAdvance * _bmfontScale + _spacingX;
            tokenRight = letterPosition.x + letterDef._width * _bmfontScale;
            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y);
            tokenLowestY > letterPosition.y - letterDef._height * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef._height * _bmfontScale);
          }
          if (newLine) continue;
          nextTokenX = nextLetterX;
          letterRight = tokenRight;
          highestY < tokenHighestY && (highestY = tokenHighestY);
          lowestY > tokenLowestY && (lowestY = tokenLowestY);
          longestLine < letterRight && (longestLine = letterRight);
          index += tokenLen;
        }
        _linesWidth.push(letterRight);
        _numberOfLines = lineIndex + 1;
        _textDesiredHeight = _numberOfLines * _lineHeight * _bmfontScale;
        _numberOfLines > 1 && (_textDesiredHeight += (_numberOfLines - 1) * _lineSpacing);
        _contentSize.width = _labelWidth;
        _contentSize.height = _labelHeight;
        _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2)));
        _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)));
        _tailoredTopY = _contentSize.height;
        _tailoredBottomY = 0;
        highestY > 0 && (_tailoredTopY = _contentSize.height + highestY);
        lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY);
        return true;
      },
      _getFirstCharLen: function() {
        return 1;
      },
      _getFirstWordLen: function(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (TextUtils.isUnicodeCJK(character) || "\n" === character || TextUtils.isUnicodeSpace(character)) return 1;
        var len = 1;
        var letterDef = _fontAtlas.getLetterDefinitionForChar(character);
        if (!letterDef) return len;
        var nextLetterX = letterDef._xAdvance * _bmfontScale + _spacingX;
        var letterX = void 0;
        for (var index = startIndex + 1; index < textLen; ++index) {
          character = text.charAt(index);
          letterDef = _fontAtlas.getLetterDefinitionForChar(character);
          if (!letterDef) break;
          letterX = nextLetterX + letterDef._offsetX * _bmfontScale;
          if (letterX + letterDef._width * _bmfontScale > _maxLineWidth && !TextUtils.isUnicodeSpace(character) && _maxLineWidth > 0) return len;
          nextLetterX += letterDef._xAdvance * _bmfontScale + _spacingX;
          if ("\n" === character || TextUtils.isUnicodeSpace(character) || TextUtils.isUnicodeCJK(character)) break;
          len++;
        }
        return len;
      },
      _multilineTextWrapByWord: function() {
        return this._multilineTextWrap(this._getFirstWordLen);
      },
      _multilineTextWrapByChar: function() {
        return this._multilineTextWrap(this._getFirstCharLen);
      },
      _recordPlaceholderInfo: function(letterIndex, char) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        _lettersInfo[letterIndex]._char = char;
        _lettersInfo[letterIndex]._valid = false;
      },
      _recordLetterInfo: function(letterDefinitions, letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        character = character.charCodeAt(0);
        _lettersInfo[letterIndex]._lineIndex = lineIndex;
        _lettersInfo[letterIndex]._char = character;
        _lettersInfo[letterIndex]._valid = letterDefinitions[character]._validDefinition;
        _lettersInfo[letterIndex]._positionX = letterPosition.x;
        _lettersInfo[letterIndex]._positionY = letterPosition.y;
      },
      _alignText: function() {
        _textDesiredHeight = 0;
        _linesWidth.length = 0;
        _lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
        this._computeAlignmentOffset();
        _overflow === Overflow.SHRINK && _fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp);
        this._updateQuads() || _overflow === Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
      },
      _scaleFontSizeDown: function(fontSize) {
        var shouldUpdateContent = true;
        if (!fontSize) {
          fontSize = .1;
          shouldUpdateContent = false;
        }
        _fontSize = fontSize;
        shouldUpdateContent && this._updateContent();
      },
      _shrinkLabelToContentSize: function(lambda) {
        var fontSize = _fontSize;
        var originalLineHeight = _lineHeight;
        var fontAtlas = _fontAtlas;
        var i = 0;
        var tempLetterDefinition = fontAtlas.cloneLetterDefinition();
        var flag = true;
        while (lambda()) {
          ++i;
          var newFontSize = fontSize - i;
          flag = false;
          if (newFontSize <= 0) break;
          var scale = newFontSize / fontSize;
          fontAtlas.assignLetterDefinitions(tempLetterDefinition);
          fontAtlas.scaleFontLetterDefinition(scale);
          _lineHeight = originalLineHeight * scale;
          _lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
          this._computeAlignmentOffset();
        }
        _lineHeight = originalLineHeight;
        fontAtlas.assignLetterDefinitions(tempLetterDefinition);
        flag || fontSize - i >= 0 && this._scaleFontSizeDown(fontSize - i);
      },
      _isVerticalClamp: function() {
        return _textDesiredHeight > _contentSize.height;
      },
      _isHorizontalClamp: function() {
        var letterDefinitions = _fontAtlas._letterDefinitions;
        var letterClamp = false;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (letterInfo._valid) {
            var letterDef = letterDefinitions[letterInfo._char];
            var px = letterInfo._positionX + letterDef._width / 2 * _bmfontScale;
            var lineIndex = letterInfo._lineIndex;
            if (_labelWidth > 0) if (_isWrapText) {
              var wordWidth = _linesWidth[lineIndex];
              if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                letterClamp = true;
                break;
              }
            } else if (px > _contentSize.width) {
              letterClamp = true;
              break;
            }
          }
        }
        return letterClamp;
      },
      _isHorizontalClamped: function(px, lineIndex) {
        var wordWidth = _linesWidth[lineIndex];
        var letterOverClamp = px > _contentSize.width || px < 0;
        return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
      },
      _updateQuads: function() {
        var letterDefinitions = _fontAtlas._letterDefinitions;
        var texture = _spriteFrame._texture;
        var node = _comp.node;
        var renderData = _comp._renderData;
        renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
        var contentSize = _contentSize, appx = node._anchorPoint.x * contentSize.width, appy = node._anchorPoint.y * contentSize.height;
        var ret = true;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (!letterInfo._valid) continue;
          var letterDef = letterDefinitions[letterInfo._char];
          _tmpRect.height = letterDef._height;
          _tmpRect.width = letterDef._width;
          _tmpRect.x = letterDef._u;
          _tmpRect.y = letterDef._v;
          var py = letterInfo._positionY + _letterOffsetY;
          if (_labelHeight > 0) {
            if (py > _tailoredTopY) {
              var clipTop = py - _tailoredTopY;
              _tmpRect.y += clipTop;
              _tmpRect.height -= clipTop;
              py -= clipTop;
            }
            py - letterDef._height * _bmfontScale < _tailoredBottomY && (_tmpRect.height = py < _tailoredBottomY ? 0 : py - _tailoredBottomY);
          }
          var lineIndex = letterInfo._lineIndex;
          var px = letterInfo._positionX + letterDef._width / 2 * _bmfontScale + _linesOffsetX[lineIndex];
          if (_labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow === Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === Overflow.SHRINK) {
            if (_contentSize.width > letterDef._width) {
              ret = false;
              break;
            }
            _tmpRect.width = 0;
          }
          if (_tmpRect.height > 0 && _tmpRect.width > 0) {
            var isRotated = _spriteFrame.isRotated();
            var originalSize = _spriteFrame._originalSize;
            var rect = _spriteFrame._rect;
            var offset = _spriteFrame._offset;
            var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
            var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
            if (isRotated) {
              var originalX = _tmpRect.x;
              _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop;
              _tmpRect.y = originalX + rect.y - trimmedLeft;
              _tmpRect.y < 0 && (_tmpRect.height = _tmpRect.height + trimmedTop);
            } else {
              _tmpRect.x += rect.x - trimmedLeft;
              _tmpRect.y += rect.y + trimmedTop;
            }
            var letterPositionX = letterInfo._positionX + _linesOffsetX[letterInfo._lineIndex];
            this.appendQuad(renderData, texture, _tmpRect, isRotated, letterPositionX - appx, py - appy, _bmfontScale);
          }
        }
        return ret;
      },
      appendQuad: function(renderData, texture, rect, rotated, x, y, scale) {},
      _computeAlignmentOffset: function() {
        _linesOffsetX.length = 0;
        switch (_hAlign) {
         case macro.TextAlignment.LEFT:
          for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
          break;

         case macro.TextAlignment.CENTER:
          for (var _i = 0, l = _linesWidth.length; _i < l; _i++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
          break;

         case macro.TextAlignment.RIGHT:
          for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
        }
        switch (_vAlign) {
         case macro.VerticalTextAlignment.TOP:
          _letterOffsetY = _contentSize.height;
          break;

         case macro.VerticalTextAlignment.CENTER:
          _letterOffsetY = (_contentSize.height + _textDesiredHeight) / 2;
          break;

         case macro.VerticalTextAlignment.BOTTOM:
          _letterOffsetY = _textDesiredHeight;
        }
      },
      _setupBMFontOverflowMetrics: function() {
        var newWidth = _contentSize.width, newHeight = _contentSize.height;
        _overflow === Overflow.RESIZE_HEIGHT && (newHeight = 0);
        if (_overflow === Overflow.NONE) {
          newWidth = 0;
          newHeight = 0;
        }
        _labelWidth = newWidth;
        _labelHeight = newHeight;
        _labelDimensions.width = newWidth;
        _labelDimensions.height = newHeight;
        _maxLineWidth = newWidth;
      }
    };
  }), {
    "../../../components/CCLabel": 69,
    "../../../platform/CCMacro": 160,
    "../../../utils/text-utils": 240,
    "../../render-engine": 197
  } ],
  202: [ (function(require, module, exports) {
    var macro = require("../../../platform/CCMacro");
    var utils = require("../../../utils/text-utils");
    var renderEngine = require("../../render-engine");
    var Label = require("../../../components/CCLabel");
    var LabelOutline = require("../../../components/CCLabelOutline");
    var Overflow = Label.Overflow;
    var TextUtils = utils.TextUtils;
    var CustomFontLoader = utils.CustomFontLoader;
    var WHITE = cc.Color.WHITE;
    var _context = null;
    var _canvas = null;
    var _texture = null;
    var _fontDesc = "";
    var _string = "";
    var _fontSize = 0;
    var _drawFontsize = 0;
    var _splitedStrings = [];
    var _canvasSize = cc.size();
    var _lineHeight = 0;
    var _hAlign = 0;
    var _vAlign = 0;
    var _color = null;
    var _fontFamily = "";
    var _overflow = Overflow.NONE;
    var _isWrapText = false;
    var _isOutlined = false;
    var _outlineColor = null;
    var _outlineWidth = 0;
    var _margin = 0;
    var _isBold = false;
    var _isItalic = false;
    var _isUnderline = false;
    var _sharedLabelData = void 0;
    var _canvasPool = {
      pool: [],
      get: function() {
        var data = this.pool.pop();
        if (!data) {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          data = {
            canvas: canvas,
            context: context
          };
        }
        return data;
      },
      put: function(canvas) {
        if (this.pool.length >= 32) return;
        this.pool.push(canvas);
      }
    };
    module.exports = {
      _getAssemblerData: function() {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) _sharedLabelData = _canvasPool.get(); else if (!_sharedLabelData) {
          var labelCanvas = document.createElement("canvas");
          _sharedLabelData = {
            canvas: labelCanvas,
            context: labelCanvas.getContext("2d")
          };
        }
        _sharedLabelData.canvas.width = _sharedLabelData.canvas.height = 1;
        return _sharedLabelData;
      },
      _resetAssemblerData: function(assemblerData) {
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS && assemblerData && _canvasPool.put(assemblerData);
      },
      updateRenderData: function(comp) {
        if (!comp._renderData.vertDirty) return;
        if (this._updateFontFamly(comp)) {
          this._updateProperties(comp);
          this._calculateLabelFont();
          this._calculateSplitedStrings();
          this._updateLabelDimensions();
          this._calculateTextBaseline();
          this._updateTexture(comp);
          comp._actualFontSize = _fontSize;
          comp.node.setContentSize(_canvasSize);
          this._updateVerts(comp);
          comp._renderData.vertDirty = comp._renderData.uvDirty = false;
          _context = null;
          _canvas = null;
          _texture = null;
        }
      },
      _updateVerts: function() {},
      _updateFontFamly: function(comp) {
        if (comp.useSystemFont) _fontFamily = comp.fontFamily; else {
          if (!comp.font) return false;
          var url = comp.font.nativeUrl;
          false;
          _fontFamily = CustomFontLoader._getFontFamily(url);
          var fontDescriptor = CustomFontLoader._fontCache[_fontFamily];
          if (!fontDescriptor || !fontDescriptor.isLoaded()) {
            CustomFontLoader.loadTTF(url);
            return false;
          }
        }
        return true;
      },
      _updateProperties: function(comp) {
        var assemblerData = comp._assemblerData;
        _context = assemblerData.context;
        _canvas = assemblerData.canvas;
        _texture = comp._texture;
        _string = comp.string.toString();
        _fontSize = comp._fontSize;
        _drawFontsize = _fontSize;
        _overflow = comp.overflow;
        _canvasSize.width = comp.node.width;
        _canvasSize.height = comp.node.height;
        _lineHeight = comp._lineHeight;
        _hAlign = comp.horizontalAlign;
        _vAlign = comp.verticalAlign;
        _color = comp.node.color;
        _isBold = comp._isBold;
        _isItalic = comp._isItalic;
        _isUnderline = comp._isUnderline;
        _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || comp.enableWrapText);
        var outline = LabelOutline && comp.getComponent(LabelOutline);
        if (outline && outline.enabled) {
          _isOutlined = true;
          _margin = _outlineWidth = outline.width;
          _outlineColor = cc.color(outline.color);
          _outlineColor.a = _outlineColor.a * comp.node.color.a / 255;
        } else {
          _isOutlined = false;
          _margin = 0;
        }
      },
      _calculateFillTextStartPosition: function() {
        var lineHeight = this._getLineHeight();
        var lineCount = _splitedStrings.length;
        var labelX = void 0;
        var firstLinelabelY = void 0;
        labelX = _hAlign === macro.TextAlignment.RIGHT ? _canvasSize.width - _margin : _hAlign === macro.TextAlignment.CENTER ? _canvasSize.width / 2 : 0 + _margin;
        firstLinelabelY = _vAlign === macro.VerticalTextAlignment.TOP ? 0 : _vAlign === macro.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : _canvasSize.height - lineHeight * (lineCount - 1);
        return cc.v2(labelX, firstLinelabelY);
      },
      _updateTexture: function() {
        _context.clearRect(0, 0, _canvas.width, _canvas.height);
        _context.font = _fontDesc;
        var startPosition = this._calculateFillTextStartPosition();
        var lineHeight = this._getLineHeight();
        _context.lineJoin = "round";
        _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", " + _color.a / 255 + ")";
        var underlineStartPosition = void 0;
        for (var i = 0; i < _splitedStrings.length; ++i) {
          if (_isOutlined) {
            var strokeColor = _outlineColor || WHITE;
            _context.globalCompositeOperation = "source-over";
            _context.strokeStyle = "rgba(" + strokeColor.r + ", " + strokeColor.g + ", " + strokeColor.b + ", " + strokeColor.a / 255 + ")";
            _context.lineWidth = 2 * _outlineWidth;
            _context.strokeText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
          }
          _context.fillText(_splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
          if (_isUnderline) {
            underlineStartPosition = this._calculateUnderlineStartPosition();
            _context.save();
            _context.beginPath();
            _context.lineWidth = _fontSize / 8;
            _context.strokeStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", " + _color.a / 255 + ")";
            _context.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1);
            _context.lineTo(underlineStartPosition.x + _canvas.width, underlineStartPosition.y + i * lineHeight - 1);
            _context.stroke();
            _context.restore();
          }
        }
        _texture.handleLoadedTexture();
      },
      _calculateUnderlineStartPosition: function() {
        var lineHeight = this._getLineHeight();
        var lineCount = _splitedStrings.length;
        var labelX = void 0;
        var firstLinelabelY = void 0;
        labelX = 0 + _margin;
        firstLinelabelY = _vAlign === macro.VerticalTextAlignment.TOP ? _fontSize : _vAlign === macro.VerticalTextAlignment.CENTER ? _canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + _fontSize / 2 : _canvasSize.height - lineHeight * (lineCount - 1);
        return cc.v2(labelX, firstLinelabelY);
      },
      _updateLabelDimensions: function() {
        var paragraphedStrings = _string.split("\n");
        if (_overflow === Overflow.RESIZE_HEIGHT) _canvasSize.height = _splitedStrings.length * this._getLineHeight(); else if (_overflow === Overflow.NONE) {
          _splitedStrings = paragraphedStrings;
          var canvasSizeX = 0;
          var canvasSizeY = 0;
          for (var i = 0; i < paragraphedStrings.length; ++i) {
            var paraLength = _context.measureText(paragraphedStrings[i]).width;
            canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
          }
          canvasSizeY = _splitedStrings.length * this._getLineHeight();
          _canvasSize.width = parseFloat(canvasSizeX.toFixed(2)) + 2 * _margin;
          _canvasSize.height = parseFloat(canvasSizeY.toFixed(2));
          _isItalic && (_canvasSize.width += _drawFontsize * Math.tan(.20943951));
        }
        _canvas.width = _canvasSize.width;
        _canvas.height = _canvasSize.height;
      },
      _calculateTextBaseline: function() {
        var node = this._node;
        var hAlign = void 0;
        var vAlign = void 0;
        hAlign = _hAlign === macro.TextAlignment.RIGHT ? "right" : _hAlign === macro.TextAlignment.CENTER ? "center" : "left";
        _context.textAlign = hAlign;
        vAlign = _vAlign === macro.VerticalTextAlignment.TOP ? "top" : _vAlign === macro.VerticalTextAlignment.CENTER ? "middle" : "bottom";
        _context.textBaseline = vAlign;
      },
      _calculateSplitedStrings: function() {
        var paragraphedStrings = _string.split("\n");
        if (_isWrapText) {
          _splitedStrings = [];
          var canvasWidthNoMargin = _canvasSize.width - 2 * _margin;
          for (var i = 0; i < paragraphedStrings.length; ++i) {
            var allWidth = _context.measureText(paragraphedStrings[i]).width;
            var textFragment = TextUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context));
            _splitedStrings = _splitedStrings.concat(textFragment);
          }
        } else _splitedStrings = paragraphedStrings;
      },
      _getFontDesc: function() {
        var fontDesc = _fontSize.toString() + "px ";
        fontDesc += _fontFamily;
        _isBold && (fontDesc = "bold " + fontDesc);
        return fontDesc;
      },
      _getLineHeight: function() {
        var nodeSpacingY = _lineHeight;
        nodeSpacingY = 0 === nodeSpacingY ? _fontSize : nodeSpacingY * _fontSize / _drawFontsize;
        return 0 | nodeSpacingY;
      },
      _calculateParagraphLength: function(paragraphedStrings, ctx) {
        var paragraphLength = [];
        for (var i = 0; i < paragraphedStrings.length; ++i) {
          var textMetric = ctx.measureText(paragraphedStrings[i]);
          paragraphLength.push(textMetric.width);
        }
        return paragraphLength;
      },
      _measureText: function(ctx) {
        return function(string) {
          return ctx.measureText(string).width;
        };
      },
      _calculateLabelFont: function() {
        _fontDesc = this._getFontDesc();
        _context.font = _fontDesc;
        if (_overflow === Overflow.SHRINK) {
          var paragraphedStrings = _string.split("\n");
          var paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
          _splitedStrings = paragraphedStrings;
          var i = 0;
          var totalHeight = 0;
          var maxLength = 0;
          if (_isWrapText) {
            var canvasWidthNoMargin = _canvasSize.width - 2 * _margin;
            var canvasHeightNoMargin = _canvasSize.height - 2 * _margin;
            if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;
              return;
            }
            totalHeight = canvasHeightNoMargin + 1;
            maxLength = canvasWidthNoMargin + 1;
            var actualFontSize = _fontSize + 1;
            var textFragment = "";
            var tryDivideByTwo = true;
            var startShrinkFontSize = 0 | actualFontSize;
            while (totalHeight > canvasHeightNoMargin || maxLength > canvasWidthNoMargin) {
              if (tryDivideByTwo) actualFontSize = startShrinkFontSize / 2 | 0; else {
                actualFontSize = startShrinkFontSize - 1;
                startShrinkFontSize = actualFontSize;
              }
              if (actualFontSize <= 0) {
                cc.logID(4003);
                break;
              }
              _fontSize = actualFontSize;
              _fontDesc = this._getFontDesc();
              _context.font = _fontDesc;
              _splitedStrings = [];
              totalHeight = 0;
              for (i = 0; i < paragraphedStrings.length; ++i) {
                var j = 0;
                var allWidth = _context.measureText(paragraphedStrings[i]).width;
                textFragment = TextUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context));
                while (j < textFragment.length) {
                  var measureWidth = _context.measureText(textFragment[j]).width;
                  maxLength = measureWidth;
                  totalHeight += this._getLineHeight();
                  ++j;
                }
                _splitedStrings = _splitedStrings.concat(textFragment);
              }
              if (tryDivideByTwo) if (totalHeight > canvasHeightNoMargin) startShrinkFontSize = 0 | actualFontSize; else {
                tryDivideByTwo = false;
                totalHeight = canvasHeightNoMargin + 1;
              }
            }
          } else {
            totalHeight = paragraphedStrings.length * this._getLineHeight();
            for (i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
            var scaleX = (_canvasSize.width - 2 * _margin) / maxLength;
            var scaleY = _canvasSize.height / totalHeight;
            _fontSize = _drawFontsize * Math.min(1, scaleX, scaleY) | 0;
            _fontDesc = this._getFontDesc();
            _context.font = _fontDesc;
          }
        }
      }
    };
  }), {
    "../../../components/CCLabel": 69,
    "../../../components/CCLabelOutline": 70,
    "../../../platform/CCMacro": 160,
    "../../../utils/text-utils": 240,
    "../../render-engine": 197
  } ],
  203: [ (function(require, module, exports) {
    "use strict";
    module.exports = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode) return triangles;
      var minX, minY, maxX, maxY, x, y, size;
      hasHoles && (outerNode = eliminateHoles(data, holeIndices, outerNode, dim));
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          x < minX && (minX = x);
          y < minY && (minY = y);
          x > maxX && (maxX = x);
          y > maxY && (maxY = y);
        }
        size = Math.max(maxX - minX, maxY - minY);
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, size);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last); else for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      end || (end = start);
      var p = start, again;
      do {
        again = false;
        if (p.steiner || !equals(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) return null;
          again = true;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
      if (!ear) return;
      !pass && size && indexCurve(ear, minX, minY, size);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (pass) if (1 === pass) {
            ear = cureLocalIntersections(ear, triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, size, 2);
          } else 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size); else earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, size) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
      var p = ear.nextZ;
      while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
      }
      p = ear.prevZ;
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, size) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, size);
            earcutLinked(c, triangles, dim, minX, minY, size);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        list === list.next && (list.steiner = true);
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
      }
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y) return p;
              if (hy === p.next.y) return p.next;
            }
            m = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      if (hx === qx) return m.prev;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m.next;
      while (p !== stop) {
        if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      }
      return m;
    }
    function indexCurve(start, minX, minY, size) {
      var p = start;
      do {
        null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size));
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (0 === pSize) {
              e = q;
              q = q.nextZ;
              qSize--;
            } else if (0 !== qSize && q) if (p.z <= q.z) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            } else {
              e = p;
              p = p.nextZ;
              pSize--;
            }
            tail ? tail.nextZ = e : list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, size) {
      x = 32767 * (x - minX) / size;
      y = 32767 * (y - minY) / size;
      x = 16711935 & (x | x << 8);
      x = 252645135 & (x | x << 4);
      x = 858993459 & (x | x << 2);
      x = 1431655765 & (x | x << 1);
      y = 16711935 & (y | y << 8);
      y = 252645135 & (y | y << 4);
      y = 858993459 & (y | y << 2);
      y = 1431655765 & (y | y << 1);
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        p.x < leftmost.x && (leftmost = p);
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
      return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside);
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (last) {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      } else {
        p.prev = p;
        p.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      p.prevZ && (p.prevZ.nextZ = p.nextZ);
      p.nextZ && (p.nextZ.prevZ = p.prevZ);
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
      }
      return 0 === polygonArea && 0 === trianglesArea ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
      }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }), {} ],
  204: [ (function(require, module, exports) {
    var Helper = require("../../../../graphics/helper");
    var PointFlags = require("../../../../graphics/types").PointFlags;
    class Point extends cc.Vec2 {
      constructor(x, y) {
        super(x, y);
        this.reset();
      }
      reset() {
        this.dx = 0;
        this.dy = 0;
        this.dmx = 0;
        this.dmy = 0;
        this.flags = 0;
        this.len = 0;
      }
    }
    class Path {
      constructor() {
        this.reset();
      }
      reset() {
        this.closed = false;
        this.nbevel = 0;
        this.complex = true;
        this.points ? this.points.length = 0 : this.points = [];
      }
    }
    class Impl {
      constructor() {
        this._tessTol = .25;
        this._distTol = .01;
        this._updatePathOffset = false;
        this._paths = null;
        this._pathLength = 0;
        this._pathOffset = 0;
        this._points = null;
        this._pointsOffset = 0;
        this._commandx = 0;
        this._commandy = 0;
        this._paths = [];
        this._points = [];
        this._renderDatas = [];
        this._dataOffset = 0;
      }
      moveTo(x, y) {
        if (this._updatePathOffset) {
          this._pathOffset = this._pathLength;
          this._updatePathOffset = false;
        }
        this._addPath();
        this._addPoint(x, y, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      }
      lineTo(x, y) {
        this._addPoint(x, y, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      }
      bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        var path = this._curPath;
        var last = path.points[path.points.length - 1];
        if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
          this.lineTo(x, y);
          return;
        }
        Helper.tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      }
      quadraticCurveTo(cx, cy, x, y) {
        var x0 = this._commandx;
        var y0 = this._commandy;
        this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
      }
      arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
      }
      ellipse(cx, cy, rx, ry) {
        Helper.ellipse(this, cx, cy, rx, ry);
        this._curPath.complex = false;
      }
      circle(cx, cy, r) {
        Helper.ellipse(this, cx, cy, r, r);
        this._curPath.complex = false;
      }
      rect(x, y, w, h) {
        this.moveTo(x, y);
        this.lineTo(x, y + h);
        this.lineTo(x + w, y + h);
        this.lineTo(x + w, y);
        this.close();
        this._curPath.complex = false;
      }
      roundRect(x, y, w, h, r) {
        Helper.roundRect(this, x, y, w, h, r);
        this._curPath.complex = false;
      }
      clear(comp, clean) {
        this._pathLength = 0;
        this._pathOffset = 0;
        this._pointsOffset = 0;
        this._dataOffset = 0;
        this._curPath = null;
        var datas = this._renderDatas;
        if (clean) {
          this._paths.length = 0;
          this._points.length = 0;
          for (var i = 0, l = datas.length; i < l; i++) comp.destroyRenderData(datas[i]);
          datas.length = 0;
        } else for (var _i = 0, _l = datas.length; _i < _l; _i++) {
          var data = datas[_i];
          data.indiceCount = data._indices.length = 0;
          data.vertexCount = 0;
        }
      }
      close() {
        this._curPath.closed = true;
      }
      _addPath() {
        var offset = this._pathLength;
        var path = this._paths[offset];
        if (path) path.reset(); else {
          path = new Path();
          this._paths.push(path);
        }
        this._pathLength++;
        this._curPath = path;
        return path;
      }
      _addPoint(x, y, flags) {
        var path = this._curPath;
        if (!path) return;
        var pt;
        var points = this._points;
        var pathPoints = path.points;
        var offset = this._pointsOffset++;
        pt = points[offset];
        if (pt) {
          pt.x = x;
          pt.y = y;
        } else {
          pt = new Point(x, y);
          points.push(pt);
        }
        pt.flags = flags;
        pathPoints.push(pt);
      }
    }
    module.exports = Impl;
  }), {
    "../../../../graphics/helper": 105,
    "../../../../graphics/types": 107
  } ],
  205: [ (function(require, module, exports) {
    var Graphics = require("../../../../graphics/graphics");
    var PointFlags = require("../../../../graphics/types").PointFlags;
    var LineJoin = Graphics.LineJoin;
    var LineCap = Graphics.LineCap;
    var Earcut = require("./earcut");
    var Impl = require("./impl");
    var vfmtPosUvColor = require("../../vertex-format").vfmtPosUvColor;
    var macro = require("../../../../platform/CCMacro");
    var MAX_VERTEX = 65535;
    var MAX_INDICE = 2 * MAX_VERTEX;
    var js = require("../../../../platform/js");
    var renderEngine = require("../../../render-engine");
    var math = renderEngine.math;
    var PI = Math.PI;
    var min = Math.min;
    var max = Math.max;
    var ceil = Math.ceil;
    var acos = Math.acos;
    var cos = Math.cos;
    var sin = Math.sin;
    var atan2 = Math.atan2;
    var abs = Math.abs;
    var _renderData = null;
    var _impl = null;
    var _curColor = 0;
    function curveDivs(r, arc, tol) {
      var da = 2 * acos(r / (r + tol));
      return max(2, ceil(arc / da));
    }
    function clamp(v, min, max) {
      if (v < min) return min;
      if (v > max) return max;
      return v;
    }
    var graphicsAssembler = {
      createImpl: function() {
        return new Impl();
      },
      updateRenderData: function(graphics) {
        var datas = graphics._impl._renderDatas;
        0 === datas.length && datas.push(graphics.requestRenderData());
        for (var i = 0, l = datas.length; i < l; i++) datas[i].material = graphics.getMaterial();
      },
      fillBuffers: function(graphics, renderer) {
        var node = graphics.node, z = node._position.z;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var nodeColor = node.color, nodeR = nodeColor.r / 255, nodeG = nodeColor.g / 255, nodeB = nodeColor.b / 255, nodeA = nodeColor.a / 255;
        var buffer = renderer.getBuffer("mesh", vfmtPosUvColor), vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData;
        var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        var renderDatas = graphics._impl._renderDatas;
        for (var index = 0, length = renderDatas.length; index < length; index++) {
          var renderData = renderDatas[index], data = renderData._data;
          buffer.request(renderData.vertexCount, renderData.indiceCount);
          for (var i = 0, l = data.length; i < l; i++) {
            vbuf[vertexOffset++] = data[i].x * a + data[i].y * c + tx;
            vbuf[vertexOffset++] = data[i].x * b + data[i].y * d + ty;
            vertexOffset += 2;
            var color = data[i].color;
            var cr = (255 & color) * nodeR;
            var cg = ((65280 & color) >> 8) * nodeG;
            var cb = ((16711680 & color) >> 16) * nodeB;
            var ca = ((4278190080 & color) >>> 24) * nodeA;
            color = (ca << 24 >>> 0) + (cb << 16) + (cg << 8) + cr;
            uintbuf[vertexOffset++] = color;
          }
          var indicesBuffer = renderData._indices;
          for (var _i = 0, _l = indicesBuffer.length; _i < _l; _i++) ibuf[indiceOffset + _i] = vertexId + indicesBuffer[_i];
        }
      },
      genRenderData: function(graphics, cverts) {
        var renderDatas = _impl._renderDatas;
        var renderData = renderDatas[_impl._dataOffset];
        var maxVertsCount = renderData.vertexCount + cverts;
        if (maxVertsCount > MAX_VERTEX || 3 * maxVertsCount > MAX_INDICE) {
          ++_impl._dataOffset;
          maxVertsCount = cverts;
          if (_impl._dataOffset < renderDatas.length) renderData = renderDatas[_impl._dataOffset]; else {
            renderData = graphics.requestRenderData();
            renderDatas[_impl._dataOffset] = renderData;
          }
        }
        maxVertsCount > renderData.dataLength && (renderData.dataLength = maxVertsCount);
        return renderData;
      },
      stroke: function(graphics) {
        var renderDatas = graphics._impl._renderDatas;
        0 === renderDatas.length && renderDatas.push(graphics.requestRenderData());
        _curColor = graphics._strokeColor._val;
        this._flattenPaths(graphics._impl);
        this._expandStroke(graphics);
        graphics._impl._updatePathOffset = true;
      },
      fill: function(graphics) {
        var renderDatas = graphics._impl._renderDatas;
        0 === renderDatas.length && renderDatas.push(graphics.requestRenderData());
        _curColor = graphics._fillColor._val;
        this._expandFill(graphics);
        graphics._impl._updatePathOffset = true;
      },
      _expandStroke: function(graphics) {
        var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
        _impl = graphics._impl;
        var ncap = curveDivs(w, PI, _impl._tessTol);
        this._calculateJoins(_impl, w, lineJoin, miterLimit);
        var paths = _impl._paths;
        var cverts = 0;
        for (var i = _impl._pathOffset, l = _impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pointsLength = path.points.length;
          lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1);
          path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
        }
        var renderData = _renderData = this.genRenderData(graphics, cverts), data = renderData._data, indicesBuffer = renderData._indices;
        for (var _i2 = _impl._pathOffset, _l2 = _impl._pathLength; _i2 < _l2; _i2++) {
          var _path = paths[_i2];
          var pts = _path.points;
          var _pointsLength = pts.length;
          var offset = renderData.vertexCount;
          var p0 = void 0, p1 = void 0;
          var start = void 0, end = void 0, loop = void 0;
          loop = _path.closed;
          if (loop) {
            p0 = pts[_pointsLength - 1];
            p1 = pts[0];
            start = 0;
            end = _pointsLength;
          } else {
            p0 = pts[0];
            p1 = pts[1];
            start = 1;
            end = _pointsLength - 1;
          }
          if (!loop) {
            var dPos = p1.sub(p0);
            dPos.normalizeSelf();
            var dx = dPos.x;
            var dy = dPos.y;
            lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
          }
          for (var j = start; j < end; ++j) {
            if (lineJoin === LineJoin.ROUND) this._roundJoin(p0, p1, w, w, ncap); else if (0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL))) this._bevelJoin(p0, p1, w, w); else {
              this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w);
              this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w);
            }
            p0 = p1;
            p1 = pts[j + 1];
          }
          if (loop) {
            this._vset(data[offset].x, data[offset].y);
            this._vset(data[offset + 1].x, data[offset + 1].y);
          } else {
            var _dPos = p1.sub(p0);
            _dPos.normalizeSelf();
            var _dx = _dPos.x;
            var _dy = _dPos.y;
            lineCap === LineCap.BUTT ? this._buttCap(p1, _dx, _dy, w, 0) : lineCap === LineCap.BUTT || lineCap === LineCap.SQUARE ? this._buttCap(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
          }
          var indicesOffset = indicesBuffer.length;
          for (var _start = offset + 2, _end = renderData.vertexCount; _start < _end; _start++) {
            indicesBuffer[indicesOffset++] = _start - 2;
            indicesBuffer[indicesOffset++] = _start - 1;
            indicesBuffer[indicesOffset++] = _start;
          }
        }
        renderData.indiceCount = indicesBuffer.length;
        _renderData = null;
        _impl = null;
      },
      _expandFill: function(graphics) {
        _impl = graphics._impl;
        var paths = _impl._paths;
        var cverts = 0;
        for (var i = _impl._pathOffset, l = _impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pointsLength = path.points.length;
          cverts += pointsLength;
        }
        var renderData = _renderData = this.genRenderData(graphics, cverts), data = renderData._data, indicesBuffer = renderData._indices;
        for (var _i3 = _impl._pathOffset, _l3 = _impl._pathLength; _i3 < _l3; _i3++) {
          var _path2 = paths[_i3];
          var pts = _path2.points;
          var _pointsLength2 = pts.length;
          if (0 === _pointsLength2) continue;
          var offset = renderData.vertexCount;
          for (var j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
          var indicesOffset = indicesBuffer.length;
          if (_path2.complex) {
            var earcutData = [];
            for (var _j = offset, end = renderData.vertexCount; _j < end; _j++) {
              earcutData.push(data[_j].x);
              earcutData.push(data[_j].y);
            }
            var newIndices = Earcut(earcutData, null, 2);
            if (!newIndices || 0 === newIndices.length) continue;
            for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) indicesBuffer[indicesOffset + _j2] = newIndices[_j2] + offset;
          } else {
            var first = offset;
            for (var start = offset + 2, _end2 = renderData.vertexCount; start < _end2; start++) {
              indicesBuffer[indicesOffset++] = first;
              indicesBuffer[indicesOffset++] = start - 1;
              indicesBuffer[indicesOffset++] = start;
            }
          }
        }
        renderData.indiceCount = indicesBuffer.length;
        _renderData = null;
        _impl = null;
      },
      _calculateJoins: function(impl, w, lineJoin, miterLimit) {
        var iw = 0;
        w > 0 && (iw = 1 / w);
        var paths = impl._paths;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pts = path.points;
          var ptsLength = pts.length;
          var p0 = pts[ptsLength - 1];
          var p1 = pts[0];
          var nleft = 0;
          path.nbevel = 0;
          for (var j = 0; j < ptsLength; j++) {
            var dmr2 = void 0, cross = void 0, limit = void 0;
            var dlx0 = p0.dy;
            var dly0 = -p0.dx;
            var dlx1 = p1.dy;
            var dly1 = -p1.dx;
            p1.dmx = .5 * (dlx0 + dlx1);
            p1.dmy = .5 * (dly0 + dly1);
            dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;
            if (dmr2 > 1e-6) {
              var scale = 1 / dmr2;
              scale > 600 && (scale = 600);
              p1.dmx *= scale;
              p1.dmy *= scale;
            }
            cross = p1.dx * p0.dy - p0.dx * p1.dy;
            if (cross > 0) {
              nleft++;
              p1.flags |= PointFlags.PT_LEFT;
            }
            limit = max(11, min(p0.len, p1.len) * iw);
            dmr2 * limit * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL);
            p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL);
            0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++;
            p0 = p1;
            p1 = pts[j + 1];
          }
        }
      },
      _flattenPaths: function(impl) {
        var paths = impl._paths;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pts = path.points;
          var p0 = pts[pts.length - 1];
          var p1 = pts[0];
          if (p0.equals(p1)) {
            path.closed = true;
            pts.pop();
            p0 = pts[pts.length - 1];
          }
          for (var j = 0, size = pts.length; j < size; j++) {
            var dPos = p1.sub(p0);
            p0.len = dPos.mag();
            (dPos.x || dPos.y) && dPos.normalizeSelf();
            p0.dx = dPos.x;
            p0.dy = dPos.y;
            p0 = p1;
            p1 = pts[j + 1];
          }
        }
      },
      _chooseBevel: function(bevel, p0, p1, w) {
        var x = p1.x;
        var y = p1.y;
        var x0 = void 0, y0 = void 0, x1 = void 0, y1 = void 0;
        if (0 !== bevel) {
          x0 = x + p0.dy * w;
          y0 = y - p0.dx * w;
          x1 = x + p1.dy * w;
          y1 = y - p1.dx * w;
        } else {
          x0 = x1 = x + p1.dmx * w;
          y0 = y1 = y + p1.dmy * w;
        }
        return [ x0, y0, x1, y1 ];
      },
      _buttCap: function(p, dx, dy, w, d) {
        var px = p.x - dx * d;
        var py = p.y - dy * d;
        var dlx = dy;
        var dly = -dx;
        this._vset(px + dlx * w, py + dly * w);
        this._vset(px - dlx * w, py - dly * w);
      },
      _roundCapStart: function(p, dx, dy, w, ncap) {
        var px = p.x;
        var py = p.y;
        var dlx = dy;
        var dly = -dx;
        for (var i = 0; i < ncap; i++) {
          var a = i / (ncap - 1) * PI;
          var ax = cos(a) * w, ay = sin(a) * w;
          this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay);
          this._vset(px, py);
        }
        this._vset(px + dlx * w, py + dly * w);
        this._vset(px - dlx * w, py - dly * w);
      },
      _roundCapEnd: function(p, dx, dy, w, ncap) {
        var px = p.x;
        var py = p.y;
        var dlx = dy;
        var dly = -dx;
        this._vset(px + dlx * w, py + dly * w);
        this._vset(px - dlx * w, py - dly * w);
        for (var i = 0; i < ncap; i++) {
          var a = i / (ncap - 1) * PI;
          var ax = cos(a) * w, ay = sin(a) * w;
          this._vset(px, py);
          this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
        }
      },
      _roundJoin: function(p0, p1, lw, rw, ncap) {
        var dlx0 = p0.dy;
        var dly0 = -p0.dx;
        var dlx1 = p1.dy;
        var dly1 = -p1.dx;
        var p1x = p1.x;
        var p1y = p1.y;
        if (0 !== (p1.flags & PointFlags.PT_LEFT)) {
          var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
          var lx0 = out[0];
          var ly0 = out[1];
          var lx1 = out[2];
          var ly1 = out[3];
          var a0 = atan2(-dly0, -dlx0);
          var a1 = atan2(-dly1, -dlx1);
          a1 > a0 && (a1 -= 2 * PI);
          this._vset(lx0, ly0);
          this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
          var n = clamp(ceil((a0 - a1) / PI) * ncap, 2, ncap);
          for (var i = 0; i < n; i++) {
            var u = i / (n - 1);
            var a = a0 + u * (a1 - a0);
            var rx = p1x + cos(a) * rw;
            var ry = p1y + sin(a) * rw;
            this._vset(p1x, p1y);
            this._vset(rx, ry);
          }
          this._vset(lx1, ly1);
          this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
        } else {
          var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
          var rx0 = _out[0];
          var ry0 = _out[1];
          var rx1 = _out[2];
          var ry1 = _out[3];
          var _a = atan2(dly0, dlx0);
          var _a2 = atan2(dly1, dlx1);
          _a2 < _a && (_a2 += 2 * PI);
          this._vset(p1x + dlx0 * rw, p1y + dly0 * rw);
          this._vset(rx0, ry0);
          var _n = clamp(ceil((_a2 - _a) / PI) * ncap, 2, ncap);
          for (var _i4 = 0; _i4 < _n; _i4++) {
            var _u = _i4 / (_n - 1);
            var _a3 = _a + _u * (_a2 - _a);
            var lx = p1x + cos(_a3) * lw;
            var ly = p1y + sin(_a3) * lw;
            this._vset(lx, ly);
            this._vset(p1x, p1y);
          }
          this._vset(p1x + dlx1 * rw, p1y + dly1 * rw);
          this._vset(rx1, ry1);
        }
      },
      _bevelJoin: function(p0, p1, lw, rw) {
        var rx0 = void 0, ry0 = void 0, rx1 = void 0, ry1 = void 0;
        var lx0 = void 0, ly0 = void 0, lx1 = void 0, ly1 = void 0;
        var dlx0 = p0.dy;
        var dly0 = -p0.dx;
        var dlx1 = p1.dy;
        var dly1 = -p1.dx;
        if (p1.flags & PointFlags.PT_LEFT) {
          var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
          lx0 = out[0];
          ly0 = out[1];
          lx1 = out[2];
          ly1 = out[3];
          this._vset(lx0, ly0);
          this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw);
          this._vset(lx1, ly1);
          this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw);
        } else {
          var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
          rx0 = _out2[0];
          ry0 = _out2[1];
          rx1 = _out2[2];
          ry1 = _out2[3];
          this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw);
          this._vset(rx0, ry0);
          this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw);
          this._vset(rx1, ry1);
        }
      },
      _vset: function(x, y) {
        var data = _renderData._data;
        var offset = _renderData.vertexCount;
        data[offset].x = x;
        data[offset].y = y;
        data[offset].color = _curColor;
        _renderData.vertexCount++;
      }
    };
    Graphics._assembler = graphicsAssembler;
    module.exports = graphicsAssembler;
  }), {
    "../../../../graphics/graphics": 104,
    "../../../../graphics/types": 107,
    "../../../../platform/CCMacro": 160,
    "../../../../platform/js": 175,
    "../../../render-engine": 197,
    "../../vertex-format": 223,
    "./earcut": 203,
    "./impl": 204
  } ],
  206: [ (function(require, module, exports) {
    require("./sprite");
    require("./mask-assembler");
    require("./graphics");
    require("./label");
    require("./motion-streak");
  }), {
    "./graphics": 205,
    "./label": 208,
    "./mask-assembler": 210,
    "./motion-streak": 211,
    "./sprite": 213
  } ],
  207: [ (function(require, module, exports) {
    var macro = require("../../../../platform/CCMacro");
    var renderEngine = require("../../../render-engine");
    var js = require("../../../../platform/js");
    var bmfontUtls = require("../../../utils/label/bmfont");
    var ttfAssembler = require("./ttf");
    module.exports = js.addon({
      createData: function(comp) {
        return comp.requestRenderData();
      },
      fillBuffers: function(comp, renderer) {
        var node = comp.node, renderData = comp._renderData, data = renderData._data, color = node.color._val;
        var matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var buffer = renderer._quadBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData;
        var vertexCount = renderData.vertexCount;
        buffer.request(vertexCount, renderData.indiceCount);
        for (var i = 0; i < vertexCount; i++) {
          var vert = data[i];
          vbuf[vertexOffset++] = vert.x * a + vert.y * c + tx;
          vbuf[vertexOffset++] = vert.x * b + vert.y * d + ty;
          vbuf[vertexOffset++] = vert.u;
          vbuf[vertexOffset++] = vert.v;
        }
      },
      appendQuad: function(renderData, texture, rect, rotated, x, y, scale) {
        var dataOffset = renderData.dataLength;
        renderData.dataLength += 4;
        renderData.vertexCount = renderData.dataLength;
        renderData.indiceCount = renderData.dataLength / 2 * 3;
        var data = renderData._data;
        var texw = texture.width, texh = texture.height;
        var rectWidth = rect.width, rectHeight = rect.height;
        var l = void 0, b = void 0, r = void 0, t = void 0;
        if (rotated) {
          l = rect.x / texw;
          r = (rect.x + rectHeight) / texw;
          b = (rect.y + rectWidth) / texh;
          t = rect.y / texh;
          data[dataOffset].u = l;
          data[dataOffset].v = t;
          data[dataOffset + 1].u = l;
          data[dataOffset + 1].v = b;
          data[dataOffset + 2].u = r;
          data[dataOffset + 2].v = t;
          data[dataOffset + 3].u = r;
          data[dataOffset + 3].v = b;
        } else {
          l = rect.x / texw;
          r = (rect.x + rectWidth) / texw;
          b = (rect.y + rectHeight) / texh;
          t = rect.y / texh;
          data[dataOffset].u = l;
          data[dataOffset].v = b;
          data[dataOffset + 1].u = r;
          data[dataOffset + 1].v = b;
          data[dataOffset + 2].u = l;
          data[dataOffset + 2].v = t;
          data[dataOffset + 3].u = r;
          data[dataOffset + 3].v = t;
        }
        data[dataOffset].x = x;
        data[dataOffset].y = y - rectHeight * scale;
        data[dataOffset + 1].x = x + rectWidth * scale;
        data[dataOffset + 1].y = y - rectHeight * scale;
        data[dataOffset + 2].x = x;
        data[dataOffset + 2].y = y;
        data[dataOffset + 3].x = x + rectWidth * scale;
        data[dataOffset + 3].y = y;
      }
    }, bmfontUtls);
  }), {
    "../../../../platform/CCMacro": 160,
    "../../../../platform/js": 175,
    "../../../render-engine": 197,
    "../../../utils/label/bmfont": 201,
    "./ttf": 209
  } ],
  208: [ (function(require, module, exports) {
    var Label = require("../../../../components/CCLabel");
    var ttfAssembler = require("./ttf");
    var bmfontAssembler = require("./bmfont");
    var labelAssembler = {
      getAssembler: function(comp) {
        var assembler = ttfAssembler;
        comp.font instanceof cc.BitmapFont && (assembler = bmfontAssembler);
        return assembler;
      },
      updateRenderData: function(label) {
        return label.__allocedDatas;
      }
    };
    Label._assembler = labelAssembler;
    module.exports = labelAssembler;
  }), {
    "../../../../components/CCLabel": 69,
    "./bmfont": 207,
    "./ttf": 209
  } ],
  209: [ (function(require, module, exports) {
    var macro = require("../../../../platform/CCMacro");
    var renderEngine = require("../../../render-engine");
    var js = require("../../../../platform/js");
    var ttfUtls = require("../../../utils/label/ttf");
    module.exports = js.addon({
      createData: function(comp) {
        var renderData = comp.requestRenderData();
        renderData.dataLength = 4;
        renderData.vertexCount = 4;
        renderData.indiceCount = 6;
        var data = renderData._data;
        data[0].u = 0;
        data[0].v = 1;
        data[1].u = 1;
        data[1].v = 1;
        data[2].u = 0;
        data[2].v = 0;
        data[3].u = 1;
        data[3].v = 0;
        return renderData;
      },
      fillBuffers: function(comp, renderer) {
        var data = comp._renderData._data, node = comp.node, matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var buffer = renderer._quadBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData;
        buffer.request(4, 6);
        for (var i = 0; i < 4; i++) {
          var vert = data[i];
          vbuf[vertexOffset++] = vert.x * a + vert.y * c + tx;
          vbuf[vertexOffset++] = vert.x * b + vert.y * d + ty;
          vbuf[vertexOffset++] = vert.u;
          vbuf[vertexOffset++] = vert.v;
        }
      },
      _updateVerts: function(comp) {
        var renderData = comp._renderData;
        var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var data = renderData._data;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = width - appx;
        data[1].y = -appy;
        data[2].x = -appx;
        data[2].y = height - appy;
        data[3].x = width - appx;
        data[3].y = height - appy;
      }
    }, ttfUtls);
  }), {
    "../../../../platform/CCMacro": 160,
    "../../../../platform/js": 175,
    "../../../render-engine": 197,
    "../../../utils/label/ttf": 202
  } ],
  210: [ (function(require, module, exports) {
    var StencilManager = require("../stencil-manager");
    var Node = require("../../../CCNode");
    var Mask = require("../../../components/CCMask");
    var renderEngine = require("../../render-engine");
    var RenderFlow = require("../../render-flow");
    var js = require("../../../platform/js");
    var spriteAssembler = require("./sprite/simple");
    var Graphics = require("../../../graphics/graphics");
    var graphicsAssembler = require("./graphics");
    var _stencilMgr = StencilManager.sharedManager;
    var _color = cc.color(255, 255, 255, 0);
    var _graphicsPool = [];
    function getGraphics() {
      var graphics = _graphicsPool.pop();
      if (!graphics) {
        var graphicsNode = new Node();
        graphics = graphicsNode.addComponent(Graphics);
        graphics.lineWidth = 0;
      }
      return graphics;
    }
    var maskFrontAssembler = {
      updateGraphics: function(mask) {
        var renderData = mask._renderData;
        var graphics = mask._graphics;
        graphics.clear(false);
        var width = renderData._width;
        var height = renderData._height;
        var x = -width * renderData._pivotX;
        var y = -height * renderData._pivotY;
        if (mask._type === Mask.Type.RECT) graphics.rect(x, y, width, height); else if (mask._type === Mask.Type.ELLIPSE) {
          var cx = x + width / 2, cy = y + height / 2, rx = width / 2, ry = height / 2;
          graphics.ellipse(cx, cy, rx, ry);
        }
        graphics.fill();
      },
      updateRenderData: function(mask) {
        mask._renderData || (mask._type === Mask.Type.IMAGE_STENCIL ? mask._renderData = spriteAssembler.createData(mask) : mask._renderData = mask.requestRenderData());
        var renderData = mask._renderData;
        var size = mask.node._contentSize;
        var anchor = mask.node._anchorPoint;
        renderData.updateSizeNPivot(size.width, size.height, anchor.x, anchor.y);
        mask._material = mask._frontMaterial;
        if (mask._type === Mask.Type.IMAGE_STENCIL) if (mask.spriteFrame) {
          renderData.dataLength = 4;
          spriteAssembler.updateRenderData(mask);
          renderData.material = mask.getMaterial();
        } else mask._material = null; else {
          mask._graphics = getGraphics();
          this.updateGraphics(mask);
          mask._graphics._material = mask._material;
          graphicsAssembler.updateRenderData(mask._graphics);
        }
      },
      fillBuffers: function(mask, renderer) {
        if (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) {
          _stencilMgr.pushMask(mask);
          if (mask._type === Mask.Type.IMAGE_STENCIL) spriteAssembler.fillBuffers(mask, renderer); else {
            mask._graphics.node = mask.node;
            graphicsAssembler.fillBuffers(mask._graphics, renderer);
          }
        }
        mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      }
    };
    var maskEndAssembler = {
      updateRenderData: function(mask) {
        mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame ? mask._material = mask._endMaterial : mask._material = null;
        var material = mask._material;
        if (mask._type === Mask.Type.IMAGE_STENCIL) {
          var data = mask._renderData;
          data.material = material;
        } else {
          var datas = mask._graphics._impl._renderDatas;
          for (var i = 0; i < datas.length; i++) datas[i].material = material;
        }
      },
      fillBuffers: function(mask, renderer) {
        if (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) {
          _stencilMgr.popMask();
          if (mask._type === Mask.Type.IMAGE_STENCIL) spriteAssembler.fillBuffers(mask, renderer); else {
            mask._graphics.node = mask.node;
            graphicsAssembler.fillBuffers(mask._graphics, renderer);
            _graphicsPool.push(mask._graphics);
            mask._graphics = null;
          }
        }
        mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_UPDATE_RENDER_DATA;
      }
    };
    Mask._assembler = maskFrontAssembler;
    Mask._postAssembler = maskEndAssembler;
    module.exports = {
      front: maskFrontAssembler,
      end: maskEndAssembler
    };
  }), {
    "../../../CCNode": 30,
    "../../../components/CCMask": 72,
    "../../../graphics/graphics": 104,
    "../../../platform/js": 175,
    "../../render-engine": 197,
    "../../render-flow": 198,
    "../stencil-manager": 222,
    "./graphics": 205,
    "./sprite/simple": 216
  } ],
  211: [ (function(require, module, exports) {
    var js = require("../../../platform/js");
    var renderEngine = require("../../../renderer/render-engine");
    var MotionStreak = require("../../../components/CCMotionStreak");
    var RenderFlow = require("../../render-flow");
    var vfmtPosUvColor = require("../vertex-format").vfmtPosUvColor;
    function Point(point, dir) {
      this.point = point || cc.v2();
      this.dir = dir || cc.v2();
      this.distance = 0;
      this.time = 0;
    }
    Point.prototype.setPoint = function(x, y) {
      this.point.x = x;
      this.point.y = y;
    };
    Point.prototype.setDir = function(x, y) {
      this.dir.x = x;
      this.dir.y = y;
    };
    var _tangent = cc.v2();
    var _miter = cc.v2();
    var _normal = cc.v2();
    var _vec2 = cc.v2();
    function normal(out, dir) {
      out.x = -dir.y;
      out.y = dir.x;
      return out;
    }
    function computeMiter(miter, lineA, lineB, halfThick, maxMultiple) {
      lineA.add(lineB, _tangent);
      _tangent.normalizeSelf();
      miter.x = -_tangent.y;
      miter.y = _tangent.x;
      _vec2.x = -lineA.y;
      _vec2.y = lineA.x;
      var multiple = 1 / miter.dot(_vec2);
      maxMultiple && (multiple = Math.min(multiple, maxMultiple));
      return halfThick * multiple;
    }
    var motionStreakAssembler = {
      updateRenderData: function(comp) {
        var dt = cc.director.getDeltaTime();
        this.update(comp, dt);
        var renderData = comp._renderData;
        var size = comp.node._contentSize;
        var anchor = comp.node._anchorPoint;
        renderData.updateSizeNPivot(size.width, size.height, anchor.x, anchor.y);
        renderData.material = comp.getMaterial();
      },
      update: function(comp, dt) {
        var renderData = comp._renderData;
        renderData || (renderData = comp._renderData = comp.requestRenderData());
        false;
        var stroke = comp._stroke / 2;
        var node = comp.node;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var points = comp._points;
        var cur = void 0;
        if (points.length > 1) {
          var difx = points[0].x - tx;
          var dify = points[0].y - ty;
          difx * difx + dify * dify < comp.minSeg && (cur = points[0]);
        }
        if (!cur) {
          cur = new Point();
          points.splice(0, 0, cur);
        }
        cur.setPoint(tx, ty);
        cur.time = comp._fadeTime;
        renderData.dataLength = 0;
        if (points.length < 2) return;
        var data = renderData._data;
        var color = comp._color, cr = color.r, cg = color.g, cb = color.b, ca = color.a;
        var prev = points[1];
        prev.distance = cur.point.sub(prev.point, _vec2).mag();
        _vec2.normalizeSelf();
        prev.setDir(_vec2.x, _vec2.y);
        cur.setDir(_vec2.x, _vec2.y);
        var fadeTime = comp._fadeTime;
        var findLast = false;
        for (var i = points.length - 1; i >= 0; i--) {
          var p = points[i];
          var point = p.point;
          var dir = p.dir;
          p.time -= dt;
          if (p.time < 0) {
            points.splice(i, 1);
            continue;
          }
          var progress = p.time / fadeTime;
          var next = points[i - 1];
          if (!findLast) {
            if (!next) {
              points.splice(i, 1);
              continue;
            }
            point.x = next.point.x - dir.x * progress;
            point.y = next.point.y - dir.y * progress;
          }
          findLast = true;
          normal(_normal, dir);
          renderData.dataLength += 2;
          var da = progress * ca;
          var _c = (da << 24 >>> 0) + (cb << 16) + (cg << 8) + cr;
          var dataIndex = data.length - 1;
          data[dataIndex].x = point.x - _normal.x * stroke;
          data[dataIndex].y = point.y - _normal.y * stroke;
          data[dataIndex].u = 0;
          data[dataIndex].v = progress;
          data[dataIndex].color = _c;
          dataIndex--;
          data[dataIndex].x = point.x + _normal.x * stroke;
          data[dataIndex].y = point.y + _normal.y * stroke;
          data[dataIndex].u = 1;
          data[dataIndex].v = progress;
          data[dataIndex].color = _c;
        }
        renderData.vertexCount = renderData.dataLength;
        renderData.indiceCount = 3 * (renderData.vertexCount - 2);
      },
      fillBuffers: function(comp, renderer) {
        var node = comp.node, renderData = comp._renderData, data = renderData._data;
        var buffer = renderer.getBuffer("mesh", vfmtPosUvColor), vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData, vertexCount = renderData.vertexCount;
        var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(vertexCount, renderData.indiceCount);
        var vert = void 0;
        for (var i = 0, l = renderData.vertexCount; i < l; i++) {
          vert = data[i];
          vbuf[vertexOffset++] = vert.x;
          vbuf[vertexOffset++] = vert.y;
          vbuf[vertexOffset++] = vert.u;
          vbuf[vertexOffset++] = vert.v;
          uintbuf[vertexOffset++] = vert.color;
        }
        for (var _i = 0, _l = renderData.vertexCount; _i < _l; _i += 2) {
          var start = vertexId + _i;
          ibuf[indiceOffset++] = start;
          ibuf[indiceOffset++] = start + 2;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 2;
          ibuf[indiceOffset++] = start + 3;
        }
        comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      }
    };
    module.exports = MotionStreak._assembler = motionStreakAssembler;
  }), {
    "../../../components/CCMotionStreak": 73,
    "../../../platform/js": 175,
    "../../../renderer/render-engine": 197,
    "../../render-flow": 198,
    "../vertex-format": 223
  } ],
  212: [ (function(require, module, exports) {
    var Sprite = require("../../../../components/CCSprite");
    var FillType = Sprite.FillType;
    var dynamicAtlasManager = require("../../../utils/dynamic-atlas/manager");
    module.exports = {
      useModel: false,
      updateRenderData: function(sprite) {
        var frame = sprite.spriteFrame;
        if (frame) {
          frame._original || dynamicAtlasManager.insertSpriteFrame(frame);
          sprite._material && sprite._material._texture === frame._texture || sprite._activateMaterial();
        }
        var renderData = sprite._renderData;
        if (renderData && frame) {
          var uvDirty = renderData.uvDirty, vertDirty = renderData.vertDirty;
          if (!uvDirty && !vertDirty) return sprite.__allocedDatas;
          var fillStart = sprite._fillStart;
          var fillRange = sprite._fillRange;
          if (fillRange < 0) {
            fillStart += fillRange;
            fillRange = -fillRange;
          }
          fillRange = fillStart + fillRange;
          fillStart = fillStart > 1 ? 1 : fillStart;
          fillStart = fillStart < 0 ? 0 : fillStart;
          fillRange = fillRange > 1 ? 1 : fillRange;
          fillRange = fillRange < 0 ? 0 : fillRange;
          fillRange -= fillStart;
          fillRange = fillRange < 0 ? 0 : fillRange;
          var fillEnd = fillStart + fillRange;
          fillEnd = fillEnd > 1 ? 1 : fillEnd;
          uvDirty && this.updateUVs(sprite, fillStart, fillEnd);
          if (vertDirty) {
            this.updateVerts(sprite, fillStart, fillEnd);
            this.updateWorldVerts(sprite);
          }
        }
      },
      updateUVs: function(sprite, fillStart, fillEnd) {
        var spriteFrame = sprite._spriteFrame, renderData = sprite._renderData, data = renderData._data;
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        var ul = void 0, vb = void 0, ur = void 0, vt = void 0;
        var quadUV0 = void 0, quadUV1 = void 0, quadUV2 = void 0, quadUV3 = void 0, quadUV4 = void 0, quadUV5 = void 0, quadUV6 = void 0, quadUV7 = void 0;
        if (spriteFrame._rotated) {
          ul = textureRect.x / atlasWidth;
          vb = (textureRect.y + textureRect.width) / atlasHeight;
          ur = (textureRect.x + textureRect.height) / atlasWidth;
          vt = textureRect.y / atlasHeight;
          quadUV0 = quadUV2 = ul;
          quadUV4 = quadUV6 = ur;
          quadUV3 = quadUV7 = vb;
          quadUV1 = quadUV5 = vt;
        } else {
          ul = textureRect.x / atlasWidth;
          vb = (textureRect.y + textureRect.height) / atlasHeight;
          ur = (textureRect.x + textureRect.width) / atlasWidth;
          vt = textureRect.y / atlasHeight;
          quadUV0 = quadUV4 = ul;
          quadUV2 = quadUV6 = ur;
          quadUV1 = quadUV3 = vb;
          quadUV5 = quadUV7 = vt;
        }
        switch (sprite._fillType) {
         case FillType.HORIZONTAL:
          data[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart;
          data[0].v = quadUV1;
          data[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
          data[1].v = quadUV3;
          data[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart;
          data[2].v = quadUV5;
          data[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
          data[3].v = quadUV7;
          break;

         case FillType.VERTICAL:
          data[0].u = quadUV0;
          data[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart;
          data[1].u = quadUV2;
          data[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart;
          data[2].u = quadUV4;
          data[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
          data[3].u = quadUV6;
          data[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
          break;

         default:
          cc.errorID(2626);
        }
        renderData.uvDirty = false;
      },
      updateVerts: function(sprite, fillStart, fillEnd) {
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var l = -appx, b = -appy, r = width - appx, t = height - appy;
        var progressStart = void 0, progressEnd = void 0;
        switch (sprite._fillType) {
         case FillType.HORIZONTAL:
          progressStart = l + (r - l) * fillStart;
          progressEnd = l + (r - l) * fillEnd;
          l = progressStart;
          r = progressEnd;
          break;

         case FillType.VERTICAL:
          progressStart = b + (t - b) * fillStart;
          progressEnd = b + (t - b) * fillEnd;
          b = progressStart;
          t = progressEnd;
          break;

         default:
          cc.errorID(2626);
        }
        data[4].x = l;
        data[4].y = b;
        data[5].x = r;
        data[5].y = b;
        data[6].x = l;
        data[6].y = t;
        data[7].x = r;
        data[7].y = t;
        renderData.vertDirty = false;
      },
      createData: function(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 8;
        renderData.vertexCount = 4;
        renderData.indiceCount = 6;
        return renderData;
      },
      updateWorldVerts: function(sprite) {
        var node = sprite.node, data = sprite._renderData._data;
        var matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        for (var i = 0; i < 4; i++) {
          var local = data[i + 4];
          var world = data[i];
          world.x = local.x * a + local.y * c + tx;
          world.y = local.x * b + local.y * d + ty;
        }
      },
      fillBuffers: function(sprite, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(sprite);
        var data = sprite._renderData._data, node = sprite.node, matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var buffer = renderer._quadBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData;
        buffer.request(4, 6);
        for (var i = 0; i < 4; i++) {
          var vert = data[i];
          vbuf[vertexOffset++] = vert.x;
          vbuf[vertexOffset++] = vert.y;
          vbuf[vertexOffset++] = vert.u;
          vbuf[vertexOffset++] = vert.v;
        }
      }
    };
  }), {
    "../../../../components/CCSprite": 82,
    "../../../utils/dynamic-atlas/manager": 200
  } ],
  213: [ (function(require, module, exports) {
    var Sprite = require("../../../../components/CCSprite");
    var dynamicAtlasManager = require("../../../utils/dynamic-atlas/manager");
    var SpriteType = Sprite.Type;
    var FillType = Sprite.FillType;
    var simpleRenderUtil = require("./simple");
    var slicedRenderUtil = require("./sliced");
    var tiledRenderUtil = require("./tiled");
    var radialFilledRenderUtil = require("./radial-filled");
    var barFilledRenderUtil = require("./bar-filled");
    var meshRenderUtil = require("./mesh");
    var spriteAssembler = {
      getAssembler: function(sprite) {
        var util = simpleRenderUtil;
        switch (sprite.type) {
         case SpriteType.SLICED:
          util = slicedRenderUtil;
          break;

         case SpriteType.TILED:
          util = tiledRenderUtil;
          break;

         case SpriteType.FILLED:
          util = sprite._fillType === FillType.RADIAL ? radialFilledRenderUtil : barFilledRenderUtil;
          break;

         case SpriteType.MESH:
          util = meshRenderUtil;
        }
        return util;
      },
      updateRenderData: function(sprite) {
        return sprite.__allocedDatas;
      }
    };
    Sprite._assembler = spriteAssembler;
    module.exports = spriteAssembler;
  }), {
    "../../../../components/CCSprite": 82,
    "../../../utils/dynamic-atlas/manager": 200,
    "./bar-filled": 212,
    "./mesh": 214,
    "./radial-filled": 215,
    "./simple": 216,
    "./sliced": 217,
    "./tiled": 218
  } ],
  214: [ (function(require, module, exports) {
    var dynamicAtlasManager = require("../../../utils/dynamic-atlas/manager");
    module.exports = {
      useModel: false,
      createData: function(sprite) {
        return sprite.requestRenderData();
      },
      updateRenderData: function(sprite) {
        var frame = sprite.spriteFrame;
        if (frame) {
          frame._original || dynamicAtlasManager.insertSpriteFrame(frame);
          sprite._material && sprite._material._texture === frame._texture || sprite._activateMaterial();
        }
        var renderData = sprite._renderData;
        if (renderData && frame) {
          var vertices = frame.vertices;
          if (vertices) {
            if (renderData.vertexCount !== vertices.x.length) {
              renderData.vertexCount = vertices.x.length;
              renderData.indiceCount = vertices.triangles.length;
              renderData.dataLength = 2 * renderData.vertexCount;
              renderData.uvDirty = renderData.vertDirty = true;
            }
            renderData.uvDirty && this.updateUVs(sprite);
            var vertDirty = renderData.vertDirty;
            if (vertDirty) {
              this.updateVerts(sprite);
              this.updateWorldVerts(sprite);
            }
          }
        }
      },
      updateUVs: function(sprite) {
        var material = sprite.getMaterial();
        var texture = material.effect.getProperty("texture");
        var texw = texture._width, texh = texture._height;
        var vertices = sprite.spriteFrame.vertices, u = vertices.nu, v = vertices.nv;
        var renderData = sprite._renderData;
        var data = renderData._data;
        for (var i = 0, l = u.length; i < l; i++) {
          var vertice = data[i];
          vertice.u = u[i];
          vertice.v = v[i];
        }
        renderData.uvDirty = false;
      },
      updateVerts: function(sprite) {
        var node = sprite.node, contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), appx = node.anchorX * contentWidth, appy = node.anchorY * contentHeight;
        var frame = sprite.spriteFrame, vertices = frame.vertices, x = vertices.x, y = vertices.y, originalWidth = frame._originalSize.width, originalHeight = frame._originalSize.height, rectWidth = frame._rect.width, rectHeight = frame._rect.height, offsetX = frame._offset.x, offsetY = frame._offset.y, trimX = offsetX + (originalWidth - rectWidth) / 2, trimY = offsetY + (originalHeight - rectHeight) / 2;
        var scaleX = contentWidth / (sprite.trim ? rectWidth : originalWidth), scaleY = contentHeight / (sprite.trim ? rectHeight : originalHeight);
        var renderData = sprite._renderData;
        var data = renderData._data;
        if (sprite.trim) for (var _i = 0, _l = x.length; _i < _l; _i++) {
          var _vertice = data[_i + _l];
          _vertice.x = (x[_i] - trimX) * scaleX - appx;
          _vertice.y = (originalHeight - y[_i] - trimY) * scaleY - appy;
        } else for (var i = 0, l = x.length; i < l; i++) {
          var vertice = data[i + l];
          vertice.x = x[i] * scaleX - appx;
          vertice.y = (originalHeight - y[i]) * scaleY - appy;
        }
        renderData.vertDirty = false;
      },
      updateWorldVerts: function(sprite) {
        var node = sprite.node, renderData = sprite._renderData, data = renderData._data;
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        for (var i = 0, l = renderData.vertexCount; i < l; i++) {
          var local = data[i + l];
          var world = data[i];
          world.x = local.x * a + local.y * c + tx;
          world.y = local.x * b + local.y * d + ty;
        }
      },
      fillBuffers: function(sprite, renderer) {
        var node = sprite.node, renderData = sprite._renderData, data = renderData._data;
        renderer.worldMatDirty && this.updateWorldVerts(sprite);
        var buffer = renderer._meshBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData;
        var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(renderData.vertexCount, renderData.indiceCount);
        for (var i = 0, l = renderData.vertexCount; i < l; i++) {
          var vertice = data[i];
          vbuf[vertexOffset++] = vertice.x;
          vbuf[vertexOffset++] = vertice.y;
          vbuf[vertexOffset++] = vertice.u;
          vbuf[vertexOffset++] = vertice.v;
        }
        var triangles = sprite.spriteFrame.vertices.triangles;
        for (var _i2 = 0, _l2 = triangles.length; _i2 < _l2; _i2++) ibuf[indiceOffset++] = vertexId + triangles[_i2];
      }
    };
  }), {
    "../../../utils/dynamic-atlas/manager": 200
  } ],
  215: [ (function(require, module, exports) {
    var dynamicAtlasManager = require("../../../utils/dynamic-atlas/manager");
    var PI_2 = 2 * Math.PI;
    module.exports = {
      useModel: false,
      _vertPos: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
      _vertices: [ 0, 0, 0, 0 ],
      _uvs: [ 0, 0, 0, 0, 0, 0, 0, 0 ],
      _intersectPoint_1: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
      _intersectPoint_2: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
      _center: cc.v2(0, 0),
      _triangles: [],
      createData: function(sprite) {
        return sprite.requestRenderData();
      },
      updateRenderData: function(sprite) {
        var frame = sprite.spriteFrame;
        if (frame) {
          frame._original || dynamicAtlasManager.insertSpriteFrame(frame);
          sprite._material && sprite._material._texture === frame._texture || sprite._activateMaterial();
        }
        var renderData = sprite._renderData;
        if (renderData && frame && (renderData.vertDirty || renderData.uvDirty)) {
          var data = renderData._data;
          var fillStart = sprite._fillStart;
          var fillRange = sprite._fillRange;
          if (fillRange < 0) {
            fillStart += fillRange;
            fillRange = -fillRange;
          }
          while (fillStart >= 1) fillStart -= 1;
          while (fillStart < 0) fillStart += 1;
          fillStart *= PI_2;
          fillRange *= PI_2;
          var fillEnd = fillStart + fillRange;
          this._calculateVertices(sprite);
          this._calculateUVs(frame);
          var center = this._center;
          var vertPos = this._vertPos, vertices = this._vertices;
          var triangles = this._triangles;
          this._calcInsectedPoints(vertices[0], vertices[2], vertices[1], vertices[3], center, fillStart, this._intersectPoint_1);
          this._calcInsectedPoints(vertices[0], vertices[2], vertices[1], vertices[3], center, fillStart + fillRange, this._intersectPoint_2);
          var offset = 0;
          for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
            var triangle = triangles[triangleIndex];
            if (!triangle) continue;
            if (fillRange >= PI_2) {
              renderData.dataLength = offset + 3;
              this._generateTriangle(data, offset, center, vertPos[triangle[0]], vertPos[triangle[1]]);
              offset += 3;
              continue;
            }
            var startAngle = this._getVertAngle(center, vertPos[triangle[0]]);
            var endAngle = this._getVertAngle(center, vertPos[triangle[1]]);
            endAngle < startAngle && (endAngle += PI_2);
            startAngle -= PI_2;
            endAngle -= PI_2;
            for (var testIndex = 0; testIndex < 3; ++testIndex) {
              if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                renderData.dataLength = offset + 3;
                endAngle >= fillEnd ? this._generateTriangle(data, offset, center, vertPos[triangle[0]], this._intersectPoint_2[triangleIndex]) : this._generateTriangle(data, offset, center, vertPos[triangle[0]], vertPos[triangle[1]]);
                offset += 3;
              } else if (endAngle <= fillStart) ; else if (endAngle <= fillEnd) {
                renderData.dataLength = offset + 3;
                this._generateTriangle(data, offset, center, this._intersectPoint_1[triangleIndex], vertPos[triangle[1]]);
                offset += 3;
              } else {
                renderData.dataLength = offset + 3;
                this._generateTriangle(data, offset, center, this._intersectPoint_1[triangleIndex], this._intersectPoint_2[triangleIndex]);
                offset += 3;
              }
              startAngle += PI_2;
              endAngle += PI_2;
            }
          }
          renderData.indiceCount = renderData.vertexCount = offset;
          renderData.vertDirty = renderData.uvDirty = false;
        }
      },
      _getVertAngle: function(start, end) {
        var placementX = void 0, placementY = void 0;
        placementX = end.x - start.x;
        placementY = end.y - start.y;
        if (0 === placementX && 0 === placementY) return;
        if (0 === placementX) return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
        var angle = Math.atan(placementY / placementX);
        placementX < 0 && (angle += Math.PI);
        return angle;
      },
      _generateTriangle: function(data, offset, vert0, vert1, vert2) {
        var vertices = this._vertices;
        var v0x = vertices[0];
        var v0y = vertices[1];
        var v1x = vertices[2];
        var v1y = vertices[3];
        data[offset].x = vert0.x;
        data[offset].y = vert0.y;
        data[offset + 1].x = vert1.x;
        data[offset + 1].y = vert1.y;
        data[offset + 2].x = vert2.x;
        data[offset + 2].y = vert2.y;
        var progressX = void 0, progressY = void 0;
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, data, offset);
        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, data, offset + 1);
        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, data, offset + 2);
      },
      _generateUV: function(progressX, progressY, data, offset) {
        var uvs = this._uvs;
        var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        var uv = data[offset];
        uv.u = px1 + (px2 - px1) * progressY;
        uv.v = py1 + (py2 - py1) * progressY;
      },
      _calcInsectedPoints: function(left, right, bottom, top, center, angle, intersectPoints) {
        var sinAngle = Math.sin(angle);
        var cosAngle = Math.cos(angle);
        var tanAngle = void 0, cotAngle = void 0;
        if (0 !== Math.cos(angle)) {
          tanAngle = sinAngle / cosAngle;
          if ((left - center.x) * cosAngle > 0) {
            var yleft = center.y + tanAngle * (left - center.x);
            intersectPoints[0].x = left;
            intersectPoints[0].y = yleft;
          }
          if ((right - center.x) * cosAngle > 0) {
            var yright = center.y + tanAngle * (right - center.x);
            intersectPoints[2].x = right;
            intersectPoints[2].y = yright;
          }
        }
        if (0 !== Math.sin(angle)) {
          cotAngle = cosAngle / sinAngle;
          if ((top - center.y) * sinAngle > 0) {
            var xtop = center.x + cotAngle * (top - center.y);
            intersectPoints[3].x = xtop;
            intersectPoints[3].y = top;
          }
          if ((bottom - center.y) * sinAngle > 0) {
            var xbottom = center.x + cotAngle * (bottom - center.y);
            intersectPoints[1].x = xbottom;
            intersectPoints[1].y = bottom;
          }
        }
      },
      _calculateVertices: function(sprite) {
        var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var l = -appx, b = -appy, r = width - appx, t = height - appy;
        var vertices = this._vertices;
        vertices[0] = l;
        vertices[1] = b;
        vertices[2] = r;
        vertices[3] = t;
        var center = this._center, fillCenter = sprite._fillCenter, cx = center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
        var vertPos = this._vertPos;
        vertPos[0].x = vertPos[3].x = l;
        vertPos[1].x = vertPos[2].x = r;
        vertPos[0].y = vertPos[1].y = b;
        vertPos[2].y = vertPos[3].y = t;
        var triangles = this._triangles;
        triangles.length = 0;
        cx !== vertices[0] && (triangles[0] = [ 3, 0 ]);
        cx !== vertices[2] && (triangles[2] = [ 1, 2 ]);
        cy !== vertices[1] && (triangles[1] = [ 0, 1 ]);
        cy !== vertices[3] && (triangles[3] = [ 2, 3 ]);
      },
      _calculateUVs: function(spriteFrame) {
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        var u0 = void 0, u1 = void 0, v0 = void 0, v1 = void 0;
        var uvs = this._uvs;
        if (spriteFrame._rotated) {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.height) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.width) / atlasHeight;
          uvs[0] = uvs[2] = u0;
          uvs[4] = uvs[6] = u1;
          uvs[3] = uvs[7] = v1;
          uvs[1] = uvs[5] = v0;
        } else {
          u0 = textureRect.x / atlasWidth;
          u1 = (textureRect.x + textureRect.width) / atlasWidth;
          v0 = textureRect.y / atlasHeight;
          v1 = (textureRect.y + textureRect.height) / atlasHeight;
          uvs[0] = uvs[4] = u0;
          uvs[2] = uvs[6] = u1;
          uvs[1] = uvs[3] = v1;
          uvs[5] = uvs[7] = v0;
        }
      },
      fillBuffers: function(sprite, renderer) {
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node;
        var matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var buffer = renderer._meshBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData;
        var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(renderData.vertexCount, renderData.indiceCount);
        var count = data.length;
        for (var i = 0; i < count; i++) {
          var vert = data[i];
          vbuf[vertexOffset++] = vert.x * a + vert.y * c + tx;
          vbuf[vertexOffset++] = vert.x * b + vert.y * d + ty;
          vbuf[vertexOffset++] = vert.u;
          vbuf[vertexOffset++] = vert.v;
        }
        for (var _i = 0; _i < count; _i++) ibuf[indiceOffset + _i] = vertexId + _i;
      }
    };
  }), {
    "../../../utils/dynamic-atlas/manager": 200
  } ],
  216: [ (function(require, module, exports) {
    var js = require("../../../../platform/js");
    var dynamicAtlasManager = require("../../../utils/dynamic-atlas/manager");
    module.exports = {
      useModel: false,
      updateRenderData: function(sprite) {
        var frame = sprite._spriteFrame;
        if (frame) {
          frame._original || dynamicAtlasManager.insertSpriteFrame(frame);
          sprite._material && sprite._material._texture === frame._texture || sprite._activateMaterial();
        }
        var renderData = sprite._renderData;
        renderData && frame && renderData.vertDirty && this.updateVerts(sprite);
      },
      fillBuffers: function(sprite, renderer) {
        var data = sprite._renderData._data, node = sprite.node, matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var buffer = renderer._quadBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData;
        buffer.request(4, 6);
        var uv = sprite._spriteFrame.uv;
        vbuf[vertexOffset + 2] = uv[0];
        vbuf[vertexOffset + 3] = uv[1];
        vbuf[vertexOffset + 6] = uv[2];
        vbuf[vertexOffset + 7] = uv[3];
        vbuf[vertexOffset + 10] = uv[4];
        vbuf[vertexOffset + 11] = uv[5];
        vbuf[vertexOffset + 14] = uv[6];
        vbuf[vertexOffset + 15] = uv[7];
        var data0 = data[0], data3 = data[3], vl = data0.x, vr = data3.x, vb = data0.y, vt = data3.y;
        var al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
        vbuf[vertexOffset] = al + cb + tx;
        vbuf[vertexOffset + 1] = bl + db + ty;
        vbuf[vertexOffset + 4] = ar + cb + tx;
        vbuf[vertexOffset + 5] = br + db + ty;
        vbuf[vertexOffset + 8] = al + ct + tx;
        vbuf[vertexOffset + 9] = bl + dt + ty;
        vbuf[vertexOffset + 12] = ar + ct + tx;
        vbuf[vertexOffset + 13] = br + dt + ty;
      },
      createData: function(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 4;
        renderData.vertexCount = 4;
        renderData.indiceCount = 6;
        return renderData;
      },
      updateVerts: function(sprite) {
        var renderData = sprite._renderData, node = sprite.node, data = renderData._data, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l = void 0, b = void 0, r = void 0, t = void 0;
        if (sprite.trim) {
          l = -appx;
          b = -appy;
          r = cw - appx;
          t = ch - appy;
        } else {
          var frame = sprite.spriteFrame, ow = frame._originalSize.width, oh = frame._originalSize.height, rw = frame._rect.width, rh = frame._rect.height, offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;
          var trimLeft = offset.x + (ow - rw) / 2;
          var trimRight = offset.x - (ow - rw) / 2;
          var trimBottom = offset.y + (oh - rh) / 2;
          var trimTop = offset.y - (oh - rh) / 2;
          l = trimLeft * scaleX - appx;
          b = trimBottom * scaleY - appy;
          r = cw + trimRight * scaleX - appx;
          t = ch + trimTop * scaleY - appy;
        }
        data[0].x = l;
        data[0].y = b;
        data[1].x = r;
        data[1].y = b;
        data[2].x = l;
        data[2].y = t;
        data[3].x = r;
        data[3].y = t;
        renderData.vertDirty = false;
      }
    };
  }), {
    "../../../../platform/js": 175,
    "../../../utils/dynamic-atlas/manager": 200
  } ],
  217: [ (function(require, module, exports) {
    var Sprite = require("../../../../components/CCSprite");
    var dynamicAtlasManager = require("../../../utils/dynamic-atlas/manager");
    var FillType = Sprite.FillType;
    module.exports = {
      useModel: false,
      createData: function(sprite) {
        var renderData = sprite.requestRenderData();
        renderData.dataLength = 20;
        renderData.vertexCount = 16;
        renderData.indiceCount = 54;
        return renderData;
      },
      updateRenderData: function(sprite, batchData) {
        var frame = sprite.spriteFrame;
        if (frame) {
          frame._original || dynamicAtlasManager.insertSpriteFrame(frame);
          sprite._material && sprite._material._texture === frame._texture || sprite._activateMaterial();
        }
        var renderData = sprite._renderData;
        if (renderData && frame) {
          var vertDirty = renderData.vertDirty;
          if (vertDirty) {
            this.updateVerts(sprite);
            this.updateWorldVerts(sprite);
          }
        }
      },
      updateVerts: function(sprite) {
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var frame = sprite.spriteFrame;
        var rect = frame._rect;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var sizableWidth = width - leftWidth - rightWidth;
        var sizableHeight = height - topHeight - bottomHeight;
        var xScale = width / (leftWidth + rightWidth);
        var yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
        yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        data[0].x = -appx;
        data[0].y = -appy;
        data[1].x = leftWidth * xScale - appx;
        data[1].y = bottomHeight * yScale - appy;
        data[2].x = data[1].x + sizableWidth;
        data[2].y = data[1].y + sizableHeight;
        data[3].x = width - appx;
        data[3].y = height - appy;
        renderData.vertDirty = false;
      },
      fillBuffers: function(sprite, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(sprite);
        var renderData = sprite._renderData, data = renderData._data, node = sprite.node;
        var buffer = renderer._meshBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData, vertexCount = renderData.vertexCount;
        var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        var uvSliced = sprite.spriteFrame.uvSliced;
        buffer.request(vertexCount, renderData.indiceCount);
        for (var i = 4; i < 20; ++i) {
          var vert = data[i];
          var uvs = uvSliced[i - 4];
          vbuf[vertexOffset++] = vert.x;
          vbuf[vertexOffset++] = vert.y;
          vbuf[vertexOffset++] = uvs.u;
          vbuf[vertexOffset++] = uvs.v;
        }
        for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
          var start = vertexId + 4 * r + c;
          ibuf[indiceOffset++] = start;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 4;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 5;
          ibuf[indiceOffset++] = start + 4;
        }
      },
      updateWorldVerts: function(sprite) {
        var node = sprite.node, data = sprite._renderData._data;
        var matrix = node._worldMatrix, a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        for (var row = 0; row < 4; ++row) {
          var rowD = data[row];
          for (var col = 0; col < 4; ++col) {
            var colD = data[col];
            var world = data[4 + 4 * row + col];
            world.x = colD.x * a + rowD.y * c + tx;
            world.y = colD.x * b + rowD.y * d + ty;
          }
        }
      }
    };
  }), {
    "../../../../components/CCSprite": 82,
    "../../../utils/dynamic-atlas/manager": 200
  } ],
  218: [ (function(require, module, exports) {
    var dynamicAtlasManager = require("../../../utils/dynamic-atlas/manager");
    module.exports = {
      useModel: false,
      createData: function(sprite) {
        return sprite.requestRenderData();
      },
      updateRenderData: function(sprite) {
        var frame = sprite.spriteFrame;
        if (frame) {
          frame._original || dynamicAtlasManager.insertSpriteFrame(frame);
          sprite._material && sprite._material._texture === frame._texture || sprite._activateMaterial();
        }
        var renderData = sprite._renderData;
        if (!frame || !renderData || !(renderData.uvDirty || renderData.vertDirty)) return;
        var texture = frame._texture;
        var texw = texture.width, texh = texture.height, rect = frame._rect;
        var node = sprite.node, contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), appx = node.anchorX * contentWidth, appy = node.anchorY * contentHeight;
        var rectWidth = rect.width, rectHeight = rect.height, hRepeat = contentWidth / rectWidth, vRepeat = contentHeight / rectHeight, row = Math.ceil(vRepeat), col = Math.ceil(hRepeat);
        var data = renderData._data;
        renderData.dataLength = Math.max(8, row + 1, col + 1);
        var l = void 0, b = void 0, r = void 0, t = void 0;
        if (frame._rotated) {
          l = rect.x / texw;
          r = (rect.x + rectHeight) / texw;
          b = (rect.y + rectWidth) / texh;
          t = rect.y / texh;
          data[0].u = l;
          data[0].v = t;
          data[1].u = l;
          data[1].v = b;
          data[2].u = r;
          data[2].v = t;
          data[3].u = r;
          data[3].v = b;
          data[4].u = l;
          data[4].v = t;
          data[5].u = l;
          data[5].v = t + (b - t) * Math.min(1, vRepeat - col + 1);
          data[6].u = l + (r - l) * Math.min(1, hRepeat - row + 1);
          data[6].v = t;
          data[7].u = data[5].u;
          data[7].v = data[6].v;
        } else {
          l = rect.x / texw;
          r = (rect.x + rectWidth) / texw;
          b = (rect.y + rectHeight) / texh;
          t = rect.y / texh;
          data[0].u = l;
          data[0].v = b;
          data[1].u = r;
          data[1].v = b;
          data[2].u = l;
          data[2].v = t;
          data[3].u = r;
          data[3].v = t;
          data[4].u = l;
          data[4].v = b;
          data[5].u = l + (r - l) * Math.min(1, hRepeat - col + 1);
          data[5].v = b;
          data[6].u = l;
          data[6].v = b + (t - b) * Math.min(1, vRepeat - row + 1);
          data[7].u = data[5].u;
          data[7].v = data[6].v;
        }
        for (var i = 0; i <= col; ++i) data[i].x = Math.min(rectWidth * i, contentWidth) - appx;
        for (var _i = 0; _i <= row; ++_i) data[_i].y = Math.min(rectHeight * _i, contentHeight) - appy;
        renderData.vertexCount = row * col * 4;
        renderData.indiceCount = row * col * 6;
        renderData.uvDirty = false;
        renderData.vertDirty = false;
      },
      fillBuffers: function(sprite, renderer) {
        var node = sprite.node, renderData = sprite._renderData, data = renderData._data;
        var buffer = renderer._meshBuffer, vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData;
        var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(renderData.vertexCount, renderData.indiceCount);
        var rect = sprite.spriteFrame._rect;
        var contentWidth = Math.abs(node.width);
        var contentHeight = Math.abs(node.height);
        var hRepeat = contentWidth / rect.width;
        var vRepeat = contentHeight / rect.height;
        var row = Math.ceil(vRepeat), col = Math.ceil(hRepeat);
        var matrix = node._worldMatrix;
        var a = matrix.m00, b = matrix.m01, c = matrix.m04, d = matrix.m05, tx = matrix.m12, ty = matrix.m13;
        var x = void 0, x1 = void 0, y = void 0, y1 = void 0, lastx = void 0, lasty = void 0;
        for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
          y = data[yindex].y;
          y1 = data[yindex + 1].y;
          for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
            lasty = yindex + 1 === ylength;
            lastx = xindex + 1 === xlength;
            x = data[xindex].x;
            x1 = data[xindex + 1].x;
            vbuf[vertexOffset++] = x * a + y * c + tx;
            vbuf[vertexOffset++] = x * b + y * d + ty;
            vbuf[vertexOffset++] = lastx ? data[4].u : data[0].u;
            vbuf[vertexOffset++] = lasty ? data[4].v : data[0].v;
            vbuf[vertexOffset++] = x1 * a + y * c + tx;
            vbuf[vertexOffset++] = x1 * b + y * d + ty;
            vbuf[vertexOffset++] = lastx ? data[5].u : data[1].u;
            vbuf[vertexOffset++] = lasty ? data[5].v : data[1].v;
            vbuf[vertexOffset++] = x * a + y1 * c + tx;
            vbuf[vertexOffset++] = x * b + y1 * d + ty;
            vbuf[vertexOffset++] = lastx ? data[6].u : data[2].u;
            vbuf[vertexOffset++] = lasty ? data[6].v : data[2].v;
            vbuf[vertexOffset++] = x1 * a + y1 * c + tx;
            vbuf[vertexOffset++] = x1 * b + y1 * d + ty;
            vbuf[vertexOffset++] = lastx ? data[7].u : data[3].u;
            vbuf[vertexOffset++] = lasty ? data[7].v : data[3].v;
          }
        }
        var length = renderData.indiceCount;
        for (var i = 0; i < length; i += 6) {
          ibuf[indiceOffset++] = vertexId;
          ibuf[indiceOffset++] = vertexId + 1;
          ibuf[indiceOffset++] = vertexId + 2;
          ibuf[indiceOffset++] = vertexId + 1;
          ibuf[indiceOffset++] = vertexId + 3;
          ibuf[indiceOffset++] = vertexId + 2;
          vertexId += 4;
        }
      }
    };
  }), {
    "../../../utils/dynamic-atlas/manager": 200
  } ],
  219: [ (function(require, module, exports) {
    var renderEngine = require("../render-engine");
    var gfx = renderEngine.gfx;
    class MeshBuffer {
      constructor(renderer, vertexFormat) {
        this.byteStart = 0;
        this.byteOffset = 0;
        this.indiceStart = 0;
        this.indiceOffset = 0;
        this.vertexOffset = 0;
        this._vertexFormat = vertexFormat;
        this._vertexBytes = this._vertexFormat._bytes;
        this._vb = new gfx.VertexBuffer(renderer._device, vertexFormat, gfx.USAGE_DYNAMIC, new ArrayBuffer(), 0);
        this._ib = new gfx.IndexBuffer(renderer._device, gfx.INDEX_FMT_UINT16, gfx.USAGE_STATIC, new ArrayBuffer(), 0);
        this._vData = null;
        this._iData = null;
        this._uintVData = null;
        this._renderer = renderer;
        this._initVDataCount = 256 * vertexFormat._bytes;
        this._initIDataCount = 1536;
        this._reallocBuffer();
      }
      uploadData() {
        if (0 === this.byteOffset) return;
        var vertexsData = new Float32Array(this._vData.buffer, 0, this.byteOffset >> 2);
        var indicesData = new Uint16Array(this._iData.buffer, 0, this.indiceOffset);
        var vb = this._vb;
        vb.update(0, vertexsData);
        var ib = this._ib;
        ib.update(0, indicesData);
      }
      request(vertexCount, indiceCount) {
        if (this._renderer._buffer !== this) {
          this._renderer._flush();
          this._renderer._buffer = this;
        }
        var byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        var indiceOffset = this.indiceOffset + indiceCount;
        var byteLength = this._vData.byteLength;
        var indiceLength = this._iData.length;
        if (byteOffset > byteLength || indiceOffset > indiceLength) {
          while (byteLength < byteOffset || indiceLength < indiceOffset) {
            this._initVDataCount *= 2;
            this._initIDataCount *= 2;
            byteLength = 4 * this._initVDataCount;
            indiceLength = this._initIDataCount;
          }
          this._reallocBuffer();
        }
        this.vertexOffset += vertexCount;
        this.indiceOffset += indiceCount;
        this.byteOffset = byteOffset;
      }
      _reallocBuffer() {
        var oldVData = this._vData;
        this._vData = new Float32Array(this._initVDataCount);
        this._uintVData = new Uint32Array(this._vData.buffer);
        this._iData = new Uint16Array(this._initIDataCount);
        if (oldVData) {
          var vData = this._vData;
          for (var i = 0, l = oldVData.length; i < l; i++) vData[i] = oldVData[i];
        }
        this._vb._bytes = this._vData.byteLength;
        this._ib._bytes = this._iData.byteLength;
      }
      reset() {
        this.byteStart = 0;
        this.byteOffset = 0;
        this.indiceStart = 0;
        this.indiceOffset = 0;
        this.vertexOffset = 0;
      }
    }
    module.exports = MeshBuffer;
  }), {
    "../render-engine": 197
  } ],
  220: [ (function(require, module, exports) {
    var MeshBuffer = require("./mesh-buffer");
    class QuadBuffer extends MeshBuffer {
      _fillQuadBuffer() {
        var count = this._initIDataCount / 6;
        var buffer = this._iData;
        for (var i = 0, idx = 0; i < count; i++) {
          var vertextID = 4 * i;
          buffer[idx++] = vertextID;
          buffer[idx++] = vertextID + 1;
          buffer[idx++] = vertextID + 2;
          buffer[idx++] = vertextID + 1;
          buffer[idx++] = vertextID + 3;
          buffer[idx++] = vertextID + 2;
        }
        var indicesData = new Uint16Array(this._iData.buffer, 0, 6 * count);
        this._ib.update(0, indicesData);
      }
      uploadData() {
        var vertexsData = new Float32Array(this._vData.buffer, 0, this.byteOffset >> 2);
        this._vb.update(0, vertexsData);
      }
      _reallocBuffer() {
        MeshBuffer.prototype._reallocBuffer.call(this);
        this._fillQuadBuffer();
      }
    }
    module.exports = QuadBuffer;
  }), {
    "./mesh-buffer": 219
  } ],
  221: [ (function(require, module, exports) {
    var macro = require("../../platform/CCMacro");
    var renderEngine = require("../render-engine");
    var defaultVertexFormat = require("./vertex-format").vfmtPosUv;
    var StencilManager = require("./stencil-manager");
    var atlasManager = require("../utils/dynamic-atlas/manager");
    var RenderFlow = require("../render-flow");
    var QuadBuffer = require("./quad-buffer");
    var MeshBuffer = require("./mesh-buffer");
    var idGenerater = new (require("../../platform/id-generater"))("VertextFormat");
    var gfx = renderEngine.gfx;
    var RecyclePool = renderEngine.RecyclePool;
    var InputAssembler = renderEngine.InputAssembler;
    var IARenderData = renderEngine.IARenderData;
    var bits = renderEngine.math.bits;
    var FLOATS_PER_VERT = defaultVertexFormat._bytes / 4;
    var BYTE_PER_INDEX = 2;
    var MAX_VERTEX = macro.BATCH_VERTEX_COUNT;
    var MAX_VERTEX_BYTES = MAX_VERTEX * defaultVertexFormat._bytes;
    var MAX_INDICE = MAX_VERTEX * BYTE_PER_INDEX;
    var MAX_INDICE_BYTES = 2 * MAX_INDICE;
    var _buffers = {};
    var empty_material = new renderEngine.Material();
    empty_material.updateHash();
    var RenderComponentWalker = function(device, renderScene) {
      this._renderScene = renderScene;
      this._device = device;
      this._stencilMgr = StencilManager.sharedManager;
      this.material = empty_material;
      this.cullingMask = 1;
      var defaultFormat = new gfx.VertexFormat([]);
      this._iaPool = new RecyclePool(function() {
        return new InputAssembler();
      }, 16);
      this._modelPool = new RecyclePool(function() {
        return new renderEngine.Model();
      }, 16);
      this._quadBuffer = this.getBuffer("quad", defaultVertexFormat);
      this._meshBuffer = this.getBuffer("mesh", defaultVertexFormat);
      this._buffer = this._quadBuffer;
      this._batchedModels = [];
      this._dummyNode = new cc.Node();
      this._sortKey = 0;
      this.node = this._dummyNode;
      this.parentOpacity = 1 / 255;
      this.parentOpacityDirty = 0;
      this.worldMatDirty = 0;
      RenderFlow.init(this);
    };
    RenderComponentWalker.prototype = {
      constructor: RenderComponentWalker,
      reset: function() {
        this._iaPool.reset();
        var scene = this._renderScene;
        var models = this._batchedModels;
        for (var i = 0; i < models.length; ++i) {
          models[i].clearInputAssemblers();
          models[i].clearEffects();
          scene.removeModel(models[i]);
        }
        this._modelPool.reset();
        models.length = 0;
        this._sortKey = 0;
        for (var key in _buffers) _buffers[key].reset();
        this._buffer = this._quadBuffer;
        this.node = this._dummyNode;
        this.material = empty_material;
        this.cullingMask = 1;
        this.parentOpacity = 1 / 255;
        this.parentOpacityDirty = 0;
        this.worldMatDirty = 0;
        this._stencilMgr.reset();
      },
      _flush: function() {
        var material = this.material, buffer = this._buffer, indiceStart = buffer.indiceStart, indiceOffset = buffer.indiceOffset, indiceCount = indiceOffset - indiceStart;
        if (!material || indiceCount <= 0) return;
        var effect = material.effect;
        var ia = this._iaPool.add();
        ia._vertexBuffer = buffer._vb;
        ia._indexBuffer = buffer._ib;
        ia._start = indiceStart;
        ia._count = indiceCount;
        this._stencilMgr.handleEffect(effect);
        var model = this._modelPool.add();
        this._batchedModels.push(model);
        model.sortKey = this._sortKey++;
        model._cullingMask = this.cullingMask;
        model.setNode(this.node);
        model.addEffect(effect);
        model.addInputAssembler(ia);
        this._renderScene.addModel(model);
        buffer.byteStart = buffer.byteOffset;
        buffer.indiceStart = buffer.indiceOffset;
      },
      _flushIA: function(iaRenderData) {
        var material = iaRenderData.material;
        if (!iaRenderData.ia || !material) return;
        this.material = material;
        var effect = this._stencilMgr.handleEffect(material.effect);
        var model = this._modelPool.add();
        this._batchedModels.push(model);
        model.sortKey = this._sortKey++;
        model._cullingMask = this.cullingMask;
        model.setNode(this.node);
        model.addEffect(effect);
        model.addInputAssembler(iaRenderData.ia);
        this._renderScene.addModel(model);
      },
      _commitComp: function(comp, assembler, cullingMask) {
        if (this.material._hash != comp._material._hash || this.cullingMask !== cullingMask) {
          this._flush();
          this.node = assembler.useModel ? comp.node : this._dummyNode;
          this.material = comp._material;
          this.cullingMask = cullingMask;
        }
        assembler.fillBuffers(comp, this);
      },
      _commitIA: function(comp, assembler, cullingMask) {
        this._flush();
        this.cullingMask = cullingMask;
        this.material = comp._material;
        this.node = assembler.useModel ? comp.node : this._dummyNode;
        assembler.renderIA(comp, this);
      },
      visit: function(scene) {
        this.reset();
        RenderFlow.render(scene);
        atlasManager.update();
        this._flush();
        for (var key in _buffers) _buffers[key].uploadData();
      },
      getBuffer: function(type, vertextFormat) {
        vertextFormat.name || (vertextFormat.name = idGenerater.getNewId());
        var key = type + vertextFormat.name;
        var buffer = _buffers[key];
        if (!buffer) {
          if ("mesh" === type) buffer = new MeshBuffer(this, vertextFormat); else {
            if ("quad" !== type) {
              cc.error("Not support buffer type [" + type + "]");
              return null;
            }
            buffer = new QuadBuffer(this, vertextFormat);
          }
          _buffers[key] = buffer;
        }
        return buffer;
      }
    };
    module.exports = RenderComponentWalker;
  }), {
    "../../platform/CCMacro": 160,
    "../../platform/id-generater": 171,
    "../render-engine": 197,
    "../render-flow": 198,
    "../utils/dynamic-atlas/manager": 200,
    "./mesh-buffer": 219,
    "./quad-buffer": 220,
    "./stencil-manager": 222,
    "./vertex-format": 223
  } ],
  222: [ (function(require, module, exports) {
    var Enums = require("../../platform/CCEnum");
    var renderEngine = require("../render-engine");
    var gfx = renderEngine.gfx;
    var renderer = renderEngine.renderer;
    var RecyclePool = renderEngine.RecyclePool;
    var Stage = cc.Enum({
      DISABLED: 0,
      ENTER_LEVEL: 1,
      ENABLED: 2,
      EXIT_LEVEL: 3
    });
    function StencilManager() {
      this._maxLevel = 8;
      this._maskStack = [];
      this.stage = Stage.DISABLED;
    }
    StencilManager.prototype = {
      constructor: StencilManager,
      reset: function() {
        this._maskStack.length = 0;
        this.stage = Stage.DISABLED;
      },
      handleEffect: function(effect) {
        var technique = effect.getTechnique("transparent");
        var passes = technique.passes;
        if (this.stage === Stage.DISABLED) {
          this.stage = Stage.DISABLED;
          for (var i = 0; i < passes.length; ++i) {
            var pass = passes[i];
            pass._stencilTest && pass.disableStencilTest();
          }
          return effect;
        }
        var mask = void 0, func = void 0, ref = void 0, stencilMask = void 0, writeMask = void 0, failOp = void 0, zFailOp = gfx.STENCIL_OP_KEEP, zPassOp = gfx.STENCIL_OP_KEEP;
        if (this.stage === Stage.ENABLED) {
          func = gfx.DS_FUNC_EQUAL;
          mask = this._maskStack[this._maskStack.length - 1];
          if (mask.inverted) {
            ref = this.getInvertedRef();
            stencilMask = this.getStencilRef();
          } else {
            ref = this.getStencilRef();
            stencilMask = ref;
          }
          failOp = gfx.STENCIL_OP_KEEP;
          writeMask = 0;
        } else {
          func = gfx.DS_FUNC_NEVER;
          failOp = gfx.STENCIL_OP_REPLACE;
          if (this.stage === Stage.ENTER_LEVEL) {
            this.stage = Stage.ENABLED;
            ref = this.getStencilRef();
            stencilMask = this.getWriteMask();
            writeMask = stencilMask;
          } else if (this.stage === Stage.EXIT_LEVEL) {
            0 === this._maskStack.length ? this.stage = Stage.DISABLED : this.stage = Stage.ENABLED;
            ref = 0;
            stencilMask = this.getExitWriteMask();
            writeMask = stencilMask;
          }
        }
        for (var _i = 0; _i < passes.length; ++_i) {
          var _pass = passes[_i];
          _pass.setStencilFront(func, ref, stencilMask, failOp, zFailOp, zPassOp, writeMask);
          _pass.setStencilBack(func, ref, stencilMask, failOp, zFailOp, zPassOp, writeMask);
        }
      },
      pushMask: function(mask) {
        this._maskStack.length + 1 > this._maxLevel && cc.errorID(9e3, this._maxLevel);
        this._maskStack.push(mask);
        this.stage = Stage.ENTER_LEVEL;
      },
      popMask: function() {
        0 === this._maskStack.length && cc.errorID(9001);
        this._maskStack.pop();
        this.stage = Stage.EXIT_LEVEL;
      },
      getWriteMask: function() {
        return 1 << this._maskStack.length - 1;
      },
      getExitWriteMask: function() {
        return 1 << this._maskStack.length;
      },
      getStencilRef: function() {
        var result = 0;
        for (var i = 0; i < this._maskStack.length; ++i) result += 1 << i;
        return result;
      },
      getInvertedRef: function() {
        var result = 0;
        for (var i = 0; i < this._maskStack.length - 1; ++i) result += 1 << i;
        return result;
      }
    };
    StencilManager.sharedManager = new StencilManager();
    StencilManager.Stage = Stage;
    module.exports = StencilManager;
  }), {
    "../../platform/CCEnum": 157,
    "../render-engine": 197
  } ],
  223: [ (function(require, module, exports) {
    var renderEngine = require("../render-engine");
    var gfx = renderEngine.gfx;
    var vfmt3D = new gfx.VertexFormat([ {
      name: gfx.ATTR_POSITION,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: gfx.ATTR_UV0,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_COLOR,
      type: gfx.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmt3D.name = "vfmt3D";
    var vfmtPosUvColor = new gfx.VertexFormat([ {
      name: gfx.ATTR_POSITION,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_UV0,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_COLOR,
      type: gfx.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtPosUvColor.name = "vfmtPosUvColor";
    var vfmtPosUv = new gfx.VertexFormat([ {
      name: gfx.ATTR_POSITION,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_UV0,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    } ]);
    vfmtPosUv.name = "vfmtPosUv";
    module.exports = {
      vfmt3D: vfmt3D,
      vfmtPosUvColor: vfmtPosUvColor,
      vfmtPosUv: vfmtPosUv
    };
  }), {
    "../render-engine": 197
  } ],
  224: [ (function(require, module, exports) {
    require("../platform/CCSys");
    var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
    var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
    var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
    cc.path = {
      join: function() {
        var l = arguments.length;
        var result = "";
        for (var i = 0; i < l; i++) result = (result + ("" === result ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
        return result;
      },
      extname: function(pathStr) {
        var temp = EXTNAME_RE.exec(pathStr);
        return temp ? temp[1] : "";
      },
      mainFileName: function(fileName) {
        if (fileName) {
          var idx = fileName.lastIndexOf(".");
          if (-1 !== idx) return fileName.substring(0, idx);
        }
        return fileName;
      },
      basename: function(pathStr, extname) {
        var index = pathStr.indexOf("?");
        index > 0 && (pathStr = pathStr.substring(0, index));
        var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
        var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
        if (!result) return null;
        var baseName = result[2];
        if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() === extname.toLowerCase()) return baseName.substring(0, baseName.length - extname.length);
        return baseName;
      },
      dirname: function(pathStr) {
        var temp = DIRNAME_RE.exec(pathStr);
        return temp ? temp[2] : "";
      },
      changeExtname: function(pathStr, extname) {
        extname = extname || "";
        var index = pathStr.indexOf("?");
        var tempStr = "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf(".");
        if (index < 0) return pathStr + extname + tempStr;
        return pathStr.substring(0, index) + extname + tempStr;
      },
      changeBasename: function(pathStr, basename, isSameExt) {
        if (0 === basename.indexOf(".")) return this.changeExtname(pathStr, basename);
        var index = pathStr.indexOf("?");
        var tempStr = "";
        var ext = isSameExt ? this.extname(pathStr) : "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf("/");
        index = index <= 0 ? 0 : index + 1;
        return pathStr.substring(0, index) + basename + ext + tempStr;
      },
      _normalize: function(url) {
        var oldUrl = url = String(url);
        do {
          oldUrl = url;
          url = url.replace(NORMALIZE_RE, "");
        } while (oldUrl.length !== url.length);
        return url;
      },
      sep: cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/",
      stripSep: function(path) {
        return path.replace(/[\/\\]$/, "");
      }
    };
    module.exports = cc.path;
  }), {
    "../platform/CCSys": 164
  } ],
  225: [ (function(require, module, exports) {
    var AffineTransform = function(a, b, c, d, tx, ty) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    };
    AffineTransform.create = function(a, b, c, d, tx, ty) {
      return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: tx,
        ty: ty
      };
    };
    AffineTransform.identity = function() {
      return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
    };
    AffineTransform.clone = function(t) {
      return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx,
        ty: t.ty
      };
    };
    AffineTransform.concat = function(out, t1, t2) {
      var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
      out.a = a * t2.a + b * t2.c;
      out.b = a * t2.b + b * t2.d;
      out.c = c * t2.a + d * t2.c;
      out.d = c * t2.b + d * t2.d;
      out.tx = tx * t2.a + ty * t2.c + t2.tx;
      out.ty = tx * t2.b + ty * t2.d + t2.ty;
      return out;
    };
    AffineTransform.invert = function(out, t) {
      var a = t.a, b = t.b, c = t.c, d = t.d;
      var determinant = 1 / (a * d - b * c);
      var tx = t.tx, ty = t.ty;
      out.a = determinant * d;
      out.b = -determinant * b;
      out.c = -determinant * c;
      out.d = determinant * a;
      out.tx = determinant * (c * ty - d * tx);
      out.ty = determinant * (b * tx - a * ty);
      return out;
    };
    AffineTransform.fromMat4 = function(out, mat) {
      out.a = mat.m00;
      out.b = mat.m01;
      out.c = mat.m04;
      out.d = mat.m05;
      out.tx = mat.m12;
      out.ty = mat.m13;
      return out;
    };
    AffineTransform.transformVec2 = function(out, point, transOrY, t) {
      var x, y;
      if (void 0 === t) {
        t = transOrY;
        x = point.x;
        y = point.y;
      } else {
        x = point;
        y = transOrY;
      }
      out.x = t.a * x + t.c * y + t.tx;
      out.y = t.b * x + t.d * y + t.ty;
      return out;
    };
    AffineTransform.transformSize = function(out, size, t) {
      out.width = t.a * size.width + t.c * size.height;
      out.height = t.b * size.width + t.d * size.height;
      return out;
    };
    AffineTransform.transformRect = function(out, rect, t) {
      var ol = rect.x;
      var ob = rect.y;
      var or = ol + rect.width;
      var ot = ob + rect.height;
      var lbx = t.a * ol + t.c * ob + t.tx;
      var lby = t.b * ol + t.d * ob + t.ty;
      var rbx = t.a * or + t.c * ob + t.tx;
      var rby = t.b * or + t.d * ob + t.ty;
      var ltx = t.a * ol + t.c * ot + t.tx;
      var lty = t.b * ol + t.d * ot + t.ty;
      var rtx = t.a * or + t.c * ot + t.tx;
      var rty = t.b * or + t.d * ot + t.ty;
      var minX = Math.min(lbx, rbx, ltx, rtx);
      var maxX = Math.max(lbx, rbx, ltx, rtx);
      var minY = Math.min(lby, rby, lty, rty);
      var maxY = Math.max(lby, rby, lty, rty);
      out.x = minX;
      out.y = minY;
      out.width = maxX - minX;
      out.height = maxY - minY;
      return out;
    };
    AffineTransform.transformObb = function(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var tx = anAffineTransform.a * x + anAffineTransform.c * y + anAffineTransform.tx;
      var ty = anAffineTransform.b * x + anAffineTransform.d * y + anAffineTransform.ty;
      var xa = anAffineTransform.a * width;
      var xb = anAffineTransform.b * width;
      var yc = anAffineTransform.c * height;
      var yd = anAffineTransform.d * height;
      out_tl.x = tx;
      out_tl.y = ty;
      out_tr.x = xa + tx;
      out_tr.y = xb + ty;
      out_bl.x = yc + tx;
      out_bl.y = yd + ty;
      out_br.x = xa + yc + tx;
      out_br.y = xb + yd + ty;
    };
    cc.AffineTransform = module.exports = AffineTransform;
  }), {} ],
  226: [ (function(require, module, exports) {
    var Flags = require("../platform/CCObject").Flags;
    var misc = require("./misc");
    var js = require("../platform/js");
    var IdGenerater = require("../platform/id-generater");
    var eventManager = require("../event-manager");
    var RenderFlow = require("../renderer/render-flow");
    var Destroying = Flags.Destroying;
    var DontDestroy = Flags.DontDestroy;
    var Deactivating = Flags.Deactivating;
    var CHILD_ADDED = "child-added";
    var CHILD_REMOVED = "child-removed";
    var idGenerater = new IdGenerater("Node");
    function getConstructor(typeOrClassName) {
      if (!typeOrClassName) {
        cc.errorID(3804);
        return null;
      }
      if ("string" === typeof typeOrClassName) return js.getClassByName(typeOrClassName);
      return typeOrClassName;
    }
    function findComponent(node, constructor) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        if (comp.constructor === constructor) return comp;
      } else for (var _i = 0; _i < node._components.length; ++_i) {
        var _comp = node._components[_i];
        if (_comp instanceof constructor) return _comp;
      }
      return null;
    }
    function findComponents(node, constructor, components) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        comp.constructor === constructor && components.push(comp);
      } else for (var _i2 = 0; _i2 < node._components.length; ++_i2) {
        var _comp2 = node._components[_i2];
        _comp2 instanceof constructor && components.push(_comp2);
      }
    }
    function findChildComponent(children, constructor) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        var comp = findComponent(node, constructor);
        if (comp) return comp;
        if (node._children.length > 0) {
          comp = findChildComponent(node._children, constructor);
          if (comp) return comp;
        }
      }
      return null;
    }
    function findChildComponents(children, constructor, components) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        findComponents(node, constructor, components);
        node._children.length > 0 && findChildComponents(node._children, constructor, components);
      }
    }
    var BaseNode = cc.Class({
      name: "cc._BaseNode",
      extends: cc.Object,
      properties: {
        _parent: null,
        _children: [],
        _active: true,
        _level: 0,
        _components: [],
        _prefab: null,
        _persistNode: {
          get: function() {
            return (this._objFlags & DontDestroy) > 0;
          },
          set: function(value) {
            value ? this._objFlags |= DontDestroy : this._objFlags &= ~DontDestroy;
          }
        },
        name: {
          get: function() {
            return this._name;
          },
          set: function(value) {
            false;
            this._name = value;
          }
        },
        uuid: {
          get: function() {
            return this._id;
          }
        },
        children: {
          get: function() {
            return this._children;
          }
        },
        childrenCount: {
          get: function() {
            return this._children.length;
          }
        },
        active: {
          get: function() {
            return this._active;
          },
          set: function(value) {
            value = !!value;
            if (this._active !== value) {
              this._active = value;
              var parent = this._parent;
              if (parent) {
                var couldActiveInScene = parent._activeInHierarchy;
                couldActiveInScene && cc.director._nodeActivator.activateNode(this, value);
              }
            }
          }
        },
        activeInHierarchy: {
          get: function() {
            return this._activeInHierarchy;
          }
        }
      },
      ctor: function(name) {
        this._name = void 0 !== name ? name : "New Node";
        this._activeInHierarchy = false;
        this._id = idGenerater.getNewId();
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
        this.__eventTargets = [];
        this._renderFlag = RenderFlow.FLAG_TRANSFORM;
      },
      getParent: function() {
        return this._parent;
      },
      setParent: function(value) {
        if (this._parent === value) return;
        false;
        var oldParent = this._parent;
        (true, oldParent) && oldParent._objFlags & Deactivating && cc.errorID(3821);
        this._parent = value || null;
        this._onSetParent(value);
        if (value) {
          (true, value._objFlags & Deactivating) && cc.errorID(3821);
          this._level = value._level + 1;
          eventManager._setDirtyForNode(this);
          value._children.push(this);
          value.emit && value.emit(CHILD_ADDED, this);
          value._renderFlag |= RenderFlow.FLAG_CHILDREN;
        }
        if (oldParent) {
          if (!(oldParent._objFlags & Destroying)) {
            var removeAt = oldParent._children.indexOf(this);
            false;
            oldParent._children.splice(removeAt, 1);
            oldParent.emit && oldParent.emit(CHILD_REMOVED, this);
            this._onHierarchyChanged(oldParent);
            0 === oldParent._children.length && (oldParent._renderFlag &= ~RenderFlow.FLAG_CHILDREN);
          }
        } else value && this._onHierarchyChanged(null);
      },
      attr: function(attrs) {
        js.mixin(this, attrs);
      },
      getChildByUuid: function(uuid) {
        if (!uuid) {
          cc.log("Invalid uuid");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
        return null;
      },
      getChildByName: function(name) {
        if (!name) {
          cc.log("Invalid name");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
        return null;
      },
      addChild: function(child) {
        false;
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.setParent(this);
      },
      insertChild: function(child, siblingIndex) {
        child.parent = this;
        child.setSiblingIndex(siblingIndex);
      },
      getSiblingIndex: function() {
        return this._parent ? this._parent._children.indexOf(this) : 0;
      },
      setSiblingIndex: function(index) {
        if (!this._parent) return;
        if (this._parent._objFlags & Deactivating) {
          cc.errorID(3821);
          return;
        }
        var siblings = this._parent._children;
        index = -1 !== index ? index : siblings.length - 1;
        var oldIndex = siblings.indexOf(this);
        if (index !== oldIndex) {
          siblings.splice(oldIndex, 1);
          index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this);
          this._onSiblingIndexChanged && this._onSiblingIndexChanged(index);
        }
      },
      walk: function(prefunc, postfunc) {
        var BaseNode = cc._BaseNode;
        var index = 1;
        var children, child, curr, i, afterChildren;
        var stack = BaseNode._stacks[BaseNode._stackId];
        if (!stack) {
          stack = [];
          BaseNode._stacks.push(stack);
        }
        BaseNode._stackId++;
        stack.length = 0;
        stack[0] = this;
        var parent = null;
        afterChildren = false;
        while (index) {
          index--;
          curr = stack[index];
          if (!curr) continue;
          !afterChildren && prefunc ? prefunc(curr) : afterChildren && postfunc && postfunc(curr);
          stack[index] = null;
          if (!afterChildren) {
            if (curr._children.length > 0) {
              parent = curr;
              children = curr._children;
              i = 0;
              stack[index] = children[i];
              index++;
            } else {
              stack[index] = curr;
              index++;
              afterChildren = true;
            }
            continue;
          }
          afterChildren = false;
          if (children) {
            i++;
            if (children[i]) {
              stack[index] = children[i];
              index++;
            } else if (parent) {
              stack[index] = parent;
              index++;
              afterChildren = true;
              if (parent._parent) {
                children = parent._parent._children;
                i = children.indexOf(parent);
                parent = parent._parent;
              } else {
                parent = null;
                children = null;
              }
              if (i < 0) break;
            }
          }
        }
        stack.length = 0;
        BaseNode._stackId--;
      },
      cleanup: function() {},
      removeFromParent: function(cleanup) {
        if (this._parent) {
          void 0 === cleanup && (cleanup = true);
          this._parent.removeChild(this, cleanup);
        }
      },
      removeChild: function(child, cleanup) {
        if (this._children.indexOf(child) > -1) {
          (cleanup || void 0 === cleanup) && child.cleanup();
          child.parent = null;
        }
      },
      removeAllChildren: function(cleanup) {
        var children = this._children;
        void 0 === cleanup && (cleanup = true);
        for (var i = children.length - 1; i >= 0; i--) {
          var node = children[i];
          if (node) {
            cleanup && node.cleanup();
            node.parent = null;
          }
        }
        this._children.length = 0;
      },
      isChildOf: function(parent) {
        var child = this;
        do {
          if (child === parent) return true;
          child = child._parent;
        } while (child);
        return false;
      },
      getComponent: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findComponent(this, constructor);
        return null;
      },
      getComponents: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        constructor && findComponents(this, constructor, components);
        return components;
      },
      getComponentInChildren: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findChildComponent(this._children, constructor);
        return null;
      },
      getComponentsInChildren: function(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        if (constructor) {
          findComponents(this, constructor, components);
          findChildComponents(this._children, constructor, components);
        }
        return components;
      },
      _checkMultipleComp: false,
      addComponent: function(typeOrClassName) {
        false;
        var constructor;
        if ("string" === typeof typeOrClassName) {
          constructor = js.getClassByName(typeOrClassName);
          if (!constructor) {
            cc.errorID(3807, typeOrClassName);
            cc._RFpeek() && cc.errorID(3808, typeOrClassName);
            return null;
          }
        } else {
          if (!typeOrClassName) {
            cc.errorID(3804);
            return null;
          }
          constructor = typeOrClassName;
        }
        if ("function" !== typeof constructor) {
          cc.errorID(3809);
          return null;
        }
        if (!js.isChildClassOf(constructor, cc.Component)) {
          cc.errorID(3810);
          return null;
        }
        false;
        var ReqComp = constructor._requireComponent;
        if (ReqComp && !this.getComponent(ReqComp)) {
          var depended = this.addComponent(ReqComp);
          if (!depended) return null;
        }
        var component = new constructor();
        component.node = this;
        this._components.push(component);
        (false, false) && cc.engine && this._id in cc.engine.attachedObjsForEditor && (cc.engine.attachedObjsForEditor[component._id] = component);
        this._activeInHierarchy && cc.director._nodeActivator.activateComp(component);
        return component;
      },
      _addComponentAt: false,
      removeComponent: function(component) {
        if (!component) {
          cc.errorID(3813);
          return;
        }
        component instanceof cc.Component || (component = this.getComponent(component));
        component && component.destroy();
      },
      _getDependComponent: false,
      _removeComponent: function(component) {
        if (!component) {
          cc.errorID(3814);
          return;
        }
        if (!(this._objFlags & Destroying)) {
          var i = this._components.indexOf(component);
          if (-1 !== i) {
            this._components.splice(i, 1);
            (false, false) && cc.engine && delete cc.engine.attachedObjsForEditor[component._id];
          } else component.node !== this && cc.errorID(3815);
        }
      },
      _disableChildComps: function() {
        var i, len = this._components.length;
        for (i = 0; i < len; ++i) {
          var component = this._components[i];
          component._enabled && cc.director._compScheduler.disableComp(component);
        }
        for (i = 0, len = this._children.length; i < len; ++i) {
          var node = this._children[i];
          node._active && node._disableChildComps();
        }
      },
      destroy: function() {
        cc.Object.prototype.destroy.call(this) && this._activeInHierarchy && this._disableChildComps();
      },
      destroyAllChildren: function() {
        var children = this._children;
        for (var i = 0; i < children.length; ++i) children[i].destroy();
      },
      _onSetParent: function(value) {},
      _onPostActivated: function() {},
      _onBatchRestored: function() {},
      _onBatchCreated: function() {},
      _onHierarchyChanged: function(oldParent) {
        var newParent = this._parent;
        if (this._persistNode && !(newParent instanceof cc.Scene)) {
          cc.game.removePersistRootNode(this);
          false;
        }
        var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);
        this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
        var scene;
        var inCurrentSceneBefore;
        var inCurrentSceneNow;
        var newPrefabRoot;
        var myPrefabInfo;
        false, false;
      },
      _instantiate: function(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        var thisPrefabInfo = this._prefab;
        false;
        var syncing = thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
        syncing || false;
        cloned._parent = null;
        cloned._onBatchRestored();
        return cloned;
      },
      _registerIfAttached: (false, false) && function(register) {
        var attachedObjsForEditor = cc.engine.attachedObjsForEditor;
        if (register) {
          attachedObjsForEditor[this._id] = this;
          for (var i = 0; i < this._components.length; i++) {
            var comp = this._components[i];
            attachedObjsForEditor[comp._id] = comp;
          }
          cc.engine.emit("node-attach-to-scene", {
            target: this
          });
        } else {
          cc.engine.emit("node-detach-from-scene", {
            target: this
          });
          delete attachedObjsForEditor[this._id];
          for (var _i3 = 0; _i3 < this._components.length; _i3++) {
            var _comp3 = this._components[_i3];
            delete attachedObjsForEditor[_comp3._id];
          }
        }
        var children = this._children;
        for (var _i4 = 0, len = children.length; _i4 < len; ++_i4) {
          var child = children[_i4];
          child._registerIfAttached(register);
        }
      },
      _onPreDestroy: function() {
        var i, len;
        this._objFlags |= Destroying;
        var parent = this._parent;
        var destroyByParent = parent && parent._objFlags & Destroying;
        !destroyByParent && (false, false) && this._registerIfAttached(false);
        var children = this._children;
        for (i = 0, len = children.length; i < len; ++i) children[i]._destroyImmediate();
        for (i = 0, len = this._components.length; i < len; ++i) {
          var component = this._components[i];
          component._destroyImmediate();
        }
        var eventTargets = this.__eventTargets;
        for (i = 0, len = eventTargets.length; i < len; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        this._persistNode && cc.game.removePersistRootNode(this);
        if (!destroyByParent && parent) {
          var childIndex = parent._children.indexOf(this);
          parent._children.splice(childIndex, 1);
          parent.emit && parent.emit("child-removed", this);
        }
        return destroyByParent;
      },
      onRestore: false
    });
    BaseNode.idGenerater = idGenerater;
    BaseNode._stacks = [ [] ];
    BaseNode._stackId = 0;
    BaseNode.prototype._onPreDestroyBase = BaseNode.prototype._onPreDestroy;
    false;
    BaseNode.prototype._onHierarchyChangedBase = BaseNode.prototype._onHierarchyChanged;
    false;
    var SameNameGetSets = [ "name", "children", "childrenCount" ];
    misc.propertyDefine(BaseNode, SameNameGetSets, {});
    false;
    cc._BaseNode = module.exports = BaseNode;
  }), {
    "../event-manager": 98,
    "../platform/CCObject": 161,
    "../platform/id-generater": 171,
    "../platform/js": 175,
    "../renderer/render-flow": 198,
    "./misc": 233
  } ],
  227: [ (function(require, module, exports) {
    var EPSILON = 1e-6;
    function binarySearchEpsilon(array, value) {
      for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m];
        if (test > value + EPSILON) h = m - 1; else {
          if (!(test < value - EPSILON)) return m;
          l = m + 1;
        }
      }
      return ~l;
    }
    module.exports = {
      binarySearchEpsilon: binarySearchEpsilon
    };
  }), {} ],
  228: [ (function(require, module, exports) {
    var Base64Values = require("./misc").BASE64_VALUES;
    var HexChars = "0123456789abcdef".split("");
    var _t = [ "", "", "", "" ];
    var UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t);
    var Indices = UuidTemplate.map((function(x, i) {
      return "-" === x ? NaN : i;
    })).filter(isFinite);
    module.exports = function(base64) {
      if (22 !== base64.length) return base64;
      UuidTemplate[0] = base64[0];
      UuidTemplate[1] = base64[1];
      for (var i = 2, j = 2; i < 22; i += 2) {
        var lhs = Base64Values[base64.charCodeAt(i)];
        var rhs = Base64Values[base64.charCodeAt(i + 1)];
        UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
        UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4];
        UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
      }
      return UuidTemplate.join("");
    };
    false;
  }), {
    "./misc": 233
  } ],
  229: [ (function(require, module, exports) {
    cc.find = module.exports = function(path, referenceNode) {
      if (null == path) {
        cc.errorID(5600);
        return null;
      }
      if (referenceNode) false; else {
        var scene = cc.director.getScene();
        if (!scene) {
          false;
          return null;
        }
        false;
        referenceNode = scene;
      }
      var match = referenceNode;
      var startIndex = "/" !== path[0] ? 0 : 1;
      var nameList = path.split("/");
      for (var n = startIndex; n < nameList.length; n++) {
        var name = nameList[n];
        var children = match._children;
        match = null;
        for (var t = 0, len = children.length; t < len; ++t) {
          var subChild = children[t];
          if (subChild.name === name) {
            match = subChild;
            break;
          }
        }
        if (!match) return null;
      }
      return match;
    };
  }), {} ],
  230: [ (function(require, module, exports) {
    var eventRegx = /^(click)(\s)*=/;
    var imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=/;
    var HtmlTextParser = function() {
      this._parsedObject = {};
      this._specialSymbolArray = [];
      this._specialSymbolArray.push([ /&lt;/g, "<" ]);
      this._specialSymbolArray.push([ /&gt;/g, ">" ]);
      this._specialSymbolArray.push([ /&amp;/g, "&" ]);
      this._specialSymbolArray.push([ /&quot;/g, '"' ]);
      this._specialSymbolArray.push([ /&apos;/g, "'" ]);
    };
    HtmlTextParser.prototype = {
      constructor: HtmlTextParser,
      parse: function(htmlString) {
        this._resultObjectArray = [];
        this._stack = [];
        var startIndex = 0;
        var length = htmlString.length;
        while (startIndex < length) {
          var tagBeginIndex = htmlString.indexOf("<", startIndex);
          if (tagBeginIndex < 0) {
            this._stack.pop();
            this._processResult(htmlString.substring(startIndex));
            startIndex = length;
          } else {
            this._processResult(htmlString.substring(startIndex, tagBeginIndex));
            var tagEndIndex = htmlString.indexOf(">", startIndex);
            -1 === tagEndIndex ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(htmlString.substring(tagBeginIndex + 1, tagEndIndex));
            startIndex = tagEndIndex + 1;
          }
        }
        return this._resultObjectArray;
      },
      _attributeToObject: function(attribute) {
        attribute = attribute.trim();
        var obj = {};
        var header = attribute.match(/^(color|size)(\s)*=/);
        var tagName;
        var nextSpace;
        var eventObj;
        var eventHanlderString;
        if (header) {
          tagName = header[0];
          attribute = attribute.substring(tagName.length).trim();
          if ("" === attribute) return obj;
          nextSpace = attribute.indexOf(" ");
          switch (tagName[0]) {
           case "c":
            obj.color = nextSpace > -1 ? attribute.substring(0, nextSpace).trim() : attribute;
            break;

           case "s":
            obj.size = parseInt(attribute);
          }
          if (nextSpace > -1) {
            eventHanlderString = attribute.substring(nextSpace + 1).trim();
            eventObj = this._processEventHandler(eventHanlderString);
            obj.event = eventObj;
          }
          return obj;
        }
        header = attribute.match(/^(br(\s)*\/)/);
        if (header && header[0].length > 0) {
          tagName = header[0].trim();
          if (tagName.startsWith("br") && "/" === tagName[tagName.length - 1]) {
            obj.isNewLine = true;
            this._resultObjectArray.push({
              text: "",
              style: {
                newline: true
              }
            });
            return obj;
          }
        }
        header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/);
        if (header && header[0].length > 0) {
          tagName = header[0].trim();
          if (tagName.startsWith("img") && "/" === tagName[tagName.length - 1]) {
            header = attribute.match(imageAttrReg);
            var tagValue;
            var remainingArgument;
            var isValidImageTag = false;
            while (header) {
              attribute = attribute.substring(attribute.indexOf(header[0]));
              tagName = attribute.substr(0, header[0].length);
              remainingArgument = attribute.substring(tagName.length).trim();
              nextSpace = remainingArgument.indexOf(" ");
              tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
              tagName = tagName.replace(/[^a-zA-Z]/g, "").trim();
              tagName = tagName.toLocaleLowerCase();
              attribute = remainingArgument.substring(nextSpace).trim();
              if ("src" === tagName) {
                obj.isImage = true;
                tagValue.endsWith("/") && (tagValue = tagValue.substring(0, tagValue.length - 1));
                if (0 === tagValue.indexOf("'")) {
                  isValidImageTag = true;
                  tagValue = tagValue.substring(1, tagValue.length - 1);
                } else if (0 === tagValue.indexOf('"')) {
                  isValidImageTag = true;
                  tagValue = tagValue.substring(1, tagValue.length - 1);
                }
                obj.src = tagValue;
              } else "height" === tagName ? obj.imageHeight = parseInt(tagValue) : "width" === tagName ? obj.imageWidth = parseInt(tagValue) : "click" === tagName && (obj.event = this._processEventHandler(tagName + "=" + tagValue));
              header = attribute.match(imageAttrReg);
            }
            isValidImageTag && obj.isImage && this._resultObjectArray.push({
              text: "",
              style: obj
            });
            return {};
          }
        }
        header = attribute.match(/^(outline(\s)*[^>]*)/);
        if (header) {
          attribute = header[0].substring("outline".length).trim();
          var defaultOutlineObject = {
            color: "#ffffff",
            width: 1
          };
          if (attribute) {
            var outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=/;
            header = attribute.match(outlineAttrReg);
            var tagValue;
            while (header) {
              attribute = attribute.substring(attribute.indexOf(header[0]));
              tagName = attribute.substr(0, header[0].length);
              remainingArgument = attribute.substring(tagName.length).trim();
              nextSpace = remainingArgument.indexOf(" ");
              tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
              tagName = tagName.replace(/[^a-zA-Z]/g, "").trim();
              tagName = tagName.toLocaleLowerCase();
              attribute = remainingArgument.substring(nextSpace).trim();
              "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + tagValue) : "color" === tagName ? defaultOutlineObject.color = tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(tagValue));
              header = attribute.match(outlineAttrReg);
            }
          }
          obj.outline = defaultOutlineObject;
        }
        header = attribute.match(/^(on|u|b|i)(\s)*/);
        if (header && header[0].length > 0) {
          tagName = header[0];
          attribute = attribute.substring(tagName.length).trim();
          switch (tagName[0]) {
           case "u":
            obj.underline = true;
            break;

           case "i":
            obj.italic = true;
            break;

           case "b":
            obj.bold = true;
          }
          if ("" === attribute) return obj;
          eventObj = this._processEventHandler(attribute);
          obj.event = eventObj;
        }
        return obj;
      },
      _processEventHandler: function(eventString) {
        var index = 0;
        var obj = {};
        var eventNames = eventString.match(eventRegx);
        var isValidTag = false;
        while (eventNames) {
          var eventName = eventNames[0];
          var eventValue = "";
          isValidTag = false;
          eventString = eventString.substring(eventName.length).trim();
          if ('"' === eventString.charAt(0)) {
            index = eventString.indexOf('"', 1);
            if (index > -1) {
              eventValue = eventString.substring(1, index).trim();
              isValidTag = true;
            }
            index++;
          } else if ("'" === eventString.charAt(0)) {
            index = eventString.indexOf("'", 1);
            if (index > -1) {
              eventValue = eventString.substring(1, index).trim();
              isValidTag = true;
            }
            index++;
          } else {
            var match = eventString.match(/(\S)+/);
            eventValue = match ? match[0] : "";
            index = eventValue.length;
          }
          if (isValidTag) {
            eventName = eventName.substring(0, eventName.length - 1).trim();
            obj[eventName] = eventValue;
          }
          eventString = eventString.substring(index).trim();
          eventNames = eventString.match(eventRegx);
        }
        return obj;
      },
      _addToStack: function(attribute) {
        var obj = this._attributeToObject(attribute);
        if (0 === this._stack.length) this._stack.push(obj); else {
          if (obj.isNewLine || obj.isImage) return;
          var previousTagObj = this._stack[this._stack.length - 1];
          for (var key in previousTagObj) obj[key] || (obj[key] = previousTagObj[key]);
          this._stack.push(obj);
        }
      },
      _processResult: function(value) {
        if ("" === value) return;
        value = this._escapeSpecialSymbol(value);
        this._stack.length > 0 ? this._resultObjectArray.push({
          text: value,
          style: this._stack[this._stack.length - 1]
        }) : this._resultObjectArray.push({
          text: value
        });
      },
      _escapeSpecialSymbol: function(str) {
        for (var i = 0; i < this._specialSymbolArray.length; ++i) {
          var key = this._specialSymbolArray[i][0];
          var value = this._specialSymbolArray[i][1];
          str = str.replace(key, value);
        }
        return str;
      }
    };
    false;
    module.exports = HtmlTextParser;
  }), {} ],
  231: [ (function(require, module, exports) {
    require("./CCPath");
    true;
    require("./profiler/CCProfiler");
    require("./find");
    require("./mutable-forward-iterator");
  }), {
    "./CCPath": 224,
    "./find": 229,
    "./mutable-forward-iterator": 234,
    "./profiler/CCProfiler": 237
  } ],
  232: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var renderEngine = require("../renderer/render-engine");
    var Quat = require("../value-types/quat");
    var math = renderEngine.math;
    var mat4Pool = new js.Pool(128);
    mat4Pool.get = function() {
      var matrix = this._get();
      matrix ? math.mat4.identity(matrix) : matrix = math.mat4.create();
      return matrix;
    };
    var quatPool = new js.Pool(64);
    quatPool.get = function() {
      var quat = this._get();
      if (quat) {
        quat.x = quat.y = quat.z = 0;
        quat.w = 1;
      } else quat = math.quat.create();
      return quat;
    };
    module.exports = {
      mat4: mat4Pool,
      quat: quatPool
    };
  }), {
    "../platform/js": 175,
    "../renderer/render-engine": 197,
    "../value-types/quat": 244
  } ],
  233: [ (function(require, module, exports) {
    var js = require("../platform/js");
    var sys = require("../platform/CCSys");
    var misc = {};
    misc.propertyDefine = function(ctor, sameNameGetSets, diffNameGetSets) {
      function define(np, propName, getter, setter) {
        var pd = Object.getOwnPropertyDescriptor(np, propName);
        if (pd) {
          pd.get && (np[getter] = pd.get);
          pd.set && setter && (np[setter] = pd.set);
        } else {
          var getterFunc = np[getter];
          var clsName;
          false;
          js.getset(np, propName, getterFunc, np[setter]);
        }
      }
      var propName, np = ctor.prototype;
      for (var i = 0; i < sameNameGetSets.length; i++) {
        propName = sameNameGetSets[i];
        var suffix = propName[0].toUpperCase() + propName.slice(1);
        define(np, propName, "get" + suffix, "set" + suffix);
      }
      for (propName in diffNameGetSets) {
        var getset = diffNameGetSets[propName];
        define(np, propName, getset[0], getset[1]);
      }
    };
    misc.NextPOT = function(x) {
      x -= 1;
      x |= x >> 1;
      x |= x >> 2;
      x |= x >> 4;
      x |= x >> 8;
      x |= x >> 16;
      return x + 1;
    };
    false;
    misc.BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
    var BASE64_KEYS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var BASE64_VALUES = new Array(123);
    for (var i = 0; i < 123; ++i) BASE64_VALUES[i] = 64;
    for (var _i = 0; _i < 64; ++_i) BASE64_VALUES[BASE64_KEYS.charCodeAt(_i)] = _i;
    misc.BASE64_VALUES = BASE64_VALUES;
    misc.pushToMap = function(map, key, value, pushFront) {
      var exists = map[key];
      if (exists) if (Array.isArray(exists)) if (pushFront) {
        exists.push(exists[0]);
        exists[0] = value;
      } else exists.push(value); else map[key] = pushFront ? [ value, exists ] : [ exists, value ]; else map[key] = value;
    };
    misc.clampf = function(value, min_inclusive, max_inclusive) {
      if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
      }
      return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
    };
    misc.clamp01 = function(value) {
      return value < 0 ? 0 : value < 1 ? value : 1;
    };
    misc.lerp = function(a, b, r) {
      return a + (b - a) * r;
    };
    misc.degreesToRadians = function(angle) {
      return angle * cc.macro.RAD;
    };
    misc.radiansToDegrees = function(angle) {
      return angle * cc.macro.DEG;
    };
    cc.misc = module.exports = misc;
  }), {
    "../platform/CCSys": 164,
    "../platform/js": 175
  } ],
  234: [ (function(require, module, exports) {
    function MutableForwardIterator(array) {
      this.i = 0;
      this.array = array;
    }
    var proto = MutableForwardIterator.prototype;
    proto.remove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.removeAt(index);
    };
    proto.removeAt = function(i) {
      this.array.splice(i, 1);
      i <= this.i && --this.i;
    };
    proto.fastRemove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.fastRemoveAt(index);
    };
    proto.fastRemoveAt = function(i) {
      var array = this.array;
      array[i] = array[array.length - 1];
      --array.length;
      i <= this.i && --this.i;
    };
    proto.push = function(item) {
      this.array.push(item);
    };
    module.exports = MutableForwardIterator;
  }), {} ],
  235: [ (function(require, module, exports) {
    var Node = require("../CCNode");
    var EventType = Node.EventType;
    var DirtyFlag = Node._LocalDirtyFlag;
    var renderEngine = require("../renderer/render-engine");
    var RenderFlow = require("../renderer/render-flow");
    var math = renderEngine.math;
    var ONE_DEGREE = Math.PI / 180;
    var POSITION_ON = 1;
    var SCALE_ON = 2;
    var ROTATION_ON = 4;
    var _updateLocalMatrix2d = null;
    var _calculWorldMatrix2d = null;
    function _updateLocalMatrix3d() {
      if (this._localMatDirty) {
        var t = this._matrix;
        math.mat4.fromRTS(t, this._quat, this._position, this._scale);
        if (this._skewX || this._skewY) {
          var a = t.m00, b = t.m01, c = t.m04, d = t.m05;
          var skx = Math.tan(this._skewX * ONE_DEGREE);
          var sky = Math.tan(this._skewY * ONE_DEGREE);
          Infinity === skx && (skx = 99999999);
          Infinity === sky && (sky = 99999999);
          t.m00 = a + c * sky;
          t.m01 = b + d * sky;
          t.m04 = c + a * skx;
          t.m05 = d + b * skx;
        }
        this._localMatDirty = 0;
        this._worldMatDirty = true;
      }
    }
    function _calculWorldMatrix3d() {
      this._localMatDirty && this._updateLocalMatrix();
      if (this._parent) {
        var parentMat = this._parent._worldMatrix;
        math.mat4.mul(this._worldMatrix, parentMat, this._matrix);
      } else math.mat4.copy(this._worldMatrix, this._matrix);
      this._worldMatDirty = false;
    }
    function getPosition() {
      return new cc.Vec3(this._position);
    }
    function setPosition(newPosOrX, y, z) {
      var x = void 0;
      if (void 0 === y) {
        x = newPosOrX.x;
        y = newPosOrX.y;
        z = newPosOrX.z || 0;
      } else {
        x = newPosOrX;
        z = z || 0;
      }
      var pos = this._position;
      if (pos.x === x && pos.y === y && pos.z === z) return;
      var oldPosition;
      false;
      pos.x = x;
      pos.y = y;
      pos.z = z;
      this.setLocalDirty(DirtyFlag.POSITION);
      this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
      this._eventMask & POSITION_ON && this.emit(EventType.POSITION_CHANGED);
    }
    function getQuat() {
      return math.quat.clone(this._quat);
    }
    function setQuat(quat, y, z, w) {
      var x = void 0;
      if (void 0 === y) {
        x = quat.x;
        y = quat.y;
        z = quat.z;
        w = quat.w;
      }
      var old = this._quat;
      if (old.x !== x || old.y !== y || old.z !== z || old.w !== w) {
        old.x = x;
        old.y = y;
        old.z = z;
        old.w = w;
        this.setLocalDirty(DirtyFlag.ROTATION);
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
        this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
      }
    }
    function getScale() {
      return cc.v3(this._scale);
    }
    function setScale(x, y, z) {
      if (x && "number" !== typeof x) {
        y = x.y;
        z = x.z || 1;
        x = x.x;
      } else if (void 0 !== x && void 0 === y) {
        y = x;
        z = x;
      } else void 0 === z && (z = 1);
      if (this._scale.x !== x || this._scale.y !== y || this._scale.z !== z) {
        this._scale.x = x;
        this._scale.y = y;
        this._scale.z = z;
        this.setLocalDirty(DirtyFlag.SCALE);
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
        this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
      }
    }
    cc._polyfill3D = module.exports = {
      enabled: false,
      enable: function() {
        var proto = cc.Node.prototype;
        if (!_updateLocalMatrix2d) {
          _updateLocalMatrix2d = proto._updateLocalMatrix;
          _calculWorldMatrix2d = proto._calculWorldMatrix;
        }
        if (!this.enabled) {
          proto._updateLocalMatrix = _updateLocalMatrix3d;
          proto._calculWorldMatrix = _calculWorldMatrix3d;
          proto.getPosition = getPosition;
          proto.setPosition = setPosition;
          proto.getScale = getScale;
          proto.setScale = setScale;
          this.enabled = true;
        }
      },
      disable: function() {
        if (this.enabled) {
          cc.Node.prototype._updateLocalMatrix = _updateLocalMatrix2d;
          cc.Node.prototype._calculWorldMatrix = _calculWorldMatrix2d;
          this.enabled = false;
        }
      }
    };
  }), {
    "../CCNode": 30,
    "../renderer/render-engine": 197,
    "../renderer/render-flow": 198
  } ],
  236: [ (function(require, module, exports) {
    var math = require("../renderer").renderEngine.math;
    cc._PrefabInfo = cc.Class({
      name: "cc.PrefabInfo",
      properties: {
        root: null,
        asset: null,
        fileId: "",
        sync: false,
        _synced: {
          default: false,
          serializable: false
        }
      }
    });
    module.exports = {
      syncWithPrefab: function(node) {
        var _prefab = node._prefab;
        _prefab._synced = true;
        if (!_prefab.asset) {
          false;
          cc.errorID(3701, node.name);
          node._prefab = null;
          return;
        }
        var _objFlags = node._objFlags;
        var _parent = node._parent;
        var _id = node._id;
        var _name = node._name;
        var _active = node._active;
        var x = node._position.x;
        var y = node._position.y;
        var _quat = node._quat;
        var _localZOrder = node._localZOrder;
        var _globalZOrder = node._globalZOrder;
        cc.game._isCloning = true;
        var prefabRoot;
        true;
        _prefab.asset._doInstantiate(node);
        cc.game._isCloning = false;
        node._objFlags = _objFlags;
        node._parent = _parent;
        node._id = _id;
        node._prefab = _prefab;
        node._name = _name;
        node._active = _active;
        node._position.x = x;
        node._position.y = y;
        math.quat.copy(node._quat, _quat);
        node._localZOrder = _localZOrder;
        node._globalZOrder = _globalZOrder;
      }
    };
  }), {
    "../renderer": 196
  } ],
  237: [ (function(require, module, exports) {
    var macro = require("../../platform/CCMacro");
    var PerfCounter = require("./perf-counter");
    var _showFPS = false;
    var _fontSize = 15;
    var _atlas = null;
    var _stats = null;
    var _rootNode = null;
    var _label = null;
    function generateAtlas() {
      if (_atlas) return;
      var textureWidth = 256, textureHeight = 256;
      var canvas = document.createElement("canvas");
      canvas.style.width = canvas.width = textureWidth;
      canvas.style.height = canvas.height = textureHeight;
      var ctx = canvas.getContext("2d");
      ctx.font = _fontSize + "px Arial";
      ctx.textBaseline = "top";
      ctx.textAlign = "left";
      ctx.fillStyle = "#fff";
      var space = 2;
      var x = space;
      var y = space;
      var lineHeight = _fontSize;
      _atlas = new cc.LabelAtlas();
      _atlas._fntConfig = {
        atlasName: "profiler-arial",
        commonHeight: lineHeight,
        fontSize: _fontSize,
        kerningDict: {},
        fontDefDictionary: {}
      };
      _atlas._name = "profiler-arial";
      _atlas.fontSize = _fontSize;
      var dict = _atlas._fntConfig.fontDefDictionary;
      for (var i = 32; i <= 126; i++) {
        var char = String.fromCharCode(i);
        var width = ctx.measureText(char).width;
        if (x + width >= textureWidth) {
          x = space;
          y += lineHeight + space;
        }
        ctx.fillText(char, x, y);
        dict[i] = {
          xAdvance: width,
          xOffset: 0,
          yOffset: 0,
          rect: {
            x: x,
            y: y,
            width: width,
            height: lineHeight
          }
        };
        x += width + space;
      }
      var texture = new cc.Texture2D();
      texture.initWithElement(canvas);
      var spriteFrame = new cc.SpriteFrame();
      spriteFrame.setTexture(texture);
      _atlas.spriteFrame = spriteFrame;
    }
    function generateStats() {
      if (_stats) return;
      _stats = {
        frame: {
          desc: "Frame time (ms)",
          min: 0,
          max: 50,
          average: 500
        },
        fps: {
          desc: "Framerate (FPS)",
          below: 30,
          average: 500
        },
        draws: {
          desc: "Draw call"
        },
        logic: {
          desc: "Game Logic (ms)",
          min: 0,
          max: 50,
          average: 500,
          color: "#080"
        },
        render: {
          desc: "Renderer (ms)",
          min: 0,
          max: 50,
          average: 500,
          color: "#f90"
        },
        mode: {
          desc: cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WebGL" : "Canvas",
          min: 1
        }
      };
      var now = performance.now();
      for (var id in _stats) _stats[id]._counter = new PerfCounter(id, _stats[id], now);
    }
    function generateNode() {
      if (_rootNode && _rootNode.isValid) return;
      _rootNode = new cc.Node("PROFILER-NODE");
      _rootNode.x = _rootNode.y = 10;
      _rootNode.zIndex = macro.MAX_ZINDEX;
      cc.game.addPersistRootNode(_rootNode);
      var left = new cc.Node("LEFT-PANEL");
      left.anchorX = left.anchorY = 0;
      left.parent = _rootNode;
      var leftLabel = left.addComponent(cc.Label);
      leftLabel.font = _atlas;
      leftLabel.fontSize = _fontSize;
      leftLabel.lineHeight = _fontSize;
      var right = new cc.Node("RIGHT-PANEL");
      right.anchorX = 1;
      right.anchorY = 0;
      right.x = 200;
      right.parent = _rootNode;
      var rightLabel = right.addComponent(cc.Label);
      rightLabel.horizontalAlign = cc.Label.HorizontalAlign.RIGHT;
      rightLabel.font = _atlas;
      rightLabel.fontSize = _fontSize;
      rightLabel.lineHeight = _fontSize;
      _label = {
        left: leftLabel,
        right: rightLabel
      };
    }
    function beforeUpdate() {
      generateNode();
      var now = cc.director._lastUpdate;
      _stats["frame"]._counter.start(now);
      _stats["logic"]._counter.start(now);
    }
    function afterUpdate() {
      var now = performance.now();
      cc.director.isPaused() ? _stats["frame"]._counter.start(now) : _stats["logic"]._counter.end(now);
      _stats["render"]._counter.start(now);
    }
    function updateLabel(stat) {
      var length = 20;
      var desc = stat.desc;
      var value = stat._counter.human() + "";
      stat.label.string = stat.desc + "  " + stat._counter.human();
    }
    function afterDraw() {
      var now = performance.now();
      _stats["render"]._counter.end(now);
      _stats["draws"]._counter.value = cc.renderer.drawCalls;
      _stats["frame"]._counter.end(now);
      _stats["fps"]._counter.frame(now);
      var left = "";
      var right = "";
      for (var id in _stats) {
        var stat = _stats[id];
        stat._counter.sample(now);
        left += stat.desc + "\n";
        right += stat._counter.human() + "\n";
      }
      _label.left.string = left;
      _label.right.string = right;
    }
    cc.profiler = module.exports = {
      isShowingStats: function() {
        return _showFPS;
      },
      hideStats: function() {
        if (_showFPS) {
          _rootNode && (_rootNode.active = false);
          cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.off(cc.Director.EVENT_AFTER_UPDATE, afterUpdate);
          cc.director.off(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = false;
        }
      },
      showStats: function() {
        if (!_showFPS) {
          generateAtlas();
          generateStats();
          _rootNode && (_rootNode.active = true);
          cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.on(cc.Director.EVENT_AFTER_UPDATE, afterUpdate);
          cc.director.on(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = true;
        }
      }
    };
  }), {
    "../../platform/CCMacro": 160,
    "./perf-counter": 239
  } ],
  238: [ (function(require, module, exports) {
    class Counter {
      constructor(id, opts, now) {
        this._id = id;
        this._opts = opts || {};
        this._value = 0;
        this._total = 0;
        this._averageValue = 0;
        this._accumValue = 0;
        this._accumSamples = 0;
        this._accumStart = now;
      }
      _average(v, now) {
        if (this._opts.average) {
          this._accumValue += v;
          ++this._accumSamples;
          var t = now;
          if (t - this._accumStart >= this._opts.average) {
            this._averageValue = this._accumValue / this._accumSamples;
            this._accumValue = 0;
            this._accumStart = t;
            this._accumSamples = 0;
          }
        }
      }
      get value() {
        return this._value;
      }
      set value(v) {
        this._value = v;
      }
      sample(now) {
        this._average(this._value, now);
      }
      human() {
        var v = this._opts.average ? this._averageValue : this._value;
        return Math.round(100 * v) / 100;
      }
      alarm() {
        return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
      }
    }
    module.exports = Counter;
  }), {} ],
  239: [ (function(require, module, exports) {
    var Counter = require("./counter");
    class PerfCounter extends Counter {
      constructor(id, opts, now) {
        super(id, opts, now);
        this._time = now;
      }
      start(now) {
        this._time = now;
      }
      end(now) {
        this._value = now - this._time;
        this._average(this._value);
      }
      tick() {
        this.end();
        this.start();
      }
      frame(now) {
        var t = now;
        var e = t - this._time;
        this._total++;
        var avg = this._opts.average || 1e3;
        if (e > avg) {
          this._value = 1e3 * this._total / e;
          this._total = 0;
          this._time = t;
          this._average(this._value);
        }
      }
    }
    module.exports = PerfCounter;
  }), {
    "./counter": 238
  } ],
  240: [ (function(require, module, exports) {
    var HtmlTextParser = require("./html-text-parser");
    var CustomFontDescriptor = function() {
      this._status = "unloaded";
      this._observers = [];
      this._isLoadWithCSS = false;
    };
    CustomFontDescriptor.prototype.onLoaded = function() {
      this._status = "loaded";
      this._observers.forEach((function(item) {
        item && item();
      }));
    };
    CustomFontDescriptor.prototype.isLoaded = function() {
      return "loaded" === this._status;
    };
    CustomFontDescriptor.prototype.addHandler = function(callback) {
      -1 === this._observers.indexOf(callback) && this._observers.push(callback);
    };
    var CustomFontLoader = {
      _fontCache: {},
      _fontWidthCache: {},
      _canvasContext: null,
      _testString: "BESbswy",
      _allFontsLoaded: false,
      _intervalId: 0,
      loadTTF: function(url, callback) {
        var fontFamilyName = this._getFontFamily(url);
        var md5Pipe = cc.loader.md5Pipe;
        md5Pipe && (url = md5Pipe.transformURL(url));
        var useFontFace = cc.sys.browserType !== cc.sys.BROWSER_TYPE_BAIDU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_BAIDU_APP && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ;
        window.FontFace && useFontFace ? this._loadWithFontFace(fontFamilyName, url, callback) : this._loadWithCSS(fontFamilyName, url, callback);
        0 === this._intervalId && (this._intervalId = setInterval(this._checkFontLoaded.bind(this), 100));
      },
      _checkFontLoaded: function() {
        this._allFontsLoaded = true;
        for (var k in this._fontCache) {
          var fontDescriptor = this._fontCache[k];
          if (fontDescriptor.isLoaded() || !fontDescriptor._isLoadWithCSS) continue;
          var oldWidth = this._fontWidthCache[k];
          this._canvasContext.font = "40px " + k;
          var newWidth = this._canvasContext.measureText(this._testString).width;
          oldWidth !== newWidth ? fontDescriptor.onLoaded() : this._allFontsLoaded = false;
        }
        if (this._allFontsLoaded) {
          clearInterval(this._intervalId);
          this._intervalId = 0;
        }
      },
      _loadWithFontFace: function(fontFamilyName, url, callback) {
        var fontDescriptor = this._fontCache[fontFamilyName];
        if (fontDescriptor) fontDescriptor.isLoaded() || fontDescriptor.addHandler(callback); else {
          var fontFace = new FontFace(fontFamilyName, "url('" + url + "')");
          document.fonts.add(fontFace);
          fontDescriptor = new CustomFontDescriptor();
          fontDescriptor.addHandler(callback);
          this._fontCache[fontFamilyName] = fontDescriptor;
          fontFace.load();
          fontFace.loaded.then((function() {
            fontDescriptor.onLoaded();
          }));
        }
      },
      _loadWithCSS: function(fontFamilyName, url, callback) {
        var fontDescriptor = this._fontCache[fontFamilyName];
        if (fontDescriptor) fontDescriptor.isLoaded() || fontDescriptor.addHandler(callback); else {
          var doc = document;
          var fontStyle = document.createElement("style");
          fontStyle.type = "text/css";
          doc.body.appendChild(fontStyle);
          var fontStr = "";
          isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:";
          fontStr += "url('" + url + "');";
          fontStyle.textContent = fontStr + "}";
          var preloadDiv = document.createElement("div");
          var _divStyle = preloadDiv.style;
          _divStyle.fontFamily = fontFamilyName;
          preloadDiv.innerHTML = ".";
          _divStyle.position = "absolute";
          _divStyle.left = "-100px";
          _divStyle.top = "-100px";
          doc.body.appendChild(preloadDiv);
          fontDescriptor = new CustomFontDescriptor();
          fontDescriptor.addHandler(callback);
          this._fontCache[fontFamilyName] = fontDescriptor;
          fontDescriptor._isLoadWithCSS = true;
          if (!this._canvasContext) {
            var labelCanvas = document.createElement("canvas");
            labelCanvas.width = 100;
            labelCanvas.height = 100;
            this._canvasContext = labelCanvas.getContext("2d");
          }
          var fontDesc = "40px " + fontFamilyName;
          this._canvasContext.font = fontDesc;
          var width = this._canvasContext.measureText(this._testString).width;
          this._fontWidthCache[fontFamilyName] = width;
          var self = this;
          fontStyle.onload = function() {
            setTimeout((function() {
              if (!self._allFontsLoaded) {
                cc.logID(4004);
                fontDescriptor.onLoaded();
                cc.director.getScheduler().unschedule(this._checkFontLoaded, this);
              }
            }), 2e4);
          };
        }
      },
      _getFontFamily: function(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf(".ttf");
        if (-1 === ttfIndex) return fontHandle;
        var slashPos = fontHandle.lastIndexOf("/");
        var fontFamilyName;
        fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        return fontFamilyName;
      }
    };
    var TextUtils = {
      label_wordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430-\u044f\u0410-\u042f\u0401\u0451]+|\S)/,
      label_symbolRex: /^[!,.:;'}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/,
      label_lastWordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+|\S)$/,
      label_lastEnglish: /[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+$/,
      label_firstEnglish: /^[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]/,
      label_wrapinspection: true,
      isUnicodeCJK: function(ch) {
        var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
        var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
        var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
        return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
      },
      isUnicodeSpace: function(ch) {
        ch = ch.charCodeAt(0);
        return ch >= 9 && ch <= 13 || 32 === ch || 133 === ch || 160 === ch || 5760 === ch || ch >= 8192 && ch <= 8202 || 8232 === ch || 8233 === ch || 8239 === ch || 8287 === ch || 12288 === ch;
      },
      fragmentText: function(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];
        if (0 === stringToken.length || maxWidth < 0) {
          wrappedWords.push("");
          return wrappedWords;
        }
        var text = stringToken;
        while (allWidth > maxWidth && text.length > 1) {
          var fuzzyLen = text.length * (maxWidth / allWidth) | 0;
          var tmpText = text.substr(fuzzyLen);
          var width = allWidth - measureText(tmpText);
          var sLine = tmpText;
          var pushNum = 0;
          var checkWhile = 0;
          var checkCount = 10;
          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = text.substr(fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          checkWhile = 0;
          while (width <= maxWidth && checkWhile++ < checkCount) {
            if (tmpText) {
              var exec = this.label_wordRex.exec(tmpText);
              pushNum = exec ? exec[0].length : 1;
              sLine = tmpText;
            }
            fuzzyLen += pushNum;
            tmpText = text.substr(fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          fuzzyLen -= pushNum;
          if (0 === fuzzyLen) {
            fuzzyLen = 1;
            sLine = sLine.substr(1);
          }
          var sText = text.substr(0, fuzzyLen), result;
          if (this.label_wrapinspection && this.label_symbolRex.test(sLine || tmpText)) {
            result = this.label_lastWordRex.exec(sText);
            fuzzyLen -= result ? result[0].length : 0;
            0 === fuzzyLen && (fuzzyLen = 1);
            sLine = text.substr(fuzzyLen);
            sText = text.substr(0, fuzzyLen);
          }
          if (this.label_firstEnglish.test(sLine)) {
            result = this.label_lastEnglish.exec(sText);
            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = text.substr(fuzzyLen);
              sText = text.substr(0, fuzzyLen);
            }
          }
          if (0 === wrappedWords.length) wrappedWords.push(sText); else {
            sText = sText.trim();
            sText.length > 0 && wrappedWords.push(sText);
          }
          text = sLine || tmpText;
          allWidth = measureText(text);
        }
        if (0 === wrappedWords.length) wrappedWords.push(text); else {
          text = text.trim();
          text.length > 0 && wrappedWords.push(text);
        }
        return wrappedWords;
      }
    };
    module.exports = {
      HtmlTextParser: HtmlTextParser,
      TextUtils: TextUtils,
      CustomFontLoader: CustomFontLoader
    };
  }), {
    "./html-text-parser": 230
  } ],
  241: [ (function(require, module, exports) {
    var Texture2D = require("../assets/CCTexture2D");
    var textureUtil = {
      loadImage: function(url, cb, target) {
        cc.assertID(url, 3103);
        var tex = cc.loader.getRes(url);
        if (tex) {
          if (tex.loaded) {
            cb && cb.call(target, tex);
            return tex;
          }
          tex.once("load", (function() {
            cb && cb.call(target, tex);
          }), target);
          return tex;
        }
        tex = new Texture2D();
        tex.url = url;
        cc.loader.load({
          url: url,
          texture: tex
        }, (function(err, texture) {
          if (err) return cb && cb.call(target, err || new Error("Unknown error"));
          texture.handleLoadedTexture();
          cb && cb.call(target, texture);
        }));
        return tex;
      },
      cacheImage: function(url, image) {
        if (url && image) {
          var tex = new Texture2D();
          tex.initWithElement(image);
          var item = {
            id: url,
            url: url,
            error: null,
            content: tex,
            complete: false
          };
          cc.loader.flowOut(item);
          return tex;
        }
      },
      postLoadTexture: function(texture, callback) {
        if (texture.loaded) {
          callback && callback();
          return;
        }
        if (!texture.url) {
          callback && callback();
          return;
        }
        cc.loader.load({
          url: texture.url,
          skips: [ "Loader" ]
        }, (function(err, image) {
          if (image) {
            if (true, image instanceof cc.Texture2D) return cc.error("internal error: loader handle pipe must be skipped");
            texture.loaded || (texture._nativeAsset = image);
          }
          callback && callback(err);
        }));
      }
    };
    cc.textureUtil = module.exports = textureUtil;
  }), {
    "../assets/CCTexture2D": 49
  } ],
  242: [ (function(require, module, exports) {
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var Color = (function() {
      function Color(r, g, b, a) {
        if ("object" === typeof r) {
          g = r.g;
          b = r.b;
          a = r.a;
          r = r.r;
        }
        r = r || 0;
        g = g || 0;
        b = b || 0;
        a = "number" === typeof a ? a : 255;
        this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
      }
      js.extend(Color, ValueType);
      require("../platform/CCClass").fastDefine("cc.Color", Color, {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      });
      var DefaultColors = {
        WHITE: [ 255, 255, 255, 255 ],
        BLACK: [ 0, 0, 0, 255 ],
        TRANSPARENT: [ 0, 0, 0, 0 ],
        GRAY: [ 127.5, 127.5, 127.5 ],
        RED: [ 255, 0, 0 ],
        GREEN: [ 0, 255, 0 ],
        BLUE: [ 0, 0, 255 ],
        YELLOW: [ 255, 235, 4 ],
        ORANGE: [ 255, 127, 0 ],
        CYAN: [ 0, 255, 255 ],
        MAGENTA: [ 255, 0, 255 ]
      };
      for (var colorName in DefaultColors) js.get(Color, colorName, (function(rgba) {
        return function() {
          return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);
        };
      })(DefaultColors[colorName]));
      var proto = Color.prototype;
      proto.clone = function() {
        var ret = new Color();
        ret._val = this._val;
        return ret;
      };
      proto.equals = function(other) {
        return other && this._val === other._val;
      };
      proto.lerp = function(to, ratio, out) {
        out = out || new Color();
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var a = this.a;
        out.r = r + (to.r - r) * ratio;
        out.g = g + (to.g - g) * ratio;
        out.b = b + (to.b - b) * ratio;
        out.a = a + (to.a - a) * ratio;
        return out;
      };
      proto.toString = function() {
        return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
      };
      proto.getR = function() {
        return 255 & this._val;
      };
      proto.setR = function(red) {
        this._val = (4294967040 & this._val | ~~red) >>> 0;
        return this;
      };
      proto.getG = function() {
        return (65280 & this._val) >> 8;
      };
      proto.setG = function(green) {
        this._val = (4294902015 & this._val | ~~green << 8) >>> 0;
        return this;
      };
      proto.getB = function() {
        return (16711680 & this._val) >> 16;
      };
      proto.setB = function(blue) {
        this._val = (4278255615 & this._val | ~~blue << 16) >>> 0;
        return this;
      };
      proto.getA = function() {
        return (4278190080 & this._val) >>> 24;
      };
      proto.setA = function(alpha) {
        this._val = (16777215 & this._val | ~~alpha << 24 >>> 0) >>> 0;
        return this;
      };
      js.getset(proto, "r", proto.getR, proto.setR, true);
      js.getset(proto, "g", proto.getG, proto.setG, true);
      js.getset(proto, "b", proto.getB, proto.setB, true);
      js.getset(proto, "a", proto.getA, proto.setA, true);
      proto.toCSS = function(opt) {
        return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a / 255).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
      };
      proto.fromHEX = function(hexString) {
        hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString;
        var r = parseInt(hexString.substr(0, 2), 16) || 0;
        var g = parseInt(hexString.substr(2, 2), 16) || 0;
        var b = parseInt(hexString.substr(4, 2), 16) || 0;
        var a = parseInt(hexString.substr(6, 2), 16) || 255;
        this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
        return this;
      };
      proto.toHEX = function(fmt) {
        var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ];
        var i = -1;
        if ("#rgb" === fmt) for (i = 0; i < hex.length; ++i) hex[i].length > 1 && (hex[i] = hex[i][0]); else if ("#rrggbb" === fmt) for (i = 0; i < hex.length; ++i) 1 === hex[i].length && (hex[i] = "0" + hex[i]);
        return hex.join("");
      };
      proto.toRGBValue = function() {
        return 16777215 & this._val;
      };
      proto.fromHSV = function(h, s, v) {
        var r, g, b;
        if (0 === s) r = g = b = v; else if (0 === v) r = g = b = 0; else {
          1 === h && (h = 0);
          h *= 6;
          s = s;
          v = v;
          var i = Math.floor(h);
          var f = h - i;
          var p = v * (1 - s);
          var q = v * (1 - s * f);
          var t = v * (1 - s * (1 - f));
          switch (i) {
           case 0:
            r = v;
            g = t;
            b = p;
            break;

           case 1:
            r = q;
            g = v;
            b = p;
            break;

           case 2:
            r = p;
            g = v;
            b = t;
            break;

           case 3:
            r = p;
            g = q;
            b = v;
            break;

           case 4:
            r = t;
            g = p;
            b = v;
            break;

           case 5:
            r = v;
            g = p;
            b = q;
          }
        }
        r *= 255;
        g *= 255;
        b *= 255;
        this._val = (r << 24 >>> 0) + (g << 16) + (b << 8) + this.a;
        return this;
      };
      proto.toHSV = function() {
        var r = this.r / 255;
        var g = this.g / 255;
        var b = this.b / 255;
        var hsv = {
          h: 0,
          s: 0,
          v: 0
        };
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var delta = 0;
        hsv.v = max;
        hsv.s = max ? (max - min) / max : 0;
        if (hsv.s) {
          delta = max - min;
          hsv.h = r === max ? (g - b) / delta : g === max ? 2 + (b - r) / delta : 4 + (r - g) / delta;
          hsv.h /= 6;
          hsv.h < 0 && (hsv.h += 1);
        } else hsv.h = 0;
        return hsv;
      };
      proto.fromColor = function(color) {
        if (color._val) this._val = color._val; else {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          this.a = color.a;
        }
      };
      return Color;
    })();
    cc.Color = Color;
    cc.color = function color(r, g, b, a) {
      if ("string" === typeof r) {
        var result = new cc.Color();
        return result.fromHEX(r);
      }
      if ("object" === typeof r) return new cc.Color(r.r, r.g, r.b, r.a);
      return new cc.Color(r, g, b, a);
    };
    module.exports = cc.Color;
  }), {
    "../platform/CCClass": 155,
    "../platform/js": 175,
    "./value-type": 247
  } ],
  243: [ (function(require, module, exports) {
    require("./value-type");
    require("./vec2");
    require("./vec3");
    require("./quat");
    require("./size");
    require("./rect");
    require("./color");
    cc.vmath = require("../renderer/render-engine").math;
  }), {
    "../renderer/render-engine": 197,
    "./color": 242,
    "./quat": 244,
    "./rect": 245,
    "./size": 246,
    "./value-type": 247,
    "./vec2": 248,
    "./vec3": 249
  } ],
  244: [ (function(require, module, exports) {
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    function Quat(x, y, z, w) {
      if (x && "object" === typeof x) {
        z = x.z;
        y = x.y;
        x = x.x;
        w = x.w;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.w = w || 1;
    }
    js.extend(Quat, ValueType);
    CCClass.fastDefine("cc.Quat", Quat, {
      x: 0,
      y: 0,
      z: 0,
      w: 1
    });
    var proto = Quat.prototype;
    proto.clone = function() {
      return new Quat(this.x, this.y, this.z, this.w);
    };
    proto.set = function(newValue) {
      this.x = newValue.x;
      this.y = newValue.y;
      this.z = newValue.z;
      this.w = newValue.w;
      return this;
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
    };
    proto.getRoll = function() {
      var sinr = 2 * (this.w * this.x + this.y * this.z);
      var cosr = 1 - 2 * (this.x * this.x + this.y * this.y);
      return 180 * Math.atan2(sinr, cosr) / Math.PI;
    };
    proto.getPitch = function() {
      var sinp = 2 * (this.w * this.y - this.z * this.x);
      var pitch = sinp > 1 ? 1 : sinp;
      pitch = sinp < -1 ? -1 : sinp;
      pitch = 180 * Math.asin(pitch) / Math.PI;
      return pitch;
    };
    proto.getYaw = function() {
      var siny = 2 * (this.w * this.z + this.x * this.y);
      var cosy = 1 - 2 * (this.y * this.y + this.z * this.z);
      return 180 * Math.atan2(siny, cosy) / Math.PI;
    };
    cc.quat = function quat(x, y, z, w) {
      return new Quat(x, y, z, w);
    };
    module.exports = cc.Quat = Quat;
  }), {
    "../platform/CCClass": 155,
    "../platform/js": 175,
    "./value-type": 247
  } ],
  245: [ (function(require, module, exports) {
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    function Rect(x, y, w, h) {
      if (x && "object" === typeof x) {
        y = x.y;
        w = x.width;
        h = x.height;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.width = w || 0;
      this.height = h || 0;
    }
    js.extend(Rect, ValueType);
    require("../platform/CCClass").fastDefine("cc.Rect", Rect, {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    Rect.fromMinMax = function(v1, v2) {
      var min_x = Math.min(v1.x, v2.x);
      var min_y = Math.min(v1.y, v2.y);
      var max_x = Math.max(v1.x, v2.x);
      var max_y = Math.max(v1.y, v2.y);
      return new Rect(min_x, min_y, max_x - min_x, max_y - min_y);
    };
    var proto = Rect.prototype;
    proto.clone = function() {
      return new Rect(this.x, this.y, this.width, this.height);
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Rect();
      var x = this.x;
      var y = this.y;
      var width = this.width;
      var height = this.height;
      out.x = x + (to.x - x) * ratio;
      out.y = y + (to.y - y) * ratio;
      out.width = width + (to.width - width) * ratio;
      out.height = height + (to.height - height) * ratio;
      return out;
    };
    proto.intersects = function(rect) {
      var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = rect.x + rect.width, maxby = rect.y + rect.height;
      return !(maxax < rect.x || maxbx < this.x || maxay < rect.y || maxby < this.y);
    };
    proto.intersection = function(out, rectB) {
      var axMin = this.x, ayMin = this.y, axMax = this.x + this.width, ayMax = this.y + this.height;
      var bxMin = rectB.x, byMin = rectB.y, bxMax = rectB.x + rectB.width, byMax = rectB.y + rectB.height;
      out.x = Math.max(axMin, bxMin);
      out.y = Math.max(ayMin, byMin);
      out.width = Math.min(axMax, bxMax) - out.x;
      out.height = Math.min(ayMax, byMax) - out.y;
      return out;
    };
    proto.contains = function(point) {
      return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
    };
    proto.containsRect = function(rect) {
      return this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height;
    };
    proto.union = function(out, rectB) {
      var ax = this.x, ay = this.y, aw = this.width, ah = this.height;
      var bx = rectB.x, by = rectB.y, bw = rectB.width, bh = rectB.height;
      out.x = Math.min(ax, bx);
      out.y = Math.min(ay, by);
      out.width = Math.max(ax + aw, bx + bw) - out.x;
      out.height = Math.max(ay + ah, by + bh) - out.y;
      return out;
    };
    proto.transformMat4 = function(out, mat) {
      var ol = this.x;
      var ob = this.y;
      var or = ol + this.width;
      var ot = ob + this.height;
      var lbx = mat.m00 * ol + mat.m04 * ob + mat.m12;
      var lby = mat.m01 * ol + mat.m05 * ob + mat.m13;
      var rbx = mat.m00 * or + mat.m04 * ob + mat.m12;
      var rby = mat.m01 * or + mat.m05 * ob + mat.m13;
      var ltx = mat.m00 * ol + mat.m04 * ot + mat.m12;
      var lty = mat.m01 * ol + mat.m05 * ot + mat.m13;
      var rtx = mat.m00 * or + mat.m04 * ot + mat.m12;
      var rty = mat.m01 * or + mat.m05 * ot + mat.m13;
      var minX = Math.min(lbx, rbx, ltx, rtx);
      var maxX = Math.max(lbx, rbx, ltx, rtx);
      var minY = Math.min(lby, rby, lty, rty);
      var maxY = Math.max(lby, rby, lty, rty);
      out.x = minX;
      out.y = minY;
      out.width = maxX - minX;
      out.height = maxY - minY;
      return out;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
    };
    js.getset(proto, "xMin", (function() {
      return this.x;
    }), (function(value) {
      this.width += this.x - value;
      this.x = value;
    }));
    js.getset(proto, "yMin", (function() {
      return this.y;
    }), (function(value) {
      this.height += this.y - value;
      this.y = value;
    }));
    js.getset(proto, "xMax", (function() {
      return this.x + this.width;
    }), (function(value) {
      this.width = value - this.x;
    }));
    js.getset(proto, "yMax", (function() {
      return this.y + this.height;
    }), (function(value) {
      this.height = value - this.y;
    }));
    js.getset(proto, "center", (function() {
      return new cc.Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
    }), (function(value) {
      this.x = value.x - .5 * this.width;
      this.y = value.y - .5 * this.height;
    }));
    js.getset(proto, "origin", (function() {
      return new cc.Vec2(this.x, this.y);
    }), (function(value) {
      this.x = value.x;
      this.y = value.y;
    }));
    js.getset(proto, "size", (function() {
      return new cc.Size(this.width, this.height);
    }), (function(value) {
      this.width = value.width;
      this.height = value.height;
    }));
    cc.Rect = Rect;
    cc.rect = function rect(x, y, w, h) {
      return new Rect(x, y, w, h);
    };
    module.exports = cc.Rect;
  }), {
    "../platform/CCClass": 155,
    "../platform/js": 175,
    "./value-type": 247
  } ],
  246: [ (function(require, module, exports) {
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    function Size(width, height) {
      if (width && "object" === typeof width) {
        height = width.height;
        width = width.width;
      }
      this.width = width || 0;
      this.height = height || 0;
    }
    js.extend(Size, ValueType);
    require("../platform/CCClass").fastDefine("cc.Size", Size, {
      width: 0,
      height: 0
    });
    js.get(Size, "ZERO", (function() {
      return new Size(0, 0);
    }));
    var proto = Size.prototype;
    proto.clone = function() {
      return new Size(this.width, this.height);
    };
    proto.equals = function(other) {
      return other && this.width === other.width && this.height === other.height;
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Size();
      var width = this.width;
      var height = this.height;
      out.width = width + (to.width - width) * ratio;
      out.height = height + (to.height - height) * ratio;
      return out;
    };
    proto.toString = function() {
      return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
    };
    cc.size = function(w, h) {
      return new Size(w, h);
    };
    cc.Size = module.exports = Size;
  }), {
    "../platform/CCClass": 155,
    "../platform/js": 175,
    "./value-type": 247
  } ],
  247: [ (function(require, module, exports) {
    var js = require("../platform/js");
    function ValueType() {}
    js.setClassName("cc.ValueType", ValueType);
    var proto = ValueType.prototype;
    false;
    proto.toString = function() {
      return "" + {};
    };
    cc.ValueType = module.exports = ValueType;
  }), {
    "../platform/js": 175
  } ],
  248: [ (function(require, module, exports) {
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    var misc = require("../utils/misc");
    function Vec2(x, y) {
      if (x && "object" === typeof x) {
        y = x.y;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
    }
    js.extend(Vec2, ValueType);
    CCClass.fastDefine("cc.Vec2", Vec2, {
      x: 0,
      y: 0
    });
    var proto = Vec2.prototype;
    proto.clone = function() {
      return new Vec2(this.x, this.y);
    };
    proto.set = function(newValue) {
      this.x = newValue.x;
      this.y = newValue.y;
      return this;
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y;
    };
    proto.fuzzyEquals = function(other, variance) {
      if (this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance) return true;
      return false;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")";
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Vec2();
      var x = this.x;
      var y = this.y;
      out.x = x + (to.x - x) * ratio;
      out.y = y + (to.y - y) * ratio;
      return out;
    };
    proto.clampf = function(min_inclusive, max_inclusive) {
      this.x = misc.clampf(this.x, min_inclusive.x, max_inclusive.x);
      this.y = misc.clampf(this.y, min_inclusive.y, max_inclusive.y);
      return this;
    };
    proto.addSelf = function(vector) {
      this.x += vector.x;
      this.y += vector.y;
      return this;
    };
    proto.add = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x + vector.x;
      out.y = this.y + vector.y;
      return out;
    };
    proto.subSelf = function(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
      return this;
    };
    proto.sub = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x - vector.x;
      out.y = this.y - vector.y;
      return out;
    };
    proto.mulSelf = function(num) {
      this.x *= num;
      this.y *= num;
      return this;
    };
    proto.mul = function(num, out) {
      out = out || new Vec2();
      out.x = this.x * num;
      out.y = this.y * num;
      return out;
    };
    proto.scaleSelf = function(vector) {
      this.x *= vector.x;
      this.y *= vector.y;
      return this;
    };
    proto.scale = function(vector, out) {
      out = out || new Vec2();
      out.x = this.x * vector.x;
      out.y = this.y * vector.y;
      return out;
    };
    proto.divSelf = function(num) {
      this.x /= num;
      this.y /= num;
      return this;
    };
    proto.div = function(num, out) {
      out = out || new Vec2();
      out.x = this.x / num;
      out.y = this.y / num;
      return out;
    };
    proto.negSelf = function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    };
    proto.neg = function(out) {
      out = out || new Vec2();
      out.x = -this.x;
      out.y = -this.y;
      return out;
    };
    proto.dot = function(vector) {
      return this.x * vector.x + this.y * vector.y;
    };
    proto.cross = function(vector) {
      return this.x * vector.y - this.y * vector.x;
    };
    proto.mag = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    };
    proto.magSqr = function() {
      return this.x * this.x + this.y * this.y;
    };
    proto.normalizeSelf = function() {
      var magSqr = this.x * this.x + this.y * this.y;
      if (1 === magSqr) return this;
      if (0 === magSqr) {
        console.warn("Can't normalize zero vector");
        return this;
      }
      var invsqrt = 1 / Math.sqrt(magSqr);
      this.x *= invsqrt;
      this.y *= invsqrt;
      return this;
    };
    proto.normalize = function(out) {
      out = out || new Vec2();
      out.x = this.x;
      out.y = this.y;
      out.normalizeSelf();
      return out;
    };
    proto.angle = function(vector) {
      var magSqr1 = this.magSqr();
      var magSqr2 = vector.magSqr();
      if (0 === magSqr1 || 0 === magSqr2) {
        console.warn("Can't get angle between zero vector");
        return 0;
      }
      var dot = this.dot(vector);
      var theta = dot / Math.sqrt(magSqr1 * magSqr2);
      theta = misc.clampf(theta, -1, 1);
      return Math.acos(theta);
    };
    proto.signAngle = function(vector) {
      return Math.atan2(this.y, this.x) - Math.atan2(vector.y, vector.x);
    };
    proto.rotate = function(radians, out) {
      out = out || new Vec2();
      out.x = this.x;
      out.y = this.y;
      return out.rotateSelf(radians);
    };
    proto.rotateSelf = function(radians) {
      var sin = Math.sin(radians);
      var cos = Math.cos(radians);
      var x = this.x;
      this.x = cos * x - sin * this.y;
      this.y = sin * x + cos * this.y;
      return this;
    };
    proto.project = function(vector) {
      return vector.mul(this.dot(vector) / vector.dot(vector));
    };
    js.get(Vec2, "ONE", (function() {
      return new Vec2(1, 1);
    }));
    js.get(Vec2, "ZERO", (function() {
      return new Vec2(0, 0);
    }));
    js.get(Vec2, "UP", (function() {
      return new Vec2(0, 1);
    }));
    js.get(Vec2, "RIGHT", (function() {
      return new Vec2(1, 0);
    }));
    cc.Vec2 = Vec2;
    cc.v2 = function v2(x, y) {
      return new Vec2(x, y);
    };
    cc.p = cc.v2;
    module.exports = cc.Vec2;
  }), {
    "../platform/CCClass": 155,
    "../platform/js": 175,
    "../utils/misc": 233,
    "./value-type": 247
  } ],
  249: [ (function(require, module, exports) {
    var ValueType = require("./value-type");
    var js = require("../platform/js");
    var CCClass = require("../platform/CCClass");
    var math = require("../renderer/render-engine").math;
    var misc = require("../utils/misc");
    function Vec3(x, y, z) {
      if (x && "object" === typeof x) {
        z = x.z;
        y = x.y;
        x = x.x;
      }
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
    }
    js.extend(Vec3, ValueType);
    CCClass.fastDefine("cc.Vec3", Vec3, {
      x: 0,
      y: 0,
      z: 0
    });
    var proto = Vec3.prototype;
    proto.clone = function() {
      return new Vec3(this.x, this.y, this.z);
    };
    proto.set = function(newValue) {
      this.x = newValue.x;
      this.y = newValue.y;
      this.z = newValue.z;
      return this;
    };
    proto.equals = function(other) {
      return other && this.x === other.x && this.y === other.y && this.z === other.z;
    };
    proto.fuzzyEquals = function(other, variance) {
      if (this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance && this.z - variance <= other.z && other.z <= this.z + variance) return true;
      return false;
    };
    proto.toString = function() {
      return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ")";
    };
    proto.lerp = function(to, ratio, out) {
      out = out || new Vec3();
      math.vec3.lerp(out, this, to, ratio);
      return out;
    };
    proto.clampf = function(min_inclusive, max_inclusive) {
      this.x = misc.clampf(this.x, min_inclusive.x, max_inclusive.x);
      this.y = misc.clampf(this.y, min_inclusive.y, max_inclusive.y);
      this.z = misc.clampf(this.z, min_inclusive.z, max_inclusive.z);
      return this;
    };
    proto.addSelf = function(vector) {
      this.x += vector.x;
      this.y += vector.y;
      this.z += vector.z;
      return this;
    };
    proto.add = function(vector, out) {
      out = out || new Vec3();
      out.x = this.x + vector.x;
      out.y = this.y + vector.y;
      out.z = this.z + vector.z;
      return out;
    };
    proto.subSelf = function(vector) {
      this.x -= vector.x;
      this.y -= vector.y;
      this.z -= vector.z;
      return this;
    };
    proto.sub = function(vector, out) {
      out = out || new Vec3();
      out.x = this.x - vector.x;
      out.y = this.y - vector.y;
      out.z = this.z - vector.z;
      return out;
    };
    proto.mulSelf = function(num) {
      this.x *= num;
      this.y *= num;
      this.z *= num;
      return this;
    };
    proto.mul = function(num, out) {
      out = out || new Vec3();
      out.x = this.x * num;
      out.y = this.y * num;
      out.z = this.z * num;
      return out;
    };
    proto.scaleSelf = function(vector) {
      this.x *= vector.x;
      this.y *= vector.y;
      this.z *= vector.z;
      return this;
    };
    proto.scale = function(vector, out) {
      out = out || new Vec3();
      out.x = this.x * vector.x;
      out.y = this.y * vector.y;
      out.z = this.z * vector.z;
      return out;
    };
    proto.divSelf = function(num) {
      this.x /= num;
      this.y /= num;
      this.z /= num;
      return this;
    };
    proto.div = function(num, out) {
      out = out || new Vec3();
      out.x = this.x / num;
      out.y = this.y / num;
      out.z = this.z / num;
      return out;
    };
    proto.negSelf = function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    };
    proto.neg = function(out) {
      out = out || new Vec3();
      out.x = -this.x;
      out.y = -this.y;
      out.z = -this.z;
      return out;
    };
    proto.dot = function(vector) {
      return this.x * vector.x + this.y * vector.y + this.z * vector.z;
    };
    proto.cross = function(vector, out) {
      out = out || new Vec3();
      math.vec3.cross(out, this, vector);
      return out;
    };
    proto.mag = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };
    proto.magSqr = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };
    proto.normalizeSelf = function() {
      math.vec3.normalize(this, this);
      return this;
    };
    proto.normalize = function(out) {
      out = out || new Vec3();
      math.vec3.normalize(out, this);
      return out;
    };
    cc.v3 = function v3(x, y, z) {
      return new Vec3(x, y, z);
    };
    module.exports = cc.Vec3 = Vec3;
  }), {
    "../platform/CCClass": 155,
    "../platform/js": 175,
    "../renderer/render-engine": 197,
    "../utils/misc": 233,
    "./value-type": 247
  } ],
  250: [ (function(require, module, exports) {
    var js = cc.js;
    var deprecateEnum;
    var markAsRemoved;
    var markAsRemovedInObject;
    var provideClearError;
    var markFunctionWarning;
    var ERR;
    false;
  }), {} ],
  251: [ (function(require, module, exports) {
    require("./core/CCGame");
    require("./actions");
  }), {
    "./actions": 10,
    "./core/CCGame": 29
  } ],
  252: [ (function(require, module, exports) {
    var zlib = require("../compression/zlib.min");
    var PNGReader = function(data) {
      var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, ccshort, text, _i, _j, _ref;
      this.data = data;
      this.pos = 8;
      this.palette = [];
      this.imgData = [];
      this.transparency = {};
      this.animation = null;
      this.text = {};
      frame = null;
      while (true) {
        chunkSize = this.readUInt32();
        section = function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i < 4; i = ++_i) _results.push(String.fromCharCode(this.data[this.pos++]));
          return _results;
        }.call(this).join("");
        switch (section) {
         case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;

         case "acTL":
          this.animation = {
            numFrames: this.readUInt32(),
            numPlays: this.readUInt32() || Infinity,
            frames: []
          };
          break;

         case "PLTE":
          this.palette = this.read(chunkSize);
          break;

         case "fcTL":
          frame && this.animation.frames.push(frame);
          this.pos += 4;
          frame = {
            width: this.readUInt32(),
            height: this.readUInt32(),
            xOffset: this.readUInt32(),
            yOffset: this.readUInt32()
          };
          delayNum = this.readUInt16();
          delayDen = this.readUInt16() || 100;
          frame.delay = 1e3 * delayNum / delayDen;
          frame.disposeOp = this.data[this.pos++];
          frame.blendOp = this.data[this.pos++];
          frame.data = [];
          break;

         case "IDAT":
         case "fdAT":
          if ("fdAT" === section) {
            this.pos += 4;
            chunkSize -= 4;
          }
          data = (null != frame ? frame.data : void 0) || this.imgData;
          for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) data.push(this.data[this.pos++]);
          break;

         case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
           case 3:
            this.transparency.indexed = this.read(chunkSize);
            ccshort = 255 - this.transparency.indexed.length;
            if (ccshort > 0) for (i = _j = 0; 0 <= ccshort ? _j < ccshort : _j > ccshort; i = 0 <= ccshort ? ++_j : --_j) this.transparency.indexed.push(255);
            break;

           case 0:
            this.transparency.grayscale = this.read(chunkSize)[0];
            break;

           case 2:
            this.transparency.rgb = this.read(chunkSize);
          }
          break;

         case "tEXt":
          text = this.read(chunkSize);
          index = text.indexOf(0);
          key = String.fromCharCode.apply(String, text.slice(0, index));
          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
          break;

         case "IEND":
          frame && this.animation.frames.push(frame);
          this.colors = function() {
            switch (this.colorType) {
             case 0:
             case 3:
             case 4:
              return 1;

             case 2:
             case 6:
              return 3;
            }
          }.call(this);
          this.hasAlphaChannel = 4 === (_ref = this.colorType) || 6 === _ref;
          colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          this.colorSpace = function() {
            switch (this.colors) {
             case 1:
              return "DeviceGray";

             case 3:
              return "DeviceRGB";
            }
          }.call(this);
          Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
          return;

         default:
          this.pos += chunkSize;
        }
        this.pos += 4;
        if (this.pos > this.data.length) throw new Error(cc._getError(6017));
      }
    };
    PNGReader.prototype = {
      constructor: PNGReader,
      read: function(bytes) {
        var i, _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) _results.push(this.data[this.pos++]);
        return _results;
      },
      readUInt32: function() {
        var b1, b2, b3, b4;
        b1 = this.data[this.pos++] << 24;
        b2 = this.data[this.pos++] << 16;
        b3 = this.data[this.pos++] << 8;
        b4 = this.data[this.pos++];
        return b1 | b2 | b3 | b4;
      },
      readUInt16: function() {
        var b1, b2;
        b1 = this.data[this.pos++] << 8;
        b2 = this.data[this.pos++];
        return b1 | b2;
      },
      decodePixels: function(data) {
        var ccbyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
        null == data && (data = this.imgData);
        if (0 === data.length) return new Uint8Array(0);
        var inflate = new zlib.Inflate(data, {
          index: 0,
          verify: false
        });
        data = inflate.decompress();
        pixelBytes = this.pixelBitlength / 8;
        scanlineLength = pixelBytes * this.width;
        pixels = new Uint8Array(scanlineLength * this.height);
        length = data.length;
        row = 0;
        pos = 0;
        c = 0;
        while (pos < length) {
          switch (data[pos++]) {
           case 0:
            for (i = _i = 0; _i < scanlineLength; i = _i += 1) pixels[c++] = data[pos++];
            break;

           case 1:
            for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
              ccbyte = data[pos++];
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              pixels[c++] = (ccbyte + left) % 256;
            }
            break;

           case 2:
            for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
              ccbyte = data[pos++];
              col = (i - i % pixelBytes) / pixelBytes;
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
              pixels[c++] = (upper + ccbyte) % 256;
            }
            break;

           case 3:
            for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
              ccbyte = data[pos++];
              col = (i - i % pixelBytes) / pixelBytes;
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
              pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256;
            }
            break;

           case 4:
            for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
              ccbyte = data[pos++];
              col = (i - i % pixelBytes) / pixelBytes;
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              if (0 === row) upper = upperLeft = 0; else {
                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
              }
              p = left + upper - upperLeft;
              pa = Math.abs(p - left);
              pb = Math.abs(p - upper);
              pc = Math.abs(p - upperLeft);
              paeth = pa <= pb && pa <= pc ? left : pb <= pc ? upper : upperLeft;
              pixels[c++] = (ccbyte + paeth) % 256;
            }
            break;

           default:
            throw new Error(cc._getError(6018, data[pos - 1]));
          }
          row++;
        }
        return pixels;
      },
      copyToImageData: function(imageData, pixels) {
        var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
        colors = this.colors;
        palette = null;
        alpha = this.hasAlphaChannel;
        if (this.palette.length) {
          palette = null != (_ref = this._decodedPalette) ? _ref : this._decodedPalette = this.decodePalette();
          colors = 4;
          alpha = true;
        }
        data = imageData.data || imageData;
        length = data.length;
        input = palette || pixels;
        i = j = 0;
        if (1 === colors) while (i < length) {
          k = palette ? 4 * pixels[i / 4] : j;
          v = input[k++];
          data[i++] = v;
          data[i++] = v;
          data[i++] = v;
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        } else while (i < length) {
          k = palette ? 4 * pixels[i / 4] : j;
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        }
      },
      decodePalette: function() {
        var c, i, palette, pos, ret, transparency, _i, _ref, _ref1;
        palette = this.palette;
        transparency = this.transparency.indexed || [];
        ret = new Uint8Array((transparency.length || 0) + palette.length);
        pos = 0;
        c = 0;
        for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
          ret[pos++] = palette[i];
          ret[pos++] = palette[i + 1];
          ret[pos++] = palette[i + 2];
          ret[pos++] = null != (_ref1 = transparency[c++]) ? _ref1 : 255;
        }
        return ret;
      },
      render: function(canvas) {
        var ctx, data;
        canvas.width = this.width;
        canvas.height = this.height;
        ctx = canvas.getContext("2d");
        data = ctx.createImageData(this.width, this.height);
        this.copyToImageData(data, this.decodePixels());
        return ctx.putImageData(data, 0, 0);
      }
    };
    module.exports = PNGReader;
  }), {
    "../compression/zlib.min": 27
  } ],
  253: [ (function(require, module, exports) {
    var Asset = require("../core/assets/CCAsset");
    var Texture2D = require("../core/assets/CCTexture2D");
    var ParticleAsset = cc.Class({
      name: "cc.ParticleAsset",
      extends: Asset,
      properties: {
        texture: {
          default: null,
          type: Texture2D
        }
      }
    });
    cc.ParticleAsset = module.exports = ParticleAsset;
  }), {
    "../core/assets/CCAsset": 34,
    "../core/assets/CCTexture2D": 49
  } ],
  254: [ (function(require, module, exports) {
    var macro = require("../core/platform/CCMacro");
    var ParticleAsset = require("./CCParticleAsset");
    var RenderComponent = require("../core/components/CCRenderComponent");
    var codec = require("../compression/ZipUtils");
    var PNGReader = require("./CCPNGReader");
    var tiffReader = require("./CCTIFFReader");
    var textureUtil = require("../core/utils/texture-util");
    var renderEngine = require("../core/renderer/render-engine");
    var RenderFlow = require("../core/renderer/render-flow");
    var ParticleSimulator = require("./particle-simulator");
    var gfx = renderEngine.gfx;
    var ParticleMaterial = renderEngine.ParticleMaterial;
    var Particles = renderEngine.Particles;
    var BlendFactor = macro.BlendFactor;
    function getImageFormatByData(imgData) {
      if (imgData.length > 8 && 137 === imgData[0] && 80 === imgData[1] && 78 === imgData[2] && 71 === imgData[3] && 13 === imgData[4] && 10 === imgData[5] && 26 === imgData[6] && 10 === imgData[7]) return macro.ImageFormat.PNG;
      if (imgData.length > 2 && (73 === imgData[0] && 73 === imgData[1] || 77 === imgData[0] && 77 === imgData[1] || 255 === imgData[0] && 216 === imgData[1])) return macro.ImageFormat.TIFF;
      return macro.ImageFormat.UNKNOWN;
    }
    var EmitterMode = cc.Enum({
      GRAVITY: 0,
      RADIUS: 1
    });
    var PositionType = cc.Enum({
      FREE: 0,
      RELATIVE: 1,
      GROUPED: 2
    });
    var properties = {
      preview: {
        default: true,
        editorOnly: true,
        notify: false,
        animatable: false,
        tooltip: false
      },
      _custom: false,
      custom: {
        get: function() {
          return this._custom;
        },
        set: function(value) {
          false;
          if (this._custom !== value) {
            this._custom = value;
            value || this._applyFile();
            false;
          }
        },
        animatable: false,
        tooltip: false
      },
      _file: {
        default: null,
        type: ParticleAsset
      },
      file: {
        get: function() {
          return this._file;
        },
        set: function(value, force) {
          if (this._file !== value || false) {
            this._file = value;
            if (value) {
              this._applyFile();
              false;
            } else this.custom = true;
          }
        },
        animatable: false,
        type: ParticleAsset,
        tooltip: false
      },
      _spriteFrame: {
        default: null,
        type: cc.SpriteFrame
      },
      spriteFrame: {
        get: function() {
          return this._spriteFrame;
        },
        set: function(value, force) {
          var lastSprite = this._spriteFrame;
          false;
          if (lastSprite === value) return;
          this._spriteFrame = value;
          if ((lastSprite && lastSprite.getTexture()) !== (value && value.getTexture())) {
            this._texture = null;
            this._applySpriteFrame(lastSprite);
          }
          false;
        },
        type: cc.SpriteFrame,
        tooltip: false
      },
      texture: {
        get: function() {
          return this._texture ? this._texture.url : "";
        },
        set: function(value) {
          cc.warnID(6017);
        },
        type: cc.Texture2D,
        tooltip: false,
        readonly: true,
        visible: false,
        animatable: false
      },
      particleCount: {
        visible: false,
        get: function() {
          return this._simulator.particles.length;
        },
        readonly: true
      },
      _srcBlendFactor: BlendFactor.SRC_ALPHA,
      srcBlendFactor: {
        get: function() {
          return this._srcBlendFactor;
        },
        set: function(value) {
          this._srcBlendFactor = value;
          this._updateBlendFunc();
        },
        animatable: false,
        type: BlendFactor,
        tooltip: false
      },
      _dstBlendFactor: BlendFactor.ONE_MINUS_SRC_ALPHA,
      dstBlendFactor: {
        get: function() {
          return this._dstBlendFactor;
        },
        set: function(value) {
          this._dstBlendFactor = value;
          this._updateBlendFunc();
        },
        animatable: false,
        type: BlendFactor,
        tooltip: false
      },
      _stopped: true,
      stopped: {
        get: function() {
          return this._stopped;
        },
        animatable: false,
        visible: false
      },
      playOnLoad: true,
      autoRemoveOnFinish: {
        default: false,
        animatable: false,
        tooltip: false
      },
      active: {
        get: function() {
          return this._simulator.active;
        },
        visible: false
      },
      totalParticles: 150,
      duration: -1,
      emissionRate: 10,
      life: 1,
      lifeVar: 0,
      _startColor: null,
      startColor: {
        get: function() {
          return this._startColor;
        },
        set: function(val) {
          this._startColor.r = val.r;
          this._startColor.g = val.g;
          this._startColor.b = val.b;
          this._startColor.a = val.a;
        }
      },
      _startColorVar: null,
      startColorVar: {
        get: function() {
          return this._startColorVar;
        },
        set: function(val) {
          this._startColorVar.r = val.r;
          this._startColorVar.g = val.g;
          this._startColorVar.b = val.b;
          this._startColorVar.a = val.a;
        }
      },
      _endColor: null,
      endColor: {
        get: function() {
          return this._endColor;
        },
        set: function(val) {
          this._endColor.r = val.r;
          this._endColor.g = val.g;
          this._endColor.b = val.b;
          this._endColor.a = val.a;
        }
      },
      _endColorVar: null,
      endColorVar: {
        get: function() {
          return this._endColorVar;
        },
        set: function(val) {
          this._endColorVar.r = val.r;
          this._endColorVar.g = val.g;
          this._endColorVar.b = val.b;
          this._endColorVar.a = val.a;
        }
      },
      angle: 90,
      angleVar: 20,
      startSize: 50,
      startSizeVar: 0,
      endSize: 0,
      endSizeVar: 0,
      startSpin: 0,
      startSpinVar: 0,
      endSpin: 0,
      endSpinVar: 0,
      sourcePos: cc.v2(0, 0),
      posVar: cc.v2(0, 0),
      positionType: {
        default: PositionType.FREE,
        type: PositionType
      },
      emitterMode: {
        default: EmitterMode.GRAVITY,
        type: EmitterMode
      },
      gravity: cc.v2(0, 0),
      speed: 180,
      speedVar: 50,
      tangentialAccel: 80,
      tangentialAccelVar: 0,
      radialAccel: 0,
      radialAccelVar: 0,
      rotationIsDir: false,
      startRadius: 0,
      startRadiusVar: 0,
      endRadius: 0,
      endRadiusVar: 0,
      rotatePerS: 0,
      rotatePerSVar: 0
    };
    var ParticleSystem = cc.Class({
      name: "cc.ParticleSystem",
      extends: RenderComponent,
      editor: false,
      ctor: function() {
        this._previewTimer = null;
        this._focused = false;
        this._willStart = false;
        this._texture = null;
        this._simulator = new ParticleSimulator(this);
        this._startColor = {
          r: 255,
          g: 255,
          b: 255,
          a: 255
        };
        this._startColorVar = {
          r: 0,
          g: 0,
          b: 0,
          a: 0
        };
        this._endColor = {
          r: 255,
          g: 255,
          b: 255,
          a: 0
        };
        this._endColorVar = {
          r: 0,
          g: 0,
          b: 0,
          a: 0
        };
      },
      properties: properties,
      statics: {
        DURATION_INFINITY: -1,
        START_SIZE_EQUAL_TO_END_SIZE: -1,
        START_RADIUS_EQUAL_TO_END_RADIUS: -1,
        EmitterMode: EmitterMode,
        PositionType: PositionType
      },
      onFocusInEditor: false,
      onLostFocusInEditor: false,
      __preload: function() {
        if (this._file) if (this._custom) {
          var missCustomTexture = !this._texture;
          missCustomTexture && this._applyFile();
        } else this._applyFile();
        true;
        this.playOnLoad && this.resetSystem();
      },
      onLoad: function() {
        ParticleSystem._assembler.createIA(this);
      },
      onEnable: function() {
        this._super();
        this.node._renderFlag &= ~RenderFlow.FLAG_RENDER;
        this._activateMaterial();
      },
      onDestroy: function() {
        this.autoRemoveOnFinish && (this.autoRemoveOnFinish = false);
        this._super();
      },
      update: function(dt) {
        !this._simulator.finished && this._material && this._simulator.step(dt);
      },
      addParticle: function() {},
      stopSystem: function() {
        this._stopped = true;
        this._simulator.stop();
      },
      resetSystem: function() {
        this._stopped = false;
        this._simulator.reset();
        this._material ? this.markForCustomIARender(true) : this._activateMaterial();
      },
      isFull: function() {
        return this.particleCount >= this.totalParticles;
      },
      setTextureWithRect: function(texture, rect) {
        texture instanceof cc.Texture2D && (this.spriteFrame = new cc.SpriteFrame(texture, rect));
      },
      _applyFile: function() {
        var file = this._file;
        if (file) {
          var self = this;
          cc.loader.load(file.nativeUrl, (function(err, content) {
            if (err || !content) throw err || new Error(cc._getError(6029));
            if (!self.isValid) return;
            self._plistFile = file.nativeUrl;
            self._custom ? self._initTextureWithDictionary(content) : self._initWithDictionary(content);
            file.texture && (self.spriteFrame = new cc.SpriteFrame(file.texture));
          }));
        }
      },
      _initTextureWithDictionary: function(dict) {
        var imgPath = cc.path.changeBasename(this._plistFile, dict["textureFileName"]);
        if (dict["textureFileName"]) {
          var tex = textureUtil.loadImage(imgPath);
          this.spriteFrame = new cc.SpriteFrame(tex);
        } else if (dict["textureImageData"]) {
          var textureData = dict["textureImageData"];
          if (!(textureData && textureData.length > 0)) return false;
          var buffer = codec.unzipBase64AsArray(textureData, 1);
          if (!buffer) {
            cc.logID(6010);
            return false;
          }
          var imageFormat = getImageFormatByData(buffer);
          if (imageFormat !== macro.ImageFormat.TIFF && imageFormat !== macro.ImageFormat.PNG) {
            cc.logID(6011);
            return false;
          }
          var canvasObj = document.createElement("canvas");
          if (imageFormat === macro.ImageFormat.PNG) {
            var myPngObj = new PNGReader(buffer);
            myPngObj.render(canvasObj);
          } else tiffReader.parseTIFF(buffer, canvasObj);
          var tex = textureUtil.cacheImage(imgPath, canvasObj);
          tex || cc.logID(6012);
          this.spriteFrame = new cc.SpriteFrame(tex);
        }
        return true;
      },
      _initWithDictionary: function(dict) {
        this.totalParticles = parseInt(dict["maxParticles"] || 0);
        this.life = parseFloat(dict["particleLifespan"] || 0);
        this.lifeVar = parseFloat(dict["particleLifespanVariance"] || 0);
        this.emissionRate = this.totalParticles / this.life;
        this.duration = parseFloat(dict["duration"] || 0);
        this.srcBlendFactor = parseInt(dict["blendFuncSource"] || macro.SRC_ALPHA);
        this.dstBlendFactor = parseInt(dict["blendFuncDestination"] || macro.ONE_MINUS_SRC_ALPHA);
        var locStartColor = this.startColor;
        locStartColor.r = 255 * parseFloat(dict["startColorRed"] || 1);
        locStartColor.g = 255 * parseFloat(dict["startColorGreen"] || 1);
        locStartColor.b = 255 * parseFloat(dict["startColorBlue"] || 1);
        locStartColor.a = 255 * parseFloat(dict["startColorAlpha"] || 1);
        var locStartColorVar = this.startColorVar;
        locStartColorVar.r = 255 * parseFloat(dict["startColorVarianceRed"] || 1);
        locStartColorVar.g = 255 * parseFloat(dict["startColorVarianceGreen"] || 1);
        locStartColorVar.b = 255 * parseFloat(dict["startColorVarianceBlue"] || 1);
        locStartColorVar.a = 255 * parseFloat(dict["startColorVarianceAlpha"] || 1);
        var locEndColor = this.endColor;
        locEndColor.r = 255 * parseFloat(dict["finishColorRed"] || 1);
        locEndColor.g = 255 * parseFloat(dict["finishColorGreen"] || 1);
        locEndColor.b = 255 * parseFloat(dict["finishColorBlue"] || 1);
        locEndColor.a = 255 * parseFloat(dict["finishColorAlpha"] || 1);
        var locEndColorVar = this.endColorVar;
        locEndColorVar.r = 255 * parseFloat(dict["finishColorVarianceRed"] || 1);
        locEndColorVar.g = 255 * parseFloat(dict["finishColorVarianceGreen"] || 1);
        locEndColorVar.b = 255 * parseFloat(dict["finishColorVarianceBlue"] || 1);
        locEndColorVar.a = 255 * parseFloat(dict["finishColorVarianceAlpha"] || 1);
        this.startSize = parseFloat(dict["startParticleSize"] || 0);
        this.startSizeVar = parseFloat(dict["startParticleSizeVariance"] || 0);
        this.endSize = parseFloat(dict["finishParticleSize"] || 0);
        this.endSizeVar = parseFloat(dict["finishParticleSizeVariance"] || 0);
        this.sourcePos.x = 0;
        this.sourcePos.y = 0;
        this.posVar.x = parseFloat(dict["sourcePositionVariancex"] || 0);
        this.posVar.y = parseFloat(dict["sourcePositionVariancey"] || 0);
        this.angle = parseFloat(dict["angle"] || 0);
        this.angleVar = parseFloat(dict["angleVariance"] || 0);
        this.startSpin = parseFloat(dict["rotationStart"] || 0);
        this.startSpinVar = parseFloat(dict["rotationStartVariance"] || 0);
        this.endSpin = parseFloat(dict["rotationEnd"] || 0);
        this.endSpinVar = parseFloat(dict["rotationEndVariance"] || 0);
        this.emitterMode = parseInt(dict["emitterType"] || EmitterMode.GRAVITY);
        if (this.emitterMode === EmitterMode.GRAVITY) {
          this.gravity.x = parseFloat(dict["gravityx"] || 0);
          this.gravity.y = parseFloat(dict["gravityy"] || 0);
          this.speed = parseFloat(dict["speed"] || 0);
          this.speedVar = parseFloat(dict["speedVariance"] || 0);
          this.radialAccel = parseFloat(dict["radialAcceleration"] || 0);
          this.radialAccelVar = parseFloat(dict["radialAccelVariance"] || 0);
          this.tangentialAccel = parseFloat(dict["tangentialAcceleration"] || 0);
          this.tangentialAccelVar = parseFloat(dict["tangentialAccelVariance"] || 0);
          var locRotationIsDir = dict["rotationIsDir"] || "";
          if (null !== locRotationIsDir) {
            locRotationIsDir = locRotationIsDir.toString().toLowerCase();
            this.rotationIsDir = "true" === locRotationIsDir || "1" === locRotationIsDir;
          } else this.rotationIsDir = false;
        } else {
          if (this.emitterMode !== EmitterMode.RADIUS) {
            cc.warnID(6009);
            return false;
          }
          this.startRadius = parseFloat(dict["maxRadius"] || 0);
          this.startRadiusVar = parseFloat(dict["maxRadiusVariance"] || 0);
          this.endRadius = parseFloat(dict["minRadius"] || 0);
          this.endRadiusVar = parseFloat(dict["minRadiusVariance"] || 0);
          this.rotatePerS = parseFloat(dict["rotatePerSecond"] || 0);
          this.rotatePerSVar = parseFloat(dict["rotatePerSecondVariance"] || 0);
        }
        this._initTextureWithDictionary(dict);
        return true;
      },
      _onTextureLoaded: function(event) {
        this._texture = this._spriteFrame.getTexture();
        this._renderData && (this._renderData.uvDirty = true);
        this._activateMaterial();
      },
      _applySpriteFrame: function(oldFrame) {
        oldFrame && oldFrame.off && oldFrame.off("load", this._onTextureLoaded, this);
        var spriteFrame = this._spriteFrame;
        if (spriteFrame) if (spriteFrame.textureLoaded()) this._onTextureLoaded(null); else {
          spriteFrame.once("load", this._onTextureLoaded, this);
          spriteFrame.ensureLoadTexture();
        }
      },
      _activateMaterial: function() {
        if (!this._material) {
          this._material = new renderEngine.SpriteMaterial();
          this._material.useTexture = true;
          this._material.useModel = true;
          this._material.useColor = false;
        }
        if (this._texture && this._texture.loaded) {
          this.markForUpdateRenderData(true);
          this.markForCustomIARender(true);
          this._material.texture = this._texture;
        } else {
          this.markForCustomIARender(false);
          this._spriteFrame && this._applySpriteFrame();
        }
        this._updateBlendFunc();
      },
      _updateBlendFunc: function() {
        if (!this._material) return;
        var pass = this._material._mainTech.passes[0];
        pass.setBlend(gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor, gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor);
        this._material.updateHash();
      },
      _finishedSimulation: function() {
        false;
        this.disableRender();
        this.autoRemoveOnFinish && this._stopped && this.node.destroy();
      }
    });
    cc.ParticleSystem = module.exports = ParticleSystem;
  }), {
    "../compression/ZipUtils": 24,
    "../core/components/CCRenderComponent": 77,
    "../core/platform/CCMacro": 160,
    "../core/renderer/render-engine": 197,
    "../core/renderer/render-flow": 198,
    "../core/utils/texture-util": 241,
    "./CCPNGReader": 252,
    "./CCParticleAsset": 253,
    "./CCTIFFReader": 255,
    "./particle-simulator": 257
  } ],
  255: [ (function(require, module, exports) {
    var tiffReader = {
      _littleEndian: false,
      _tiffData: null,
      _fileDirectories: [],
      getUint8: function(offset) {
        return this._tiffData[offset];
      },
      getUint16: function(offset) {
        return this._littleEndian ? this._tiffData[offset + 1] << 8 | this._tiffData[offset] : this._tiffData[offset] << 8 | this._tiffData[offset + 1];
      },
      getUint32: function(offset) {
        var a = this._tiffData;
        return this._littleEndian ? a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset] : a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3];
      },
      checkLittleEndian: function() {
        var BOM = this.getUint16(0);
        if (18761 === BOM) this.littleEndian = true; else {
          if (19789 !== BOM) {
            console.log(BOM);
            throw TypeError(cc._getError(6019));
          }
          this.littleEndian = false;
        }
        return this.littleEndian;
      },
      hasTowel: function() {
        if (42 !== this.getUint16(2)) throw RangeError(cc._getError(6020));
        return true;
      },
      getFieldTypeName: function(fieldType) {
        var typeNames = this.fieldTypeNames;
        if (fieldType in typeNames) return typeNames[fieldType];
        return null;
      },
      getFieldTagName: function(fieldTag) {
        var tagNames = this.fieldTagNames;
        if (fieldTag in tagNames) return tagNames[fieldTag];
        cc.logID(6021, fieldTag);
        return "Tag" + fieldTag;
      },
      getFieldTypeLength: function(fieldTypeName) {
        if (-1 !== [ "BYTE", "ASCII", "SBYTE", "UNDEFINED" ].indexOf(fieldTypeName)) return 1;
        if (-1 !== [ "SHORT", "SSHORT" ].indexOf(fieldTypeName)) return 2;
        if (-1 !== [ "LONG", "SLONG", "FLOAT" ].indexOf(fieldTypeName)) return 4;
        if (-1 !== [ "RATIONAL", "SRATIONAL", "DOUBLE" ].indexOf(fieldTypeName)) return 8;
        return null;
      },
      getFieldValues: function(fieldTagName, fieldTypeName, typeCount, valueOffset) {
        var fieldValues = [];
        var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
        var fieldValueSize = fieldTypeLength * typeCount;
        if (fieldValueSize <= 4) false === this.littleEndian ? fieldValues.push(valueOffset >>> 8 * (4 - fieldTypeLength)) : fieldValues.push(valueOffset); else for (var i = 0; i < typeCount; i++) {
          var indexOffset = fieldTypeLength * i;
          if (fieldTypeLength >= 8) if (-1 !== [ "RATIONAL", "SRATIONAL" ].indexOf(fieldTypeName)) {
            fieldValues.push(this.getUint32(valueOffset + indexOffset));
            fieldValues.push(this.getUint32(valueOffset + indexOffset + 4));
          } else cc.logID(8e3); else fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
        }
        "ASCII" === fieldTypeName && fieldValues.forEach((function(e, i, a) {
          a[i] = String.fromCharCode(e);
        }));
        return fieldValues;
      },
      getBytes: function(numBytes, offset) {
        if (numBytes <= 0) cc.logID(8001); else {
          if (numBytes <= 1) return this.getUint8(offset);
          if (numBytes <= 2) return this.getUint16(offset);
          if (numBytes <= 3) return this.getUint32(offset) >>> 8;
          if (numBytes <= 4) return this.getUint32(offset);
          cc.logID(8002);
        }
      },
      getBits: function(numBits, byteOffset, bitOffset) {
        bitOffset = bitOffset || 0;
        var extraBytes = Math.floor(bitOffset / 8);
        var newByteOffset = byteOffset + extraBytes;
        var totalBits = bitOffset + numBits;
        var shiftRight = 32 - numBits;
        var shiftLeft, rawBits;
        if (totalBits <= 0) cc.logID(6023); else if (totalBits <= 8) {
          shiftLeft = 24 + bitOffset;
          rawBits = this.getUint8(newByteOffset);
        } else if (totalBits <= 16) {
          shiftLeft = 16 + bitOffset;
          rawBits = this.getUint16(newByteOffset);
        } else if (totalBits <= 32) {
          shiftLeft = bitOffset;
          rawBits = this.getUint32(newByteOffset);
        } else cc.logID(6022);
        return {
          bits: rawBits << shiftLeft >>> shiftRight,
          byteOffset: newByteOffset + Math.floor(totalBits / 8),
          bitOffset: totalBits % 8
        };
      },
      parseFileDirectory: function(byteOffset) {
        var numDirEntries = this.getUint16(byteOffset);
        var tiffFields = [];
        for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, 
        entryCount++) {
          var fieldTag = this.getUint16(i);
          var fieldType = this.getUint16(i + 2);
          var typeCount = this.getUint32(i + 4);
          var valueOffset = this.getUint32(i + 8);
          var fieldTagName = this.getFieldTagName(fieldTag);
          var fieldTypeName = this.getFieldTypeName(fieldType);
          var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
          tiffFields[fieldTagName] = {
            type: fieldTypeName,
            values: fieldValues
          };
        }
        this._fileDirectories.push(tiffFields);
        var nextIFDByteOffset = this.getUint32(i);
        0 !== nextIFDByteOffset && this.parseFileDirectory(nextIFDByteOffset);
      },
      clampColorSample: function(colorSample, bitsPerSample) {
        var multiplier = Math.pow(2, 8 - bitsPerSample);
        return Math.floor(colorSample * multiplier + (multiplier - 1));
      },
      parseTIFF: function(tiffData, canvas) {
        canvas = canvas || document.createElement("canvas");
        this._tiffData = tiffData;
        this.canvas = canvas;
        this.checkLittleEndian();
        if (!this.hasTowel()) return;
        var firstIFDByteOffset = this.getUint32(4);
        this._fileDirectories.length = 0;
        this.parseFileDirectory(firstIFDByteOffset);
        var fileDirectory = this._fileDirectories[0];
        var imageWidth = fileDirectory["ImageWidth"].values[0];
        var imageLength = fileDirectory["ImageLength"].values[0];
        this.canvas.width = imageWidth;
        this.canvas.height = imageLength;
        var strips = [];
        var compression = fileDirectory["Compression"] ? fileDirectory["Compression"].values[0] : 1;
        var samplesPerPixel = fileDirectory["SamplesPerPixel"].values[0];
        var sampleProperties = [];
        var bitsPerPixel = 0;
        var hasBytesPerPixel = false;
        fileDirectory["BitsPerSample"].values.forEach((function(bitsPerSample, i, bitsPerSampleValues) {
          sampleProperties[i] = {
            bitsPerSample: bitsPerSample,
            hasBytesPerSample: false,
            bytesPerSample: void 0
          };
          if (bitsPerSample % 8 === 0) {
            sampleProperties[i].hasBytesPerSample = true;
            sampleProperties[i].bytesPerSample = bitsPerSample / 8;
          }
          bitsPerPixel += bitsPerSample;
        }), this);
        if (bitsPerPixel % 8 === 0) {
          hasBytesPerPixel = true;
          var bytesPerPixel = bitsPerPixel / 8;
        }
        var stripOffsetValues = fileDirectory["StripOffsets"].values;
        var numStripOffsetValues = stripOffsetValues.length;
        if (fileDirectory["StripByteCounts"]) var stripByteCountValues = fileDirectory["StripByteCounts"].values; else {
          cc.logID(8003);
          if (1 !== numStripOffsetValues) throw Error(cc._getError(6024));
          var stripByteCountValues = [ Math.ceil(imageWidth * imageLength * bitsPerPixel / 8) ];
        }
        for (var i = 0; i < numStripOffsetValues; i++) {
          var stripOffset = stripOffsetValues[i];
          strips[i] = [];
          var stripByteCount = stripByteCountValues[i];
          for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) switch (compression) {
           case 1:
            for (var m = 0, pixel = []; m < samplesPerPixel; m++) {
              if (!sampleProperties[m].hasBytesPerSample) {
                var sampleInfo = this.getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
                pixel.push(sampleInfo.bits);
                byteOffset = sampleInfo.byteOffset - stripOffset;
                bitOffset = sampleInfo.bitOffset;
                throw RangeError(cc._getError(6025));
              }
              var sampleOffset = sampleProperties[m].bytesPerSample * m;
              pixel.push(this.getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));
            }
            strips[i].push(pixel);
            if (!hasBytesPerPixel) {
              jIncrement = 0;
              throw RangeError(cc._getError(6026));
            }
            jIncrement = bytesPerPixel;
            break;

           case 2:
           case 3:
           case 4:
           case 5:
           case 6:
           case 7:
            break;

           case 32773:
            if (getHeader) {
              getHeader = false;
              var blockLength = 1;
              var iterations = 1;
              var header = this.getInt8(stripOffset + byteOffset);
              header >= 0 && header <= 127 ? blockLength = header + 1 : header >= -127 && header <= -1 ? iterations = 1 - header : getHeader = true;
            } else {
              var currentByte = this.getUint8(stripOffset + byteOffset);
              for (var m = 0; m < iterations; m++) {
                if (!sampleProperties[sample].hasBytesPerSample) throw RangeError(cc._getError(6025));
                currentSample = currentSample << 8 * numBytes | currentByte;
                numBytes++;
                if (numBytes === sampleProperties[sample].bytesPerSample) {
                  pixel.push(currentSample);
                  currentSample = numBytes = 0;
                  sample++;
                }
                if (sample === samplesPerPixel) {
                  strips[i].push(pixel);
                  pixel = [];
                  sample = 0;
                }
              }
              blockLength--;
              0 === blockLength && (getHeader = true);
            }
            jIncrement = 1;
          }
        }
        if (canvas.getContext) {
          var ctx = this.canvas.getContext("2d");
          ctx.fillStyle = "rgba(255, 255, 255, 0)";
          var rowsPerStrip = fileDirectory["RowsPerStrip"] ? fileDirectory["RowsPerStrip"].values[0] : imageLength;
          var numStrips = strips.length;
          var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
          var rowsInLastStrip = 0 === imageLengthModRowsPerStrip ? rowsPerStrip : imageLengthModRowsPerStrip;
          var numRowsInStrip = rowsPerStrip;
          var numRowsInPreviousStrip = 0;
          var photometricInterpretation = fileDirectory["PhotometricInterpretation"].values[0];
          var extraSamplesValues = [];
          var numExtraSamples = 0;
          if (fileDirectory["ExtraSamples"]) {
            extraSamplesValues = fileDirectory["ExtraSamples"].values;
            numExtraSamples = extraSamplesValues.length;
          }
          if (fileDirectory["ColorMap"]) {
            var colorMapValues = fileDirectory["ColorMap"].values;
            var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
          }
          for (var i = 0; i < numStrips; i++) {
            i + 1 === numStrips && (numRowsInStrip = rowsInLastStrip);
            var numPixels = strips[i].length;
            var yPadding = numRowsInPreviousStrip * i;
            for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) for (var x = 0; x < imageWidth; x++, 
            j++) {
              var pixelSamples = strips[i][j];
              var red = 0;
              var green = 0;
              var blue = 0;
              var opacity = 1;
              if (numExtraSamples > 0) for (var k = 0; k < numExtraSamples; k++) if (1 === extraSamplesValues[k] || 2 === extraSamplesValues[k]) {
                opacity = pixelSamples[3 + k] / 256;
                break;
              }
              switch (photometricInterpretation) {
               case 0:
                if (sampleProperties[0].hasBytesPerSample) var invertValue = Math.pow(16, 2 * sampleProperties[0].bytesPerSample);
                pixelSamples.forEach((function(sample, index, samples) {
                  samples[index] = invertValue - sample;
                }));

               case 1:
                red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                break;

               case 2:
                red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                break;

               case 3:
                if (void 0 === colorMapValues) throw Error(cc._getError(6027));
                var colorMapIndex = pixelSamples[0];
                red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
                green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                break;

               default:
                throw RangeError(cc._getError(6028, photometricInterpretation));
              }
              ctx.fillStyle = "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
              ctx.fillRect(x, yPadding + y, 1, 1);
            }
            numRowsInPreviousStrip = numRowsInStrip;
          }
        }
        return this.canvas;
      },
      fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
      },
      fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
      }
    };
    module.exports = tiffReader;
  }), {} ],
  256: [ (function(require, module, exports) {
    require("./CCParticleAsset");
    require("./CCParticleSystem");
    require("./particle-simulator");
    require("./particle-system-assembler");
  }), {
    "./CCParticleAsset": 253,
    "./CCParticleSystem": 254,
    "./particle-simulator": 257,
    "./particle-system-assembler": 258
  } ],
  257: [ (function(require, module, exports) {
    var AffineTrans = require("../core/utils/affine-transform");
    var js = require("../core/platform/js");
    var misc = require("../core/utils/misc");
    var ZERO_VEC2 = cc.v2(0, 0);
    var _trans = AffineTrans.create();
    var _pos = cc.v2();
    var _tpa = cc.v2();
    var _tpb = cc.v2();
    var _tpc = cc.v2();
    var Particle = function() {
      this.pos = cc.v2(0, 0);
      this.startPos = cc.v2(0, 0);
      this.color = cc.color(0, 0, 0, 255);
      this.deltaColor = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      };
      this.size = 0;
      this.deltaSize = 0;
      this.rotation = 0;
      this.deltaRotation = 0;
      this.timeToLive = 0;
      this.drawPos = cc.v2(0, 0);
      this.dir = cc.v2(0, 0);
      this.radialAccel = 0;
      this.tangentialAccel = 0;
      this.angle = 0;
      this.degreesPerSecond = 0;
      this.radius = 0;
      this.deltaRadius = 0;
    };
    var pool = new js.Pool(function(par) {
      par.pos.set(ZERO_VEC2);
      par.startPos.set(ZERO_VEC2);
      par.color._val = 4278190080;
      par.deltaColor.r = par.deltaColor.g = par.deltaColor.b = 0;
      par.deltaColor.a = 255;
      par.size = 0;
      par.deltaSize = 0;
      par.rotation = 0;
      par.deltaRotation = 0;
      par.timeToLive = 0;
      par.drawPos.set(ZERO_VEC2);
      par.dir.set(ZERO_VEC2);
      par.radialAccel = 0;
      par.tangentialAccel = 0;
      par.angle = 0;
      par.degreesPerSecond = 0;
      par.radius = 0;
      par.deltaRadius = 0;
    }, 1024);
    pool.get = function() {
      return this._get() || new Particle();
    };
    var Simulator = function(system) {
      this.sys = system;
      this.particles = [];
      this.active = false;
      this.finished = false;
      this.elapsed = 0;
      this.emitCounter = 0;
      this._uvFilled = 0;
    };
    Simulator.prototype.stop = function() {
      this.active = false;
      this.elapsed = this.sys.duration;
      this.emitCounter = 0;
    };
    Simulator.prototype.reset = function() {
      this.active = true;
      this.elapsed = 0;
      this.emitCounter = 0;
      this.finished = false;
      var particles = this.particles;
      for (var id = 0; id < particles.length; ++id) pool.put(particles[id]);
      particles.length = 0;
    };
    Simulator.prototype.emitParticle = function(pos) {
      var psys = this.sys;
      var clampf = misc.clampf;
      var particle = pool.get();
      this.particles.push(particle);
      particle.timeToLive = psys.life + psys.lifeVar * (Math.random() - .5) * 2;
      var timeToLive = particle.timeToLive = Math.max(0, particle.timeToLive);
      particle.pos.x = psys.sourcePos.x + psys.posVar.x * (Math.random() - .5) * 2;
      particle.pos.y = psys.sourcePos.y + psys.posVar.y * (Math.random() - .5) * 2;
      var sr = void 0, sg = void 0, sb = void 0, sa = void 0;
      var startColor = psys._startColor, startColorVar = psys._startColorVar;
      var endColor = psys._endColor, endColorVar = psys._endColorVar;
      particle.color.r = sr = clampf(startColor.r + startColorVar.r * (Math.random() - .5) * 2, 0, 255);
      particle.color.g = sg = clampf(startColor.g + startColorVar.g * (Math.random() - .5) * 2, 0, 255);
      particle.color.b = sb = clampf(startColor.b + startColorVar.b * (Math.random() - .5) * 2, 0, 255);
      particle.color.a = sa = clampf(startColor.a + startColorVar.a * (Math.random() - .5) * 2, 0, 255);
      particle.deltaColor.r = (clampf(endColor.r + endColorVar.r * (Math.random() - .5) * 2, 0, 255) - sr) / timeToLive;
      particle.deltaColor.g = (clampf(endColor.g + endColorVar.g * (Math.random() - .5) * 2, 0, 255) - sg) / timeToLive;
      particle.deltaColor.b = (clampf(endColor.b + endColorVar.b * (Math.random() - .5) * 2, 0, 255) - sb) / timeToLive;
      particle.deltaColor.a = (clampf(endColor.a + endColorVar.a * (Math.random() - .5) * 2, 0, 255) - sa) / timeToLive;
      var startS = psys.startSize + psys.startSizeVar * (Math.random() - .5) * 2;
      startS = Math.max(0, startS);
      particle.size = startS;
      if (psys.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE) particle.deltaSize = 0; else {
        var endS = psys.endSize + psys.endSizeVar * (Math.random() - .5) * 2;
        endS = Math.max(0, endS);
        particle.deltaSize = (endS - startS) / timeToLive;
      }
      var startA = psys.startSpin + psys.startSpinVar * (Math.random() - .5) * 2;
      var endA = psys.endSpin + psys.endSpinVar * (Math.random() - .5) * 2;
      particle.rotation = startA;
      particle.deltaRotation = (endA - startA) / timeToLive;
      particle.startPos.x = pos.x;
      particle.startPos.y = pos.y;
      var a = misc.degreesToRadians(psys.angle + psys.angleVar * (Math.random() - .5) * 2);
      if (psys.emitterMode === cc.ParticleSystem.EmitterMode.GRAVITY) {
        var s = psys.speed + psys.speedVar * (Math.random() - .5) * 2;
        particle.dir.x = Math.cos(a);
        particle.dir.y = Math.sin(a);
        particle.dir.mulSelf(s);
        particle.radialAccel = psys.radialAccel + psys.radialAccelVar * (Math.random() - .5) * 2;
        particle.tangentialAccel = psys.tangentialAccel + psys.tangentialAccelVar * (Math.random() - .5) * 2;
        psys.rotationIsDir && (particle.rotation = -misc.radiansToDegrees(Math.atan2(particle.dir.y, particle.dir.x)));
      } else {
        var startRadius = psys.startRadius + psys.startRadiusVar * (Math.random() - .5) * 2;
        var endRadius = psys.endRadius + psys.endRadiusVar * (Math.random() - .5) * 2;
        particle.radius = startRadius;
        particle.deltaRadius = psys.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / timeToLive;
        particle.angle = a;
        particle.degreesPerSecond = misc.degreesToRadians(psys.rotatePerS + psys.rotatePerSVar * (Math.random() - .5) * 2);
      }
    };
    Simulator.prototype.updateUVs = function(particleCount) {
      if (this.sys._buffer && this.sys._spriteFrame) {
        var FLOAT_PER_PARTICLE = 4 * this.sys._vertexFormat._bytes / 4;
        var vbuf = this.sys._buffer._vData;
        var uv = this.sys._spriteFrame.uv;
        for (var i = this._uvFilled; i < particleCount; i++) {
          var offset = i * FLOAT_PER_PARTICLE;
          vbuf[offset + 2] = uv[0];
          vbuf[offset + 3] = uv[1];
          vbuf[offset + 7] = uv[2];
          vbuf[offset + 8] = uv[3];
          vbuf[offset + 12] = uv[4];
          vbuf[offset + 13] = uv[5];
          vbuf[offset + 17] = uv[6];
          vbuf[offset + 18] = uv[7];
        }
        this._uvFilled = particleCount;
      }
    };
    Simulator.prototype.updateParticleBuffer = function(particle, pos, buffer, offset) {
      var vbuf = buffer._vData;
      var uintbuf = buffer._uintVData;
      var x = pos.x, y = pos.y;
      var size_2 = particle.size / 2;
      if (particle.rotation) {
        var x1 = -size_2, y1 = -size_2;
        var x2 = size_2, y2 = size_2;
        var rad = -misc.degreesToRadians(particle.rotation);
        var cr = Math.cos(rad), sr = Math.sin(rad);
        vbuf[offset] = x1 * cr - y1 * sr + x;
        vbuf[offset + 1] = x1 * sr + y1 * cr + y;
        vbuf[offset + 5] = x2 * cr - y1 * sr + x;
        vbuf[offset + 6] = x2 * sr + y1 * cr + y;
        vbuf[offset + 10] = x1 * cr - y2 * sr + x;
        vbuf[offset + 11] = x1 * sr + y2 * cr + y;
        vbuf[offset + 15] = x2 * cr - y2 * sr + x;
        vbuf[offset + 16] = x2 * sr + y2 * cr + y;
      } else {
        vbuf[offset] = x - size_2;
        vbuf[offset + 1] = y - size_2;
        vbuf[offset + 5] = x + size_2;
        vbuf[offset + 6] = y - size_2;
        vbuf[offset + 10] = x - size_2;
        vbuf[offset + 11] = y + size_2;
        vbuf[offset + 15] = x + size_2;
        vbuf[offset + 16] = y + size_2;
      }
      uintbuf[offset + 4] = particle.color._val;
      uintbuf[offset + 9] = particle.color._val;
      uintbuf[offset + 14] = particle.color._val;
      uintbuf[offset + 19] = particle.color._val;
    };
    Simulator.prototype.step = function(dt) {
      var psys = this.sys;
      var node = psys.node;
      var particles = this.particles;
      var FLOAT_PER_PARTICLE = 4 * psys._vertexFormat._bytes / 4;
      node._updateWorldMatrix();
      AffineTrans.fromMat4(_trans, node._worldMatrix);
      if (psys.positionType === cc.ParticleSystem.PositionType.FREE) AffineTrans.transformVec2(_pos, ZERO_VEC2, _trans); else if (psys.positionType === cc.ParticleSystem.PositionType.RELATIVE) {
        _pos.x = node._position.x;
        _pos.y = node._position.y;
      }
      AffineTrans.invert(_trans, _trans);
      var worldToNodeTrans = _trans;
      if (this.active && psys.emissionRate) {
        var rate = 1 / psys.emissionRate;
        particles.length < psys.totalParticles && (this.emitCounter += dt);
        while (particles.length < psys.totalParticles && this.emitCounter > rate) {
          this.emitParticle(_pos);
          this.emitCounter -= rate;
        }
        this.elapsed += dt;
        -1 !== psys.duration && psys.duration < this.elapsed && psys.stopSystem();
      }
      var buffer = psys._buffer;
      var particleCount = particles.length;
      buffer.reset();
      buffer.request(4 * particleCount, 6 * particles.length);
      particleCount > this._uvFilled && this.updateUVs(particleCount);
      var particleIdx = 0;
      while (particleIdx < particles.length) {
        _tpa.x = _tpa.y = _tpb.x = _tpb.y = _tpc.x = _tpc.y = 0;
        var particle = particles[particleIdx];
        particle.timeToLive -= dt;
        if (particle.timeToLive > 0) {
          if (psys.emitterMode === cc.ParticleSystem.EmitterMode.GRAVITY) {
            var tmp = _tpc, radial = _tpa, tangential = _tpb;
            if (particle.pos.x || particle.pos.y) {
              radial.set(particle.pos);
              radial.normalizeSelf();
            }
            tangential.set(radial);
            radial.mulSelf(particle.radialAccel);
            var newy = tangential.x;
            tangential.x = -tangential.y;
            tangential.y = newy;
            tangential.mulSelf(particle.tangentialAccel);
            tmp.set(radial);
            tmp.addSelf(tangential);
            tmp.addSelf(psys.gravity);
            tmp.mulSelf(dt);
            particle.dir.addSelf(tmp);
            tmp.set(particle.dir);
            tmp.mulSelf(dt);
            particle.pos.addSelf(tmp);
          } else {
            particle.angle += particle.degreesPerSecond * dt;
            particle.radius += particle.deltaRadius * dt;
            particle.pos.x = -Math.cos(particle.angle) * particle.radius;
            particle.pos.y = -Math.sin(particle.angle) * particle.radius;
          }
          particle.color.r += particle.deltaColor.r * dt;
          particle.color.g += particle.deltaColor.g * dt;
          particle.color.b += particle.deltaColor.b * dt;
          particle.color.a += particle.deltaColor.a * dt;
          particle.size += particle.deltaSize * dt;
          particle.size < 0 && (particle.size = 0);
          particle.rotation += particle.deltaRotation * dt;
          var newPos = _tpa;
          if (psys.positionType === cc.ParticleSystem.PositionType.FREE || psys.positionType === cc.ParticleSystem.PositionType.RELATIVE) {
            var diff = _tpb, startPos = _tpc;
            AffineTrans.transformVec2(diff, _pos, worldToNodeTrans);
            AffineTrans.transformVec2(startPos, particle.startPos, worldToNodeTrans);
            diff.subSelf(startPos);
            newPos.set(particle.pos);
            newPos.subSelf(diff);
          } else newPos.set(particle.pos);
          var offset = FLOAT_PER_PARTICLE * particleIdx;
          this.updateParticleBuffer(particle, newPos, buffer, offset);
          ++particleIdx;
        } else {
          var deadParticle = particles[particleIdx];
          particleIdx !== particles.length - 1 && (particles[particleIdx] = particles[particles.length - 1]);
          pool.put(deadParticle);
          particles.length--;
          if (0 === particles.length) {
            this.finished = true;
            psys._finishedSimulation();
          }
        }
      }
      if (particles.length > 0) {
        buffer.uploadData();
        psys._ia._count = 6 * particles.length;
      }
    };
    module.exports = Simulator;
  }), {
    "../core/platform/js": 175,
    "../core/utils/affine-transform": 225,
    "../core/utils/misc": 233
  } ],
  258: [ (function(require, module, exports) {
    var js = require("../core/platform/js");
    var ParticleSystem = require("./CCParticleSystem");
    var renderer = require("../core/renderer/");
    var renderEngine = require("../core/renderer/render-engine");
    var vfmtPosUvColor = require("../core/renderer/webgl/vertex-format").vfmtPosUvColor;
    var QuadBuffer = require("../core/renderer/webgl/quad-buffer");
    var RenderFlow = require("../core/renderer/render-flow");
    var particleSystemAssembler = {
      useModel: true,
      createIA: function(comp) {
        var device = renderer.device;
        comp._vertexFormat = vfmtPosUvColor;
        comp._buffer = new QuadBuffer(renderer._walker, vfmtPosUvColor);
        comp._ia = new renderEngine.InputAssembler();
        comp._ia._vertexBuffer = comp._buffer._vb;
        comp._ia._indexBuffer = comp._buffer._ib;
        comp._ia._start = 0;
        comp._ia._count = 0;
      },
      updateRenderData: function(comp) {
        if (!comp._renderData) {
          comp._renderData = new renderEngine.IARenderData();
          comp._renderData.ia = comp._ia;
        }
        comp._renderData.material = comp._material;
      },
      renderIA: function(comp, renderer) {
        renderer._flushIA(comp._renderData);
      }
    };
    ParticleSystem._assembler = particleSystemAssembler;
    module.exports = particleSystemAssembler;
  }), {
    "../core/platform/js": 175,
    "../core/renderer/": 196,
    "../core/renderer/render-engine": 197,
    "../core/renderer/render-flow": 198,
    "../core/renderer/webgl/quad-buffer": 220,
    "../core/renderer/webgl/vertex-format": 223,
    "./CCParticleSystem": 254
  } ],
  259: [ (function(require, module, exports) {
    var codec = require("../compression/ZipUtils");
    var zlib = require("../compression/zlib.min");
    var js = require("../core/platform/js");
    require("../core/platform/CCSAXParser");
    function uint8ArrayToUint32Array(uint8Arr) {
      if (uint8Arr.length % 4 !== 0) return null;
      var arrLen = uint8Arr.length / 4;
      var retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];
      for (var i = 0; i < arrLen; i++) {
        var offset = 4 * i;
        retArr[i] = uint8Arr[offset] + 256 * uint8Arr[offset + 1] + 65536 * uint8Arr[offset + 2] + uint8Arr[offset + 3] * (1 << 24);
      }
      return retArr;
    }
    cc.TMXLayerInfo = function() {
      this.properties = {};
      this.name = "";
      this._layerSize = null;
      this._tiles = [];
      this.visible = true;
      this._opacity = 0;
      this.ownTiles = true;
      this._minGID = 1e5;
      this._maxGID = 0;
      this.offset = cc.v2(0, 0);
    };
    cc.TMXLayerInfo.prototype = {
      constructor: cc.TMXLayerInfo,
      getProperties: function() {
        return this.properties;
      },
      setProperties: function(value) {
        this.properties = value;
      }
    };
    cc.TMXObjectGroupInfo = function() {
      this.properties = {};
      this.name = "";
      this._objects = [];
      this.visible = true;
      this._opacity = 0;
      this._color = new cc.Color(255, 255, 255, 255);
      this.offset = cc.v2(0, 0);
      this._draworder = "topdown";
    };
    cc.TMXObjectGroupInfo.prototype = {
      constructor: cc.TMXObjectGroupInfo,
      getProperties: function() {
        return this.properties;
      },
      setProperties: function(value) {
        this.properties = value;
      }
    };
    cc.TMXTilesetInfo = function() {
      this.name = "";
      this.firstGid = 0;
      this.spacing = 0;
      this.margin = 0;
      this.sourceImage = null;
      this.imageSize = cc.size(0, 0);
      this.tileOffset = cc.v2(0, 0);
      this._tileSize = cc.size(0, 0);
    };
    cc.TMXTilesetInfo.prototype = {
      constructor: cc.TMXTilesetInfo,
      rectForGID: function(gid, result) {
        var rect = result || cc.rect(0, 0, 0, 0);
        rect.width = this._tileSize.width;
        rect.height = this._tileSize.height;
        gid &= cc.TiledMap.TileFlag.FLIPPED_MASK;
        gid -= parseInt(this.firstGid, 10);
        var max_x = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        rect.x = parseInt(gid % max_x * (this._tileSize.width + this.spacing) + this.margin, 10);
        rect.y = parseInt(parseInt(gid / max_x, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
        return rect;
      }
    };
    function getPropertyList(node) {
      var res = [];
      var properties = node.getElementsByTagName("properties");
      for (var i = 0; i < properties.length; ++i) {
        var property = properties[i].getElementsByTagName("property");
        for (var j = 0; j < property.length; ++j) res.push(property[j]);
      }
      return res.length ? res : null;
    }
    cc.TMXMapInfo = function(tmxFile, tsxMap, textures) {
      this.properties = [];
      this.orientation = null;
      this.parentElement = null;
      this.parentGID = null;
      this.layerAttrs = 0;
      this.storingCharacters = false;
      this.currentString = null;
      this._parser = new cc.SAXParser();
      this._objectGroups = [];
      this._allChildren = [];
      this._mapSize = cc.size(0, 0);
      this._tileSize = cc.size(0, 0);
      this._layers = [];
      this._tilesets = [];
      this._tileProperties = {};
      this._tsxMap = null;
      this._textures = null;
      this._staggerAxis = null;
      this._staggerIndex = null;
      this._hexSideLength = 0;
      this.initWithXML(tmxFile, tsxMap, textures);
    };
    cc.TMXMapInfo.prototype = {
      constructor: cc.TMXMapInfo,
      getOrientation: function() {
        return this.orientation;
      },
      setOrientation: function(value) {
        this.orientation = value;
      },
      getStaggerAxis: function() {
        return this._staggerAxis;
      },
      setStaggerAxis: function(value) {
        this._staggerAxis = value;
      },
      getStaggerIndex: function() {
        return this._staggerIndex;
      },
      setStaggerIndex: function(value) {
        this._staggerIndex = value;
      },
      getHexSideLength: function() {
        return this._hexSideLength;
      },
      setHexSideLength: function(value) {
        this._hexSideLength = value;
      },
      getMapSize: function() {
        return cc.size(this._mapSize.width, this._mapSize.height);
      },
      setMapSize: function(value) {
        this._mapSize.width = value.width;
        this._mapSize.height = value.height;
      },
      _getMapWidth: function() {
        return this._mapSize.width;
      },
      _setMapWidth: function(width) {
        this._mapSize.width = width;
      },
      _getMapHeight: function() {
        return this._mapSize.height;
      },
      _setMapHeight: function(height) {
        this._mapSize.height = height;
      },
      getTileSize: function() {
        return cc.size(this._tileSize.width, this._tileSize.height);
      },
      setTileSize: function(value) {
        this._tileSize.width = value.width;
        this._tileSize.height = value.height;
      },
      _getTileWidth: function() {
        return this._tileSize.width;
      },
      _setTileWidth: function(width) {
        this._tileSize.width = width;
      },
      _getTileHeight: function() {
        return this._tileSize.height;
      },
      _setTileHeight: function(height) {
        this._tileSize.height = height;
      },
      getLayers: function() {
        return this._layers;
      },
      setLayers: function(value) {
        this._allChildren.push(value);
        this._layers.push(value);
      },
      getTilesets: function() {
        return this._tilesets;
      },
      setTilesets: function(value) {
        this._tilesets.push(value);
      },
      getObjectGroups: function() {
        return this._objectGroups;
      },
      setObjectGroups: function(value) {
        this._allChildren.push(value);
        this._objectGroups.push(value);
      },
      getAllChildren: function() {
        return this._allChildren;
      },
      getParentElement: function() {
        return this.parentElement;
      },
      setParentElement: function(value) {
        this.parentElement = value;
      },
      getParentGID: function() {
        return this.parentGID;
      },
      setParentGID: function(value) {
        this.parentGID = value;
      },
      getLayerAttribs: function() {
        return this.layerAttrs;
      },
      setLayerAttribs: function(value) {
        this.layerAttrs = value;
      },
      getStoringCharacters: function() {
        return this.storingCharacters;
      },
      setStoringCharacters: function(value) {
        this.storingCharacters = value;
      },
      getProperties: function() {
        return this.properties;
      },
      setProperties: function(value) {
        this.properties = value;
      },
      initWithXML: function(tmxString, tsxMap, textures) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this._tsxMap = tsxMap;
        this._textures = textures;
        this._objectGroups.length = 0;
        this._allChildren.length = 0;
        this.properties.length = 0;
        this._tileProperties.length = 0;
        this.currentString = "";
        this.storingCharacters = false;
        this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
        this.parentElement = cc.TiledMap.NONE;
        return this.parseXMLString(tmxString);
      },
      parseXMLString: function(xmlStr, tilesetFirstGid) {
        var mapXML = this._parser._parseXML(xmlStr);
        var i, j;
        var map = mapXML.documentElement;
        var version = map.getAttribute("version");
        var orientationStr = map.getAttribute("orientation");
        var staggerAxisStr = map.getAttribute("staggeraxis");
        var staggerIndexStr = map.getAttribute("staggerindex");
        var hexSideLengthStr = map.getAttribute("hexsidelength");
        if ("map" === map.nodeName) {
          "1.0" !== version && null !== version && cc.logID(7216, version);
          "orthogonal" === orientationStr ? this.orientation = cc.TiledMap.Orientation.ORTHO : "isometric" === orientationStr ? this.orientation = cc.TiledMap.Orientation.ISO : "hexagonal" === orientationStr ? this.orientation = cc.TiledMap.Orientation.HEX : null !== orientationStr && cc.logID(7217, orientationStr);
          "x" === staggerAxisStr ? this.setStaggerAxis(cc.TiledMap.StaggerAxis.STAGGERAXIS_X) : "y" === staggerAxisStr && this.setStaggerAxis(cc.TiledMap.StaggerAxis.STAGGERAXIS_Y);
          "odd" === staggerIndexStr ? this.setStaggerIndex(cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD) : "even" === staggerIndexStr && this.setStaggerIndex(cc.TiledMap.StaggerIndex.STAGGERINDEX_EVEN);
          hexSideLengthStr && this.setHexSideLength(parseFloat(hexSideLengthStr));
          var mapSize = cc.size(0, 0);
          mapSize.width = parseFloat(map.getAttribute("width"));
          mapSize.height = parseFloat(map.getAttribute("height"));
          this.setMapSize(mapSize);
          mapSize = cc.size(0, 0);
          mapSize.width = parseFloat(map.getAttribute("tilewidth"));
          mapSize.height = parseFloat(map.getAttribute("tileheight"));
          this.setTileSize(mapSize);
          var propertyArr = getPropertyList(map);
          if (propertyArr) {
            var aPropertyDict = {};
            for (i = 0; i < propertyArr.length; i++) aPropertyDict[propertyArr[i].getAttribute("name")] = propertyArr[i].getAttribute("value");
            this.properties = aPropertyDict;
          }
        }
        var tilesets = map.getElementsByTagName("tileset");
        if ("map" !== map.nodeName) {
          tilesets = [];
          tilesets.push(map);
        }
        for (i = 0; i < tilesets.length; i++) {
          var selTileset = tilesets[i];
          var tsxName = selTileset.getAttribute("source");
          if (tsxName) {
            var currentFirstGID = parseInt(selTileset.getAttribute("firstgid"));
            var tsxXmlString = this._tsxMap[tsxName];
            tsxXmlString && this.parseXMLString(tsxXmlString, currentFirstGID);
          } else {
            var tileset = new cc.TMXTilesetInfo();
            tileset.name = selTileset.getAttribute("name") || "";
            tileset.firstGid = tilesetFirstGid || (parseInt(selTileset.getAttribute("firstgid")) || 0);
            tileset.spacing = parseInt(selTileset.getAttribute("spacing")) || 0;
            tileset.margin = parseInt(selTileset.getAttribute("margin")) || 0;
            var tilesetSize = cc.size(0, 0);
            tilesetSize.width = parseFloat(selTileset.getAttribute("tilewidth"));
            tilesetSize.height = parseFloat(selTileset.getAttribute("tileheight"));
            tileset._tileSize = tilesetSize;
            var image = selTileset.getElementsByTagName("image")[0];
            var imagename = image.getAttribute("source");
            imagename.replace(/\\/g, "/");
            tileset.sourceImage = this._textures[imagename];
            tileset.sourceImage || cc.errorID(7221, imagename);
            this.setTilesets(tileset);
            var offset = selTileset.getElementsByTagName("tileoffset")[0];
            if (offset) {
              var offsetX = parseFloat(offset.getAttribute("x"));
              var offsetY = parseFloat(offset.getAttribute("y"));
              tileset.tileOffset = cc.v2(offsetX, offsetY);
            }
            var tiles = selTileset.getElementsByTagName("tile");
            if (tiles) for (var tIdx = 0; tIdx < tiles.length; tIdx++) {
              var t = tiles[tIdx];
              this.parentGID = parseInt(tileset.firstGid) + parseInt(t.getAttribute("id") || 0);
              var tp = getPropertyList(t);
              if (tp) {
                var dict = {};
                for (j = 0; j < tp.length; j++) {
                  var name = tp[j].getAttribute("name");
                  dict[name] = tp[j].getAttribute("value");
                }
                this._tileProperties[this.parentGID] = dict;
              }
            }
          }
        }
        var childNodes = map.childNodes;
        for (i = 0; i < childNodes.length; i++) {
          var childNode = childNodes[i];
          if (this._shouldIgnoreNode(childNode)) continue;
          if ("layer" === childNode.nodeName) {
            var layer = this._parseLayer(childNode);
            this.setLayers(layer);
          }
          if ("objectgroup" === childNode.nodeName) {
            var objectGroup = this._parseObjectGroup(childNode);
            this.setObjectGroups(objectGroup);
          }
        }
        return map;
      },
      _shouldIgnoreNode: function(node) {
        return 3 === node.nodeType || 8 === node.nodeType || 4 === node.nodeType;
      },
      _parseLayer: function(selLayer) {
        var data = selLayer.getElementsByTagName("data")[0];
        var layer = new cc.TMXLayerInfo();
        layer.name = selLayer.getAttribute("name");
        var layerSize = cc.size(0, 0);
        layerSize.width = parseFloat(selLayer.getAttribute("width"));
        layerSize.height = parseFloat(selLayer.getAttribute("height"));
        layer._layerSize = layerSize;
        var visible = selLayer.getAttribute("visible");
        layer.visible = !("0" == visible);
        var opacity = selLayer.getAttribute("opacity") || 1;
        layer._opacity = opacity ? parseInt(255 * parseFloat(opacity)) : 255;
        layer.offset = cc.v2(parseFloat(selLayer.getAttribute("x")) || 0, parseFloat(selLayer.getAttribute("y")) || 0);
        var nodeValue = "";
        for (var j = 0; j < data.childNodes.length; j++) nodeValue += data.childNodes[j].nodeValue;
        nodeValue = nodeValue.trim();
        var compression = data.getAttribute("compression");
        var encoding = data.getAttribute("encoding");
        if (compression && "gzip" !== compression && "zlib" !== compression) {
          cc.logID(7218);
          return null;
        }
        var tiles = void 0;
        switch (compression) {
         case "gzip":
          tiles = codec.unzipBase64AsArray(nodeValue, 4);
          break;

         case "zlib":
          var inflator = new zlib.Inflate(codec.Base64.decodeAsArray(nodeValue, 1));
          tiles = uint8ArrayToUint32Array(inflator.decompress());
          break;

         case null:
         case "":
          if ("base64" === encoding) tiles = codec.Base64.decodeAsArray(nodeValue, 4); else if ("csv" === encoding) {
            tiles = [];
            var csvTiles = nodeValue.split(",");
            for (var csvIdx = 0; csvIdx < csvTiles.length; csvIdx++) tiles.push(parseInt(csvTiles[csvIdx]));
          } else {
            var selDataTiles = data.getElementsByTagName("tile");
            tiles = [];
            for (var xmlIdx = 0; xmlIdx < selDataTiles.length; xmlIdx++) tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute("gid")));
          }
          break;

         default:
          this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.logID(7219);
        }
        tiles && (layer._tiles = new Uint32Array(tiles));
        var layerProps = getPropertyList(selLayer);
        if (layerProps) {
          var layerProp = {};
          for (var _j = 0; _j < layerProps.length; _j++) layerProp[layerProps[_j].getAttribute("name")] = layerProps[_j].getAttribute("value");
          layer.properties = layerProp;
        }
        return layer;
      },
      _parseObjectGroup: function(selGroup) {
        var objectGroup = new cc.TMXObjectGroupInfo();
        objectGroup.name = selGroup.getAttribute("name") || "";
        objectGroup.offset = cc.v2(parseFloat(selGroup.getAttribute("offsetx")), parseFloat(selGroup.getAttribute("offsety")));
        var opacity = selGroup.getAttribute("opacity") || 1;
        objectGroup._opacity = opacity ? parseInt(255 * parseFloat(opacity)) : 255;
        var visible = selGroup.getAttribute("visible");
        visible && 0 === parseInt(visible) && (objectGroup.visible = false);
        var color = selGroup.getAttribute("color");
        color && (objectGroup._color = cc.hexToColor(color));
        var draworder = selGroup.getAttribute("draworder");
        draworder && (objectGroup._draworder = draworder);
        var groupProps = getPropertyList(selGroup);
        if (groupProps) {
          var parsedProps = {};
          for (var j = 0; j < groupProps.length; j++) parsedProps[groupProps[j].getAttribute("name")] = groupProps[j].getAttribute("value");
          objectGroup.setProperties(parsedProps);
        }
        var objects = selGroup.getElementsByTagName("object");
        if (objects) for (var _j2 = 0; _j2 < objects.length; _j2++) {
          var selObj = objects[_j2];
          var objectProp = {};
          objectProp["id"] = selObj.getAttribute("id") || 0;
          objectProp["name"] = selObj.getAttribute("name") || "";
          objectProp["width"] = parseFloat(selObj.getAttribute("width")) || 0;
          objectProp["height"] = parseFloat(selObj.getAttribute("height")) || 0;
          objectProp["x"] = selObj.getAttribute("x") || 0;
          objectProp["y"] = selObj.getAttribute("y") || 0;
          objectProp["rotation"] = parseFloat(selObj.getAttribute("rotation")) || 0;
          var docObjProps = getPropertyList(selObj);
          if (docObjProps) for (var k = 0; k < docObjProps.length; k++) objectProp[docObjProps[k].getAttribute("name")] = docObjProps[k].getAttribute("value");
          var visibleAttr = selObj.getAttribute("visible");
          objectProp["visible"] = !(visibleAttr && 0 === parseInt(visibleAttr));
          var gid = selObj.getAttribute("gid");
          if (gid) {
            objectProp["gid"] = parseInt(gid);
            objectProp["type"] = cc.TiledMap.TMXObjectType.IMAGE;
          }
          var ellipse = selObj.getElementsByTagName("ellipse");
          ellipse && ellipse.length > 0 && (objectProp["type"] = cc.TiledMap.TMXObjectType.ELLIPSE);
          var polygonProps = selObj.getElementsByTagName("polygon");
          if (polygonProps && polygonProps.length > 0) {
            objectProp["type"] = cc.TiledMap.TMXObjectType.POLYGON;
            var selPgPointStr = polygonProps[0].getAttribute("points");
            selPgPointStr && (objectProp["points"] = this._parsePointsString(selPgPointStr));
          }
          var polylineProps = selObj.getElementsByTagName("polyline");
          if (polylineProps && polylineProps.length > 0) {
            objectProp["type"] = cc.TiledMap.TMXObjectType.POLYLINE;
            var selPlPointStr = polylineProps[0].getAttribute("points");
            selPlPointStr && (objectProp["polylinePoints"] = this._parsePointsString(selPlPointStr));
          }
          objectProp["type"] || (objectProp["type"] = cc.TiledMap.TMXObjectType.RECT);
          objectGroup._objects.push(objectProp);
        }
        return objectGroup;
      },
      _parsePointsString: function(pointsString) {
        if (!pointsString) return null;
        var points = [];
        var pointsStr = pointsString.split(" ");
        for (var i = 0; i < pointsStr.length; i++) {
          var selPointStr = pointsStr[i].split(",");
          points.push({
            x: parseFloat(selPointStr[0]),
            y: parseFloat(selPointStr[1])
          });
        }
        return points;
      },
      getTileProperties: function() {
        return this._tileProperties;
      },
      setTileProperties: function(tileProperties) {
        this._tileProperties.push(tileProperties);
      },
      getCurrentString: function() {
        return this.currentString;
      },
      setCurrentString: function(currentString) {
        this.currentString = currentString;
      }
    };
    var _p = cc.TMXMapInfo.prototype;
    js.getset(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
    js.getset(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
    js.getset(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
    js.getset(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
    cc.TMXLayerInfo.ATTRIB_NONE = 1;
    cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
    cc.TMXLayerInfo.ATTRIB_GZIP = 4;
    cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
  }), {
    "../compression/ZipUtils": 24,
    "../compression/zlib.min": 27,
    "../core/platform/CCSAXParser": 162,
    "../core/platform/js": 175
  } ],
  260: [ (function(require, module, exports) {
    var RenderComponent = require("../core/components/CCRenderComponent");
    var renderer = require("../core/renderer");
    var renderEngine = require("../core/renderer/render-engine");
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var TiledLayer = cc.Class({
      name: "cc.TiledLayer",
      extends: RenderComponent,
      ctor: function() {
        this._tiles = [];
        this._texGrids = [];
        this._textures = [];
        this._spriteTiles = {};
        this._tiledTiles = [];
        this._layerName = "";
        this._layerOrientation = null;
      },
      getLayerName: function() {
        return this._layerName;
      },
      setLayerName: function(layerName) {
        this._layerName = layerName;
      },
      getProperty: function(propertyName) {
        return this._properties[propertyName];
      },
      getPositionAt: function(pos, y) {
        var x = void 0;
        if (void 0 !== y) {
          x = Math.floor(pos);
          y = Math.floor(y);
        } else {
          x = Math.floor(pos.x);
          y = Math.floor(pos.y);
        }
        var ret = void 0;
        switch (this._layerOrientation) {
         case cc.TiledMap.Orientation.ORTHO:
          ret = this._positionForOrthoAt(x, y);
          break;

         case cc.TiledMap.Orientation.ISO:
          ret = this._positionForIsoAt(x, y);
          break;

         case cc.TiledMap.Orientation.HEX:
          ret = this._positionForHexAt(x, y);
        }
        return ret;
      },
      _positionForIsoAt: function(x, y) {
        return cc.v2(this._mapTileSize.width / 2 * (this._layerSize.width + x - y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - x - y - 2));
      },
      _positionForOrthoAt: function(x, y) {
        return cc.v2(x * this._mapTileSize.width, (this._layerSize.height - y - 1) * this._mapTileSize.height);
      },
      _positionForHexAt: function(x, y) {
        var xy = void 0;
        var offset = this._tileset.tileOffset;
        var odd_even = this._staggerIndex === cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
        switch (this._staggerAxis) {
         case cc.TiledMap.StaggerAxis.STAGGERAXIS_Y:
          var diffX = 0;
          y % 2 === 1 && (diffX = this._mapTileSize.width / 2 * odd_even);
          xy = cc.v2(x * this._mapTileSize.width + diffX + offset.x, (this._layerSize.height - y - 1) * (this._mapTileSize.height - (this._mapTileSize.height - this._hexSideLength) / 2) - offset.y);
          break;

         case cc.TiledMap.StaggerAxis.STAGGERAXIS_X:
          var diffY = 0;
          x % 2 === 1 && (diffY = this._mapTileSize.height / 2 * -odd_even);
          xy = cc.v2(x * (this._mapTileSize.width - (this._mapTileSize.width - this._hexSideLength) / 2) + offset.x, (this._layerSize.height - y - 1) * this._mapTileSize.height + diffY - offset.y);
          break;

         default:
          xy = cc.v2(0, 0);
        }
        return xy;
      },
      setTileGIDAt: function(gid, posOrX, flagsOrY, flags) {
        if (void 0 === posOrX) throw new Error("_ccsg.TMXLayer.setTileGID(): pos should be non-null");
        var pos = void 0;
        if (void 0 === flags && posOrX instanceof cc.Vec2) {
          pos = posOrX;
          flags = flagsOrY;
        } else pos = cc.v2(posOrX, flagsOrY);
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) throw new Error("CCTiledLayer.setTileGID(): invalid position");
        if (!this._tiles) {
          cc.logID(7206);
          return;
        }
        if (0 !== gid && gid < this._tileset.firstGid) {
          cc.logID(7207, gid);
          return;
        }
        flags = flags || 0;
        var currentFlags = this.getTileFlagsAt(pos);
        var currentGID = this.getTileGIDAt(pos);
        if (currentGID === gid && currentFlags === flags) return;
        var gidAndFlags = (gid | flags) >>> 0;
        this._updateTileForGID(gidAndFlags, pos);
      },
      _updateTileForGID: function(gid, pos) {
        if (!this._texGrids[gid]) return;
        var idx = 0 | pos.x + pos.y * this._layerSize.width;
        idx < this._tiles.length && (this._tiles[idx] = gid);
      },
      getTileGIDAt: function(pos, y) {
        if (void 0 === pos) throw new Error("_ccsg.TMXLayer.getTileGIDAt(): pos should be non-null");
        var x = pos;
        if (void 0 === y) {
          x = pos.x;
          y = pos.y;
        }
        if (x >= this._layerSize.width || y >= this._layerSize.height || x < 0 || y < 0) throw new Error("_ccsg.TMXLayer.getTileGIDAt(): invalid position");
        if (!this._tiles) {
          cc.logID(7205);
          return null;
        }
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        var tile = this._tiles[index];
        return (tile & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0;
      },
      getTileFlagsAt: function(pos, y) {
        if (!pos) throw new Error("_ccsg.TMXLayer.getTileFlagsAt(): pos should be non-null");
        void 0 !== y && (pos = cc.v2(pos, y));
        if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) throw new Error("_ccsg.TMXLayer.getTileFlagsAt(): invalid position");
        if (!this._tiles) {
          cc.logID(7208);
          return null;
        }
        var idx = Math.floor(pos.x) + Math.floor(pos.y) * this._layerSize.width;
        var tile = this._tiles[idx];
        return (tile & cc.TiledMap.TileFlag.FLIPPED_ALL) >>> 0;
      },
      getTiledTileAt: function(pos, y) {
        if (void 0 === pos) throw new Error("_ccsg.TMXLayer.getTileAt(): pos should be non-null");
        var x = pos;
        if (void 0 === y) {
          x = pos.x;
          y = pos.y;
        }
        if (x >= this._layerSize.width || y >= this._layerSize.height || x < 0 || y < 0) throw new Error("_ccsg.TMXLayer.getTileAt(): invalid position");
        if (!this._tiles) {
          cc.logID(7204);
          return null;
        }
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        return this._tiledTiles[index];
      },
      setTiledTileAt: function(pos, y, tiledTile) {
        if (void 0 === pos) throw new Error("_ccsg.TMXLayer.getTileAt(): pos should be non-null");
        var x = pos;
        if (void 0 === y) {
          x = pos.x;
          y = pos.y;
        }
        if (x >= this._layerSize.width || y >= this._layerSize.height || x < 0 || y < 0) throw new Error("_ccsg.TMXLayer.getTileAt(): invalid position");
        if (!this._tiles) {
          cc.logID(7204);
          return null;
        }
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        return this._tiledTiles[index] = tiledTile;
      },
      getTexture: function() {
        return this._texture;
      },
      setTexture: function(texture) {
        this._texture = texture;
        this._activateMaterial();
      },
      getLayerSize: function() {
        return this._layerSize;
      },
      getMapTileSize: function() {
        return this._mapTileSize;
      },
      getTileSet: function() {
        return this._tileset;
      },
      setTileSet: function(tileset) {
        this._tileset = tileset;
      },
      getLayerOrientation: function() {
        return this._layerOrientation;
      },
      getProperties: function() {
        return this._properties;
      },
      _init: function(tileset, layerInfo, mapInfo) {
        var size = layerInfo._layerSize;
        this._layerName = layerInfo.name;
        this._tiles = layerInfo._tiles;
        this._properties = layerInfo.properties;
        this._layerSize = size;
        this._minGID = layerInfo._minGID;
        this._maxGID = layerInfo._maxGID;
        this._opacity = layerInfo._opacity;
        this._staggerAxis = mapInfo.getStaggerAxis();
        this._staggerIndex = mapInfo.getStaggerIndex();
        this._hexSideLength = mapInfo.getHexSideLength();
        this._tileset = tileset;
        this._layerOrientation = mapInfo.orientation;
        this._mapTileSize = mapInfo.getTileSize();
        var tilesets = mapInfo._tilesets;
        if (tilesets) {
          this._textures.length = tilesets.length;
          this._texGrids.length = 0;
          for (var i = 0, l = tilesets.length; i < l; ++i) {
            var tilesetInfo = tilesets[i];
            var tex = tilesetInfo.sourceImage;
            this._textures[i] = tex;
            this._fillTextureGrids(tilesetInfo, i);
            tileset === tilesetInfo && (this._texture = tex);
          }
        }
        this._offset = this._calculateLayerOffset(layerInfo.offset);
        if (this.layerOrientation === cc.TiledMap.Orientation.HEX) {
          var width = 0, height = 0;
          if (this._staggerAxis === cc.TiledMap.StaggerAxis.STAGGERAXIS_X) {
            height = mapInfo._tileSize.height * (this._layerSize.height + .5);
            width = (mapInfo._tileSize.width + this._hexSideLength) * Math.floor(this._layerSize.width / 2) + mapInfo._tileSize.width * (this._layerSize.width % 2);
          } else {
            width = mapInfo._tileSize.width * (this._layerSize.width + .5);
            height = (mapInfo._tileSize.height + this._hexSideLength) * Math.floor(this._layerSize.height / 2) + mapInfo._tileSize.height * (this._layerSize.height % 2);
          }
          this.node.setContentSize(width, height);
        } else this.node.setContentSize(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height);
        this._useAutomaticVertexZ = false;
        this._vertexZvalue = 0;
        this._activateMaterial();
      },
      _calculateLayerOffset: function(pos) {
        var ret = cc.v2(0, 0);
        switch (this.layerOrientation) {
         case cc.TiledMap.Orientation.ORTHO:
          ret = cc.v2(pos.x * this._mapTileSize.width, -pos.y * this._mapTileSize.height);
          break;

         case cc.TiledMap.Orientation.ISO:
          ret = cc.v2(this._mapTileSize.width / 2 * (pos.x - pos.y), this._mapTileSize.height / 2 * (-pos.x - pos.y));
          break;

         case cc.TiledMap.Orientation.HEX:
          if (this._staggerAxis === cc.TiledMap.StaggerAxis.STAGGERAXIS_Y) {
            var diffX = this._staggerIndex === cc.TiledMap.StaggerIndex.STAGGERINDEX_EVEN ? this._mapTileSize.width / 2 : 0;
            ret = cc.v2(pos.x * this._mapTileSize.width + diffX, -pos.y * (this._mapTileSize.height - (this._mapTileSize.width - this._hexSideLength) / 2));
          } else if (this._staggerAxis === cc.TiledMap.StaggerAxis.STAGGERAXIS_X) {
            var diffY = this._staggerIndex === cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD ? this._mapTileSize.height / 2 : 0;
            ret = cc.v2(pos.x * (this._mapTileSize.width - (this._mapTileSize.width - this._hexSideLength) / 2), -pos.y * this._mapTileSize.height + diffY);
          }
        }
        return ret;
      },
      _fillTextureGrids: function(tileset, texId) {
        var tex = this._textures[texId];
        if (!tex.loaded) {
          tex.once("load", (function() {
            this._fillTextureGrids(tileset, texId);
          }), this);
          return;
        }
        if (!tileset.imageSize.width || !tileset.imageSize.height) {
          tileset.imageSize.width = tex.width;
          tileset.imageSize.height = tex.height;
        }
        var tw = tileset._tileSize.width, th = tileset._tileSize.height, imageW = tex.width, imageH = tex.height, spacing = tileset.spacing, margin = tileset.margin, cols = Math.floor((imageW - 2 * margin + spacing) / (tw + spacing)), rows = Math.floor((imageH - 2 * margin + spacing) / (th + spacing)), count = rows * cols, gid = tileset.firstGid, maxGid = tileset.firstGid + count, grids = this._texGrids, grid = null, override = !!grids[gid], texelCorrect = cc.macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX ? .5 : 0;
        for (;gid < maxGid; ++gid) {
          override && !grids[gid] && (override = false);
          if (!override && grids[gid]) break;
          grid = {
            texId: texId,
            x: 0,
            y: 0,
            width: tw,
            height: th,
            t: 0,
            l: 0,
            r: 0,
            b: 0
          };
          tileset.rectForGID(gid, grid);
          grid.x += texelCorrect;
          grid.y += texelCorrect;
          grid.width -= 2 * texelCorrect;
          grid.height -= 2 * texelCorrect;
          grid.t = grid.y / imageH;
          grid.l = grid.x / imageW;
          grid.r = (grid.x + grid.width) / imageW;
          grid.b = (grid.y + grid.height) / imageH;
          grids[gid] = grid;
        }
      },
      _activateMaterial: function() {
        var material = this._material;
        if (!material) {
          material = this._material = new SpriteMaterial();
          material.useColor = false;
        }
        if (this._texture) {
          material.texture = this._texture;
          this.markForUpdateRenderData(true);
          this.markForRender(true);
        } else this.disableRender();
        this.setMaterial(material);
      }
    });
    cc.TiledLayer = module.exports = TiledLayer;
  }), {
    "../core/components/CCRenderComponent": 77,
    "../core/renderer": 196,
    "../core/renderer/render-engine": 197
  } ],
  261: [ (function(require, module, exports) {
    require("./CCTMXXMLParser");
    require("./CCTiledMapAsset");
    require("./CCTiledLayer");
    require("./CCTiledTile");
    require("./CCTiledObjectGroup");
    var Orientation = cc.Enum({
      ORTHO: 0,
      HEX: 1,
      ISO: 2
    });
    var Property = cc.Enum({
      NONE: 0,
      MAP: 1,
      LAYER: 2,
      OBJECTGROUP: 3,
      OBJECT: 4,
      TILE: 5
    });
    var TileFlag = cc.Enum({
      HORIZONTAL: 2147483648,
      VERTICAL: 1073741824,
      DIAGONAL: 536870912,
      FLIPPED_ALL: 3758096384,
      FLIPPED_MASK: 536870911
    });
    var StaggerAxis = cc.Enum({
      STAGGERAXIS_X: 0,
      STAGGERAXIS_Y: 1
    });
    var StaggerIndex = cc.Enum({
      STAGGERINDEX_ODD: 0,
      STAGGERINDEX_EVEN: 1
    });
    var TMXObjectType = cc.Enum({
      RECT: 0,
      ELLIPSE: 1,
      POLYGON: 2,
      POLYLINE: 3,
      IMAGE: 4
    });
    var TiledMap = cc.Class({
      name: "cc.TiledMap",
      extends: cc.Component,
      editor: false,
      ctor: function() {
        this._layers = [];
        this._groups = [];
        this._properties = [];
        this._tileProperties = [];
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
      },
      statics: {
        Orientation: Orientation,
        Property: Property,
        TileFlag: TileFlag,
        StaggerAxis: StaggerAxis,
        StaggerIndex: StaggerIndex,
        TMXObjectType: TMXObjectType
      },
      properties: {
        _tmxFile: {
          default: null,
          type: cc.TiledMapAsset
        },
        tmxAsset: {
          get: function() {
            return this._tmxFile;
          },
          set: function(value, force) {
            if (this._tmxFile !== value || false) {
              this._tmxFile = value;
              this._applyFile();
            }
          },
          type: cc.TiledMapAsset
        }
      },
      getMapSize: function() {
        return this._mapSize;
      },
      getTileSize: function() {
        return this._tileSize;
      },
      getMapOrientation: function() {
        return this._mapOrientation;
      },
      getObjectGroups: function() {
        return this._groups;
      },
      getObjectGroup: function(groupName) {
        var groups = this._groups;
        for (var i = 0, l = groups.length; i < l; i++) {
          var group = groups[i];
          if (group && group.getGroupName() === groupName) return group;
        }
        return null;
      },
      getProperties: function() {
        return this._properties;
      },
      getLayers: function() {
        return this._layers;
      },
      getLayer: function(layerName) {
        var layers = this._layers;
        for (var i = 0, l = layers.length; i < l; i++) {
          var layer = layers[i];
          if (layer && layer.getLayerName() === layerName) return layer;
        }
        return null;
      },
      getProperty: function(propertyName) {
        return this._properties[propertyName.toString()];
      },
      getPropertiesForGID: function(GID) {
        return this._tileProperties[GID];
      },
      onEnable: function() {
        this._tmxFile && this._applyFile();
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
      },
      onDisable: function() {
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
      },
      _applyFile: function() {
        var file = this._tmxFile;
        var self = this;
        if (file) {
          var texValues = file.textures;
          var texKeys = file.textureNames;
          var textures = {};
          for (var i = 0; i < texValues.length; ++i) textures[texKeys[i]] = texValues[i];
          var tsxFileNames = file.tsxFileNames;
          var tsxFiles = file.tsxFiles;
          var tsxMap = {};
          for (var _i = 0; _i < tsxFileNames.length; ++_i) tsxFileNames[_i].length > 0 && (tsxMap[tsxFileNames[_i]] = tsxFiles[_i].text);
          var mapInfo = new cc.TMXMapInfo(file.tmxXmlStr, tsxMap, textures);
          var tilesets = mapInfo.getTilesets();
          tilesets && 0 !== tilesets.length || cc.logID(7213);
          this._buildWithMapInfo(mapInfo);
        }
      },
      _syncAnchorPoint: function() {
        var anchor = this.node.getAnchorPoint();
        for (var i = 0, l = this._layers.length; i < l; i++) this._layers[i].node.setAnchorPoint(anchor);
      },
      _buildWithMapInfo: function(mapInfo) {
        this._mapSize = mapInfo.getMapSize();
        this._tileSize = mapInfo.getTileSize();
        this._mapOrientation = mapInfo.orientation;
        this._properties = mapInfo.properties;
        this._tileProperties = mapInfo.getTileProperties();
        var layers = this._layers;
        for (var i = 0, l = layers.length; i < l; i++) layers[i].node.removeFromParent();
        layers.length = 0;
        var groups = this._groups;
        for (var _i2 = 0, _l = groups.length; _i2 < _l; _i2++) groups[_i2].node.removeFromParent();
        groups.length = 0;
        var node = this.node;
        var layerInfos = mapInfo.getAllChildren();
        if (layerInfos && layerInfos.length > 0) for (var _i3 = 0, len = layerInfos.length; _i3 < len; _i3++) {
          var layerInfo = layerInfos[_i3];
          var name = layerInfo.name;
          var child = this.node.getChildByName(name);
          if (!child) {
            child = new cc.Node();
            child.name = name;
            node.addChild(child);
          }
          if (layerInfo instanceof cc.TMXLayerInfo && layerInfo.visible) {
            var layer = child.getComponent(cc.TiledLayer);
            layer || (layer = child.addComponent(cc.TiledLayer));
            var tileset = this._tilesetForLayer(layerInfo, mapInfo);
            layer._init(tileset, layerInfo, mapInfo);
            layerInfo.ownTiles = false;
            this.node.width = Math.max(this.node.width, child.width);
            this.node.height = Math.max(this.node.height, child.height);
            layers.push(layer);
          } else if (layerInfo instanceof cc.TMXObjectGroupInfo) {
            var group = child.getComponent(cc.TiledObjectGroup);
            group || (group = child.addComponent(cc.TiledObjectGroup));
            group._init(layerInfo, mapInfo);
            groups.push(group);
          }
        }
        this._syncAnchorPoint();
      },
      _tilesetForLayer: function(layerInfo, mapInfo) {
        var size = layerInfo._layerSize;
        var tilesets = mapInfo.getTilesets();
        if (tilesets) for (var i = tilesets.length - 1; i >= 0; i--) {
          var tileset = tilesets[i];
          if (tileset) for (var y = 0; y < size.height; y++) for (var x = 0; x < size.width; x++) {
            var pos = x + size.width * y;
            var gid = layerInfo._tiles[pos];
            if (0 !== gid && (gid & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0 >= tileset.firstGid) return tileset;
          }
        }
        cc.logID(7215, layerInfo.name);
        return null;
      }
    });
    cc.TiledMap = module.exports = TiledMap;
    cc.js.obsolete(cc.TiledMap.prototype, "cc.TiledMap.tmxFile", "tmxAsset", true);
    cc.js.get(cc.TiledMap.prototype, "mapLoaded", (function() {
      cc.errorID(7203);
      return [];
    }), false);
  }), {
    "./CCTMXXMLParser": 259,
    "./CCTiledLayer": 260,
    "./CCTiledMapAsset": 262,
    "./CCTiledObjectGroup": 263,
    "./CCTiledTile": 264
  } ],
  262: [ (function(require, module, exports) {
    var TiledMapAsset = cc.Class({
      name: "cc.TiledMapAsset",
      extends: cc.Asset,
      properties: {
        tmxXmlStr: "",
        textures: {
          default: [],
          type: [ cc.Texture2D ]
        },
        textureNames: [ cc.String ],
        tsxFiles: [ cc.TextAsset ],
        tsxFileNames: [ cc.String ]
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      createNode: false
    });
    cc.TiledMapAsset = TiledMapAsset;
    module.exports = TiledMapAsset;
  }), {} ],
  263: [ (function(require, module, exports) {
    var TiledObjectGroup = cc.Class({
      name: "cc.TiledObjectGroup",
      extends: cc.Component,
      getPositionOffset: function() {
        return this._positionOffset;
      },
      getProperties: function() {
        this._properties;
      },
      getGroupName: function() {
        return this._groupName;
      },
      getProperty: function(propertyName) {
        return this._properties[propertyName.toString()];
      },
      getObject: function(objectName) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          var obj = this._objects[i];
          if (obj && obj.name === objectName) return obj;
        }
        return null;
      },
      getObjects: function() {
        return this._objects;
      },
      _init: function(groupInfo, mapInfo) {
        this._groupName = groupInfo.name;
        this._positionOffset = groupInfo.offset;
        this._mapInfo = mapInfo;
        this._properties = groupInfo.getProperties();
        var mapSize = mapInfo._mapSize;
        var tileSize = mapInfo._tileSize;
        var width = 0, height = 0;
        if (mapInfo.orientation === cc.TiledMap.Orientation.HEX) if (mapInfo.getStaggerAxis() === cc.TiledMap.StaggerAxis.STAGGERAXIS_X) {
          height = tileSize.height * (mapSize.height + .5);
          width = (tileSize.width + mapInfo.getHexSideLength()) * Math.floor(mapSize.width / 2) + tileSize.width * (mapSize.width % 2);
        } else {
          width = tileSize.width * (mapSize.width + .5);
          height = (tileSize.height + mapInfo.getHexSideLength()) * Math.floor(mapSize.height / 2) + tileSize.height * (mapSize.height % 2);
        } else {
          width = mapSize.width * tileSize.width;
          height = mapSize.height * tileSize.height;
        }
        this.node.setContentSize(width, height);
        var objects = groupInfo._objects;
        for (var i = 0, l = objects.length; i < l; i++) {
          var object = objects[i];
          if (cc.TiledMap.Orientation.ISO !== this._mapOrientation) object.y = height - object.y; else {
            var _mapSize = mapInfo.getMapSize();
            var _tileSize = mapInfo.getTileSize();
            var posIdxX = (this._container.offset.x + offset.x) / _tileSize.width * 2;
            var posIdxY = (this._container.offset.y + offset.y) / _tileSize.height;
            object.x = _tileSize.width / 2 * (_mapSize.width + posIdxX - posIdxY);
            object.y = _tileSize.height / 2 * (2 * _mapSize.height - posIdxX - posIdxY);
          }
        }
        this._objects = objects;
      }
    });
    cc.TiledObjectGroup = module.exports = TiledObjectGroup;
  }), {} ],
  264: [ (function(require, module, exports) {
    var TiledTile = cc.Class({
      name: "cc.TiledTile",
      extends: cc.Component,
      editor: false,
      properties: {
        _x: 0,
        _y: 0,
        _gid: 0,
        _layer: null,
        x: {
          get: function() {
            return this._x;
          },
          set: function(value) {
            if (value === this._x) return;
            this._resetTile();
            this._x = value;
            this._updateInfo();
          }
        },
        y: {
          get: function() {
            return this._y;
          },
          set: function(value) {
            if (value === this._y) return;
            this._resetTile();
            this._y = value;
            this._updateInfo();
          }
        },
        gid: {
          get: function() {
            return this._gid;
          },
          set: function(value) {
            this._gid = value;
          }
        },
        layer: {
          type: cc.TiledLayer,
          get: function() {
            return this._layer;
          },
          set: function(value) {
            if (value === this._layer) return;
            this._resetTile();
            this._layer = value;
            this._updateInfo();
          }
        }
      },
      onEnable: function() {
        false;
        this._layer && this._layer.setTiledTileAt(this._x, this._y, this);
      },
      onDisable: function() {
        this._resetTile();
      },
      _resetTile: function() {
        this._layer && this._layer.getTiledTileAt(this._x, this._y) === this && this._layer.setTiledTileAt(this._x, this._y, null);
      },
      _updateInfo: function() {
        if (!this._layer) return;
        var x = this._x, y = this._y;
        if (this._layer.getTiledTileAt(x, y)) {
          cc.warn("There is already a TiledTile at [%s, %s]", x, y);
          return;
        }
        this.node.setPosition(this._layer.getPositionAt(x, y));
        this._gid = this._layer.getTileGIDAt(x, y);
        this._layer.setTiledTileAt(x, y, this);
      }
    });
  }), {} ],
  265: [ (function(require, module, exports) {
    require("./CCTiledMap");
    require("./tmx-layer-assembler");
  }), {
    "./CCTiledMap": 261,
    "./tmx-layer-assembler": 266
  } ],
  266: [ (function(require, module, exports) {
    var TiledLayer = require("./CCTiledLayer");
    var TiledMap = require("./CCTiledMap");
    var js = require("../core/platform/js");
    var renderEngine = require("../core/renderer/render-engine");
    var RenderFlow = require("../core/renderer/render-flow");
    var vfmtPosUvColor = require("../../cocos2d/core/renderer/webgl/vertex-format").vfmtPosUvColor;
    var Orientation = TiledMap.Orientation;
    var TileFlag = TiledMap.TileFlag;
    var FLIPPED_MASK = TileFlag.FLIPPED_MASK;
    var StaggerAxis = TiledMap.StaggerAxis;
    var StaggerIndex = TiledMap.StaggerIndex;
    var math = renderEngine.math;
    var mat4 = math.mat4;
    var vec3 = math.vec3;
    var _mat4_temp = mat4.create();
    var _mat4_temp2 = mat4.create();
    var _vec3_temp = vec3.create();
    var tmxAssembler = {
      updateRenderData: function(comp) {
        var renderData = comp._renderData;
        renderData || (renderData = comp._renderData = comp.requestRenderData());
        var size = comp.node._contentSize;
        var anchor = comp.node._anchorPoint;
        renderData.updateSizeNPivot(size.width, size.height, anchor.x, anchor.y);
        renderData.material = comp.getMaterial();
        this.updateVertices(comp);
      },
      fillBuffers: function(comp, renderer) {
        var renderData = comp._renderData;
        var data = renderData._data;
        var buffer = renderer.getBuffer("mesh", vfmtPosUvColor), vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData, vertexCount = renderData.vertexCount;
        var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
        buffer.request(vertexCount, renderData.indiceCount);
        for (var i = 0, l = renderData.vertexCount; i < l; i++) {
          var vert = data[i];
          vbuf[vertexOffset++] = vert.x;
          vbuf[vertexOffset++] = vert.y;
          vbuf[vertexOffset++] = vert.u;
          vbuf[vertexOffset++] = vert.v;
          uintbuf[vertexOffset++] = vert.color;
        }
        for (var _i = 0, _l = renderData.indiceCount; _i < _l; _i += 6) {
          ibuf[indiceOffset++] = vertexId;
          ibuf[indiceOffset++] = vertexId + 1;
          ibuf[indiceOffset++] = vertexId + 2;
          ibuf[indiceOffset++] = vertexId + 1;
          ibuf[indiceOffset++] = vertexId + 3;
          ibuf[indiceOffset++] = vertexId + 2;
          vertexId += 4;
        }
        comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      },
      updateVertices: function(comp) {
        var node = comp.node;
        var renderData = comp._renderData;
        var data = renderData._data;
        var color = node._color._val;
        renderData.dataLength = renderData.vertexCount = renderData.indiceCount = 0;
        var layerOrientation = comp._layerOrientation, tiles = comp._tiles;
        if (!tiles || !comp._tileset) return;
        var appx = node._anchorPoint.x * node._contentSize.width, appy = node._anchorPoint.y * node._contentSize.height;
        mat4.copy(_mat4_temp, node._worldMatrix);
        vec3.set(_vec3_temp, -appx, -appy, 0);
        mat4.translate(_mat4_temp, _mat4_temp, _vec3_temp);
        var a = _mat4_temp.m00, b = _mat4_temp.m01, c = _mat4_temp.m04, d = _mat4_temp.m05, tx = _mat4_temp.m12, ty = _mat4_temp.m13;
        var maptw = comp._mapTileSize.width, mapth = comp._mapTileSize.height, tilew = comp._tileset._tileSize.width, tileh = comp._tileset._tileSize.height, extw = tilew - maptw, exth = tileh - mapth, winw = cc.winSize.width, winh = cc.winSize.height, rows = comp._layerSize.height, cols = comp._layerSize.width, grids = comp._texGrids, tiledTiles = comp._tiledTiles, ox = node._position.x + comp._offset.x, oy = node._position.y + comp._offset.y, mapx = ox * a + oy * c + tx, mapy = ox * b + oy * d + ty, w = tilew * a, h = tileh * d;
        var startCol = 0, startRow = 0, maxCol = cols, maxRow = rows;
        var cullingA = a, cullingD = d, cullingMapx = mapx, cullingMapy = mapy, cullingW = w, cullingH = h;
        var enabledCulling = cc.macro.ENABLE_TILEDMAP_CULLING;
        if (enabledCulling) {
          var camera = cc.Camera.findCamera(comp.node);
          if (camera) {
            camera.getWorldToCameraMatrix(_mat4_temp2);
            mat4.mul(_mat4_temp, _mat4_temp, _mat4_temp2);
            cullingA = _mat4_temp.m00;
            cullingD = _mat4_temp.m05;
            cullingMapx = ox * cullingA + oy * _mat4_temp.m04 + _mat4_temp.m12;
            cullingMapy = ox * _mat4_temp.m01 + oy * cullingD + _mat4_temp.m13;
            cullingW = tilew * cullingA;
            cullingH = tileh * cullingD;
          }
          if (layerOrientation === Orientation.ORTHO) {
            mat4.invert(_mat4_temp, _mat4_temp);
            var rect = cc.visibleRect;
            var _a = _mat4_temp.m00, _b = _mat4_temp.m01, _c = _mat4_temp.m04, _d = _mat4_temp.m05, _tx = _mat4_temp.m12, _ty = _mat4_temp.m13;
            var v0x = rect.topLeft.x * _a + rect.topLeft.y * _c + _tx;
            var v0y = rect.topLeft.x * _b + rect.topLeft.y * _d + _ty;
            var v1x = rect.bottomLeft.x * _a + rect.bottomLeft.y * _c + _tx;
            var v1y = rect.bottomLeft.x * _b + rect.bottomLeft.y * _d + _ty;
            var v2x = rect.topRight.x * _a + rect.topRight.y * _c + _tx;
            var v2y = rect.topRight.x * _b + rect.topRight.y * _d + _ty;
            var v3x = rect.bottomRight.x * _a + rect.bottomRight.y * _c + _tx;
            var v3y = rect.bottomRight.x * _b + rect.bottomRight.y * _d + _ty;
            var minx = Math.min(v0x, v1x, v2x, v3x), maxx = Math.max(v0x, v1x, v2x, v3x), miny = Math.min(v0y, v1y, v2y, v3y), maxy = Math.max(v0y, v1y, v2y, v3y);
            startCol = Math.floor(minx / maptw);
            startRow = rows - Math.ceil(maxy / mapth);
            maxCol = Math.ceil((maxx + extw) / maptw);
            maxRow = rows - Math.floor((miny - exth) / mapth);
            startCol < 0 && (startCol = 0);
            startRow < 0 && (startRow = 0);
            maxCol > cols && (maxCol = cols);
            maxRow > rows && (maxRow = rows);
          }
        }
        var colOffset = startRow * cols, gid = void 0, grid = void 0, top = void 0, left = void 0, bottom = void 0, right = void 0, gt = void 0, gl = void 0, gb = void 0, gr = void 0, axis = void 0, tileOffset = void 0, diffX1 = void 0, diffY1 = void 0, odd_even = void 0;
        if (layerOrientation === Orientation.HEX) {
          var hexSideLength = comp._hexSideLength;
          axis = comp._staggerAxis;
          tileOffset = comp._tileset.tileOffset;
          odd_even = comp._staggerIndex === StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
          diffX1 = axis === StaggerAxis.STAGGERAXIS_X ? (maptw - hexSideLength) / 2 : 0;
          diffY1 = axis === StaggerAxis.STAGGERAXIS_Y ? (mapth - hexSideLength) / 2 : 0;
        }
        var dataOffset = 0;
        var a2 = void 0, b2 = void 0, c2 = void 0, d2 = void 0, tx2 = void 0, ty2 = void 0, color2 = void 0;
        for (var row = startRow; row < maxRow; ++row) {
          for (var col = startCol; col < maxCol; ++col) {
            var index = colOffset + col;
            var flippedX = false, flippedY = false;
            var tiledTile = tiledTiles[index];
            gid = tiledTile ? tiledTile.gid : comp._tiles[index];
            grid = grids[(gid & FLIPPED_MASK) >>> 0];
            if (!grid) continue;
            switch (layerOrientation) {
             case Orientation.ORTHO:
              left = col * maptw;
              bottom = (rows - row - 1) * mapth;
              break;

             case Orientation.ISO:
              left = maptw / 2 * (cols + col - row - 1);
              bottom = mapth / 2 * (2 * rows - col - row - 2);
              break;

             case Orientation.HEX:
              var diffX2 = axis === StaggerAxis.STAGGERAXIS_Y && row % 2 === 1 ? maptw / 2 * odd_even : 0;
              left = col * (maptw - diffX1) + diffX2 + tileOffset.x;
              var diffY2 = axis === StaggerAxis.STAGGERAXIS_X && col % 2 === 1 ? mapth / 2 * -odd_even : 0;
              bottom = (rows - row - 1) * (mapth - diffY1) + diffY2 - tileOffset.y;
            }
            if (tiledTile) {
              var tiledNode = tiledTile.node;
              color2 = color;
              color = tiledNode.color._val;
              a2 = a;
              b2 = b;
              c2 = c;
              d2 = d;
              tx2 = tx;
              ty2 = ty;
              tiledNode._updateLocalMatrix();
              mat4.copy(_mat4_temp, tiledNode._mat4_temp);
              vec3.set(_vec3_temp, -left, -bottom, 0);
              mat4.translate(_mat4_temp, _mat4_temp, _vec3_temp);
              mat4.multiply(_mat4_temp, node._worldMatrix, _mat4_temp);
              a = _mat4_temp.m00;
              b = _mat4_temp.m01;
              c = _mat4_temp.m04;
              d = _mat4_temp.m05;
              tx = _mat4_temp.m12;
              ty = _mat4_temp.m13;
            }
            right = left + tilew;
            top = bottom + tileh;
            if (enabledCulling && layerOrientation === Orientation.ISO) {
              gb = cullingMapy + bottom * cullingD;
              if (gb > winh + cullingH) {
                col += Math.floor(2 * (gb - winh) / cullingH) - 1;
                continue;
              }
              gr = cullingMapx + right * cullingA;
              if (gr < -cullingW) {
                col += Math.floor(2 * -gr / cullingW) - 1;
                continue;
              }
              gl = cullingMapx + left * cullingA;
              gt = cullingMapy + top * cullingD;
              if (gl > winw || gt < 0) {
                col = maxCol;
                continue;
              }
            }
            if (gid > TileFlag.DIAGONAL) {
              flippedX = (gid & TileFlag.HORIZONTAL) >>> 0;
              flippedY = (gid & TileFlag.VERTICAL) >>> 0;
            }
            renderData.vertexCount += 4;
            renderData.indiceCount += 6;
            renderData.dataLength = renderData.vertexCount;
            data[dataOffset].x = left * a + top * c + tx;
            data[dataOffset].y = left * b + top * d + ty;
            data[dataOffset].u = flippedX ? grid.r : grid.l;
            data[dataOffset].v = flippedY ? grid.b : grid.t;
            data[dataOffset].color = color;
            dataOffset++;
            data[dataOffset].x = left * a + bottom * c + tx;
            data[dataOffset].y = left * b + bottom * d + ty;
            data[dataOffset].u = flippedX ? grid.r : grid.l;
            data[dataOffset].v = flippedY ? grid.t : grid.b;
            data[dataOffset].color = color;
            dataOffset++;
            data[dataOffset].x = right * a + top * c + tx;
            data[dataOffset].y = right * b + top * d + ty;
            data[dataOffset].u = flippedX ? grid.l : grid.r;
            data[dataOffset].v = flippedY ? grid.b : grid.t;
            data[dataOffset].color = color;
            dataOffset++;
            data[dataOffset].x = right * a + bottom * c + tx;
            data[dataOffset].y = right * b + bottom * d + ty;
            data[dataOffset].u = flippedX ? grid.l : grid.r;
            data[dataOffset].v = flippedY ? grid.t : grid.b;
            data[dataOffset].color = color;
            dataOffset++;
            if (tiledTile) {
              color = color2;
              a = a2;
              b = b2;
              c = c2;
              d = d2;
              tx = tx2;
              ty = ty2;
            }
          }
          colOffset += cols;
        }
      }
    };
    module.exports = TiledLayer._assembler = tmxAssembler;
  }), {
    "../../cocos2d/core/renderer/webgl/vertex-format": 223,
    "../core/platform/js": 175,
    "../core/renderer/render-engine": 197,
    "../core/renderer/render-flow": 198,
    "./CCTiledLayer": 260,
    "./CCTiledMap": 261
  } ],
  267: [ (function(require, module, exports) {
    var VideoPlayerImpl = require("./video-player-impl");
    var EventType = VideoPlayerImpl.EventType;
    var ResourceType = cc.Enum({
      REMOTE: 0,
      LOCAL: 1
    });
    var VideoPlayer = cc.Class({
      name: "cc.VideoPlayer",
      extends: cc.Component,
      editor: false,
      properties: {
        _resourceType: ResourceType.REMOTE,
        resourceType: {
          tooltip: false,
          type: ResourceType,
          set: function(value) {
            this._resourceType = value;
            this._updateVideoSource();
          },
          get: function() {
            return this._resourceType;
          }
        },
        _remoteURL: "",
        remoteURL: {
          tooltip: false,
          type: cc.String,
          set: function(url) {
            this._remoteURL = url;
            this._updateVideoSource();
          },
          get: function() {
            return this._remoteURL;
          }
        },
        _clip: {
          default: null,
          type: cc.Asset
        },
        clip: {
          tooltip: false,
          get: function() {
            return this._clip;
          },
          set: function(value) {
            this._clip = value;
            this._updateVideoSource();
          },
          type: cc.Asset
        },
        currentTime: {
          tooltip: false,
          type: cc.Float,
          set: function(time) {
            this._impl && this._impl.seekTo(time);
          },
          get: function() {
            if (this._impl) return this._impl.currentTime();
            return -1;
          }
        },
        _volume: 1,
        volume: {
          get: function() {
            return this._volume;
          },
          set: function(value) {
            this._volume = value;
            this.isPlaying() && !this._mute && this._syncVolume();
          },
          range: [ 0, 1 ],
          type: cc.Float,
          tooltip: false
        },
        _mute: false,
        mute: {
          get: function() {
            return this._mute;
          },
          set: function(value) {
            this._mute = value;
            this._syncVolume();
          },
          tooltip: false
        },
        keepAspectRatio: {
          tooltip: false,
          default: true,
          type: cc.Boolean,
          notify: function() {
            this._impl.setKeepAspectRatioEnabled(this.keepAspectRatio);
          }
        },
        isFullscreen: {
          tooltip: false,
          default: false,
          type: cc.Boolean,
          notify: function() {
            this._impl.setFullScreenEnabled(this.isFullscreen);
          }
        },
        videoPlayerEvent: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        EventType: EventType,
        ResourceType: ResourceType
      },
      ctor: function() {
        this._impl = new VideoPlayerImpl();
      },
      _syncVolume: function() {
        var impl = this._impl;
        if (impl) {
          var volume = this._mute ? 0 : this._volume;
          impl.setVolume(volume);
        }
      },
      _updateVideoSource: function() {
        var url = "";
        this.resourceType === ResourceType.REMOTE ? url = this.remoteURL : this._clip && (url = this._clip.nativeUrl || "");
        url && cc.loader.md5Pipe && (url = cc.loader.md5Pipe.transformURL(url));
        this._impl.setURL(url);
      },
      onLoad: function() {
        var impl = this._impl;
        if (impl) {
          impl.createDomElementIfNeeded();
          this._updateVideoSource();
          impl.seekTo(this.currentTime);
          impl.setKeepAspectRatioEnabled(this.keepAspectRatio);
          impl.setFullScreenEnabled(this.isFullscreen);
          this.pause();
          true;
          impl.setEventListener(EventType.PLAYING, this.onPlaying.bind(this));
          impl.setEventListener(EventType.PAUSED, this.onPasued.bind(this));
          impl.setEventListener(EventType.STOPPED, this.onStopped.bind(this));
          impl.setEventListener(EventType.COMPLETED, this.onCompleted.bind(this));
          impl.setEventListener(EventType.META_LOADED, this.onMetaLoaded.bind(this));
          impl.setEventListener(EventType.CLICKED, this.onClicked.bind(this));
          impl.setEventListener(EventType.READY_TO_PLAY, this.onReadyToPlay.bind(this));
        }
      },
      onEnable: function() {
        this._impl && this._impl.enable();
      },
      onDisable: function() {
        this._impl && this._impl.disable();
      },
      onDestroy: function() {
        if (this._impl) {
          this._impl.destroy();
          this._impl = null;
        }
      },
      update: function(dt) {
        this._impl && this._impl.updateMatrix(this.node);
      },
      onReadyToPlay: function() {
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.READY_TO_PLAY);
        this.node.emit("ready-to-play", this);
      },
      onMetaLoaded: function() {
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.META_LOADED);
        this.node.emit("meta-loaded", this);
      },
      onClicked: function() {
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.CLICKED);
        this.node.emit("clicked", this);
      },
      onPlaying: function() {
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.PLAYING);
        this.node.emit("playing", this);
      },
      onPasued: function() {
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.PAUSED);
        this.node.emit("paused", this);
      },
      onStopped: function() {
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.STOPPED);
        this.node.emit("stopped", this);
      },
      onCompleted: function() {
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.COMPLETED);
        this.node.emit("completed", this);
      },
      play: function() {
        if (this._impl) {
          this._syncVolume();
          this._impl.play();
        }
      },
      resume: function() {
        if (this._impl) {
          this._syncVolume();
          this._impl.resume();
        }
      },
      pause: function() {
        this._impl && this._impl.pause();
      },
      stop: function() {
        this._impl && this._impl.stop();
      },
      getDuration: function() {
        if (this._impl) return this._impl.duration();
        return -1;
      },
      isPlaying: function() {
        if (this._impl) return this._impl.isPlaying();
        return false;
      }
    });
    cc.VideoPlayer = module.exports = VideoPlayer;
  }), {
    "./video-player-impl": 268
  } ],
  268: [ (function(require, module, exports) {
    var utils = require("../core/platform/utils");
    var sys = require("../core/platform/CCSys");
    var renderEngine = require("../core/renderer/render-engine");
    var math = renderEngine.math;
    var _mat4_temp = math.mat4.create();
    var VideoPlayerImpl = cc.Class({
      name: "VideoPlayerImpl",
      ctor: function() {
        this._EventList = {};
        this._video = null;
        this._url = "";
        this._loaded = false;
        this._visible = false;
        this._played = false;
        this._playing = false;
        this._ignorePause = false;
        this._forceUpdate = true;
        this._m00 = 0;
        this._m01 = 0;
        this._m04 = 0;
        this._m05 = 0;
        this._m12 = 0;
        this._m13 = 0;
        this._w = 0;
        this._h = 0;
        this.__eventListeners = {};
      },
      _bindEvent: function() {
        var video = this._video, self = this;
        var cbs = this.__eventListeners;
        cbs.loadedmetadata = function() {
          self._dispatchEvent(VideoPlayerImpl.EventType.META_LOADED);
        };
        cbs.ended = function() {
          if (this._video !== video) return;
          self._playing = false;
          self._dispatchEvent(VideoPlayerImpl.EventType.COMPLETED);
        };
        cbs.play = function() {
          if (self._video !== video) return;
          self._playing = true;
          self._dispatchEvent(VideoPlayerImpl.EventType.PLAYING);
        };
        cbs.pause = function() {
          if (self._ignorePause || self._video !== video) return;
          self._playing = false;
          self._dispatchEvent(VideoPlayerImpl.EventType.PAUSED);
        };
        cbs.click = function() {
          self._dispatchEvent(VideoPlayerImpl.EventType.CLICKED);
        };
        video.addEventListener("loadedmetadata", cbs.loadedmetadata);
        video.addEventListener("ended", cbs.ended);
        video.addEventListener("play", cbs.play);
        video.addEventListener("pause", cbs.pause);
        video.addEventListener("click", cbs.click);
        function onCanPlay() {
          if (this._loaded) return;
          var video = this._video;
          if (4 === video.readyState) {
            this._loaded = true;
            video.currentTime = 0;
            this._dispatchEvent(VideoPlayerImpl.EventType.READY_TO_PLAY);
            this._updateVisibility();
          }
        }
        cbs.onCanPlay = onCanPlay.bind(this);
        video.addEventListener("canplay", cbs.onCanPlay);
        video.addEventListener("canplaythrough", cbs.onCanPlay);
        video.addEventListener("suspend", cbs.onCanPlay);
      },
      _updateVisibility: function() {
        if (!this._video) return;
        var video = this._video;
        if (this._visible) video.style.visibility = "visible"; else {
          video.style.visibility = "hidden";
          video.pause();
          this._playing = false;
        }
        this._forceUpdate = true;
      },
      _updateSize: function(width, height) {
        var video = this._video;
        if (!video) return;
        video.style.width = width + "px";
        video.style.height = height + "px";
      },
      _createDom: function() {
        var video = document.createElement("video");
        video.style.position = "absolute";
        video.style.bottom = "0px";
        video.style.left = "0px";
        video.className = "cocosVideo";
        video.setAttribute("preload", "auto");
        video.setAttribute("webkit-playsinline", "");
        video.setAttribute("playsinline", "");
        var orientation = cc.winSize.width > cc.winSize.height ? "landscape" : "portrait";
        video.setAttribute("x5-playsinline", "");
        video.setAttribute("x5-video-player-type", "h5");
        video.setAttribute("x5-video-orientation", orientation);
        this._video = video;
        cc.game.container.appendChild(video);
      },
      createDomElementIfNeeded: function() {
        this._video || this._createDom();
      },
      removeDom: function() {
        var video = this._video;
        if (video) {
          var hasChild = utils.contains(cc.game.container, video);
          hasChild && cc.game.container.removeChild(video);
          var cbs = this.__eventListeners;
          video.removeEventListener("loadedmetadata", cbs.loadedmetadata);
          video.removeEventListener("ended", cbs.ended);
          video.removeEventListener("play", cbs.play);
          video.removeEventListener("pause", cbs.pause);
          video.removeEventListener("click", cbs.click);
          video.removeEventListener("canplay", cbs.onCanPlay);
          video.removeEventListener("canplaythrough", cbs.onCanPlay);
          video.removeEventListener("suspend", cbs.onCanPlay);
          cbs.loadedmetadata = null;
          cbs.ended = null;
          cbs.play = null;
          cbs.pause = null;
          cbs.click = null;
          cbs.onCanPlay = null;
        }
        this._video = null;
        this._url = "";
      },
      setURL: function(path) {
        var source = void 0, extname = void 0;
        if (this._url === path) return;
        this._url = path;
        cc.loader.resPath && !/^http/.test(path) && (path = cc.path.join(cc.loader.resPath, path));
        this.removeDom();
        this.createDomElementIfNeeded();
        this._bindEvent();
        var video = this._video;
        video.style["visibility"] = "hidden";
        this._loaded = false;
        this._played = false;
        this._playing = false;
        source = document.createElement("source");
        source.src = path;
        video.appendChild(source);
        extname = cc.path.extname(path);
        var polyfill = VideoPlayerImpl._polyfill;
        for (var i = 0; i < polyfill.canPlayType.length; i++) if (extname !== polyfill.canPlayType[i]) {
          source = document.createElement("source");
          source.src = path.replace(extname, polyfill.canPlayType[i]);
          video.appendChild(source);
        }
      },
      getURL: function() {
        return this._url;
      },
      play: function() {
        var _this = this;
        var video = this._video;
        if (!video || !this._visible) return;
        this._played = true;
        if (this._playing) return;
        if (VideoPlayerImpl._polyfill.autoplayAfterOperation) (function() {
          var self = _this;
          setTimeout((function() {
            video.play();
            self._playing = !video.paused;
          }), 20);
        })(); else {
          video.play();
          this._playing = !video.paused;
        }
      },
      pause: function() {
        var video = this._video;
        if (!this._playing) return;
        this._playing = false;
        if (!video) return;
        video.pause();
      },
      _resume: function() {
        this.play();
      },
      stop: function() {
        var video = this._video;
        if (!video || !this._visible) return;
        this._ignorePause = true;
        video.pause();
        var self = this;
        setTimeout((function() {
          self._dispatchEvent(VideoPlayerImpl.EventType.STOPPED);
          self._ignorePause = false;
        }), 0);
        video.currentTime = 0;
        this._playing = false;
      },
      setVolume: function(volume) {
        var video = this._video;
        video && (video.volume = volume);
      },
      seekTo: function(time) {
        var video = this._video;
        if (!video) return;
        this._loaded ? video.currentTime = time : (function() {
          var cb = function() {
            video.currentTime = time;
            video.removeEventListener(VideoPlayerImpl._polyfill.event, cb);
          };
          video.addEventListener(VideoPlayerImpl._polyfill.event, cb);
        })();
        VideoPlayerImpl._polyfill.autoplayAfterOperation && this.isPlaying() && setTimeout((function() {
          video.play();
        }), 20);
      },
      isPlaying: function() {
        var video = this._video;
        VideoPlayerImpl._polyfill.autoplayAfterOperation && this._playing && setTimeout((function() {
          video.play();
        }), 20);
        return this._playing;
      },
      duration: function() {
        var video = this._video;
        var duration = -1;
        if (!video) return duration;
        duration = video.duration;
        duration <= 0 && cc.logID(7702);
        return duration;
      },
      currentTime: function() {
        var video = this._video;
        if (!video) return -1;
        return video.currentTime;
      },
      setKeepAspectRatioEnabled: function() {
        cc.logID(7700);
      },
      isKeepAspectRatioEnabled: function() {
        return true;
      },
      setFullScreenEnabled: function(enable) {
        var video = this._video;
        if (!video) return;
        enable ? cc.screen.requestFullScreen(video) : cc.screen.exitFullScreen(video);
      },
      isFullScreenEnabled: function() {
        cc.logID(7701);
      },
      setEventListener: function(event, callback) {
        this._EventList[event] = callback;
      },
      removeEventListener: function(event) {
        this._EventList[event] = null;
      },
      _dispatchEvent: function(event) {
        var callback = this._EventList[event];
        callback && callback.call(this, this, this._video.src);
      },
      onPlayEvent: function() {
        var callback = this._EventList[VideoPlayerImpl.EventType.PLAYING];
        callback.call(this, this, this._video.src);
      },
      enable: function() {
        var list = VideoPlayerImpl.elements;
        -1 === list.indexOf(this) && list.push(this);
        this.setVisible(true);
      },
      disable: function() {
        var list = VideoPlayerImpl.elements;
        var index = list.indexOf(this);
        -1 !== index && list.splice(index, 1);
        this.setVisible(false);
      },
      destroy: function() {
        this.disable();
        this.removeDom();
      },
      setVisible: function(visible) {
        if (this._visible !== visible) {
          this._visible = !!visible;
          this._updateVisibility();
        }
      },
      updateMatrix: function(node) {
        if (!this._video || !this._visible) return;
        node.getWorldMatrix(_mat4_temp);
        if (!this._forceUpdate && this._m00 === _mat4_temp.m00 && this._m01 === _mat4_temp.m01 && this._m04 === _mat4_temp.m04 && this._m05 === _mat4_temp.m05 && this._m12 === _mat4_temp.m12 && this._m13 === _mat4_temp.m13 && this._w === node._contentSize.width && this._h === node._contentSize.height) return;
        this._m00 = _mat4_temp.m00;
        this._m01 = _mat4_temp.m01;
        this._m04 = _mat4_temp.m04;
        this._m05 = _mat4_temp.m05;
        this._m12 = _mat4_temp.m12;
        this._m13 = _mat4_temp.m13;
        this._w = node._contentSize.width;
        this._h = node._contentSize.height;
        var scaleX = cc.view._scaleX, scaleY = cc.view._scaleY;
        var dpr = cc.view._devicePixelRatio;
        scaleX /= dpr;
        scaleY /= dpr;
        var container = cc.game.container;
        var a = _mat4_temp.m00 * scaleX, b = _mat4_temp.m01, c = _mat4_temp.m04, d = _mat4_temp.m05 * scaleY;
        var offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
        var offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
        var w = void 0, h = void 0;
        if (VideoPlayerImpl._polyfill.zoomInvalid) {
          this._updateSize(this._w * a, this._h * d);
          a = 1;
          d = 1;
          w = this._w * scaleX;
          h = this._h * scaleY;
        } else {
          this._updateSize(this._w, this._h);
          w = this._w * scaleX;
          h = this._h * scaleY;
        }
        var appx = w * _mat4_temp.m00 * node._anchorPoint.x;
        var appy = h * _mat4_temp.m05 * node._anchorPoint.y;
        var tx = _mat4_temp.m12 * scaleX - appx + offsetX, ty = _mat4_temp.m13 * scaleY - appy + offsetY;
        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
        this._video.style["transform"] = matrix;
        this._video.style["-webkit-transform"] = matrix;
        this._video.style["transform-origin"] = "0px 100% 0px";
        this._video.style["-webkit-transform-origin"] = "0px 100% 0px";
      }
    });
    VideoPlayerImpl.EventType = {
      PLAYING: 0,
      PAUSED: 1,
      STOPPED: 2,
      COMPLETED: 3,
      META_LOADED: 4,
      CLICKED: 5,
      READY_TO_PLAY: 6
    };
    VideoPlayerImpl.elements = [];
    VideoPlayerImpl.pauseElements = [];
    cc.game.on(cc.game.EVENT_HIDE, (function() {
      var list = VideoPlayerImpl.elements;
      for (var element, i = 0; i < list.length; i++) {
        element = list[i];
        if (element.isPlaying()) {
          element.pause();
          VideoPlayerImpl.pauseElements.push(element);
        }
      }
    }));
    cc.game.on(cc.game.EVENT_SHOW, (function() {
      var list = VideoPlayerImpl.pauseElements;
      var element = list.pop();
      while (element) {
        element.play();
        element = list.pop();
      }
    }));
    VideoPlayerImpl._polyfill = {
      devicePixelRatio: false,
      event: "canplay",
      canPlayType: []
    };
    var dom = document.createElement("video");
    if (sys.platform !== sys.WECHAT_GAME) {
      if (dom.canPlayType("video/ogg")) {
        VideoPlayerImpl._polyfill.canPlayType.push(".ogg");
        VideoPlayerImpl._polyfill.canPlayType.push(".ogv");
      }
      dom.canPlayType("video/mp4") && VideoPlayerImpl._polyfill.canPlayType.push(".mp4");
      dom.canPlayType("video/webm") && VideoPlayerImpl._polyfill.canPlayType.push(".webm");
    }
    sys.browserType === sys.BROWSER_TYPE_FIREFOX && (VideoPlayerImpl._polyfill.autoplayAfterOperation = true);
    sys.OS_ANDROID !== sys.os || sys.browserType !== sys.BROWSER_TYPE_SOUGOU && sys.browserType !== sys.BROWSER_TYPE_360 || (VideoPlayerImpl._polyfill.zoomInvalid = true);
    var style = document.createElement("style");
    style.innerHTML = ".cocosVideo:-moz-full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:-webkit-full-screen{transform:matrix(1,0,0,1,0,0) !important;}";
    document.head.appendChild(style);
    module.exports = VideoPlayerImpl;
  }), {
    "../core/platform/CCSys": 164,
    "../core/platform/utils": 179,
    "../core/renderer/render-engine": 197
  } ],
  269: [ (function(require, module, exports) {
    var WebViewImpl = require("./webview-impl");
    var EventType = WebViewImpl.EventType;
    function emptyCallback() {}
    var WebView = cc.Class({
      name: "cc.WebView",
      extends: cc.Component,
      editor: false,
      properties: {
        _useOriginalSize: true,
        _url: "",
        url: {
          type: String,
          tooltip: false,
          get: function() {
            return this._url;
          },
          set: function(url) {
            this._url = url;
            var impl = this._impl;
            impl && impl.loadURL(url);
          }
        },
        webviewEvents: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        EventType: EventType
      },
      ctor: function() {
        this._impl = new WebViewImpl();
      },
      onEnable: function() {
        var impl = this._impl;
        impl.createDomElementIfNeeded(this.node.width, this.node.height);
        impl.loadURL(this._url);
        impl.setVisible(true);
        true;
        impl.setEventListener(EventType.LOADED, this._onWebViewLoaded.bind(this));
        impl.setEventListener(EventType.LOADING, this._onWebViewLoading.bind(this));
        impl.setEventListener(EventType.ERROR, this._onWebViewLoadError.bind(this));
      },
      onDisable: function() {
        var impl = this._impl;
        impl.setVisible(false);
        true;
        impl.setEventListener(EventType.LOADED, emptyCallback);
        impl.setEventListener(EventType.LOADING, emptyCallback);
        impl.setEventListener(EventType.ERROR, emptyCallback);
      },
      onDestroy: function() {
        if (this._impl) {
          this._impl.destroy();
          this._impl = null;
        }
      },
      update: function(dt) {
        this._impl && this._impl.updateMatrix(this.node);
      },
      _onWebViewLoaded: function() {
        cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADED);
        this.node.emit("loaded", this);
      },
      _onWebViewLoading: function() {
        cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADING);
        this.node.emit("loading", this);
        return true;
      },
      _onWebViewLoadError: function() {
        cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.ERROR);
        this.node.emit("error", this);
      },
      setJavascriptInterfaceScheme: function(scheme) {
        this._impl && this._impl.setJavascriptInterfaceScheme(scheme);
      },
      setOnJSCallback: function(callback) {
        this._impl && this._impl.setOnJSCallback(callback);
      },
      evaluateJS: function(str) {
        this._impl && this._impl.evaluateJS(str);
      }
    });
    cc.WebView = module.exports = WebView;
  }), {
    "./webview-impl": 270
  } ],
  270: [ (function(require, module, exports) {
    var utils = require("../core/platform/utils");
    var eventManager = require("../core/event-manager");
    var sys = require("../core/platform/CCSys");
    var renderEngine = require("../core/renderer/render-engine");
    var math = renderEngine.math;
    var _mat4_temp = math.mat4.create();
    var WebViewImpl = cc.Class({
      name: "WebViewImpl",
      ctor: function() {
        this._EventList = {};
        this._visible = false;
        this._parent = null;
        this._div = null;
        this._iframe = null;
        this._listener = null;
        this._forceUpdate = true;
        this._m00 = 0;
        this._m01 = 0;
        this._m04 = 0;
        this._m05 = 0;
        this._m12 = 0;
        this._m13 = 0;
        this._w = 0;
        this._h = 0;
        this.__eventListeners = {};
      },
      _updateVisibility: function() {
        if (!this._div) return;
        var div = this._div;
        this._visible ? div.style.visibility = "visible" : div.style.visibility = "hidden";
        this._forceUpdate = true;
      },
      _updateSize: function(w, h) {
        var div = this._div;
        if (div) {
          div.style.width = w + "px";
          div.style.height = h + "px";
        }
      },
      _initEvent: function() {
        var _this = this;
        var iframe = this._iframe;
        iframe && (function() {
          var cbs = _this.__eventListeners, self = _this;
          cbs.load = function() {
            self._dispatchEvent(WebViewImpl.EventType.LOADED);
          };
          cbs.error = function() {
            self._dispatchEvent(WebViewImpl.EventType.ERROR);
          };
          iframe.addEventListener("load", cbs.load);
          iframe.addEventListener("error", cbs.error);
        })();
      },
      _initStyle: function() {
        if (!this._div) return;
        var div = this._div;
        div.style.position = "absolute";
        div.style.bottom = "0px";
        div.style.left = "0px";
      },
      _createDom: function(w, h) {
        if (WebViewImpl._polyfill.enableDiv) {
          this._div = document.createElement("div");
          this._div.style["-webkit-overflow"] = "auto";
          this._div.style["-webkit-overflow-scrolling"] = "touch";
          this._iframe = document.createElement("iframe");
          this._div.appendChild(this._iframe);
          this._iframe.style.width = "100%";
          this._iframe.style.height = "100%";
        } else this._div = this._iframe = document.createElement("iframe");
        WebViewImpl._polyfill.enableBG && (this._div.style["background"] = "#FFF");
        this._div.style["background"] = "#FFF";
        this._div.style.height = h + "px";
        this._div.style.width = w + "px";
        this._div.style.overflow = "scroll";
        this._iframe.style.border = "none";
        cc.game.container.appendChild(this._div);
        this._updateVisibility();
      },
      _createNativeControl: function(w, h) {
        this._createDom(w, h);
        this._initStyle();
        this._initEvent();
      },
      createDomElementIfNeeded: function(w, h) {
        this._div ? this._updateSize(w, h) : this._createNativeControl(w, h);
      },
      removeDom: function() {
        var div = this._div;
        if (div) {
          var hasChild = utils.contains(cc.game.container, div);
          hasChild && cc.game.container.removeChild(div);
          this._div = null;
        }
        var iframe = this._iframe;
        if (iframe) {
          var cbs = this.__eventListeners;
          iframe.removeEventListener("load", cbs.load);
          iframe.removeEventListener("error", cbs.error);
          cbs.load = null;
          cbs.error = null;
          this._iframe = null;
        }
      },
      setOnJSCallback: function(callback) {},
      setJavascriptInterfaceScheme: function(scheme) {},
      loadData: function(data, MIMEType, encoding, baseURL) {},
      loadHTMLString: function(string, baseURL) {},
      loadURL: function(url) {
        var _this2 = this;
        var iframe = this._iframe;
        iframe && (function() {
          iframe.src = url;
          var self = _this2;
          var cb = function() {
            self._loaded = true;
            self._updateVisibility();
            iframe.removeEventListener("load", cb);
          };
          iframe.addEventListener("load", cb);
          _this2._dispatchEvent(WebViewImpl.EventType.LOADING);
        })();
      },
      stopLoading: function() {
        cc.logID(7800);
      },
      reload: function() {
        var iframe = this._iframe;
        if (iframe) {
          var win = iframe.contentWindow;
          win && win.location && win.location.reload();
        }
      },
      canGoBack: function() {
        cc.logID(7801);
        return true;
      },
      canGoForward: function() {
        cc.logID(7802);
        return true;
      },
      goBack: function() {
        try {
          if (WebViewImpl._polyfill.closeHistory) return cc.logID(7803);
          var iframe = this._iframe;
          if (iframe) {
            var win = iframe.contentWindow;
            win && win.location && win.history.back.call(win);
          }
        } catch (err) {
          cc.log(err);
        }
      },
      goForward: function() {
        try {
          if (WebViewImpl._polyfill.closeHistory) return cc.logID(7804);
          var iframe = this._iframe;
          if (iframe) {
            var win = iframe.contentWindow;
            win && win.location && win.history.forward.call(win);
          }
        } catch (err) {
          cc.log(err);
        }
      },
      evaluateJS: function(str) {
        var iframe = this._iframe;
        if (iframe) {
          var win = iframe.contentWindow;
          try {
            win.eval(str);
            this._dispatchEvent(WebViewImpl.EventType.JS_EVALUATED);
          } catch (err) {
            console.error(err);
          }
        }
      },
      setScalesPageToFit: function() {
        cc.logID(7805);
      },
      setEventListener: function(event, callback) {
        this._EventList[event] = callback;
      },
      removeEventListener: function(event) {
        this._EventList[event] = null;
      },
      _dispatchEvent: function(event) {
        var callback = this._EventList[event];
        callback && callback.call(this, this, this._iframe.src);
      },
      _createRenderCmd: function() {
        return new WebViewImpl.RenderCmd(this);
      },
      destroy: function() {
        this.removeDom();
      },
      setVisible: function(visible) {
        if (this._visible !== visible) {
          this._visible = !!visible;
          this._updateVisibility();
        }
      },
      updateMatrix: function(node) {
        if (!this._div || !this._visible) return;
        node.getWorldMatrix(_mat4_temp);
        if (!this._forceUpdate && this._m00 === _mat4_temp.m00 && this._m01 === _mat4_temp.m01 && this._m04 === _mat4_temp.m04 && this._m05 === _mat4_temp.m05 && this._m12 === _mat4_temp.m12 && this._m13 === _mat4_temp.m13 && this._w === node._contentSize.width && this._h === node._contentSize.height) return;
        this._m00 = _mat4_temp.m00;
        this._m01 = _mat4_temp.m01;
        this._m04 = _mat4_temp.m04;
        this._m05 = _mat4_temp.m05;
        this._m12 = _mat4_temp.m12;
        this._m13 = _mat4_temp.m13;
        this._w = node._contentSize.width;
        this._h = node._contentSize.height;
        var scaleX = cc.view._scaleX, scaleY = cc.view._scaleY;
        var dpr = cc.view._devicePixelRatio;
        scaleX /= dpr;
        scaleY /= dpr;
        var container = cc.game.container;
        var a = _mat4_temp.m00 * scaleX, b = _mat4_temp.m01, c = _mat4_temp.m04, d = _mat4_temp.m05 * scaleY;
        var offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
        var offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
        this._updateSize(this._w, this._h);
        var w = this._div.clientWidth * scaleX;
        var h = this._div.clientHeight * scaleY;
        var appx = w * _mat4_temp.m00 * node._anchorPoint.x;
        var appy = h * _mat4_temp.m05 * node._anchorPoint.y;
        var tx = _mat4_temp.m12 * scaleX - appx + offsetX, ty = _mat4_temp.m13 * scaleY - appy + offsetY;
        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
        this._div.style["transform"] = matrix;
        this._div.style["-webkit-transform"] = matrix;
        this._div.style["transform-origin"] = "0px 100% 0px";
        this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
      }
    });
    WebViewImpl.EventType = {
      LOADING: 0,
      LOADED: 1,
      ERROR: 2,
      JS_EVALUATED: 3
    };
    var polyfill = WebViewImpl._polyfill = {
      devicePixelRatio: false,
      enableDiv: false
    };
    sys.os === sys.OS_IOS && (polyfill.enableDiv = true);
    sys.isMobile ? sys.browserType === sys.BROWSER_TYPE_FIREFOX && (polyfill.enableBG = true) : sys.browserType === sys.BROWSER_TYPE_IE && (polyfill.closeHistory = true);
    module.exports = WebViewImpl;
  }), {
    "../core/event-manager": 98,
    "../core/platform/CCSys": 164,
    "../core/platform/utils": 179,
    "../core/renderer/render-engine": 197
  } ],
  271: [ (function(require, module, exports) {
    require("./cocos2d/core");
    require("./cocos2d/animation");
    false;
    require("./cocos2d/particle");
    require("./cocos2d/tilemap");
    require("./cocos2d/videoplayer/CCVideoPlayer");
    require("./cocos2d/webview/CCWebView");
    require("./cocos2d/core/components/CCStudioComponent");
    require("./extensions/ccpool/CCNodePool");
    require("./cocos2d/actions");
    require("./extensions/spine");
    require("./extensions/dragonbones");
    true;
    require("./cocos2d/deprecated");
  }), {
    "./cocos2d/actions": 10,
    "./cocos2d/animation": 18,
    "./cocos2d/core": 108,
    "./cocos2d/core/components/CCStudioComponent": 83,
    "./cocos2d/deprecated": 250,
    "./cocos2d/particle": 256,
    "./cocos2d/particle/CCParticleAsset": 253,
    "./cocos2d/tilemap": 265,
    "./cocos2d/tilemap/CCTiledMapAsset": 262,
    "./cocos2d/videoplayer/CCVideoPlayer": 267,
    "./cocos2d/webview/CCWebView": 269,
    "./extensions/ccpool/CCNodePool": 272,
    "./extensions/dragonbones": 280,
    "./extensions/spine": 283
  } ],
  272: [ (function(require, module, exports) {
    cc.NodePool = function(poolHandlerComp) {
      this.poolHandlerComp = poolHandlerComp;
      this._pool = [];
    };
    cc.NodePool.prototype = {
      constructor: cc.NodePool,
      size: function() {
        return this._pool.length;
      },
      clear: function() {
        var count = this._pool.length;
        for (var i = 0; i < count; ++i) this._pool[i].destroy();
        this._pool.length = 0;
      },
      put: function(obj) {
        if (obj && -1 === this._pool.indexOf(obj)) {
          obj.removeFromParent(false);
          var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
          handler && handler.unuse && handler.unuse();
          this._pool.push(obj);
        }
      },
      get: function() {
        var last = this._pool.length - 1;
        if (last < 0) return null;
        var obj = this._pool[last];
        this._pool.length = last;
        var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
        handler && handler.reuse && handler.reuse.apply(handler, arguments);
        return obj;
      }
    };
    module.exports = cc.NodePool;
  }), {} ],
  273: [ (function(require, module, exports) {
    var RenderComponent = require("../../cocos2d/core/components/CCRenderComponent");
    var renderer = require("../../cocos2d/core/renderer");
    var renderEngine = require("../../cocos2d/core/renderer/render-engine");
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var EventTarget = require("../../cocos2d/core/event/event-target");
    var Node = require("../../cocos2d/core/CCNode");
    var Graphics = require("../../cocos2d/core/graphics/graphics");
    var DefaultArmaturesEnum = cc.Enum({
      default: -1
    });
    var DefaultAnimsEnum = cc.Enum({
      "<None>": 0
    });
    function setEnumAttr(obj, propName, enumDef) {
      cc.Class.attr(obj, propName, {
        type: "Enum",
        enumList: cc.Enum.getList(enumDef)
      });
    }
    var ArmatureDisplay = cc.Class({
      name: "dragonBones.ArmatureDisplay",
      extends: RenderComponent,
      mixins: [ EventTarget ],
      editor: false,
      properties: {
        _factory: {
          default: null,
          type: dragonBones.CCFactory,
          serializable: false
        },
        dragonAsset: {
          default: null,
          type: dragonBones.DragonBonesAsset,
          notify: function() {
            this._parseDragonAsset();
            this._refresh();
            false;
          },
          tooltip: false
        },
        dragonAtlasAsset: {
          default: null,
          type: dragonBones.DragonBonesAtlasAsset,
          notify: function() {
            this._parseDragonAtlasAsset();
            this._buildArmature();
            this._activateMaterial();
          },
          tooltip: false
        },
        _armatureName: "",
        armatureName: {
          get: function() {
            return this._armatureName;
          },
          set: function(value) {
            this._armatureName = value;
            var animNames = this.getAnimationNames(this._armatureName);
            if (!this.animationName || animNames.indexOf(this.animationName) < 0) {
              false;
              this.animationName = "";
            }
            this._refresh();
          },
          visible: false
        },
        _animationName: "",
        animationName: {
          get: function() {
            return this._animationName;
          },
          set: function(value) {
            this._animationName = value;
          },
          visible: false
        },
        _defaultArmatureIndex: {
          default: 0,
          notify: function() {
            var armatureName = "";
            if (this.dragonAsset) {
              var armaturesEnum = void 0;
              this.dragonAsset && (armaturesEnum = this.dragonAsset.getArmatureEnum());
              if (!armaturesEnum) return cc.errorID(7400, this.name);
              armatureName = armaturesEnum[this._defaultArmatureIndex];
            }
            void 0 !== armatureName ? this.armatureName = armatureName : cc.errorID(7401, this.name);
          },
          type: DefaultArmaturesEnum,
          visible: true,
          editorOnly: true,
          displayName: "Armature",
          tooltip: false
        },
        _animationIndex: {
          default: 0,
          notify: function() {
            if (0 === this._animationIndex) {
              this.animationName = "";
              return;
            }
            var animsEnum = void 0;
            this.dragonAsset && (animsEnum = this.dragonAsset.getAnimsEnum(this.armatureName));
            if (!animsEnum) return;
            var animName = animsEnum[this._animationIndex];
            void 0 !== animName ? this.animationName = animName : cc.errorID(7402, this.name);
          },
          type: DefaultAnimsEnum,
          visible: true,
          editorOnly: true,
          displayName: "Animation",
          tooltip: false
        },
        timeScale: {
          default: 1,
          notify: function() {
            this._armature.animation.timeScale = this.timeScale;
          },
          tooltip: false
        },
        playTimes: {
          default: -1,
          tooltip: false
        },
        debugBones: {
          default: false,
          notify: function() {
            this._initDebugDraw();
          },
          tooltip: false
        }
      },
      ctor: function() {
        this._inited = false;
        this._factory = dragonBones.CCFactory.getInstance();
      },
      __preload: function() {
        this._init();
      },
      _init: function() {
        if (this._inited) return;
        this._inited = true;
        this._parseDragonAsset();
        this._parseDragonAtlasAsset();
        this._refresh();
        this._activateMaterial();
      },
      onEnable: function() {
        this._super();
        this._armature && dragonBones.CCFactory.getInstance()._dragonBones.clock.add(this._armature);
      },
      onDisable: function() {
        this._super();
        this._armature && dragonBones.CCFactory.getInstance()._dragonBones.clock.remove(this._armature);
      },
      onDestroy: function() {
        this._super();
        this._inited = false;
        if (this._armature) {
          this._armature.dispose();
          this._armature = null;
        }
      },
      _initDebugDraw: function() {
        if (this.debugBones) {
          if (!this._debugDraw) {
            var debugDrawNode = new Node();
            debugDrawNode.name = "DEBUG_DRAW_NODE";
            var debugDraw = debugDrawNode.addComponent(Graphics);
            debugDraw.lineWidth = 1;
            debugDraw.strokeColor = cc.color(255, 0, 0, 255);
            this._debugDraw = debugDraw;
          }
          this._debugDraw.node.parent = this.node;
        } else this._debugDraw && (this._debugDraw.node.parent = null);
      },
      _activateMaterial: function() {
        var texture = this.dragonAtlasAsset && this.dragonAtlasAsset.texture;
        var material = this._material || new SpriteMaterial();
        material.useColor = false;
        if (texture) {
          material.texture = texture;
          this.markForUpdateRenderData(true);
          this.markForRender(true);
        } else this.disableRender();
        this.setMaterial(material);
      },
      _buildArmature: function() {
        if (!this.dragonAsset || !this.dragonAtlasAsset || !this.armatureName) return;
        var factory = dragonBones.CCFactory.getInstance();
        this._armature = factory.buildArmatureDisplay(this.armatureName, this.dragonAsset._dragonBonesData.name, this);
        this._armature.animation.timeScale = this.timeScale;
        this.animationName && this.playAnimation(this.animationName, this.playTimes);
      },
      _parseDragonAsset: function() {
        this.dragonAsset && this.dragonAsset.init(this._factory);
      },
      _parseDragonAtlasAsset: function() {
        this.dragonAtlasAsset && this.dragonAtlasAsset.init(this._factory);
      },
      _refresh: function() {
        this._buildArmature();
        false;
      },
      _updateAnimEnum: false,
      _updateArmatureEnum: false,
      playAnimation: function(animName, playTimes) {
        if (this._armature) {
          this.playTimes = void 0 === playTimes ? -1 : playTimes;
          this.animationName = animName;
          return this._armature.animation.play(animName, this.playTimes);
        }
        return null;
      },
      getArmatureNames: function() {
        var dragonBonesData = this.dragonAsset && this.dragonAsset._dragonBonesData;
        return dragonBonesData && dragonBonesData.armatureNames || [];
      },
      getAnimationNames: function(armatureName) {
        var ret = [];
        if (this.dragonAsset && this.dragonAsset._dragonBonesData) {
          var armatureData = this.dragonAsset._dragonBonesData.getArmature(armatureName);
          if (armatureData) for (var animName in armatureData.animations) armatureData.animations.hasOwnProperty(animName) && ret.push(animName);
        }
        return ret;
      },
      addEventListener: function(eventType, listener, target) {
        this.addDBEventListener(eventType, listener, target);
      },
      removeEventListener: function(eventType, listener, target) {
        this.removeDBEventListener(eventType, listener, target);
      },
      buildArmature: function(armatureName, node) {
        return dragonBones.CCFactory.getInstance().createArmatureNode(this, armatureName, node);
      },
      armature: function() {
        return this._armature;
      },
      dbInit: function(armature) {
        this._armature = armature;
      },
      dbClear: function() {
        this._armature = null;
      },
      dbUpdate: function() {
        false;
        this._initDebugDraw();
        var debugDraw = this._debugDraw;
        if (!debugDraw) return;
        debugDraw.clear();
        var bones = this._armature.getBones();
        for (var i = 0, l = bones.length; i < l; i++) {
          var bone = bones[i];
          var boneLength = Math.max(bone.boneData.length, 5);
          var startX = bone.globalTransformMatrix.tx;
          var startY = -bone.globalTransformMatrix.ty;
          var endX = startX + bone.globalTransformMatrix.a * boneLength;
          var endY = startY - bone.globalTransformMatrix.b * boneLength;
          debugDraw.moveTo(startX, startY);
          debugDraw.lineTo(endX, endY);
          debugDraw.stroke();
        }
      },
      advanceTimeBySelf: function(on) {
        this.shouldAdvanced = !!on;
      },
      hasDBEventListener: function(type) {
        return this.hasEventListener(type);
      },
      addDBEventListener: function(type, listener, target) {
        this.on(type, listener, target);
      },
      removeDBEventListener: function(type, listener, target) {
        this.off(type, listener, target);
      },
      dispatchDBEvent: function(type, eventObject) {
        this.emit(type, eventObject);
      }
    });
    module.exports = dragonBones.ArmatureDisplay = ArmatureDisplay;
  }), {
    "../../cocos2d/core/CCNode": 30,
    "../../cocos2d/core/components/CCRenderComponent": 77,
    "../../cocos2d/core/event/event-target": 100,
    "../../cocos2d/core/graphics/graphics": 104,
    "../../cocos2d/core/renderer": 196,
    "../../cocos2d/core/renderer/render-engine": 197
  } ],
  274: [ (function(require, module, exports) {
    var BaseObject = dragonBones.BaseObject;
    var CCFactory = dragonBones.CCFactory = cc.Class({
      name: "dragonBones.CCFactory",
      extends: dragonBones.BaseFactory,
      statics: {
        _factory: null,
        getInstance: function() {
          CCFactory._factory || (CCFactory._factory = new CCFactory());
          return CCFactory._factory;
        }
      },
      ctor: function() {
        this._dragonBones = new dragonBones.DragonBones();
        if (true, cc.director._scheduler) {
          cc.director._scheduler.enableForTarget(this);
          cc.director._scheduler.scheduleUpdate(this, cc.Scheduler.PRIORITY_SYSTEM, false);
        }
      },
      update: function(dt) {
        this._dragonBones.advanceTime(dt);
      },
      buildArmatureDisplay: function(armatureName, dragonBonesName, comp) {
        this._display = comp;
        var armature = this.buildArmature(armatureName, dragonBonesName, comp);
        this._display = null;
        return armature;
      },
      parseTextureAtlasData: function(jsonString, texture) {
        var atlasJsonObj = JSON.parse(jsonString);
        return this._super(atlasJsonObj, texture);
      },
      createArmatureNode: function(comp, armatureName, node) {
        node = node || new cc.Node();
        var display = node.getComponent(dragonBones.ArmatureDisplay);
        display || (display = node.addComponent(dragonBones.ArmatureDisplay));
        node.name = armatureName;
        display._armatureName = armatureName;
        display._N$dragonAsset = comp.dragonAsset;
        display._N$dragonAtlasAsset = comp.dragonAtlasAsset;
        display._init();
        return display;
      },
      _buildChildArmature: function(dataPackage, slot, displayData) {
        var temp = this._display;
        var name = "CHILD_ARMATURE-" + displayData.path;
        var node = this._display.node.getChildByName(name);
        node || (node = new cc.Node());
        var display = this.createArmatureNode(temp, displayData.path, node);
        node.name = name;
        this._display = temp;
        return display._armature;
      },
      _buildTextureAtlasData: function(textureAtlasData, textureAtlas) {
        textureAtlasData ? textureAtlasData.renderTexture = textureAtlas : textureAtlasData = BaseObject.borrowObject(dragonBones.CCTextureAtlasData);
        return textureAtlasData;
      },
      _sortSlots: function() {
        var slots = this._slots;
        var sortedSlots = [];
        for (var i = 0, l = slots.length; i < l; i++) {
          var slot = slots[i];
          var zOrder = slot._zOrder;
          var inserted = false;
          for (var j = sortedSlots.length - 1; j >= 0; j--) if (zOrder >= sortedSlots[j]._zOrder) {
            sortedSlots.splice(j + 1, 0, slot);
            inserted = true;
            break;
          }
          inserted || sortedSlots.splice(0, 0, slot);
        }
        this._slots = sortedSlots;
      },
      _buildArmature: function(dataPackage) {
        var armature = BaseObject.borrowObject(dragonBones.Armature);
        armature._skinData = dataPackage.skin;
        armature._animation = BaseObject.borrowObject(dragonBones.Animation);
        armature._animation._armature = armature;
        armature._animation.animations = dataPackage.armature.animations;
        armature._isChildArmature = false;
        armature.init(dataPackage.armature, this._display, this._display, this._dragonBones);
        return armature;
      },
      _buildSlot: function(dataPackage, slotData, displays) {
        var slot = BaseObject.borrowObject(dragonBones.CCSlot);
        var displayList = [];
        slot.name = slotData.name;
        slot.reset();
        var display = slot;
        slot.init(slotData, displays, display, display);
        return slot;
      }
    });
  }), {} ],
  275: [ (function(require, module, exports) {
    var renderEngine = require("../../cocos2d/core/renderer/render-engine");
    var math = renderEngine.math;
    var BlendFactor = require("../../cocos2d/core/platform/CCMacro");
    var BinaryOffset = dragonBones.BinaryOffset;
    var BoneType = dragonBones.BoneType;
    dragonBones.CCSlot = cc.Class({
      name: "dragonBones.CCSlot",
      extends: dragonBones.Slot,
      ctor: function() {
        this._vertices = [];
        this._localVertices = [];
        this._indices = [];
        this._matrix = math.mat4.create();
        this._visible = false;
      },
      reset: function() {
        this._vertices.length = 0;
        this._localVertices.length = 0;
        this._indices.length = 0;
        math.mat4.identity(this._matrix);
        this._visible = false;
      },
      statics: {
        toString: function() {
          return "[class dragonBones.CCSlot]";
        }
      },
      _onUpdateDisplay: function() {
        this._childArmature && (this._childArmature.display._isChildArmature = true);
      },
      _initDisplay: function(value) {},
      _addDisplay: function() {
        this._visible = true;
        true;
        this._rawDisplay.parent = this._armature.display.node;
      },
      _replaceDisplay: function(value) {
        value instanceof dragonBones.ArmatureDisplay && (value.node.parent = null);
        this._display instanceof dragonBones.ArmatureDisplay && (this._display.node.parent = this._armature.display.node);
      },
      _removeDisplay: function() {
        this._visible = false;
        true;
        this._rawDisplay.parent = null;
      },
      _disposeDisplay: function(object) {},
      _updateVisible: function() {},
      _updateZOrder: function() {},
      _updateBlendMode: function() {
        return;
        var texture;
        var childSlots;
        var i, l;
        var slot;
      },
      _updateColor: function() {
        var r = 255 * this._colorTransform.redMultiplier;
        var g = 255 * this._colorTransform.greenMultiplier;
        var b = 255 * this._colorTransform.blueMultiplier;
        var a = 255 * this._colorTransform.alphaMultiplier;
        this._color = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
      },
      _updateFrame: function() {
        this._vertices.length = 0;
        this._indices.length = 0;
        var vertices = this._vertices, indices = this._indices, localVertices = this._localVertices;
        vertices.length = 0;
        indices.length = 0;
        localVertices.length = 0;
        var currentTextureData = this._textureData;
        if (!this._display || this._displayIndex < 0 || !currentTextureData) return;
        var currentDisplayData = this._displayIndex < this.rawDisplayDatas.length ? this.rawDisplayDatas[this._displayIndex] : null;
        var textureAtlas = this._armature._replacedTexture || currentTextureData.parent.renderTexture;
        if (textureAtlas && (!currentTextureData.spriteFrame || currentTextureData.spriteFrame.getTexture() !== textureAtlas)) {
          var rect = cc.rect(currentTextureData.region.x, currentTextureData.region.y, currentTextureData.region.width, currentTextureData.region.height);
          var offset = cc.v2(0, 0);
          var size = cc.size(currentTextureData.region.width, currentTextureData.region.height);
          currentTextureData.spriteFrame = new cc.SpriteFrame();
          currentTextureData.spriteFrame.setTexture(textureAtlas, rect, false, offset, size);
        }
        var textureAtlasWidth = textureAtlas.width;
        var textureAtlasHeight = textureAtlas.height;
        var region = currentTextureData.region;
        var meshData = this._meshData;
        if (meshData) {
          var scale = this._armature._armatureData.scale;
          var data = meshData.parent.parent.parent;
          var intArray = data.intArray;
          var floatArray = data.floatArray;
          var vertexCount = intArray[meshData.offset + BinaryOffset.MeshVertexCount];
          var triangleCount = intArray[meshData.offset + BinaryOffset.MeshTriangleCount];
          var vertexOffset = intArray[meshData.offset + BinaryOffset.MeshFloatOffset];
          vertexOffset < 0 && (vertexOffset += 65536);
          var uvOffset = vertexOffset + 2 * vertexCount;
          for (var i = 0, l = vertexCount; i < l; i++) {
            var x = floatArray[vertexOffset + 2 * i];
            var y = -floatArray[vertexOffset + 2 * i + 1];
            var u = (region.x + floatArray[uvOffset + 2 * i] * region.width) / textureAtlasWidth;
            var v = (region.y + floatArray[uvOffset + 2 * i + 1] * region.height) / textureAtlasHeight;
            vertices.push({
              x: x,
              y: y,
              u: u,
              v: v
            });
            localVertices.push({
              x: x,
              y: y
            });
          }
          for (var _i = 0; _i < 3 * triangleCount; ++_i) indices.push(intArray[meshData.offset + BinaryOffset.MeshVertexIndices + _i]);
          this._pivotX = 0;
          this._pivotY = 0;
        } else {
          var _scale = this._armature.armatureData.scale;
          this._pivotX = currentDisplayData.pivot.x;
          this._pivotY = currentDisplayData.pivot.y;
          var rectData = currentTextureData.frame || currentTextureData.region;
          var width = rectData.width * _scale;
          var height = rectData.height * _scale;
          if (!currentTextureData.frame && currentTextureData.rotated) {
            width = rectData.height;
            height = rectData.width;
          }
          this._pivotX *= width;
          this._pivotY *= height;
          if (currentTextureData.frame) {
            this._pivotX += currentTextureData.frame.x * _scale;
            this._pivotY += currentTextureData.frame.y * _scale;
          }
          this._pivotY -= region.height * _scale;
          for (var _i2 = 0; _i2 < 4; _i2++) {
            vertices.push({});
            localVertices.push({});
          }
          var _l = region.x / textureAtlasWidth;
          var b = (region.y + region.height) / textureAtlasHeight;
          var r = (region.x + region.width) / textureAtlasWidth;
          var t = region.y / textureAtlasHeight;
          vertices[0].u = _l;
          vertices[0].v = b;
          vertices[1].u = r;
          vertices[1].v = b;
          vertices[2].u = _l;
          vertices[2].v = t;
          vertices[3].u = r;
          vertices[3].v = t;
          localVertices[0].x = localVertices[2].x = vertices[0].x = vertices[2].x = 0;
          localVertices[1].x = localVertices[3].x = vertices[1].x = vertices[3].x = region.width;
          localVertices[0].y = localVertices[1].y = vertices[0].y = vertices[1].y = 0;
          localVertices[2].y = localVertices[3].y = vertices[2].y = vertices[3].y = region.height;
          indices[0] = 0;
          indices[1] = 1;
          indices[2] = 2;
          indices[3] = 1;
          indices[4] = 3;
          indices[5] = 2;
          this._blendModeDirty = true;
        }
      },
      _updateMesh: function() {
        var scale = this._armature._armatureData.scale;
        var meshData = this._meshData;
        var hasDeform = this._deformVertices.length > 0 && meshData.inheritDeform;
        var weight = meshData.weight;
        var localVertices = this._localVertices;
        if (null !== weight) {
          var data = meshData.parent.parent.parent;
          var intArray = data.intArray;
          var floatArray = data.floatArray;
          var vertexCount = intArray[meshData.offset + BinaryOffset.MeshVertexCount];
          var weightFloatOffset = intArray[weight.offset + BinaryOffset.WeigthFloatOffset];
          weightFloatOffset < 0 && (weightFloatOffset += 65536);
          for (var i = 0, iB = weight.offset + BinaryOffset.WeigthBoneIndices + weight.bones.length, iV = weightFloatOffset, iF = 0; i < vertexCount; ++i) {
            var boneCount = intArray[iB++];
            var xG = 0, yG = 0;
            for (var j = 0; j < boneCount; ++j) {
              var boneIndex = intArray[iB++];
              var bone = this._meshBones[boneIndex];
              if (null !== bone) {
                var matrix = bone.globalTransformMatrix;
                var _weight = floatArray[iV++];
                var xL = floatArray[iV++] * scale;
                var yL = floatArray[iV++] * scale;
                if (hasDeform) {
                  xL += this._deformVertices[iF++];
                  yL += this._deformVertices[iF++];
                }
                xG += (matrix.a * xL + matrix.c * yL + matrix.tx) * _weight;
                yG += (matrix.b * xL + matrix.d * yL + matrix.ty) * _weight;
              }
            }
            localVertices[i].x = xG;
            localVertices[i].y = -yG;
          }
        } else if (hasDeform) {
          var isSurface = this._parent._boneData.type !== BoneType.Bone;
          var _data = meshData.parent.parent.parent;
          var _intArray = _data.intArray;
          var _floatArray = _data.floatArray;
          var _vertexCount = _intArray[meshData.offset + BinaryOffset.MeshVertexCount];
          var vertexOffset = _intArray[meshData.offset + BinaryOffset.MeshFloatOffset];
          vertexOffset < 0 && (vertexOffset += 65536);
          for (var _i3 = 0, l = _vertexCount; _i3 < l; _i3++) {
            var x = _floatArray[vertexOffset + 2 * _i3] * scale + this._deformVertices[2 * _i3];
            var y = _floatArray[vertexOffset + 2 * _i3 + 1] * scale + this._deformVertices[2 * _i3 + 1];
            if (isSurface) {
              var _matrix = this._parent._getGlobalTransformMatrix(x, y);
              localVertices[_i3].x = _matrix.a * x + _matrix.c * y + _matrix.tx;
              localVertices[_i3].y = -_matrix.b * x + _matrix.d * y + _matrix.ty;
            } else {
              localVertices[_i3].x = x;
              localVertices[_i3].y = -y;
            }
          }
        }
        this._updateVertices();
      },
      _updateTransform: function() {
        var t = this._matrix;
        t.m00 = this.globalTransformMatrix.a;
        t.m01 = -this.globalTransformMatrix.b;
        t.m04 = -this.globalTransformMatrix.c;
        t.m05 = this.globalTransformMatrix.d;
        t.m12 = this.globalTransformMatrix.tx - (this.globalTransformMatrix.a * this._pivotX + this.globalTransformMatrix.c * this._pivotY);
        t.m13 = -(this.globalTransformMatrix.ty - (this.globalTransformMatrix.b * this._pivotX + this.globalTransformMatrix.d * this._pivotY));
        if (this._display instanceof dragonBones.ArmatureDisplay) {
          var node = this._display.node;
          math.mat4.copy(node._matrix, t);
          node._localMatDirty = false;
          node.setWorldDirty();
        }
        this._updateVertices();
      },
      _updateVertices: function() {
        var t = this._matrix;
        var a = t.m00, b = t.m01, c = t.m04, d = t.m05, tx = t.m12, ty = t.m13;
        var vertices = this._vertices;
        var localVertices = this._localVertices;
        for (var i = 0, l = vertices.length; i < l; i++) {
          var x = localVertices[i].x;
          var y = localVertices[i].y;
          vertices[i].x = a * x + c * y + tx;
          vertices[i].y = b * x + d * y + ty;
        }
      }
    });
  }), {
    "../../cocos2d/core/platform/CCMacro": 160,
    "../../cocos2d/core/renderer/render-engine": 197
  } ],
  276: [ (function(require, module, exports) {
    dragonBones.CCTextureAtlasData = cc.Class({
      extends: dragonBones.TextureAtlasData,
      properties: {
        texture: {
          default: null,
          serializable: false
        }
      },
      statics: {
        toString: function() {
          return "[class dragonBones.CCTextureAtlasData]";
        }
      },
      _onClear: function() {
        dragonBones.TextureAtlasData.prototype._onClear.call(this);
        this.texture = null;
      },
      createTexture: function() {
        return dragonBones.BaseObject.borrowObject(dragonBones.CCTextureData);
      }
    });
    dragonBones.CCTextureData = cc.Class({
      extends: dragonBones.TextureData,
      properties: {
        texture: {
          default: null,
          serializable: false
        }
      },
      statics: {
        toString: function() {
          return "[class dragonBones.CCTextureData]";
        }
      },
      _onClear: function() {
        dragonBones.TextureData.prototype._onClear.call(this);
        this.texture = null;
      }
    });
  }), {} ],
  277: [ (function(require, module, exports) {
    var DragonBonesAsset = cc.Class({
      name: "dragonBones.DragonBonesAsset",
      extends: cc.Asset,
      ctor: function() {
        this.reset();
      },
      properties: {
        _dragonBonesJson: "",
        dragonBonesJson: {
          get: function() {
            return this._dragonBonesJson;
          },
          set: function(value) {
            this._dragonBonesJson = value;
            this.reset();
          }
        }
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      createNode: false,
      reset: function() {
        this._dragonBonesData = null;
        false;
      },
      init: function(factory) {
        false;
        if (this._dragonBonesData) {
          var sameNamedDragonBonesData = factory.getDragonBonesData(this._dragonBonesData.name);
          if (sameNamedDragonBonesData) {
            for (var i = 0; i < this._dragonBonesData.armatureNames.length; i++) {
              var armatureName = this._dragonBonesData.armatureNames[i];
              sameNamedDragonBonesData.armatures[armatureName] || sameNamedDragonBonesData.addArmature(this._dragonBonesData.armatures[armatureName]);
            }
            this._dragonBonesData = sameNamedDragonBonesData;
          } else factory.addDragonBonesData(this._dragonBonesData);
        } else {
          false;
          var jsonObj = JSON.parse(this._dragonBonesJson);
          var _sameNamedDragonBonesData = factory.getDragonBonesData(jsonObj.name);
          if (_sameNamedDragonBonesData) {
            var dragonBonesData = void 0;
            for (var _i = 0; _i < jsonObj.armature.length; _i++) {
              var _armatureName = jsonObj.armature[_i].name;
              if (!_sameNamedDragonBonesData.armatures[_armatureName]) {
                dragonBonesData || (dragonBonesData = factory._dataParser.parseDragonBonesData(jsonObj));
                _sameNamedDragonBonesData.addArmature(dragonBonesData.armatures[_armatureName]);
              }
            }
            this._dragonBonesData = _sameNamedDragonBonesData;
          } else this._dragonBonesData = factory.parseDragonBonesData(jsonObj);
        }
      },
      getArmatureEnum: false,
      getAnimsEnum: false,
      destroy: function() {
        var useGlobalFactory = true;
        if (useGlobalFactory && this._dragonBonesData) {
          var factory = dragonBones.CCFactory.getInstance();
          factory.removeDragonBonesData(this._dragonBonesData.name, true);
        }
        this._super();
      }
    });
    dragonBones.DragonBonesAsset = module.exports = DragonBonesAsset;
  }), {} ],
  278: [ (function(require, module, exports) {
    var DragonBonesAtlasAsset = cc.Class({
      name: "dragonBones.DragonBonesAtlasAsset",
      extends: cc.Asset,
      ctor: function() {
        this.reset();
      },
      properties: {
        _atlasJson: "",
        atlasJson: {
          get: function() {
            return this._atlasJson;
          },
          set: function(value) {
            this._atlasJson = value;
            this.reset();
          }
        },
        _texture: {
          default: null,
          type: cc.Texture2D,
          formerlySerializedAs: "texture"
        },
        texture: {
          get: function() {
            return this._texture;
          },
          set: function(value) {
            this._texture = value;
            this.reset();
          }
        }
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      reset: function() {
        this._textureAtlasData = null;
      },
      createNode: false,
      init: function(factory) {
        if (this._textureAtlasData) {
          cc.log("Has textureAtlasData");
          factory.addTextureAtlasData(this._textureAtlasData);
        } else this._textureAtlasData = factory.parseTextureAtlasData(this.atlasJson, this.texture);
      },
      destroy: function() {
        var useGlobalFactory = true;
        if (useGlobalFactory && this._textureAtlasData) {
          var factory = dragonBones.CCFactory.getInstance();
          var name = this._textureAtlasData.name;
          factory.removeTextureAtlasData(name, true);
          factory.removeDragonBonesData(name, true);
        }
        this._super();
      }
    });
    dragonBones.DragonBonesAtlasAsset = module.exports = DragonBonesAtlasAsset;
  }), {} ],
  279: [ (function(require, module, exports) {
    var Armature = require("./ArmatureDisplay");
    var renderEngine = require("../../cocos2d/core/renderer/render-engine");
    var math = renderEngine.math;
    var utils = require("../../cocos2d/core/renderer/canvas/renderers/utils");
    var _color = cc.color();
    var _matrix = math.mat4.create();
    var _matrix2 = math.mat4.create();
    var armatureAssembler = {
      draw: function(ctx, comp) {
        var armature = comp._armature;
        if (!armature || comp._isChildArmature) return 0;
        ctx.save();
        var node = comp.node;
        var matrix = node._worldMatrix;
        var texture = comp.dragonAtlasAsset.texture;
        this.drawArmature(ctx, armature, texture, matrix);
        ctx.restore();
        return 1;
      },
      drawArmature: function(ctx, armature, texture, matrix) {
        var slots = armature._slots;
        for (var i = 0, l = slots.length; i < l; i++) {
          var slot = slots[i];
          if (!slot._visible || !slot._displayData) continue;
          if (slot.childArmature) {
            math.mat4.mul(_matrix, matrix, slot._matrix);
            this.drawArmature(ctx, slot.childArmature, texture, _matrix);
            continue;
          }
          var localVertices = slot._localVertices;
          if (4 !== localVertices.length) continue;
          ctx.save();
          math.mat4.mul(_matrix2, matrix, slot._matrix);
          var m = _matrix2;
          ctx.transform(m.m00, -m.m01, -m.m04, m.m05, m.m12, -m.m13);
          var vertices = slot._vertices;
          var sx = vertices[0].u * texture.width;
          var sy = vertices[3].v * texture.height;
          var sw = vertices[3].u * texture.width - sx;
          var sh = vertices[0].v * texture.height - sy;
          var x = localVertices[0].x;
          var y = localVertices[0].y;
          var w = localVertices[3].x - x;
          var h = localVertices[3].y - y;
          y = -y - h;
          _color._val = slot._color;
          var image = utils.getFrameCache(texture, _color, sx, sy, sw, sh);
          ctx.drawImage(image, x, y, w, h);
          ctx.restore();
        }
      }
    };
    module.exports = Armature._assembler = armatureAssembler;
  }), {
    "../../cocos2d/core/renderer/canvas/renderers/utils": 195,
    "../../cocos2d/core/renderer/render-engine": 197,
    "./ArmatureDisplay": 273
  } ],
  280: [ (function(require, module, exports) {
    var _global = "undefined" === typeof window ? global : window;
    _global.dragonBones = require("./lib/dragonBones");
    dragonBones.DisplayType = {
      Image: 0,
      Armature: 1,
      Mesh: 2
    };
    dragonBones.ArmatureType = {
      Armature: 0,
      MovieClip: 1,
      Stage: 2
    };
    dragonBones.ExtensionType = {
      FFD: 0,
      AdjustColor: 10,
      BevelFilter: 11,
      BlurFilter: 12,
      DropShadowFilter: 13,
      GlowFilter: 14,
      GradientBevelFilter: 15,
      GradientGlowFilter: 16
    };
    dragonBones.EventType = {
      Frame: 0,
      Sound: 1
    };
    dragonBones.ActionType = {
      Play: 0,
      Stop: 1,
      GotoAndPlay: 2,
      GotoAndStop: 3,
      FadeIn: 4,
      FadeOut: 5
    };
    dragonBones.AnimationFadeOutMode = {
      None: 0,
      SameLayer: 1,
      SameGroup: 2,
      SameLayerAndGroup: 3,
      All: 4
    };
    dragonBones.BinaryOffset = {
      WeigthBoneCount: 0,
      WeigthFloatOffset: 1,
      WeigthBoneIndices: 2,
      MeshVertexCount: 0,
      MeshTriangleCount: 1,
      MeshFloatOffset: 2,
      MeshWeightOffset: 3,
      MeshVertexIndices: 4,
      TimelineScale: 0,
      TimelineOffset: 1,
      TimelineKeyFrameCount: 2,
      TimelineFrameValueCount: 3,
      TimelineFrameValueOffset: 4,
      TimelineFrameOffset: 5,
      FramePosition: 0,
      FrameTweenType: 1,
      FrameTweenEasingOrCurveSampleCount: 2,
      FrameCurveSamples: 3,
      DeformMeshOffset: 0,
      DeformCount: 1,
      DeformValueCount: 2,
      DeformValueOffset: 3,
      DeformFloatOffset: 4
    };
    dragonBones.BoneType = {
      Bone: 0,
      Surface: 1
    };
    true;
    require("./CCFactory");
    require("./CCSlot");
    require("./CCTextureData");
    require("./DragonBonesAsset");
    require("./DragonBonesAtlasAsset");
    require("./ArmatureDisplay");
    cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
      cc.game.renderType === cc.game.RENDER_TYPE_CANVAS ? require("./canvas-assembler") : require("./webgl-assembler");
    }));
  }), {
    "./ArmatureDisplay": 273,
    "./CCFactory": 274,
    "./CCSlot": 275,
    "./CCTextureData": 276,
    "./DragonBonesAsset": 277,
    "./DragonBonesAtlasAsset": 278,
    "./canvas-assembler": 279,
    "./lib/dragonBones": 281,
    "./webgl-assembler": 282
  } ],
  281: [ (function(require, module, exports) {
    "use strict";
    var __extends = this && this.__extends || (function() {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var dragonBones;
    (function(dragonBones) {})(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var DragonBones = (function() {
        function DragonBones(eventManager) {
          this._clock = new dragonBones.WorldClock();
          this._events = [];
          this._objects = [];
          this._eventManager = null;
          this._eventManager = eventManager;
          console.info("DragonBones: " + DragonBones.VERSION + "\nWebsite: http://dragonbones.com/\nSource and Demos: https://github.com/DragonBones/");
        }
        DragonBones.prototype.advanceTime = function(passedTime) {
          if (this._objects.length > 0) {
            for (var _i = 0, _a = this._objects; _i < _a.length; _i++) {
              var object = _a[_i];
              object.returnToPool();
            }
            this._objects.length = 0;
          }
          this._clock.advanceTime(passedTime);
          if (this._events.length > 0) {
            for (var i = 0; i < this._events.length; ++i) {
              var eventObject = this._events[i];
              var armature = eventObject.armature;
              if (null !== armature._armatureData) {
                armature.eventDispatcher.dispatchDBEvent(eventObject.type, eventObject);
                eventObject.type === dragonBones.EventObject.SOUND_EVENT && this._eventManager.dispatchDBEvent(eventObject.type, eventObject);
              }
              this.bufferObject(eventObject);
            }
            this._events.length = 0;
          }
        };
        DragonBones.prototype.bufferEvent = function(value) {
          this._events.indexOf(value) < 0 && this._events.push(value);
        };
        DragonBones.prototype.bufferObject = function(object) {
          this._objects.indexOf(object) < 0 && this._objects.push(object);
        };
        Object.defineProperty(DragonBones.prototype, "clock", {
          get: function() {
            return this._clock;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(DragonBones.prototype, "eventManager", {
          get: function() {
            return this._eventManager;
          },
          enumerable: true,
          configurable: true
        });
        DragonBones.VERSION = "5.6.2";
        DragonBones.yDown = true;
        DragonBones.debug = false;
        DragonBones.debugDraw = false;
        DragonBones.webAssembly = false;
        return DragonBones;
      })();
      dragonBones.DragonBones = DragonBones;
      console.warn || (console.warn = function() {});
      console.assert || (console.assert = function() {});
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var BaseObject = (function() {
        function BaseObject() {
          this.hashCode = BaseObject._hashCode++;
          this._isInPool = false;
        }
        BaseObject._returnObject = function(object) {
          var classType = String(object.constructor);
          var maxCount = classType in BaseObject._maxCountMap ? BaseObject._maxCountMap[classType] : BaseObject._defaultMaxCount;
          var pool = BaseObject._poolsMap[classType] = BaseObject._poolsMap[classType] || [];
          if (pool.length < maxCount) if (object._isInPool) console.warn("The object is already in the pool."); else {
            object._isInPool = true;
            pool.push(object);
          }
        };
        BaseObject.toString = function() {
          throw new Error();
        };
        BaseObject.setMaxCount = function(objectConstructor, maxCount) {
          (maxCount < 0 || maxCount !== maxCount) && (maxCount = 0);
          if (null !== objectConstructor) {
            var classType = String(objectConstructor);
            var pool = classType in BaseObject._poolsMap ? BaseObject._poolsMap[classType] : null;
            null !== pool && pool.length > maxCount && (pool.length = maxCount);
            BaseObject._maxCountMap[classType] = maxCount;
          } else {
            BaseObject._defaultMaxCount = maxCount;
            for (var classType in BaseObject._poolsMap) {
              var pool = BaseObject._poolsMap[classType];
              pool.length > maxCount && (pool.length = maxCount);
              classType in BaseObject._maxCountMap && (BaseObject._maxCountMap[classType] = maxCount);
            }
          }
        };
        BaseObject.clearPool = function(objectConstructor) {
          void 0 === objectConstructor && (objectConstructor = null);
          if (null !== objectConstructor) {
            var classType = String(objectConstructor);
            var pool = classType in BaseObject._poolsMap ? BaseObject._poolsMap[classType] : null;
            null !== pool && pool.length > 0 && (pool.length = 0);
          } else for (var k in BaseObject._poolsMap) {
            var pool = BaseObject._poolsMap[k];
            pool.length = 0;
          }
        };
        BaseObject.borrowObject = function(objectConstructor) {
          var classType = String(objectConstructor);
          var pool = classType in BaseObject._poolsMap ? BaseObject._poolsMap[classType] : null;
          if (null !== pool && pool.length > 0) {
            var object_1 = pool.pop();
            object_1._isInPool = false;
            return object_1;
          }
          var object = new objectConstructor();
          object._onClear();
          return object;
        };
        BaseObject.prototype.returnToPool = function() {
          this._onClear();
          BaseObject._returnObject(this);
        };
        BaseObject._hashCode = 0;
        BaseObject._defaultMaxCount = 3e3;
        BaseObject._maxCountMap = {};
        BaseObject._poolsMap = {};
        return BaseObject;
      })();
      dragonBones.BaseObject = BaseObject;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Matrix = (function() {
        function Matrix(a, b, c, d, tx, ty) {
          void 0 === a && (a = 1);
          void 0 === b && (b = 0);
          void 0 === c && (c = 0);
          void 0 === d && (d = 1);
          void 0 === tx && (tx = 0);
          void 0 === ty && (ty = 0);
          this.a = a;
          this.b = b;
          this.c = c;
          this.d = d;
          this.tx = tx;
          this.ty = ty;
        }
        Matrix.prototype.toString = function() {
          return "[object dragonBones.Matrix] a:" + this.a + " b:" + this.b + " c:" + this.c + " d:" + this.d + " tx:" + this.tx + " ty:" + this.ty;
        };
        Matrix.prototype.copyFrom = function(value) {
          this.a = value.a;
          this.b = value.b;
          this.c = value.c;
          this.d = value.d;
          this.tx = value.tx;
          this.ty = value.ty;
          return this;
        };
        Matrix.prototype.copyFromArray = function(value, offset) {
          void 0 === offset && (offset = 0);
          this.a = value[offset];
          this.b = value[offset + 1];
          this.c = value[offset + 2];
          this.d = value[offset + 3];
          this.tx = value[offset + 4];
          this.ty = value[offset + 5];
          return this;
        };
        Matrix.prototype.identity = function() {
          this.a = this.d = 1;
          this.b = this.c = 0;
          this.tx = this.ty = 0;
          return this;
        };
        Matrix.prototype.concat = function(value) {
          var aA = this.a * value.a;
          var bA = 0;
          var cA = 0;
          var dA = this.d * value.d;
          var txA = this.tx * value.a + value.tx;
          var tyA = this.ty * value.d + value.ty;
          if (0 !== this.b || 0 !== this.c) {
            aA += this.b * value.c;
            bA += this.b * value.d;
            cA += this.c * value.a;
            dA += this.c * value.b;
          }
          if (0 !== value.b || 0 !== value.c) {
            bA += this.a * value.b;
            cA += this.d * value.c;
            txA += this.ty * value.c;
            tyA += this.tx * value.b;
          }
          this.a = aA;
          this.b = bA;
          this.c = cA;
          this.d = dA;
          this.tx = txA;
          this.ty = tyA;
          return this;
        };
        Matrix.prototype.invert = function() {
          var aA = this.a;
          var bA = this.b;
          var cA = this.c;
          var dA = this.d;
          var txA = this.tx;
          var tyA = this.ty;
          if (0 === bA && 0 === cA) {
            this.b = this.c = 0;
            if (0 === aA || 0 === dA) this.a = this.b = this.tx = this.ty = 0; else {
              aA = this.a = 1 / aA;
              dA = this.d = 1 / dA;
              this.tx = -aA * txA;
              this.ty = -dA * tyA;
            }
            return this;
          }
          var determinant = aA * dA - bA * cA;
          if (0 === determinant) {
            this.a = this.d = 1;
            this.b = this.c = 0;
            this.tx = this.ty = 0;
            return this;
          }
          determinant = 1 / determinant;
          var k = this.a = dA * determinant;
          bA = this.b = -bA * determinant;
          cA = this.c = -cA * determinant;
          dA = this.d = aA * determinant;
          this.tx = -(k * txA + cA * tyA);
          this.ty = -(bA * txA + dA * tyA);
          return this;
        };
        Matrix.prototype.transformPoint = function(x, y, result, delta) {
          void 0 === delta && (delta = false);
          result.x = this.a * x + this.c * y;
          result.y = this.b * x + this.d * y;
          if (!delta) {
            result.x += this.tx;
            result.y += this.ty;
          }
        };
        Matrix.prototype.transformRectangle = function(rectangle, delta) {
          void 0 === delta && (delta = false);
          var a = this.a;
          var b = this.b;
          var c = this.c;
          var d = this.d;
          var tx = delta ? 0 : this.tx;
          var ty = delta ? 0 : this.ty;
          var x = rectangle.x;
          var y = rectangle.y;
          var xMax = x + rectangle.width;
          var yMax = y + rectangle.height;
          var x0 = a * x + c * y + tx;
          var y0 = b * x + d * y + ty;
          var x1 = a * xMax + c * y + tx;
          var y1 = b * xMax + d * y + ty;
          var x2 = a * xMax + c * yMax + tx;
          var y2 = b * xMax + d * yMax + ty;
          var x3 = a * x + c * yMax + tx;
          var y3 = b * x + d * yMax + ty;
          var tmp = 0;
          if (x0 > x1) {
            tmp = x0;
            x0 = x1;
            x1 = tmp;
          }
          if (x2 > x3) {
            tmp = x2;
            x2 = x3;
            x3 = tmp;
          }
          rectangle.x = Math.floor(x0 < x2 ? x0 : x2);
          rectangle.width = Math.ceil((x1 > x3 ? x1 : x3) - rectangle.x);
          if (y0 > y1) {
            tmp = y0;
            y0 = y1;
            y1 = tmp;
          }
          if (y2 > y3) {
            tmp = y2;
            y2 = y3;
            y3 = tmp;
          }
          rectangle.y = Math.floor(y0 < y2 ? y0 : y2);
          rectangle.height = Math.ceil((y1 > y3 ? y1 : y3) - rectangle.y);
        };
        return Matrix;
      })();
      dragonBones.Matrix = Matrix;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Transform = (function() {
        function Transform(x, y, skew, rotation, scaleX, scaleY) {
          void 0 === x && (x = 0);
          void 0 === y && (y = 0);
          void 0 === skew && (skew = 0);
          void 0 === rotation && (rotation = 0);
          void 0 === scaleX && (scaleX = 1);
          void 0 === scaleY && (scaleY = 1);
          this.x = x;
          this.y = y;
          this.skew = skew;
          this.rotation = rotation;
          this.scaleX = scaleX;
          this.scaleY = scaleY;
        }
        Transform.normalizeRadian = function(value) {
          value = (value + Math.PI) % (2 * Math.PI);
          value += value > 0 ? -Math.PI : Math.PI;
          return value;
        };
        Transform.prototype.toString = function() {
          return "[object dragonBones.Transform] x:" + this.x + " y:" + this.y + " skewX:" + 180 * this.skew / Math.PI + " skewY:" + 180 * this.rotation / Math.PI + " scaleX:" + this.scaleX + " scaleY:" + this.scaleY;
        };
        Transform.prototype.copyFrom = function(value) {
          this.x = value.x;
          this.y = value.y;
          this.skew = value.skew;
          this.rotation = value.rotation;
          this.scaleX = value.scaleX;
          this.scaleY = value.scaleY;
          return this;
        };
        Transform.prototype.identity = function() {
          this.x = this.y = 0;
          this.skew = this.rotation = 0;
          this.scaleX = this.scaleY = 1;
          return this;
        };
        Transform.prototype.add = function(value) {
          this.x += value.x;
          this.y += value.y;
          this.skew += value.skew;
          this.rotation += value.rotation;
          this.scaleX *= value.scaleX;
          this.scaleY *= value.scaleY;
          return this;
        };
        Transform.prototype.minus = function(value) {
          this.x -= value.x;
          this.y -= value.y;
          this.skew -= value.skew;
          this.rotation -= value.rotation;
          this.scaleX /= value.scaleX;
          this.scaleY /= value.scaleY;
          return this;
        };
        Transform.prototype.fromMatrix = function(matrix) {
          var backupScaleX = this.scaleX, backupScaleY = this.scaleY;
          var PI_Q = Transform.PI_Q;
          this.x = matrix.tx;
          this.y = matrix.ty;
          this.rotation = Math.atan(matrix.b / matrix.a);
          var skewX = Math.atan(-matrix.c / matrix.d);
          this.scaleX = this.rotation > -PI_Q && this.rotation < PI_Q ? matrix.a / Math.cos(this.rotation) : matrix.b / Math.sin(this.rotation);
          this.scaleY = skewX > -PI_Q && skewX < PI_Q ? matrix.d / Math.cos(skewX) : -matrix.c / Math.sin(skewX);
          if (backupScaleX >= 0 && this.scaleX < 0) {
            this.scaleX = -this.scaleX;
            this.rotation = this.rotation - Math.PI;
          }
          if (backupScaleY >= 0 && this.scaleY < 0) {
            this.scaleY = -this.scaleY;
            skewX -= Math.PI;
          }
          this.skew = skewX - this.rotation;
          return this;
        };
        Transform.prototype.toMatrix = function(matrix) {
          if (0 === this.rotation) {
            matrix.a = 1;
            matrix.b = 0;
          } else {
            matrix.a = Math.cos(this.rotation);
            matrix.b = Math.sin(this.rotation);
          }
          if (0 === this.skew) {
            matrix.c = -matrix.b;
            matrix.d = matrix.a;
          } else {
            matrix.c = -Math.sin(this.skew + this.rotation);
            matrix.d = Math.cos(this.skew + this.rotation);
          }
          if (1 !== this.scaleX) {
            matrix.a *= this.scaleX;
            matrix.b *= this.scaleX;
          }
          if (1 !== this.scaleY) {
            matrix.c *= this.scaleY;
            matrix.d *= this.scaleY;
          }
          matrix.tx = this.x;
          matrix.ty = this.y;
          return this;
        };
        Transform.PI = Math.PI;
        Transform.PI_D = 2 * Math.PI;
        Transform.PI_H = Math.PI / 2;
        Transform.PI_Q = Math.PI / 4;
        Transform.RAD_DEG = 180 / Math.PI;
        Transform.DEG_RAD = Math.PI / 180;
        return Transform;
      })();
      dragonBones.Transform = Transform;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var ColorTransform = (function() {
        function ColorTransform(alphaMultiplier, redMultiplier, greenMultiplier, blueMultiplier, alphaOffset, redOffset, greenOffset, blueOffset) {
          void 0 === alphaMultiplier && (alphaMultiplier = 1);
          void 0 === redMultiplier && (redMultiplier = 1);
          void 0 === greenMultiplier && (greenMultiplier = 1);
          void 0 === blueMultiplier && (blueMultiplier = 1);
          void 0 === alphaOffset && (alphaOffset = 0);
          void 0 === redOffset && (redOffset = 0);
          void 0 === greenOffset && (greenOffset = 0);
          void 0 === blueOffset && (blueOffset = 0);
          this.alphaMultiplier = alphaMultiplier;
          this.redMultiplier = redMultiplier;
          this.greenMultiplier = greenMultiplier;
          this.blueMultiplier = blueMultiplier;
          this.alphaOffset = alphaOffset;
          this.redOffset = redOffset;
          this.greenOffset = greenOffset;
          this.blueOffset = blueOffset;
        }
        ColorTransform.prototype.copyFrom = function(value) {
          this.alphaMultiplier = value.alphaMultiplier;
          this.redMultiplier = value.redMultiplier;
          this.greenMultiplier = value.greenMultiplier;
          this.blueMultiplier = value.blueMultiplier;
          this.alphaOffset = value.alphaOffset;
          this.redOffset = value.redOffset;
          this.greenOffset = value.greenOffset;
          this.blueOffset = value.blueOffset;
        };
        ColorTransform.prototype.identity = function() {
          this.alphaMultiplier = this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 1;
          this.alphaOffset = this.redOffset = this.greenOffset = this.blueOffset = 0;
        };
        return ColorTransform;
      })();
      dragonBones.ColorTransform = ColorTransform;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Point = (function() {
        function Point(x, y) {
          void 0 === x && (x = 0);
          void 0 === y && (y = 0);
          this.x = x;
          this.y = y;
        }
        Point.prototype.copyFrom = function(value) {
          this.x = value.x;
          this.y = value.y;
        };
        Point.prototype.clear = function() {
          this.x = this.y = 0;
        };
        return Point;
      })();
      dragonBones.Point = Point;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Rectangle = (function() {
        function Rectangle(x, y, width, height) {
          void 0 === x && (x = 0);
          void 0 === y && (y = 0);
          void 0 === width && (width = 0);
          void 0 === height && (height = 0);
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }
        Rectangle.prototype.copyFrom = function(value) {
          this.x = value.x;
          this.y = value.y;
          this.width = value.width;
          this.height = value.height;
        };
        Rectangle.prototype.clear = function() {
          this.x = this.y = 0;
          this.width = this.height = 0;
        };
        return Rectangle;
      })();
      dragonBones.Rectangle = Rectangle;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var UserData = (function(_super) {
        __extends(UserData, _super);
        function UserData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.ints = [];
          _this.floats = [];
          _this.strings = [];
          return _this;
        }
        UserData.toString = function() {
          return "[class dragonBones.UserData]";
        };
        UserData.prototype._onClear = function() {
          this.ints.length = 0;
          this.floats.length = 0;
          this.strings.length = 0;
        };
        UserData.prototype.addInt = function(value) {
          this.ints.push(value);
        };
        UserData.prototype.addFloat = function(value) {
          this.floats.push(value);
        };
        UserData.prototype.addString = function(value) {
          this.strings.push(value);
        };
        UserData.prototype.getInt = function(index) {
          void 0 === index && (index = 0);
          return index >= 0 && index < this.ints.length ? this.ints[index] : 0;
        };
        UserData.prototype.getFloat = function(index) {
          void 0 === index && (index = 0);
          return index >= 0 && index < this.floats.length ? this.floats[index] : 0;
        };
        UserData.prototype.getString = function(index) {
          void 0 === index && (index = 0);
          return index >= 0 && index < this.strings.length ? this.strings[index] : "";
        };
        return UserData;
      })(dragonBones.BaseObject);
      dragonBones.UserData = UserData;
      var ActionData = (function(_super) {
        __extends(ActionData, _super);
        function ActionData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.data = null;
          return _this;
        }
        ActionData.toString = function() {
          return "[class dragonBones.ActionData]";
        };
        ActionData.prototype._onClear = function() {
          null !== this.data && this.data.returnToPool();
          this.type = 0;
          this.name = "";
          this.bone = null;
          this.slot = null;
          this.data = null;
        };
        return ActionData;
      })(dragonBones.BaseObject);
      dragonBones.ActionData = ActionData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var DragonBonesData = (function(_super) {
        __extends(DragonBonesData, _super);
        function DragonBonesData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.frameIndices = [];
          _this.cachedFrames = [];
          _this.armatureNames = [];
          _this.armatures = {};
          _this.userData = null;
          return _this;
        }
        DragonBonesData.toString = function() {
          return "[class dragonBones.DragonBonesData]";
        };
        DragonBonesData.prototype._onClear = function() {
          for (var k in this.armatures) {
            this.armatures[k].returnToPool();
            delete this.armatures[k];
          }
          null !== this.userData && this.userData.returnToPool();
          this.autoSearch = false;
          this.frameRate = 0;
          this.version = "";
          this.name = "";
          this.stage = null;
          this.frameIndices.length = 0;
          this.cachedFrames.length = 0;
          this.armatureNames.length = 0;
          this.binary = null;
          this.intArray = null;
          this.floatArray = null;
          this.frameIntArray = null;
          this.frameFloatArray = null;
          this.frameArray = null;
          this.timelineArray = null;
          this.userData = null;
        };
        DragonBonesData.prototype.addArmature = function(value) {
          if (value.name in this.armatures) {
            console.warn("Same armature: " + value.name);
            return;
          }
          value.parent = this;
          this.armatures[value.name] = value;
          this.armatureNames.push(value.name);
        };
        DragonBonesData.prototype.getArmature = function(name) {
          return name in this.armatures ? this.armatures[name] : null;
        };
        DragonBonesData.prototype.dispose = function() {
          console.warn("\u5df2\u5e9f\u5f03");
          this.returnToPool();
        };
        return DragonBonesData;
      })(dragonBones.BaseObject);
      dragonBones.DragonBonesData = DragonBonesData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var ArmatureData = (function(_super) {
        __extends(ArmatureData, _super);
        function ArmatureData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.aabb = new dragonBones.Rectangle();
          _this.animationNames = [];
          _this.sortedBones = [];
          _this.sortedSlots = [];
          _this.defaultActions = [];
          _this.actions = [];
          _this.bones = {};
          _this.slots = {};
          _this.constraints = {};
          _this.skins = {};
          _this.animations = {};
          _this.canvas = null;
          _this.userData = null;
          return _this;
        }
        ArmatureData.toString = function() {
          return "[class dragonBones.ArmatureData]";
        };
        ArmatureData.prototype._onClear = function() {
          for (var _i = 0, _a = this.defaultActions; _i < _a.length; _i++) {
            var action = _a[_i];
            action.returnToPool();
          }
          for (var _b = 0, _c = this.actions; _b < _c.length; _b++) {
            var action = _c[_b];
            action.returnToPool();
          }
          for (var k in this.bones) {
            this.bones[k].returnToPool();
            delete this.bones[k];
          }
          for (var k in this.slots) {
            this.slots[k].returnToPool();
            delete this.slots[k];
          }
          for (var k in this.constraints) {
            this.constraints[k].returnToPool();
            delete this.constraints[k];
          }
          for (var k in this.skins) {
            this.skins[k].returnToPool();
            delete this.skins[k];
          }
          for (var k in this.animations) {
            this.animations[k].returnToPool();
            delete this.animations[k];
          }
          null !== this.canvas && this.canvas.returnToPool();
          null !== this.userData && this.userData.returnToPool();
          this.type = 0;
          this.frameRate = 0;
          this.cacheFrameRate = 0;
          this.scale = 1;
          this.name = "";
          this.aabb.clear();
          this.animationNames.length = 0;
          this.sortedBones.length = 0;
          this.sortedSlots.length = 0;
          this.defaultActions.length = 0;
          this.actions.length = 0;
          this.defaultSkin = null;
          this.defaultAnimation = null;
          this.canvas = null;
          this.userData = null;
          this.parent = null;
        };
        ArmatureData.prototype.sortBones = function() {
          var total = this.sortedBones.length;
          if (total <= 0) return;
          var sortHelper = this.sortedBones.concat();
          var index = 0;
          var count = 0;
          this.sortedBones.length = 0;
          while (count < total) {
            var bone = sortHelper[index++];
            index >= total && (index = 0);
            if (this.sortedBones.indexOf(bone) >= 0) continue;
            var flag = false;
            for (var k in this.constraints) {
              var constraint = this.constraints[k];
              if (constraint.root === bone && this.sortedBones.indexOf(constraint.target) < 0) {
                flag = true;
                break;
              }
            }
            if (flag) continue;
            if (null !== bone.parent && this.sortedBones.indexOf(bone.parent) < 0) continue;
            this.sortedBones.push(bone);
            count++;
          }
        };
        ArmatureData.prototype.cacheFrames = function(frameRate) {
          if (this.cacheFrameRate > 0) return;
          this.cacheFrameRate = frameRate;
          for (var k in this.animations) this.animations[k].cacheFrames(this.cacheFrameRate);
        };
        ArmatureData.prototype.setCacheFrame = function(globalTransformMatrix, transform) {
          var dataArray = this.parent.cachedFrames;
          var arrayOffset = dataArray.length;
          dataArray.length += 10;
          dataArray[arrayOffset] = globalTransformMatrix.a;
          dataArray[arrayOffset + 1] = globalTransformMatrix.b;
          dataArray[arrayOffset + 2] = globalTransformMatrix.c;
          dataArray[arrayOffset + 3] = globalTransformMatrix.d;
          dataArray[arrayOffset + 4] = globalTransformMatrix.tx;
          dataArray[arrayOffset + 5] = globalTransformMatrix.ty;
          dataArray[arrayOffset + 6] = transform.rotation;
          dataArray[arrayOffset + 7] = transform.skew;
          dataArray[arrayOffset + 8] = transform.scaleX;
          dataArray[arrayOffset + 9] = transform.scaleY;
          return arrayOffset;
        };
        ArmatureData.prototype.getCacheFrame = function(globalTransformMatrix, transform, arrayOffset) {
          var dataArray = this.parent.cachedFrames;
          globalTransformMatrix.a = dataArray[arrayOffset];
          globalTransformMatrix.b = dataArray[arrayOffset + 1];
          globalTransformMatrix.c = dataArray[arrayOffset + 2];
          globalTransformMatrix.d = dataArray[arrayOffset + 3];
          globalTransformMatrix.tx = dataArray[arrayOffset + 4];
          globalTransformMatrix.ty = dataArray[arrayOffset + 5];
          transform.rotation = dataArray[arrayOffset + 6];
          transform.skew = dataArray[arrayOffset + 7];
          transform.scaleX = dataArray[arrayOffset + 8];
          transform.scaleY = dataArray[arrayOffset + 9];
          transform.x = globalTransformMatrix.tx;
          transform.y = globalTransformMatrix.ty;
        };
        ArmatureData.prototype.addBone = function(value) {
          if (value.name in this.bones) {
            console.warn("Same bone: " + value.name);
            return;
          }
          this.bones[value.name] = value;
          this.sortedBones.push(value);
        };
        ArmatureData.prototype.addSlot = function(value) {
          if (value.name in this.slots) {
            console.warn("Same slot: " + value.name);
            return;
          }
          this.slots[value.name] = value;
          this.sortedSlots.push(value);
        };
        ArmatureData.prototype.addConstraint = function(value) {
          if (value.name in this.constraints) {
            console.warn("Same constraint: " + value.name);
            return;
          }
          this.constraints[value.name] = value;
        };
        ArmatureData.prototype.addSkin = function(value) {
          if (value.name in this.skins) {
            console.warn("Same skin: " + value.name);
            return;
          }
          value.parent = this;
          this.skins[value.name] = value;
          null === this.defaultSkin && (this.defaultSkin = value);
          "default" === value.name && (this.defaultSkin = value);
        };
        ArmatureData.prototype.addAnimation = function(value) {
          if (value.name in this.animations) {
            console.warn("Same animation: " + value.name);
            return;
          }
          value.parent = this;
          this.animations[value.name] = value;
          this.animationNames.push(value.name);
          null === this.defaultAnimation && (this.defaultAnimation = value);
        };
        ArmatureData.prototype.addAction = function(value, isDefault) {
          isDefault ? this.defaultActions.push(value) : this.actions.push(value);
        };
        ArmatureData.prototype.getBone = function(name) {
          return name in this.bones ? this.bones[name] : null;
        };
        ArmatureData.prototype.getSlot = function(name) {
          return name in this.slots ? this.slots[name] : null;
        };
        ArmatureData.prototype.getConstraint = function(name) {
          return name in this.constraints ? this.constraints[name] : null;
        };
        ArmatureData.prototype.getSkin = function(name) {
          return name in this.skins ? this.skins[name] : null;
        };
        ArmatureData.prototype.getMesh = function(skinName, slotName, meshName) {
          var skin = this.getSkin(skinName);
          if (null === skin) return null;
          return skin.getDisplay(slotName, meshName);
        };
        ArmatureData.prototype.getAnimation = function(name) {
          return name in this.animations ? this.animations[name] : null;
        };
        return ArmatureData;
      })(dragonBones.BaseObject);
      dragonBones.ArmatureData = ArmatureData;
      var BoneData = (function(_super) {
        __extends(BoneData, _super);
        function BoneData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.transform = new dragonBones.Transform();
          _this.userData = null;
          return _this;
        }
        BoneData.toString = function() {
          return "[class dragonBones.BoneData]";
        };
        BoneData.prototype._onClear = function() {
          null !== this.userData && this.userData.returnToPool();
          this.inheritTranslation = false;
          this.inheritRotation = false;
          this.inheritScale = false;
          this.inheritReflection = false;
          this.type = 0;
          this.length = 0;
          this.name = "";
          this.transform.identity();
          this.userData = null;
          this.parent = null;
        };
        return BoneData;
      })(dragonBones.BaseObject);
      dragonBones.BoneData = BoneData;
      var SurfaceData = (function(_super) {
        __extends(SurfaceData, _super);
        function SurfaceData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.vertices = [];
          return _this;
        }
        SurfaceData.toString = function() {
          return "[class dragonBones.SurfaceData]";
        };
        SurfaceData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.type = 1;
          this.segmentX = 0;
          this.segmentY = 0;
          this.vertices.length = 0;
        };
        return SurfaceData;
      })(BoneData);
      dragonBones.SurfaceData = SurfaceData;
      var SlotData = (function(_super) {
        __extends(SlotData, _super);
        function SlotData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.color = null;
          _this.userData = null;
          return _this;
        }
        SlotData.createColor = function() {
          return new dragonBones.ColorTransform();
        };
        SlotData.toString = function() {
          return "[class dragonBones.SlotData]";
        };
        SlotData.prototype._onClear = function() {
          null !== this.userData && this.userData.returnToPool();
          this.blendMode = 0;
          this.displayIndex = 0;
          this.zOrder = 0;
          this.name = "";
          this.color = null;
          this.userData = null;
          this.parent = null;
        };
        SlotData.DEFAULT_COLOR = new dragonBones.ColorTransform();
        return SlotData;
      })(dragonBones.BaseObject);
      dragonBones.SlotData = SlotData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var ConstraintData = (function(_super) {
        __extends(ConstraintData, _super);
        function ConstraintData() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        ConstraintData.prototype._onClear = function() {
          this.order = 0;
          this.name = "";
          this.target = null;
          this.root = null;
          this.bone = null;
        };
        return ConstraintData;
      })(dragonBones.BaseObject);
      dragonBones.ConstraintData = ConstraintData;
      var IKConstraintData = (function(_super) {
        __extends(IKConstraintData, _super);
        function IKConstraintData() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        IKConstraintData.toString = function() {
          return "[class dragonBones.IKConstraintData]";
        };
        IKConstraintData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.scaleEnabled = false;
          this.bendPositive = false;
          this.weight = 1;
        };
        return IKConstraintData;
      })(ConstraintData);
      dragonBones.IKConstraintData = IKConstraintData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var CanvasData = (function(_super) {
        __extends(CanvasData, _super);
        function CanvasData() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        CanvasData.toString = function() {
          return "[class dragonBones.CanvasData]";
        };
        CanvasData.prototype._onClear = function() {
          this.hasBackground = false;
          this.color = 0;
          this.x = 0;
          this.y = 0;
          this.width = 0;
          this.height = 0;
        };
        return CanvasData;
      })(dragonBones.BaseObject);
      dragonBones.CanvasData = CanvasData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var SkinData = (function(_super) {
        __extends(SkinData, _super);
        function SkinData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.displays = {};
          return _this;
        }
        SkinData.toString = function() {
          return "[class dragonBones.SkinData]";
        };
        SkinData.prototype._onClear = function() {
          for (var k in this.displays) {
            var slotDisplays = this.displays[k];
            for (var _i = 0, slotDisplays_1 = slotDisplays; _i < slotDisplays_1.length; _i++) {
              var display = slotDisplays_1[_i];
              null !== display && display.returnToPool();
            }
            delete this.displays[k];
          }
          this.name = "";
          this.parent = null;
        };
        SkinData.prototype.addDisplay = function(slotName, value) {
          slotName in this.displays || (this.displays[slotName] = []);
          null !== value && (value.parent = this);
          var slotDisplays = this.displays[slotName];
          slotDisplays.push(value);
        };
        SkinData.prototype.getDisplay = function(slotName, displayName) {
          var slotDisplays = this.getDisplays(slotName);
          if (null !== slotDisplays) for (var _i = 0, slotDisplays_2 = slotDisplays; _i < slotDisplays_2.length; _i++) {
            var display = slotDisplays_2[_i];
            if (null !== display && display.name === displayName) return display;
          }
          return null;
        };
        SkinData.prototype.getDisplays = function(slotName) {
          if (!(slotName in this.displays)) return null;
          return this.displays[slotName];
        };
        return SkinData;
      })(dragonBones.BaseObject);
      dragonBones.SkinData = SkinData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var DisplayData = (function(_super) {
        __extends(DisplayData, _super);
        function DisplayData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.transform = new dragonBones.Transform();
          return _this;
        }
        DisplayData.prototype._onClear = function() {
          this.name = "";
          this.path = "";
          this.transform.identity();
          this.parent = null;
        };
        return DisplayData;
      })(dragonBones.BaseObject);
      dragonBones.DisplayData = DisplayData;
      var ImageDisplayData = (function(_super) {
        __extends(ImageDisplayData, _super);
        function ImageDisplayData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.pivot = new dragonBones.Point();
          return _this;
        }
        ImageDisplayData.toString = function() {
          return "[class dragonBones.ImageDisplayData]";
        };
        ImageDisplayData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.type = 0;
          this.pivot.clear();
          this.texture = null;
        };
        return ImageDisplayData;
      })(DisplayData);
      dragonBones.ImageDisplayData = ImageDisplayData;
      var ArmatureDisplayData = (function(_super) {
        __extends(ArmatureDisplayData, _super);
        function ArmatureDisplayData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.actions = [];
          return _this;
        }
        ArmatureDisplayData.toString = function() {
          return "[class dragonBones.ArmatureDisplayData]";
        };
        ArmatureDisplayData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          for (var _i = 0, _a = this.actions; _i < _a.length; _i++) {
            var action = _a[_i];
            action.returnToPool();
          }
          this.type = 1;
          this.inheritAnimation = false;
          this.actions.length = 0;
          this.armature = null;
        };
        ArmatureDisplayData.prototype.addAction = function(value) {
          this.actions.push(value);
        };
        return ArmatureDisplayData;
      })(DisplayData);
      dragonBones.ArmatureDisplayData = ArmatureDisplayData;
      var MeshDisplayData = (function(_super) {
        __extends(MeshDisplayData, _super);
        function MeshDisplayData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.weight = null;
          _this.glue = null;
          return _this;
        }
        MeshDisplayData.toString = function() {
          return "[class dragonBones.MeshDisplayData]";
        };
        MeshDisplayData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          null !== this.weight && this.weight.returnToPool();
          null !== this.glue && this.glue.returnToPool();
          this.type = 2;
          this.inheritDeform = false;
          this.offset = 0;
          this.weight = null;
          this.glue = null;
          this.texture = null;
        };
        return MeshDisplayData;
      })(DisplayData);
      dragonBones.MeshDisplayData = MeshDisplayData;
      var BoundingBoxDisplayData = (function(_super) {
        __extends(BoundingBoxDisplayData, _super);
        function BoundingBoxDisplayData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.boundingBox = null;
          return _this;
        }
        BoundingBoxDisplayData.toString = function() {
          return "[class dragonBones.BoundingBoxDisplayData]";
        };
        BoundingBoxDisplayData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          null !== this.boundingBox && this.boundingBox.returnToPool();
          this.type = 3;
          this.boundingBox = null;
        };
        return BoundingBoxDisplayData;
      })(DisplayData);
      dragonBones.BoundingBoxDisplayData = BoundingBoxDisplayData;
      var WeightData = (function(_super) {
        __extends(WeightData, _super);
        function WeightData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.bones = [];
          return _this;
        }
        WeightData.toString = function() {
          return "[class dragonBones.WeightData]";
        };
        WeightData.prototype._onClear = function() {
          this.count = 0;
          this.offset = 0;
          this.bones.length = 0;
        };
        WeightData.prototype.addBone = function(value) {
          this.bones.push(value);
        };
        return WeightData;
      })(dragonBones.BaseObject);
      dragonBones.WeightData = WeightData;
      var GlueData = (function(_super) {
        __extends(GlueData, _super);
        function GlueData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.meshes = [];
          return _this;
        }
        GlueData.toString = function() {
          return "[class dragonBones.GlueData]";
        };
        GlueData.prototype._onClear = function() {
          this.weights.length = 0;
          this.meshes.length = 0;
        };
        GlueData.prototype.addMesh = function(value) {
          this.meshes.push(value);
        };
        return GlueData;
      })(dragonBones.BaseObject);
      dragonBones.GlueData = GlueData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var BoundingBoxData = (function(_super) {
        __extends(BoundingBoxData, _super);
        function BoundingBoxData() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        BoundingBoxData.prototype._onClear = function() {
          this.color = 0;
          this.width = 0;
          this.height = 0;
        };
        return BoundingBoxData;
      })(dragonBones.BaseObject);
      dragonBones.BoundingBoxData = BoundingBoxData;
      var RectangleBoundingBoxData = (function(_super) {
        __extends(RectangleBoundingBoxData, _super);
        function RectangleBoundingBoxData() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        RectangleBoundingBoxData.toString = function() {
          return "[class dragonBones.RectangleBoundingBoxData]";
        };
        RectangleBoundingBoxData._computeOutCode = function(x, y, xMin, yMin, xMax, yMax) {
          var code = 0;
          x < xMin ? code |= 1 : x > xMax && (code |= 2);
          y < yMin ? code |= 4 : y > yMax && (code |= 8);
          return code;
        };
        RectangleBoundingBoxData.rectangleIntersectsSegment = function(xA, yA, xB, yB, xMin, yMin, xMax, yMax, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          var inSideA = xA > xMin && xA < xMax && yA > yMin && yA < yMax;
          var inSideB = xB > xMin && xB < xMax && yB > yMin && yB < yMax;
          if (inSideA && inSideB) return -1;
          var intersectionCount = 0;
          var outcode0 = RectangleBoundingBoxData._computeOutCode(xA, yA, xMin, yMin, xMax, yMax);
          var outcode1 = RectangleBoundingBoxData._computeOutCode(xB, yB, xMin, yMin, xMax, yMax);
          while (true) {
            if (0 === (outcode0 | outcode1)) {
              intersectionCount = 2;
              break;
            }
            if (0 !== (outcode0 & outcode1)) break;
            var x = 0;
            var y = 0;
            var normalRadian = 0;
            var outcodeOut = 0 !== outcode0 ? outcode0 : outcode1;
            if (0 !== (4 & outcodeOut)) {
              x = xA + (xB - xA) * (yMin - yA) / (yB - yA);
              y = yMin;
              null !== normalRadians && (normalRadian = .5 * -Math.PI);
            } else if (0 !== (8 & outcodeOut)) {
              x = xA + (xB - xA) * (yMax - yA) / (yB - yA);
              y = yMax;
              null !== normalRadians && (normalRadian = .5 * Math.PI);
            } else if (0 !== (2 & outcodeOut)) {
              y = yA + (yB - yA) * (xMax - xA) / (xB - xA);
              x = xMax;
              null !== normalRadians && (normalRadian = 0);
            } else if (0 !== (1 & outcodeOut)) {
              y = yA + (yB - yA) * (xMin - xA) / (xB - xA);
              x = xMin;
              null !== normalRadians && (normalRadian = Math.PI);
            }
            if (outcodeOut === outcode0) {
              xA = x;
              yA = y;
              outcode0 = RectangleBoundingBoxData._computeOutCode(xA, yA, xMin, yMin, xMax, yMax);
              null !== normalRadians && (normalRadians.x = normalRadian);
            } else {
              xB = x;
              yB = y;
              outcode1 = RectangleBoundingBoxData._computeOutCode(xB, yB, xMin, yMin, xMax, yMax);
              null !== normalRadians && (normalRadians.y = normalRadian);
            }
          }
          if (intersectionCount) if (inSideA) {
            intersectionCount = 2;
            if (null !== intersectionPointA) {
              intersectionPointA.x = xB;
              intersectionPointA.y = yB;
            }
            if (null !== intersectionPointB) {
              intersectionPointB.x = xB;
              intersectionPointB.y = xB;
            }
            null !== normalRadians && (normalRadians.x = normalRadians.y + Math.PI);
          } else if (inSideB) {
            intersectionCount = 1;
            if (null !== intersectionPointA) {
              intersectionPointA.x = xA;
              intersectionPointA.y = yA;
            }
            if (null !== intersectionPointB) {
              intersectionPointB.x = xA;
              intersectionPointB.y = yA;
            }
            null !== normalRadians && (normalRadians.y = normalRadians.x + Math.PI);
          } else {
            intersectionCount = 3;
            if (null !== intersectionPointA) {
              intersectionPointA.x = xA;
              intersectionPointA.y = yA;
            }
            if (null !== intersectionPointB) {
              intersectionPointB.x = xB;
              intersectionPointB.y = yB;
            }
          }
          return intersectionCount;
        };
        RectangleBoundingBoxData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.type = 0;
        };
        RectangleBoundingBoxData.prototype.containsPoint = function(pX, pY) {
          var widthH = .5 * this.width;
          if (pX >= -widthH && pX <= widthH) {
            var heightH = .5 * this.height;
            if (pY >= -heightH && pY <= heightH) return true;
          }
          return false;
        };
        RectangleBoundingBoxData.prototype.intersectsSegment = function(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          var widthH = .5 * this.width;
          var heightH = .5 * this.height;
          var intersectionCount = RectangleBoundingBoxData.rectangleIntersectsSegment(xA, yA, xB, yB, -widthH, -heightH, widthH, heightH, intersectionPointA, intersectionPointB, normalRadians);
          return intersectionCount;
        };
        return RectangleBoundingBoxData;
      })(BoundingBoxData);
      dragonBones.RectangleBoundingBoxData = RectangleBoundingBoxData;
      var EllipseBoundingBoxData = (function(_super) {
        __extends(EllipseBoundingBoxData, _super);
        function EllipseBoundingBoxData() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        EllipseBoundingBoxData.toString = function() {
          return "[class dragonBones.EllipseData]";
        };
        EllipseBoundingBoxData.ellipseIntersectsSegment = function(xA, yA, xB, yB, xC, yC, widthH, heightH, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          var d = widthH / heightH;
          var dd = d * d;
          yA *= d;
          yB *= d;
          var dX = xB - xA;
          var dY = yB - yA;
          var lAB = Math.sqrt(dX * dX + dY * dY);
          var xD = dX / lAB;
          var yD = dY / lAB;
          var a = (xC - xA) * xD + (yC - yA) * yD;
          var aa = a * a;
          var ee = xA * xA + yA * yA;
          var rr = widthH * widthH;
          var dR = rr - ee + aa;
          var intersectionCount = 0;
          if (dR >= 0) {
            var dT = Math.sqrt(dR);
            var sA = a - dT;
            var sB = a + dT;
            var inSideA = sA < 0 ? -1 : sA <= lAB ? 0 : 1;
            var inSideB = sB < 0 ? -1 : sB <= lAB ? 0 : 1;
            var sideAB = inSideA * inSideB;
            if (sideAB < 0) return -1;
            if (0 === sideAB) if (-1 === inSideA) {
              intersectionCount = 2;
              xB = xA + sB * xD;
              yB = (yA + sB * yD) / d;
              if (null !== intersectionPointA) {
                intersectionPointA.x = xB;
                intersectionPointA.y = yB;
              }
              if (null !== intersectionPointB) {
                intersectionPointB.x = xB;
                intersectionPointB.y = yB;
              }
              if (null !== normalRadians) {
                normalRadians.x = Math.atan2(yB / rr * dd, xB / rr);
                normalRadians.y = normalRadians.x + Math.PI;
              }
            } else if (1 === inSideB) {
              intersectionCount = 1;
              xA += sA * xD;
              yA = (yA + sA * yD) / d;
              if (null !== intersectionPointA) {
                intersectionPointA.x = xA;
                intersectionPointA.y = yA;
              }
              if (null !== intersectionPointB) {
                intersectionPointB.x = xA;
                intersectionPointB.y = yA;
              }
              if (null !== normalRadians) {
                normalRadians.x = Math.atan2(yA / rr * dd, xA / rr);
                normalRadians.y = normalRadians.x + Math.PI;
              }
            } else {
              intersectionCount = 3;
              if (null !== intersectionPointA) {
                intersectionPointA.x = xA + sA * xD;
                intersectionPointA.y = (yA + sA * yD) / d;
                null !== normalRadians && (normalRadians.x = Math.atan2(intersectionPointA.y / rr * dd, intersectionPointA.x / rr));
              }
              if (null !== intersectionPointB) {
                intersectionPointB.x = xA + sB * xD;
                intersectionPointB.y = (yA + sB * yD) / d;
                null !== normalRadians && (normalRadians.y = Math.atan2(intersectionPointB.y / rr * dd, intersectionPointB.x / rr));
              }
            }
          }
          return intersectionCount;
        };
        EllipseBoundingBoxData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.type = 1;
        };
        EllipseBoundingBoxData.prototype.containsPoint = function(pX, pY) {
          var widthH = .5 * this.width;
          if (pX >= -widthH && pX <= widthH) {
            var heightH = .5 * this.height;
            if (pY >= -heightH && pY <= heightH) {
              pY *= widthH / heightH;
              return Math.sqrt(pX * pX + pY * pY) <= widthH;
            }
          }
          return false;
        };
        EllipseBoundingBoxData.prototype.intersectsSegment = function(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          var intersectionCount = EllipseBoundingBoxData.ellipseIntersectsSegment(xA, yA, xB, yB, 0, 0, .5 * this.width, .5 * this.height, intersectionPointA, intersectionPointB, normalRadians);
          return intersectionCount;
        };
        return EllipseBoundingBoxData;
      })(BoundingBoxData);
      dragonBones.EllipseBoundingBoxData = EllipseBoundingBoxData;
      var PolygonBoundingBoxData = (function(_super) {
        __extends(PolygonBoundingBoxData, _super);
        function PolygonBoundingBoxData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.vertices = [];
          _this.weight = null;
          return _this;
        }
        PolygonBoundingBoxData.toString = function() {
          return "[class dragonBones.PolygonBoundingBoxData]";
        };
        PolygonBoundingBoxData.polygonIntersectsSegment = function(xA, yA, xB, yB, vertices, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          xA === xB && (xA = xB + 1e-6);
          yA === yB && (yA = yB + 1e-6);
          var count = vertices.length;
          var dXAB = xA - xB;
          var dYAB = yA - yB;
          var llAB = xA * yB - yA * xB;
          var intersectionCount = 0;
          var xC = vertices[count - 2];
          var yC = vertices[count - 1];
          var dMin = 0;
          var dMax = 0;
          var xMin = 0;
          var yMin = 0;
          var xMax = 0;
          var yMax = 0;
          for (var i = 0; i < count; i += 2) {
            var xD = vertices[i];
            var yD = vertices[i + 1];
            xC === xD && (xC = xD + 1e-4);
            yC === yD && (yC = yD + 1e-4);
            var dXCD = xC - xD;
            var dYCD = yC - yD;
            var llCD = xC * yD - yC * xD;
            var ll = dXAB * dYCD - dYAB * dXCD;
            var x = (llAB * dXCD - dXAB * llCD) / ll;
            if ((x >= xC && x <= xD || x >= xD && x <= xC) && (0 === dXAB || x >= xA && x <= xB || x >= xB && x <= xA)) {
              var y = (llAB * dYCD - dYAB * llCD) / ll;
              if ((y >= yC && y <= yD || y >= yD && y <= yC) && (0 === dYAB || y >= yA && y <= yB || y >= yB && y <= yA)) {
                if (null === intersectionPointB) {
                  xMin = x;
                  yMin = y;
                  xMax = x;
                  yMax = y;
                  intersectionCount++;
                  if (null !== normalRadians) {
                    normalRadians.x = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI;
                    normalRadians.y = normalRadians.x;
                  }
                  break;
                }
                var d = x - xA;
                d < 0 && (d = -d);
                if (0 === intersectionCount) {
                  dMin = d;
                  dMax = d;
                  xMin = x;
                  yMin = y;
                  xMax = x;
                  yMax = y;
                  if (null !== normalRadians) {
                    normalRadians.x = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI;
                    normalRadians.y = normalRadians.x;
                  }
                } else {
                  if (d < dMin) {
                    dMin = d;
                    xMin = x;
                    yMin = y;
                    null !== normalRadians && (normalRadians.x = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI);
                  }
                  if (d > dMax) {
                    dMax = d;
                    xMax = x;
                    yMax = y;
                    null !== normalRadians && (normalRadians.y = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI);
                  }
                }
                intersectionCount++;
              }
            }
            xC = xD;
            yC = yD;
          }
          if (1 === intersectionCount) {
            if (null !== intersectionPointA) {
              intersectionPointA.x = xMin;
              intersectionPointA.y = yMin;
            }
            if (null !== intersectionPointB) {
              intersectionPointB.x = xMin;
              intersectionPointB.y = yMin;
            }
            null !== normalRadians && (normalRadians.y = normalRadians.x + Math.PI);
          } else if (intersectionCount > 1) {
            intersectionCount++;
            if (null !== intersectionPointA) {
              intersectionPointA.x = xMin;
              intersectionPointA.y = yMin;
            }
            if (null !== intersectionPointB) {
              intersectionPointB.x = xMax;
              intersectionPointB.y = yMax;
            }
          }
          return intersectionCount;
        };
        PolygonBoundingBoxData.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          null !== this.weight && this.weight.returnToPool();
          this.type = 2;
          this.x = 0;
          this.y = 0;
          this.vertices.length = 0;
          this.weight = null;
        };
        PolygonBoundingBoxData.prototype.containsPoint = function(pX, pY) {
          var isInSide = false;
          if (pX >= this.x && pX <= this.width && pY >= this.y && pY <= this.height) for (var i = 0, l = this.vertices.length, iP = l - 2; i < l; i += 2) {
            var yA = this.vertices[iP + 1];
            var yB = this.vertices[i + 1];
            if (yB < pY && yA >= pY || yA < pY && yB >= pY) {
              var xA = this.vertices[iP];
              var xB = this.vertices[i];
              (pY - yB) * (xA - xB) / (yA - yB) + xB < pX && (isInSide = !isInSide);
            }
            iP = i;
          }
          return isInSide;
        };
        PolygonBoundingBoxData.prototype.intersectsSegment = function(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          var intersectionCount = 0;
          0 !== RectangleBoundingBoxData.rectangleIntersectsSegment(xA, yA, xB, yB, this.x, this.y, this.x + this.width, this.y + this.height, null, null, null) && (intersectionCount = PolygonBoundingBoxData.polygonIntersectsSegment(xA, yA, xB, yB, this.vertices, intersectionPointA, intersectionPointB, normalRadians));
          return intersectionCount;
        };
        return PolygonBoundingBoxData;
      })(BoundingBoxData);
      dragonBones.PolygonBoundingBoxData = PolygonBoundingBoxData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var AnimationData = (function(_super) {
        __extends(AnimationData, _super);
        function AnimationData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.cachedFrames = [];
          _this.boneTimelines = {};
          _this.surfaceTimelines = {};
          _this.slotTimelines = {};
          _this.constraintTimelines = {};
          _this.animationTimelines = {};
          _this.boneCachedFrameIndices = {};
          _this.slotCachedFrameIndices = {};
          _this.actionTimeline = null;
          _this.zOrderTimeline = null;
          return _this;
        }
        AnimationData.toString = function() {
          return "[class dragonBones.AnimationData]";
        };
        AnimationData.prototype._onClear = function() {
          for (var k in this.boneTimelines) {
            for (var _i = 0, _a = this.boneTimelines[k]; _i < _a.length; _i++) {
              var timeline = _a[_i];
              timeline.returnToPool();
            }
            delete this.boneTimelines[k];
          }
          for (var k in this.surfaceTimelines) {
            for (var _b = 0, _c = this.surfaceTimelines[k]; _b < _c.length; _b++) {
              var timeline = _c[_b];
              timeline.returnToPool();
            }
            delete this.surfaceTimelines[k];
          }
          for (var k in this.slotTimelines) {
            for (var _d = 0, _e = this.slotTimelines[k]; _d < _e.length; _d++) {
              var timeline = _e[_d];
              timeline.returnToPool();
            }
            delete this.slotTimelines[k];
          }
          for (var k in this.constraintTimelines) {
            for (var _f = 0, _g = this.constraintTimelines[k]; _f < _g.length; _f++) {
              var timeline = _g[_f];
              timeline.returnToPool();
            }
            delete this.constraintTimelines[k];
          }
          for (var k in this.animationTimelines) {
            for (var _h = 0, _j = this.animationTimelines[k]; _h < _j.length; _h++) {
              var timeline = _j[_h];
              timeline.returnToPool();
            }
            delete this.animationTimelines[k];
          }
          for (var k in this.boneCachedFrameIndices) delete this.boneCachedFrameIndices[k];
          for (var k in this.slotCachedFrameIndices) delete this.slotCachedFrameIndices[k];
          null !== this.actionTimeline && this.actionTimeline.returnToPool();
          null !== this.zOrderTimeline && this.zOrderTimeline.returnToPool();
          this.frameIntOffset = 0;
          this.frameFloatOffset = 0;
          this.frameOffset = 0;
          this.frameCount = 0;
          this.playTimes = 0;
          this.duration = 0;
          this.scale = 1;
          this.fadeInTime = 0;
          this.cacheFrameRate = 0;
          this.name = "";
          this.cachedFrames.length = 0;
          this.actionTimeline = null;
          this.zOrderTimeline = null;
          this.parent = null;
        };
        AnimationData.prototype.cacheFrames = function(frameRate) {
          if (this.cacheFrameRate > 0) return;
          this.cacheFrameRate = Math.max(Math.ceil(frameRate * this.scale), 1);
          var cacheFrameCount = Math.ceil(this.cacheFrameRate * this.duration) + 1;
          this.cachedFrames.length = cacheFrameCount;
          for (var i = 0, l = this.cacheFrames.length; i < l; ++i) this.cachedFrames[i] = false;
          for (var _i = 0, _a = this.parent.sortedBones; _i < _a.length; _i++) {
            var bone = _a[_i];
            var indices = new Array(cacheFrameCount);
            for (var i = 0, l = indices.length; i < l; ++i) indices[i] = -1;
            this.boneCachedFrameIndices[bone.name] = indices;
          }
          for (var _b = 0, _c = this.parent.sortedSlots; _b < _c.length; _b++) {
            var slot = _c[_b];
            var indices = new Array(cacheFrameCount);
            for (var i = 0, l = indices.length; i < l; ++i) indices[i] = -1;
            this.slotCachedFrameIndices[slot.name] = indices;
          }
        };
        AnimationData.prototype.addBoneTimeline = function(bone, timeline) {
          var timelines = bone.name in this.boneTimelines ? this.boneTimelines[bone.name] : this.boneTimelines[bone.name] = [];
          timelines.indexOf(timeline) < 0 && timelines.push(timeline);
        };
        AnimationData.prototype.addSurfaceTimeline = function(surface, timeline) {
          var timelines = surface.name in this.surfaceTimelines ? this.surfaceTimelines[surface.name] : this.surfaceTimelines[surface.name] = [];
          timelines.indexOf(timeline) < 0 && timelines.push(timeline);
        };
        AnimationData.prototype.addSlotTimeline = function(slot, timeline) {
          var timelines = slot.name in this.slotTimelines ? this.slotTimelines[slot.name] : this.slotTimelines[slot.name] = [];
          timelines.indexOf(timeline) < 0 && timelines.push(timeline);
        };
        AnimationData.prototype.addConstraintTimeline = function(constraint, timeline) {
          var timelines = constraint.name in this.constraintTimelines ? this.constraintTimelines[constraint.name] : this.constraintTimelines[constraint.name] = [];
          timelines.indexOf(timeline) < 0 && timelines.push(timeline);
        };
        AnimationData.prototype.addAnimationTimeline = function(name, timeline) {
          var timelines = name in this.animationTimelines ? this.animationTimelines[name] : this.animationTimelines[name] = [];
          timelines.indexOf(timeline) < 0 && timelines.push(timeline);
        };
        AnimationData.prototype.getBoneTimelines = function(name) {
          return name in this.boneTimelines ? this.boneTimelines[name] : null;
        };
        AnimationData.prototype.getSurfaceTimelines = function(name) {
          return name in this.surfaceTimelines ? this.surfaceTimelines[name] : null;
        };
        AnimationData.prototype.getSlotTimelines = function(name) {
          return name in this.slotTimelines ? this.slotTimelines[name] : null;
        };
        AnimationData.prototype.getConstraintTimelines = function(name) {
          return name in this.constraintTimelines ? this.constraintTimelines[name] : null;
        };
        AnimationData.prototype.getAnimationTimelines = function(name) {
          return name in this.animationTimelines ? this.animationTimelines[name] : null;
        };
        AnimationData.prototype.getBoneCachedFrameIndices = function(name) {
          return name in this.boneCachedFrameIndices ? this.boneCachedFrameIndices[name] : null;
        };
        AnimationData.prototype.getSlotCachedFrameIndices = function(name) {
          return name in this.slotCachedFrameIndices ? this.slotCachedFrameIndices[name] : null;
        };
        return AnimationData;
      })(dragonBones.BaseObject);
      dragonBones.AnimationData = AnimationData;
      var TimelineData = (function(_super) {
        __extends(TimelineData, _super);
        function TimelineData() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        TimelineData.toString = function() {
          return "[class dragonBones.TimelineData]";
        };
        TimelineData.prototype._onClear = function() {
          this.type = 10;
          this.offset = 0;
          this.frameIndicesOffset = -1;
        };
        return TimelineData;
      })(dragonBones.BaseObject);
      dragonBones.TimelineData = TimelineData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var AnimationConfig = (function(_super) {
        __extends(AnimationConfig, _super);
        function AnimationConfig() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.boneMask = [];
          return _this;
        }
        AnimationConfig.toString = function() {
          return "[class dragonBones.AnimationConfig]";
        };
        AnimationConfig.prototype._onClear = function() {
          this.pauseFadeOut = true;
          this.fadeOutMode = 4;
          this.fadeOutTweenType = 1;
          this.fadeOutTime = -1;
          this.actionEnabled = true;
          this.additiveBlending = false;
          this.displayControl = true;
          this.pauseFadeIn = true;
          this.resetToPose = true;
          this.fadeInTweenType = 1;
          this.playTimes = -1;
          this.layer = 0;
          this.position = 0;
          this.duration = -1;
          this.timeScale = -100;
          this.weight = 1;
          this.fadeInTime = -1;
          this.autoFadeOutTime = -1;
          this.name = "";
          this.animation = "";
          this.group = "";
          this.boneMask.length = 0;
        };
        AnimationConfig.prototype.clear = function() {
          this._onClear();
        };
        AnimationConfig.prototype.copyFrom = function(value) {
          this.pauseFadeOut = value.pauseFadeOut;
          this.fadeOutMode = value.fadeOutMode;
          this.autoFadeOutTime = value.autoFadeOutTime;
          this.fadeOutTweenType = value.fadeOutTweenType;
          this.actionEnabled = value.actionEnabled;
          this.additiveBlending = value.additiveBlending;
          this.displayControl = value.displayControl;
          this.pauseFadeIn = value.pauseFadeIn;
          this.resetToPose = value.resetToPose;
          this.playTimes = value.playTimes;
          this.layer = value.layer;
          this.position = value.position;
          this.duration = value.duration;
          this.timeScale = value.timeScale;
          this.fadeInTime = value.fadeInTime;
          this.fadeOutTime = value.fadeOutTime;
          this.fadeInTweenType = value.fadeInTweenType;
          this.weight = value.weight;
          this.name = value.name;
          this.animation = value.animation;
          this.group = value.group;
          this.boneMask.length = value.boneMask.length;
          for (var i = 0, l = this.boneMask.length; i < l; ++i) this.boneMask[i] = value.boneMask[i];
        };
        AnimationConfig.prototype.containsBoneMask = function(name) {
          return 0 === this.boneMask.length || this.boneMask.indexOf(name) >= 0;
        };
        AnimationConfig.prototype.addBoneMask = function(armature, name, recursive) {
          void 0 === recursive && (recursive = true);
          var currentBone = armature.getBone(name);
          if (null === currentBone) return;
          this.boneMask.indexOf(name) < 0 && this.boneMask.push(name);
          if (recursive) for (var _i = 0, _a = armature.getBones(); _i < _a.length; _i++) {
            var bone = _a[_i];
            this.boneMask.indexOf(bone.name) < 0 && currentBone.contains(bone) && this.boneMask.push(bone.name);
          }
        };
        AnimationConfig.prototype.removeBoneMask = function(armature, name, recursive) {
          void 0 === recursive && (recursive = true);
          var index = this.boneMask.indexOf(name);
          index >= 0 && this.boneMask.splice(index, 1);
          if (recursive) {
            var currentBone = armature.getBone(name);
            if (null !== currentBone) if (this.boneMask.length > 0) for (var _i = 0, _a = armature.getBones(); _i < _a.length; _i++) {
              var bone = _a[_i];
              var index_1 = this.boneMask.indexOf(bone.name);
              index_1 >= 0 && currentBone.contains(bone) && this.boneMask.splice(index_1, 1);
            } else for (var _b = 0, _c = armature.getBones(); _b < _c.length; _b++) {
              var bone = _c[_b];
              if (bone === currentBone) continue;
              currentBone.contains(bone) || this.boneMask.push(bone.name);
            }
          }
        };
        return AnimationConfig;
      })(dragonBones.BaseObject);
      dragonBones.AnimationConfig = AnimationConfig;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var TextureAtlasData = (function(_super) {
        __extends(TextureAtlasData, _super);
        function TextureAtlasData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.textures = {};
          return _this;
        }
        TextureAtlasData.prototype._onClear = function() {
          for (var k in this.textures) {
            this.textures[k].returnToPool();
            delete this.textures[k];
          }
          this.autoSearch = false;
          this.width = 0;
          this.height = 0;
          this.scale = 1;
          this.name = "";
          this.imagePath = "";
        };
        TextureAtlasData.prototype.copyFrom = function(value) {
          this.autoSearch = value.autoSearch;
          this.scale = value.scale;
          this.width = value.width;
          this.height = value.height;
          this.name = value.name;
          this.imagePath = value.imagePath;
          for (var k in this.textures) {
            this.textures[k].returnToPool();
            delete this.textures[k];
          }
          for (var k in value.textures) {
            var texture = this.createTexture();
            texture.copyFrom(value.textures[k]);
            this.textures[k] = texture;
          }
        };
        TextureAtlasData.prototype.addTexture = function(value) {
          if (value.name in this.textures) {
            console.warn("Same texture: " + value.name);
            return;
          }
          value.parent = this;
          this.textures[value.name] = value;
        };
        TextureAtlasData.prototype.getTexture = function(name) {
          return name in this.textures ? this.textures[name] : null;
        };
        return TextureAtlasData;
      })(dragonBones.BaseObject);
      dragonBones.TextureAtlasData = TextureAtlasData;
      var TextureData = (function(_super) {
        __extends(TextureData, _super);
        function TextureData() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.region = new dragonBones.Rectangle();
          _this.frame = null;
          return _this;
        }
        TextureData.createRectangle = function() {
          return new dragonBones.Rectangle();
        };
        TextureData.prototype._onClear = function() {
          this.rotated = false;
          this.name = "";
          this.region.clear();
          this.parent = null;
          this.frame = null;
        };
        TextureData.prototype.copyFrom = function(value) {
          this.rotated = value.rotated;
          this.name = value.name;
          this.region.copyFrom(value.region);
          this.parent = value.parent;
          null === this.frame && null !== value.frame ? this.frame = TextureData.createRectangle() : null !== this.frame && null === value.frame && (this.frame = null);
          null !== this.frame && null !== value.frame && this.frame.copyFrom(value.frame);
        };
        return TextureData;
      })(dragonBones.BaseObject);
      dragonBones.TextureData = TextureData;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones_1) {
      var Armature = (function(_super) {
        __extends(Armature, _super);
        function Armature() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._bones = [];
          _this._slots = [];
          _this._glueSlots = [];
          _this._constraints = [];
          _this._actions = [];
          _this._animation = null;
          _this._proxy = null;
          _this._replaceTextureAtlasData = null;
          _this._clock = null;
          return _this;
        }
        Armature.toString = function() {
          return "[class dragonBones.Armature]";
        };
        Armature._onSortSlots = function(a, b) {
          return a._zOrder > b._zOrder ? 1 : -1;
        };
        Armature.prototype._onClear = function() {
          null !== this._clock && this._clock.remove(this);
          for (var _i = 0, _a = this._bones; _i < _a.length; _i++) {
            var bone = _a[_i];
            bone.returnToPool();
          }
          for (var _b = 0, _c = this._slots; _b < _c.length; _b++) {
            var slot = _c[_b];
            slot.returnToPool();
          }
          for (var _d = 0, _e = this._constraints; _d < _e.length; _d++) {
            var constraint = _e[_d];
            constraint.returnToPool();
          }
          null !== this._animation && this._animation.returnToPool();
          null !== this._proxy && this._proxy.dbClear();
          null !== this._replaceTextureAtlasData && this._replaceTextureAtlasData.returnToPool();
          this.inheritAnimation = true;
          this.userData = null;
          this._lockUpdate = false;
          this._bonesDirty = false;
          this._slotsDirty = false;
          this._zOrderDirty = false;
          this._flipX = false;
          this._flipY = false;
          this._cacheFrameIndex = -1;
          this._bones.length = 0;
          this._slots.length = 0;
          this._glueSlots.length = 0;
          this._constraints.length = 0;
          this._actions.length = 0;
          this._armatureData = null;
          this._animation = null;
          this._proxy = null;
          this._display = null;
          this._replaceTextureAtlasData = null;
          this._replacedTexture = null;
          this._dragonBones = null;
          this._clock = null;
          this._parent = null;
        };
        Armature.prototype._sortBones = function() {
          var total = this._bones.length;
          if (total <= 0) return;
          var sortHelper = this._bones.concat();
          var index = 0;
          var count = 0;
          this._bones.length = 0;
          while (count < total) {
            var bone = sortHelper[index++];
            index >= total && (index = 0);
            if (this._bones.indexOf(bone) >= 0) continue;
            if (bone._hasConstraint) {
              var flag = false;
              for (var _i = 0, _a = this._constraints; _i < _a.length; _i++) {
                var constraint = _a[_i];
                if (constraint._root === bone && this._bones.indexOf(constraint._target) < 0) {
                  flag = true;
                  break;
                }
              }
              if (flag) continue;
            }
            if (null !== bone.parent && this._bones.indexOf(bone.parent) < 0) continue;
            this._bones.push(bone);
            count++;
          }
        };
        Armature.prototype._sortSlots = function() {
          this._slots.sort(Armature._onSortSlots);
        };
        Armature.prototype._sortZOrder = function(slotIndices, offset) {
          var slotDatas = this._armatureData.sortedSlots;
          var isOriginal = null === slotIndices;
          if (this._zOrderDirty || !isOriginal) {
            for (var i = 0, l = slotDatas.length; i < l; ++i) {
              var slotIndex = isOriginal ? i : slotIndices[offset + i];
              if (slotIndex < 0 || slotIndex >= l) continue;
              var slotData = slotDatas[slotIndex];
              var slot = this.getSlot(slotData.name);
              null !== slot && slot._setZorder(i);
            }
            this._slotsDirty = true;
            this._zOrderDirty = !isOriginal;
          }
        };
        Armature.prototype._addBoneToBoneList = function(value) {
          if (this._bones.indexOf(value) < 0) {
            this._bonesDirty = true;
            this._bones.push(value);
          }
        };
        Armature.prototype._removeBoneFromBoneList = function(value) {
          var index = this._bones.indexOf(value);
          index >= 0 && this._bones.splice(index, 1);
        };
        Armature.prototype._addSlotToSlotList = function(value) {
          if (this._slots.indexOf(value) < 0) {
            this._slotsDirty = true;
            this._slots.push(value);
          }
        };
        Armature.prototype._removeSlotFromSlotList = function(value) {
          var index = this._slots.indexOf(value);
          index >= 0 && this._slots.splice(index, 1);
        };
        Armature.prototype._bufferAction = function(action, append) {
          this._actions.indexOf(action) < 0 && (append ? this._actions.push(action) : this._actions.unshift(action));
        };
        Armature.prototype.dispose = function() {
          if (null !== this._armatureData) {
            this._lockUpdate = true;
            this._dragonBones.bufferObject(this);
          }
        };
        Armature.prototype.init = function(armatureData, proxy, display, dragonBones) {
          if (null !== this._armatureData) return;
          this._armatureData = armatureData;
          this._animation = dragonBones_1.BaseObject.borrowObject(dragonBones_1.Animation);
          this._proxy = proxy;
          this._display = display;
          this._dragonBones = dragonBones;
          this._proxy.dbInit(this);
          this._animation.init(this);
          this._animation.animations = this._armatureData.animations;
        };
        Armature.prototype.advanceTime = function(passedTime) {
          if (this._lockUpdate) return;
          if (null === this._armatureData) {
            console.warn("The armature has been disposed.");
            return;
          }
          if (null === this._armatureData.parent) {
            console.warn("The armature data has been disposed.\nPlease make sure dispose armature before call factory.clear().");
            return;
          }
          var prevCacheFrameIndex = this._cacheFrameIndex;
          this._animation.advanceTime(passedTime);
          if (this._bonesDirty) {
            this._bonesDirty = false;
            this._sortBones();
          }
          if (this._slotsDirty) {
            this._slotsDirty = false;
            this._sortSlots();
          }
          if (this._cacheFrameIndex < 0 || this._cacheFrameIndex !== prevCacheFrameIndex) {
            var i = 0, l = 0;
            for (i = 0, l = this._bones.length; i < l; ++i) this._bones[i].update(this._cacheFrameIndex);
            for (i = 0, l = this._slots.length; i < l; ++i) this._slots[i].update(this._cacheFrameIndex);
            for (i = 0, l = this._glueSlots.length; i < l; ++i) this._glueSlots[i]._updateGlueMesh();
          }
          if (this._actions.length > 0) {
            this._lockUpdate = true;
            for (var _i = 0, _a = this._actions; _i < _a.length; _i++) {
              var action = _a[_i];
              0 === action.type && this._animation.fadeIn(action.name);
            }
            this._actions.length = 0;
            this._lockUpdate = false;
          }
          this._proxy.dbUpdate();
        };
        Armature.prototype.invalidUpdate = function(boneName, updateSlot) {
          void 0 === boneName && (boneName = null);
          void 0 === updateSlot && (updateSlot = false);
          if (null !== boneName && boneName.length > 0) {
            var bone = this.getBone(boneName);
            if (null !== bone) {
              bone.invalidUpdate();
              if (updateSlot) for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                var slot = _a[_i];
                slot.parent === bone && slot.invalidUpdate();
              }
            }
          } else {
            for (var _b = 0, _c = this._bones; _b < _c.length; _b++) {
              var bone = _c[_b];
              bone.invalidUpdate();
            }
            if (updateSlot) for (var _d = 0, _e = this._slots; _d < _e.length; _d++) {
              var slot = _e[_d];
              slot.invalidUpdate();
            }
          }
        };
        Armature.prototype.containsPoint = function(x, y) {
          for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
            var slot = _a[_i];
            if (slot.containsPoint(x, y)) return slot;
          }
          return null;
        };
        Armature.prototype.intersectsSegment = function(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          var isV = xA === xB;
          var dMin = 0;
          var dMax = 0;
          var intXA = 0;
          var intYA = 0;
          var intXB = 0;
          var intYB = 0;
          var intAN = 0;
          var intBN = 0;
          var intSlotA = null;
          var intSlotB = null;
          for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
            var slot = _a[_i];
            var intersectionCount = slot.intersectsSegment(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians);
            if (intersectionCount > 0) {
              if (null === intersectionPointA && null === intersectionPointB) {
                intSlotA = slot;
                break;
              }
              if (null !== intersectionPointA) {
                var d = isV ? intersectionPointA.y - yA : intersectionPointA.x - xA;
                d < 0 && (d = -d);
                if (null === intSlotA || d < dMin) {
                  dMin = d;
                  intXA = intersectionPointA.x;
                  intYA = intersectionPointA.y;
                  intSlotA = slot;
                  normalRadians && (intAN = normalRadians.x);
                }
              }
              if (null !== intersectionPointB) {
                var d = intersectionPointB.x - xA;
                d < 0 && (d = -d);
                if (null === intSlotB || d > dMax) {
                  dMax = d;
                  intXB = intersectionPointB.x;
                  intYB = intersectionPointB.y;
                  intSlotB = slot;
                  null !== normalRadians && (intBN = normalRadians.y);
                }
              }
            }
          }
          if (null !== intSlotA && null !== intersectionPointA) {
            intersectionPointA.x = intXA;
            intersectionPointA.y = intYA;
            null !== normalRadians && (normalRadians.x = intAN);
          }
          if (null !== intSlotB && null !== intersectionPointB) {
            intersectionPointB.x = intXB;
            intersectionPointB.y = intYB;
            null !== normalRadians && (normalRadians.y = intBN);
          }
          return intSlotA;
        };
        Armature.prototype.getBone = function(name) {
          for (var _i = 0, _a = this._bones; _i < _a.length; _i++) {
            var bone = _a[_i];
            if (bone.name === name) return bone;
          }
          return null;
        };
        Armature.prototype.getBoneByDisplay = function(display) {
          var slot = this.getSlotByDisplay(display);
          return null !== slot ? slot.parent : null;
        };
        Armature.prototype.getSlot = function(name) {
          for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
            var slot = _a[_i];
            if (slot.name === name) return slot;
          }
          return null;
        };
        Armature.prototype.getSlotByDisplay = function(display) {
          if (null !== display) for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
            var slot = _a[_i];
            if (slot.display === display) return slot;
          }
          return null;
        };
        Armature.prototype.addBone = function(value, parentName) {
          console.assert(null !== value);
          value._setArmature(this);
          value._setParent(parentName.length > 0 ? this.getBone(parentName) : null);
        };
        Armature.prototype.addSlot = function(value, parentName) {
          var bone = this.getBone(parentName);
          console.assert(null !== value && null !== bone);
          value._setArmature(this);
          value._setParent(bone);
        };
        Armature.prototype.addConstraint = function(value) {
          this._constraints.indexOf(value) < 0 && this._constraints.push(value);
        };
        Armature.prototype.removeBone = function(value) {
          console.assert(null !== value && value.armature === this);
          value._setParent(null);
          value._setArmature(null);
        };
        Armature.prototype.removeSlot = function(value) {
          console.assert(null !== value && value.armature === this);
          value._setParent(null);
          value._setArmature(null);
        };
        Armature.prototype.getBones = function() {
          return this._bones;
        };
        Armature.prototype.getSlots = function() {
          return this._slots;
        };
        Object.defineProperty(Armature.prototype, "flipX", {
          get: function() {
            return this._flipX;
          },
          set: function(value) {
            if (this._flipX === value) return;
            this._flipX = value;
            this.invalidUpdate();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "flipY", {
          get: function() {
            return this._flipY;
          },
          set: function(value) {
            if (this._flipY === value) return;
            this._flipY = value;
            this.invalidUpdate();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "cacheFrameRate", {
          get: function() {
            return this._armatureData.cacheFrameRate;
          },
          set: function(value) {
            if (this._armatureData.cacheFrameRate !== value) {
              this._armatureData.cacheFrames(value);
              for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
                var slot = _a[_i];
                var childArmature = slot.childArmature;
                null !== childArmature && (childArmature.cacheFrameRate = value);
              }
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "name", {
          get: function() {
            return this._armatureData.name;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "armatureData", {
          get: function() {
            return this._armatureData;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "animation", {
          get: function() {
            return this._animation;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "proxy", {
          get: function() {
            return this._proxy;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "eventDispatcher", {
          get: function() {
            return this._proxy;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "display", {
          get: function() {
            return this._display;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "replacedTexture", {
          get: function() {
            return this._replacedTexture;
          },
          set: function(value) {
            if (this._replacedTexture === value) return;
            if (null !== this._replaceTextureAtlasData) {
              this._replaceTextureAtlasData.returnToPool();
              this._replaceTextureAtlasData = null;
            }
            this._replacedTexture = value;
            for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
              var slot = _a[_i];
              slot.invalidUpdate();
              slot.update(-1);
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "clock", {
          get: function() {
            return this._clock;
          },
          set: function(value) {
            if (this._clock === value) return;
            null !== this._clock && this._clock.remove(this);
            this._clock = value;
            this._clock && this._clock.add(this);
            for (var _i = 0, _a = this._slots; _i < _a.length; _i++) {
              var slot = _a[_i];
              var childArmature = slot.childArmature;
              null !== childArmature && (childArmature.clock = this._clock);
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Armature.prototype, "parent", {
          get: function() {
            return this._parent;
          },
          enumerable: true,
          configurable: true
        });
        Armature.prototype.replaceTexture = function(texture) {
          this.replacedTexture = texture;
        };
        Armature.prototype.hasEventListener = function(type) {
          return this._proxy.hasDBEventListener(type);
        };
        Armature.prototype.addEventListener = function(type, listener, target) {
          this._proxy.addDBEventListener(type, listener, target);
        };
        Armature.prototype.removeEventListener = function(type, listener, target) {
          this._proxy.removeDBEventListener(type, listener, target);
        };
        Armature.prototype.enableAnimationCache = function(frameRate) {
          this.cacheFrameRate = frameRate;
        };
        Armature.prototype.getDisplay = function() {
          return this._display;
        };
        return Armature;
      })(dragonBones_1.BaseObject);
      dragonBones_1.Armature = Armature;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var TransformObject = (function(_super) {
        __extends(TransformObject, _super);
        function TransformObject() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.globalTransformMatrix = new dragonBones.Matrix();
          _this.global = new dragonBones.Transform();
          _this.offset = new dragonBones.Transform();
          return _this;
        }
        TransformObject.prototype._onClear = function() {
          this.globalTransformMatrix.identity();
          this.global.identity();
          this.offset.identity();
          this.origin = null;
          this.userData = null;
          this._globalDirty = false;
          this._armature = null;
          this._parent = null;
        };
        TransformObject.prototype._setArmature = function(value) {
          this._armature = value;
        };
        TransformObject.prototype._setParent = function(value) {
          this._parent = value;
        };
        TransformObject.prototype.updateGlobalTransform = function() {
          if (this._globalDirty) {
            this._globalDirty = false;
            this.global.fromMatrix(this.globalTransformMatrix);
          }
        };
        Object.defineProperty(TransformObject.prototype, "armature", {
          get: function() {
            return this._armature;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(TransformObject.prototype, "parent", {
          get: function() {
            return this._parent;
          },
          enumerable: true,
          configurable: true
        });
        TransformObject._helpMatrix = new dragonBones.Matrix();
        TransformObject._helpTransform = new dragonBones.Transform();
        TransformObject._helpPoint = new dragonBones.Point();
        return TransformObject;
      })(dragonBones.BaseObject);
      dragonBones.TransformObject = TransformObject;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Bone = (function(_super) {
        __extends(Bone, _super);
        function Bone() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.animationPose = new dragonBones.Transform();
          _this._blendState = new dragonBones.BlendState();
          return _this;
        }
        Bone.toString = function() {
          return "[class dragonBones.Bone]";
        };
        Bone.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.offsetMode = 1;
          this.animationPose.identity();
          this._transformDirty = false;
          this._childrenTransformDirty = false;
          this._localDirty = true;
          this._hasConstraint = false;
          this._visible = true;
          this._cachedFrameIndex = -1;
          this._blendState.clear();
          this._boneData = null;
          this._cachedFrameIndices = null;
        };
        Bone.prototype._updateGlobalTransformMatrix = function(isCache) {
          var boneData = this._boneData;
          var parent = this._parent;
          var flipX = this._armature.flipX;
          var flipY = this._armature.flipY === dragonBones.DragonBones.yDown;
          var inherit = null !== parent;
          var rotation = 0;
          var global = this.global;
          var globalTransformMatrix = this.globalTransformMatrix;
          if (1 === this.offsetMode) if (null !== this.origin) {
            global.x = this.origin.x + this.offset.x + this.animationPose.x;
            global.y = this.origin.y + this.offset.y + this.animationPose.y;
            global.skew = this.origin.skew + this.offset.skew + this.animationPose.skew;
            global.rotation = this.origin.rotation + this.offset.rotation + this.animationPose.rotation;
            global.scaleX = this.origin.scaleX * this.offset.scaleX * this.animationPose.scaleX;
            global.scaleY = this.origin.scaleY * this.offset.scaleY * this.animationPose.scaleY;
          } else global.copyFrom(this.offset).add(this.animationPose); else if (0 === this.offsetMode) null !== this.origin ? global.copyFrom(this.origin).add(this.animationPose) : global.copyFrom(this.animationPose); else {
            inherit = false;
            global.copyFrom(this.offset);
          }
          if (inherit) {
            var parentMatrix = 0 === parent._boneData.type ? parent.globalTransformMatrix : parent._getGlobalTransformMatrix(global.x, global.y);
            if (boneData.inheritScale) {
              if (!boneData.inheritRotation) {
                parent.updateGlobalTransform();
                rotation = flipX && flipY ? global.rotation - (parent.global.rotation + Math.PI) : flipX ? global.rotation + parent.global.rotation + Math.PI : flipY ? global.rotation + parent.global.rotation : global.rotation - parent.global.rotation;
                global.rotation = rotation;
              }
              global.toMatrix(globalTransformMatrix);
              globalTransformMatrix.concat(parentMatrix);
              if (boneData.inheritTranslation) {
                global.x = globalTransformMatrix.tx;
                global.y = globalTransformMatrix.ty;
              } else {
                globalTransformMatrix.tx = global.x;
                globalTransformMatrix.ty = global.y;
              }
              isCache ? global.fromMatrix(globalTransformMatrix) : this._globalDirty = true;
            } else {
              if (boneData.inheritTranslation) {
                var x = global.x;
                var y = global.y;
                global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                global.y = parentMatrix.b * x + parentMatrix.d * y + parentMatrix.ty;
              } else {
                flipX && (global.x = -global.x);
                flipY && (global.y = -global.y);
              }
              if (boneData.inheritRotation) {
                parent.updateGlobalTransform();
                rotation = parent.global.scaleX < 0 ? global.rotation + parent.global.rotation + Math.PI : global.rotation + parent.global.rotation;
                if (parentMatrix.a * parentMatrix.d - parentMatrix.b * parentMatrix.c < 0) {
                  rotation -= 2 * global.rotation;
                  (flipX !== flipY || boneData.inheritReflection) && (global.skew += Math.PI);
                }
                global.rotation = rotation;
              } else if (flipX || flipY) {
                if (flipX && flipY) rotation = global.rotation + Math.PI; else {
                  rotation = flipX ? Math.PI - global.rotation : -global.rotation;
                  global.skew += Math.PI;
                }
                global.rotation = rotation;
              }
              global.toMatrix(globalTransformMatrix);
            }
          } else {
            if (flipX || flipY) {
              flipX && (global.x = -global.x);
              flipY && (global.y = -global.y);
              if (flipX && flipY) rotation = global.rotation + Math.PI; else {
                rotation = flipX ? Math.PI - global.rotation : -global.rotation;
                global.skew += Math.PI;
              }
              global.rotation = rotation;
            }
            global.toMatrix(globalTransformMatrix);
          }
        };
        Bone.prototype._setArmature = function(value) {
          if (this._armature === value) return;
          var oldSlots = null;
          var oldBones = null;
          if (null !== this._armature) {
            oldSlots = this.getSlots();
            oldBones = this.getBones();
            this._armature._removeBoneFromBoneList(this);
          }
          this._armature = value;
          null !== this._armature && this._armature._addBoneToBoneList(this);
          if (null !== oldSlots) for (var _i = 0, oldSlots_1 = oldSlots; _i < oldSlots_1.length; _i++) {
            var slot = oldSlots_1[_i];
            slot.parent === this && slot._setArmature(this._armature);
          }
          if (null !== oldBones) for (var _a = 0, oldBones_1 = oldBones; _a < oldBones_1.length; _a++) {
            var bone = oldBones_1[_a];
            bone.parent === this && bone._setArmature(this._armature);
          }
        };
        Bone.prototype.init = function(boneData) {
          if (null !== this._boneData) return;
          this._boneData = boneData;
          this.origin = this._boneData.transform;
        };
        Bone.prototype.update = function(cacheFrameIndex) {
          this._blendState.dirty = false;
          if (cacheFrameIndex >= 0 && null !== this._cachedFrameIndices) {
            var cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex];
            if (cachedFrameIndex >= 0 && this._cachedFrameIndex === cachedFrameIndex) this._transformDirty = false; else if (cachedFrameIndex >= 0) {
              this._transformDirty = true;
              this._cachedFrameIndex = cachedFrameIndex;
            } else {
              if (this._hasConstraint) for (var _i = 0, _a = this._armature._constraints; _i < _a.length; _i++) {
                var constraint = _a[_i];
                constraint._root === this && constraint.update();
              }
              if (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) {
                this._transformDirty = true;
                this._cachedFrameIndex = -1;
              } else if (this._cachedFrameIndex >= 0) {
                this._transformDirty = false;
                this._cachedFrameIndices[cacheFrameIndex] = this._cachedFrameIndex;
              } else {
                this._transformDirty = true;
                this._cachedFrameIndex = -1;
              }
            }
          } else {
            if (this._hasConstraint) for (var _b = 0, _c = this._armature._constraints; _b < _c.length; _b++) {
              var constraint = _c[_b];
              constraint._root === this && constraint.update();
            }
            if (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) {
              cacheFrameIndex = -1;
              this._transformDirty = true;
              this._cachedFrameIndex = -1;
            }
          }
          if (this._transformDirty) {
            this._transformDirty = false;
            this._childrenTransformDirty = true;
            if (this._cachedFrameIndex < 0) {
              var isCache = cacheFrameIndex >= 0;
              this._localDirty && this._updateGlobalTransformMatrix(isCache);
              isCache && null !== this._cachedFrameIndices && (this._cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global));
            } else this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);
          } else this._childrenTransformDirty && (this._childrenTransformDirty = false);
          this._localDirty = true;
        };
        Bone.prototype.updateByConstraint = function() {
          if (this._localDirty) {
            this._localDirty = false;
            (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) && this._updateGlobalTransformMatrix(true);
            this._transformDirty = true;
          }
        };
        Bone.prototype.invalidUpdate = function() {
          this._transformDirty = true;
        };
        Bone.prototype.contains = function(value) {
          if (value === this) return false;
          var ancestor = value;
          while (ancestor !== this && null !== ancestor) ancestor = ancestor.parent;
          return ancestor === this;
        };
        Object.defineProperty(Bone.prototype, "boneData", {
          get: function() {
            return this._boneData;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Bone.prototype, "visible", {
          get: function() {
            return this._visible;
          },
          set: function(value) {
            if (this._visible === value) return;
            this._visible = value;
            for (var _i = 0, _a = this._armature.getSlots(); _i < _a.length; _i++) {
              var slot = _a[_i];
              slot._parent === this && slot._updateVisible();
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Bone.prototype, "name", {
          get: function() {
            return this._boneData.name;
          },
          enumerable: true,
          configurable: true
        });
        Bone.prototype.getBones = function() {
          var bones = new Array();
          for (var _i = 0, _a = this._armature.getBones(); _i < _a.length; _i++) {
            var bone = _a[_i];
            bone.parent === this && bones.push(bone);
          }
          return bones;
        };
        Bone.prototype.getSlots = function() {
          var slots = new Array();
          for (var _i = 0, _a = this._armature.getSlots(); _i < _a.length; _i++) {
            var slot = _a[_i];
            slot.parent === this && slots.push(slot);
          }
          return slots;
        };
        Object.defineProperty(Bone.prototype, "slot", {
          get: function() {
            for (var _i = 0, _a = this._armature.getSlots(); _i < _a.length; _i++) {
              var slot = _a[_i];
              if (slot.parent === this) return slot;
            }
            return null;
          },
          enumerable: true,
          configurable: true
        });
        return Bone;
      })(dragonBones.TransformObject);
      dragonBones.Bone = Bone;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Surface = (function(_super) {
        __extends(Surface, _super);
        function Surface() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._vertices = [];
          _this._deformVertices = [];
          _this._hullCache = [];
          _this._matrixCahce = [];
          return _this;
        }
        Surface.toString = function() {
          return "[class dragonBones.Surface]";
        };
        Surface.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this._dX = 0;
          this._dY = 0;
          this._k = 0;
          this._kX = 0;
          this._kY = 0;
          this._vertices.length = 0;
          this._deformVertices.length = 0;
          this._matrixCahce.length = 0;
          this._hullCache.length = 0;
        };
        Surface.prototype._getAffineTransform = function(x, y, lX, lY, aX, aY, bX, bY, cX, cY, transform, matrix, isDown) {
          var dabX = bX - aX;
          var dabY = bY - aY;
          var dacX = cX - aX;
          var dacY = cY - aY;
          transform.rotation = Math.atan2(dabY, dabX);
          transform.skew = Math.atan2(dacY, dacX) - .5 * Math.PI - transform.rotation;
          isDown && (transform.rotation += Math.PI);
          transform.scaleX = Math.sqrt(dabX * dabX + dabY * dabY) / lX;
          transform.scaleY = Math.sqrt(dacX * dacX + dacY * dacY) / lY;
          transform.toMatrix(matrix);
          transform.x = matrix.tx = aX - (matrix.a * x + matrix.c * y);
          transform.y = matrix.ty = aY - (matrix.b * x + matrix.d * y);
        };
        Surface.prototype._updateVertices = function() {
          var originalVertices = this._boneData.vertices;
          var vertices = this._vertices;
          var animationVertices = this._deformVertices;
          if (null !== this._parent) if (1 === this._parent._boneData.type) for (var i = 0, l = originalVertices.length; i < l; i += 2) {
            var x = originalVertices[i] + animationVertices[i];
            var y = originalVertices[i + 1] + animationVertices[i];
            var matrix = this._parent._getGlobalTransformMatrix(x, y);
            vertices[i] = matrix.a * x + matrix.c * y + matrix.tx;
            vertices[i + 1] = matrix.b * x + matrix.d * y + matrix.ty;
          } else {
            var parentMatrix = this._parent.globalTransformMatrix;
            for (var i = 0, l = originalVertices.length; i < l; i += 2) {
              var x = originalVertices[i] + animationVertices[i];
              var y = originalVertices[i + 1] + animationVertices[i + 1];
              vertices[i] = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
              vertices[i + 1] = parentMatrix.b * x + parentMatrix.d * y + parentMatrix.ty;
            }
          } else for (var i = 0, l = originalVertices.length; i < l; i += 2) {
            vertices[i] = originalVertices[i] + animationVertices[i];
            vertices[i + 1] = originalVertices[i + 1] + animationVertices[i + 1];
          }
        };
        Surface.prototype._updateGlobalTransformMatrix = function(isCache) {
          isCache;
          var segmentXD = 2 * this._boneData.segmentX;
          var lastIndex = this._vertices.length - 2;
          var lA = 200;
          var raX = this._vertices[0];
          var raY = this._vertices[1];
          var rbX = this._vertices[segmentXD];
          var rbY = this._vertices[segmentXD + 1];
          var rcX = this._vertices[lastIndex];
          var rcY = this._vertices[lastIndex + 1];
          var rdX = this._vertices[lastIndex - segmentXD];
          var rdY = this._vertices[lastIndex - segmentXD + 1];
          var dacX = raX + .5 * (rcX - raX);
          var dacY = raY + .5 * (rcY - raY);
          var dbdX = rbX + .5 * (rdX - rbX);
          var dbdY = rbY + .5 * (rdY - rbY);
          var aX = dacX + .5 * (dbdX - dacX);
          var aY = dacY + .5 * (dbdY - dacY);
          var bX = rbX + .5 * (rcX - rbX);
          var bY = rbY + .5 * (rcY - rbY);
          var cX = rdX + .5 * (rcX - rdX);
          var cY = rdY + .5 * (rcY - rdY);
          this._globalDirty = false;
          this._getAffineTransform(0, 0, lA, lA, aX, aY, bX, bY, cX, cY, this.global, this.globalTransformMatrix, false);
        };
        Surface.prototype._getGlobalTransformMatrix = function(x, y) {
          var lB = 1e3;
          if (x < -lB || lB < x || y < -lB || lB < y) return this.globalTransformMatrix;
          var isDown = false;
          var lA = 200;
          var surfaceData = this._boneData;
          var segmentX = surfaceData.segmentX;
          var segmentY = surfaceData.segmentY;
          var segmentXD = 2 * surfaceData.segmentX;
          var dX = this._dX;
          var dY = this._dY;
          var indexX = Math.floor((x + lA) / dX);
          var indexY = Math.floor((y + lA) / dY);
          var matrixIndex = 0;
          var pX = indexX * dX - lA;
          var pY = indexY * dY - lA;
          var matrices = this._matrixCahce;
          var helpMatrix = Surface._helpMatrix;
          if (x < -lA) {
            if (y < -lA || y > lA) return this.globalTransformMatrix;
            isDown = y > this._kX * (x + lA) + pY;
            matrixIndex = 7 * (2 * (segmentX * (segmentY + 1) + 2 * segmentX + segmentY + indexY) + (isDown ? 1 : 0));
            if (this._matrixCahce[matrixIndex] > 0) helpMatrix.copyFromArray(matrices, matrixIndex + 1); else {
              var vertexIndex = indexY * (segmentXD + 2);
              var ddX = this._hullCache[4];
              var ddY = this._hullCache[5];
              var sX = this._hullCache[2] - (segmentY - indexY) * ddX;
              var sY = this._hullCache[3] - (segmentY - indexY) * ddY;
              var vertices = this._vertices;
              isDown ? this._getAffineTransform(-lA, pY + dY, lB - lA, dY, vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], sX + ddX, sY + ddY, vertices[vertexIndex], vertices[vertexIndex + 1], Surface._helpTransform, helpMatrix, true) : this._getAffineTransform(-lB, pY, lB - lA, dY, sX, sY, vertices[vertexIndex], vertices[vertexIndex + 1], sX + ddX, sY + ddY, Surface._helpTransform, helpMatrix, false);
              matrices[matrixIndex] = 1;
              matrices[matrixIndex + 1] = helpMatrix.a;
              matrices[matrixIndex + 2] = helpMatrix.b;
              matrices[matrixIndex + 3] = helpMatrix.c;
              matrices[matrixIndex + 4] = helpMatrix.d;
              matrices[matrixIndex + 5] = helpMatrix.tx;
              matrices[matrixIndex + 6] = helpMatrix.ty;
            }
          } else if (x > lA) {
            if (y < -lA || y > lA) return this.globalTransformMatrix;
            isDown = y > this._kX * (x - lB) + pY;
            matrixIndex = 7 * (2 * (segmentX * (segmentY + 1) + segmentX + indexY) + (isDown ? 1 : 0));
            if (this._matrixCahce[matrixIndex] > 0) helpMatrix.copyFromArray(matrices, matrixIndex + 1); else {
              var vertexIndex = (indexY + 1) * (segmentXD + 2) - 2;
              var ddX = this._hullCache[4];
              var ddY = this._hullCache[5];
              var sX = this._hullCache[0] + indexY * ddX;
              var sY = this._hullCache[1] + indexY * ddY;
              var vertices = this._vertices;
              isDown ? this._getAffineTransform(lB, pY + dY, lB - lA, dY, sX + ddX, sY + ddY, vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], sX, sY, Surface._helpTransform, helpMatrix, true) : this._getAffineTransform(lA, pY, lB - lA, dY, vertices[vertexIndex], vertices[vertexIndex + 1], sX, sY, vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], Surface._helpTransform, helpMatrix, false);
              matrices[matrixIndex] = 1;
              matrices[matrixIndex + 1] = helpMatrix.a;
              matrices[matrixIndex + 2] = helpMatrix.b;
              matrices[matrixIndex + 3] = helpMatrix.c;
              matrices[matrixIndex + 4] = helpMatrix.d;
              matrices[matrixIndex + 5] = helpMatrix.tx;
              matrices[matrixIndex + 6] = helpMatrix.ty;
            }
          } else if (y < -lA) {
            if (x < -lA || x > lA) return this.globalTransformMatrix;
            isDown = y > this._kY * (x - pX - dX) - lB;
            matrixIndex = 7 * (segmentX * (segmentY + 1) + 2 * indexX + (isDown ? 1 : 0));
            if (this._matrixCahce[matrixIndex] > 0) helpMatrix.copyFromArray(matrices, matrixIndex + 1); else {
              var vertexIndex = 2 * indexX;
              var ddX = this._hullCache[10];
              var ddY = this._hullCache[11];
              var sX = this._hullCache[8] + indexX * ddX;
              var sY = this._hullCache[9] + indexX * ddY;
              var vertices = this._vertices;
              isDown ? this._getAffineTransform(pX + dX, -lA, dX, lB - lA, vertices[vertexIndex + 2], vertices[vertexIndex + 3], vertices[vertexIndex], vertices[vertexIndex + 1], sX + ddX, sY + ddY, Surface._helpTransform, helpMatrix, true) : this._getAffineTransform(pX, -lB, dX, lB - lA, sX, sY, sX + ddX, sY + ddY, vertices[vertexIndex], vertices[vertexIndex + 1], Surface._helpTransform, helpMatrix, false);
              matrices[matrixIndex] = 1;
              matrices[matrixIndex + 1] = helpMatrix.a;
              matrices[matrixIndex + 2] = helpMatrix.b;
              matrices[matrixIndex + 3] = helpMatrix.c;
              matrices[matrixIndex + 4] = helpMatrix.d;
              matrices[matrixIndex + 5] = helpMatrix.tx;
              matrices[matrixIndex + 6] = helpMatrix.ty;
            }
          } else if (y > lA) {
            if (x < -lA || x > lA) return this.globalTransformMatrix;
            isDown = y > this._kY * (x - pX - dX) + lA;
            matrixIndex = 7 * (2 * (segmentX * (segmentY + 1) + segmentX + segmentY + indexY) + (isDown ? 1 : 0));
            if (this._matrixCahce[matrixIndex] > 0) helpMatrix.copyFromArray(matrices, matrixIndex + 1); else {
              var vertexIndex = segmentY * (segmentXD + 2) + 2 * indexX;
              var ddX = this._hullCache[10];
              var ddY = this._hullCache[11];
              var sX = this._hullCache[6] - (segmentX - indexX) * ddX;
              var sY = this._hullCache[7] - (segmentX - indexX) * ddY;
              var vertices = this._vertices;
              isDown ? this._getAffineTransform(pX + dX, lB, dX, lB - lA, sX + ddX, sY + ddY, sX, sY, vertices[vertexIndex + 2], vertices[vertexIndex + 3], Surface._helpTransform, helpMatrix, true) : this._getAffineTransform(pX, lA, dX, lB - lA, vertices[vertexIndex], vertices[vertexIndex + 1], vertices[vertexIndex + 2], vertices[vertexIndex + 3], sX, sY, Surface._helpTransform, helpMatrix, false);
              matrices[matrixIndex] = 1;
              matrices[matrixIndex + 1] = helpMatrix.a;
              matrices[matrixIndex + 2] = helpMatrix.b;
              matrices[matrixIndex + 3] = helpMatrix.c;
              matrices[matrixIndex + 4] = helpMatrix.d;
              matrices[matrixIndex + 5] = helpMatrix.tx;
              matrices[matrixIndex + 6] = helpMatrix.ty;
            }
          } else {
            isDown = y > this._k * (x - pX - dX) + pY;
            matrixIndex = 7 * (2 * (segmentX * indexY + indexX) + (isDown ? 1 : 0));
            if (this._matrixCahce[matrixIndex] > 0) helpMatrix.copyFromArray(matrices, matrixIndex + 1); else {
              var vertexIndex = 2 * indexX + indexY * (segmentXD + 2);
              var vertices = this._vertices;
              isDown ? this._getAffineTransform(pX + dX, pY + dY, dX, dY, vertices[vertexIndex + segmentXD + 4], vertices[vertexIndex + segmentXD + 5], vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], vertices[vertexIndex + 2], vertices[vertexIndex + 3], Surface._helpTransform, helpMatrix, true) : this._getAffineTransform(pX, pY, dX, dY, vertices[vertexIndex], vertices[vertexIndex + 1], vertices[vertexIndex + 2], vertices[vertexIndex + 3], vertices[vertexIndex + segmentXD + 2], vertices[vertexIndex + segmentXD + 3], Surface._helpTransform, helpMatrix, false);
              matrices[matrixIndex] = 1;
              matrices[matrixIndex + 1] = helpMatrix.a;
              matrices[matrixIndex + 2] = helpMatrix.b;
              matrices[matrixIndex + 3] = helpMatrix.c;
              matrices[matrixIndex + 4] = helpMatrix.d;
              matrices[matrixIndex + 5] = helpMatrix.tx;
              matrices[matrixIndex + 6] = helpMatrix.ty;
            }
          }
          return helpMatrix;
        };
        Surface.prototype.init = function(surfaceData) {
          if (null !== this._boneData) return;
          _super.prototype.init.call(this, surfaceData);
          var segmentX = surfaceData.segmentX;
          var segmentY = surfaceData.segmentY;
          var vertexCount = surfaceData.vertices.length;
          var lB = 1e3;
          var lA = 200;
          this._dX = 2 * lA / segmentX;
          this._dY = 2 * lA / segmentY;
          this._k = -this._dY / this._dX;
          this._kX = -this._dY / (lB - lA);
          this._kY = -(lB - lA) / this._dX;
          this._vertices.length = vertexCount;
          this._deformVertices.length = vertexCount;
          this._matrixCahce.length = 2 * (segmentX * segmentY + 2 * segmentX + 2 * segmentY) * 7;
          this._hullCache.length = 10;
          for (var i = 0; i < vertexCount; ++i) this._deformVertices[i] = 0;
        };
        Surface.prototype.update = function(cacheFrameIndex) {
          this._blendState.dirty = false;
          if (cacheFrameIndex >= 0 && null !== this._cachedFrameIndices) {
            var cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex];
            if (cachedFrameIndex >= 0 && this._cachedFrameIndex === cachedFrameIndex) this._transformDirty = false; else if (cachedFrameIndex >= 0) {
              this._transformDirty = true;
              this._cachedFrameIndex = cachedFrameIndex;
            } else {
              if (this._hasConstraint) for (var _i = 0, _a = this._armature._constraints; _i < _a.length; _i++) {
                var constraint = _a[_i];
                constraint._root === this && constraint.update();
              }
              if (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) {
                this._transformDirty = true;
                this._cachedFrameIndex = -1;
              } else if (this._cachedFrameIndex >= 0) {
                this._transformDirty = false;
                this._cachedFrameIndices[cacheFrameIndex] = this._cachedFrameIndex;
              } else {
                this._transformDirty = true;
                this._cachedFrameIndex = -1;
              }
            }
          } else {
            if (this._hasConstraint) for (var _b = 0, _c = this._armature._constraints; _b < _c.length; _b++) {
              var constraint = _c[_b];
              constraint._root === this && constraint.update();
            }
            if (this._transformDirty || null !== this._parent && this._parent._childrenTransformDirty) {
              cacheFrameIndex = -1;
              this._transformDirty = true;
              this._cachedFrameIndex = -1;
            }
          }
          if (this._transformDirty) {
            this._transformDirty = false;
            this._childrenTransformDirty = true;
            for (var i = 0, l = this._matrixCahce.length; i < l; i += 7) this._matrixCahce[i] = -1;
            this._updateVertices();
            if (this._cachedFrameIndex < 0) {
              var isCache = cacheFrameIndex >= 0;
              this._localDirty && this._updateGlobalTransformMatrix(isCache);
              isCache && null !== this._cachedFrameIndices && (this._cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global));
            } else this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);
            var lB = 1e3;
            var lA = 200;
            var ddX = 2 * this.global.x;
            var ddY = 2 * this.global.y;
            var helpPoint = Surface._helpPoint;
            this.globalTransformMatrix.transformPoint(lB, -lA, helpPoint);
            this._hullCache[0] = helpPoint.x;
            this._hullCache[1] = helpPoint.y;
            this._hullCache[2] = ddX - helpPoint.x;
            this._hullCache[3] = ddY - helpPoint.y;
            this.globalTransformMatrix.transformPoint(0, this._dY, helpPoint, true);
            this._hullCache[4] = helpPoint.x;
            this._hullCache[5] = helpPoint.y;
            this.globalTransformMatrix.transformPoint(lA, lB, helpPoint);
            this._hullCache[6] = helpPoint.x;
            this._hullCache[7] = helpPoint.y;
            this._hullCache[8] = ddX - helpPoint.x;
            this._hullCache[9] = ddY - helpPoint.y;
            this.globalTransformMatrix.transformPoint(this._dX, 0, helpPoint, true);
            this._hullCache[10] = helpPoint.x;
            this._hullCache[11] = helpPoint.y;
          } else this._childrenTransformDirty && (this._childrenTransformDirty = false);
          this._localDirty = true;
        };
        return Surface;
      })(dragonBones.Bone);
      dragonBones.Surface = Surface;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Slot = (function(_super) {
        __extends(Slot, _super);
        function Slot() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._localMatrix = new dragonBones.Matrix();
          _this._colorTransform = new dragonBones.ColorTransform();
          _this._deformVertices = [];
          _this._displayDatas = [];
          _this._displayList = [];
          _this._meshBones = [];
          _this._meshSlots = [];
          _this._rawDisplay = null;
          _this._meshDisplay = null;
          return _this;
        }
        Slot.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          var disposeDisplayList = [];
          for (var _i = 0, _a = this._displayList; _i < _a.length; _i++) {
            var eachDisplay = _a[_i];
            null !== eachDisplay && eachDisplay !== this._rawDisplay && eachDisplay !== this._meshDisplay && disposeDisplayList.indexOf(eachDisplay) < 0 && disposeDisplayList.push(eachDisplay);
          }
          for (var _b = 0, disposeDisplayList_1 = disposeDisplayList; _b < disposeDisplayList_1.length; _b++) {
            var eachDisplay = disposeDisplayList_1[_b];
            eachDisplay instanceof dragonBones.Armature ? eachDisplay.dispose() : this._disposeDisplay(eachDisplay, false);
          }
          null !== this._meshDisplay && this._meshDisplay !== this._rawDisplay && this._disposeDisplay(this._meshDisplay, false);
          null !== this._rawDisplay && this._disposeDisplay(this._rawDisplay, false);
          this.displayController = null;
          this._displayDirty = false;
          this._zOrderDirty = false;
          this._blendModeDirty = false;
          this._colorDirty = false;
          this._meshDirty = false;
          this._transformDirty = false;
          this._visible = true;
          this._blendMode = 0;
          this._displayIndex = -1;
          this._animationDisplayIndex = -1;
          this._zOrder = 0;
          this._cachedFrameIndex = -1;
          this._pivotX = 0;
          this._pivotY = 0;
          this._localMatrix.identity();
          this._colorTransform.identity();
          this._deformVertices.length = 0;
          this._displayList.length = 0;
          this._displayDatas.length = 0;
          this._meshBones.length = 0;
          this._meshSlots.length = 0;
          this._slotData = null;
          this._rawDisplayDatas = null;
          this._displayData = null;
          this._textureData = null;
          this._meshData = null;
          this._boundingBoxData = null;
          this._rawDisplay = null;
          this._meshDisplay = null;
          this._display = null;
          this._childArmature = null;
          this._cachedFrameIndices = null;
        };
        Slot.prototype._getDefaultRawDisplayData = function() {
          var defaultSkin = this._armature.armatureData.defaultSkin;
          if (null !== defaultSkin) {
            var defaultRawDisplayDatas = defaultSkin.getDisplays(this._slotData.name);
            if (null !== defaultRawDisplayDatas) return this._displayIndex < defaultRawDisplayDatas.length ? defaultRawDisplayDatas[this._displayIndex] : null;
          }
          return null;
        };
        Slot.prototype._updateDisplayData = function() {
          var prevDisplayData = this._displayData;
          var prevTextureData = this._textureData;
          var prevMeshData = this._meshData;
          var rawDisplayData = null;
          if (this._displayIndex >= 0) {
            if (null !== this._rawDisplayDatas) {
              rawDisplayData = this._displayIndex < this._rawDisplayDatas.length ? this._rawDisplayDatas[this._displayIndex] : null;
              null === rawDisplayData && (rawDisplayData = this._getDefaultRawDisplayData());
            }
            this._displayIndex < this._displayDatas.length && (this._displayData = this._displayDatas[this._displayIndex]);
          } else {
            rawDisplayData = null;
            this._displayData = null;
          }
          if (null !== this._displayData) if (0 === this._displayData.type || 2 === this._displayData.type) if (2 === this._displayData.type) {
            this._textureData = this._displayData.texture;
            this._meshData = this._displayData;
          } else if (null !== rawDisplayData && 2 === rawDisplayData.type) {
            this._textureData = this._displayData.texture;
            this._meshData = rawDisplayData;
          } else {
            this._textureData = this._displayData.texture;
            this._meshData = null;
          } else {
            this._textureData = null;
            this._meshData = null;
          } else {
            this._textureData = null;
            this._meshData = null;
          }
          null !== this._displayData && 3 === this._displayData.type ? this._boundingBoxData = this._displayData.boundingBox : null !== rawDisplayData && 3 === rawDisplayData.type ? this._boundingBoxData = rawDisplayData.boundingBox : this._boundingBoxData = null;
          if (this._displayData !== prevDisplayData || this._textureData !== prevTextureData || this._meshData !== prevMeshData) {
            if (null !== this._meshData) {
              this._pivotX = 0;
              this._pivotY = 0;
            } else if (null !== this._textureData) {
              var imageDisplayData = this._displayData;
              var scale = this._textureData.parent.scale * this._armature._armatureData.scale;
              var frame = this._textureData.frame;
              this._pivotX = imageDisplayData.pivot.x;
              this._pivotY = imageDisplayData.pivot.y;
              var rect = null !== frame ? frame : this._textureData.region;
              var width = rect.width;
              var height = rect.height;
              if (this._textureData.rotated && null === frame) {
                width = rect.height;
                height = rect.width;
              }
              this._pivotX *= width * scale;
              this._pivotY *= height * scale;
              if (null !== frame) {
                this._pivotX += frame.x * scale;
                this._pivotY += frame.y * scale;
              }
            } else {
              this._pivotX = 0;
              this._pivotY = 0;
            }
            if (null !== this._displayData && null !== rawDisplayData && this._displayData !== rawDisplayData && null === this._meshData) {
              rawDisplayData.transform.toMatrix(Slot._helpMatrix);
              Slot._helpMatrix.invert();
              Slot._helpMatrix.transformPoint(0, 0, Slot._helpPoint);
              this._pivotX -= Slot._helpPoint.x;
              this._pivotY -= Slot._helpPoint.y;
              this._displayData.transform.toMatrix(Slot._helpMatrix);
              Slot._helpMatrix.invert();
              Slot._helpMatrix.transformPoint(0, 0, Slot._helpPoint);
              this._pivotX += Slot._helpPoint.x;
              this._pivotY += Slot._helpPoint.y;
            }
            null !== rawDisplayData ? this.origin = rawDisplayData.transform : null !== this._displayData ? this.origin = this._displayData.transform : this.origin = null;
            if (this._meshData !== prevMeshData) if (null !== this._meshData) {
              if (null !== this._meshData.weight) {
                this._deformVertices.length = 2 * this._meshData.weight.count;
                this._meshBones.length = this._meshData.weight.bones.length;
                for (var i = 0, l = this._meshBones.length; i < l; ++i) this._meshBones[i] = this._armature.getBone(this._meshData.weight.bones[i].name);
              } else {
                var vertexCount = this._meshData.parent.parent.parent.intArray[this._meshData.offset + 0];
                this._deformVertices.length = 2 * vertexCount;
                this._meshBones.length = 0;
              }
              var armatureGlueSlots = this._armature._glueSlots;
              if (null !== this._meshData.glue) {
                this._meshSlots.length = this._meshData.glue.meshes.length;
                for (var i = 0, l = this._meshSlots.length; i < l; ++i) {
                  var mesh = this._meshData.glue.meshes[i];
                  if (null !== mesh) {
                    var flag = false;
                    for (var _i = 0, _a = this._armature.getSlots(); _i < _a.length; _i++) {
                      var slot = _a[_i];
                      for (var _b = 0, _c = slot._displayDatas; _b < _c.length; _b++) {
                        var displayData = _c[_b];
                        if (null !== displayData && 2 === displayData.type && displayData.offset === mesh.offset) {
                          flag = true;
                          this._meshSlots[i] = slot;
                          break;
                        }
                      }
                      if (flag) break;
                    }
                    flag || (this._meshSlots[i] = null);
                  } else this._meshSlots[i] = null;
                }
                armatureGlueSlots.indexOf(this) < 0 && armatureGlueSlots.push(this);
              } else {
                var index = armatureGlueSlots.indexOf(this);
                index >= 0 && armatureGlueSlots.slice(index, 1);
              }
              for (var i = 0, l = this._deformVertices.length; i < l; ++i) this._deformVertices[i] = 0;
              this._meshDirty = true;
            } else {
              this._deformVertices.length = 0;
              this._meshBones.length = 0;
              this._meshSlots.length = 0;
            } else null !== this._meshData && this._textureData !== prevTextureData && (this._meshDirty = true);
            this._displayDirty = true;
            this._transformDirty = true;
          }
        };
        Slot.prototype._updateDisplay = function() {
          var prevDisplay = null !== this._display ? this._display : this._rawDisplay;
          var prevChildArmature = this._childArmature;
          if (this._displayIndex >= 0 && this._displayIndex < this._displayList.length) {
            this._display = this._displayList[this._displayIndex];
            if (null !== this._display && this._display instanceof dragonBones.Armature) {
              this._childArmature = this._display;
              this._display = this._childArmature.display;
            } else this._childArmature = null;
          } else {
            this._display = null;
            this._childArmature = null;
          }
          var currentDisplay = null !== this._display ? this._display : this._rawDisplay;
          if (currentDisplay !== prevDisplay) {
            this._onUpdateDisplay();
            this._replaceDisplay(prevDisplay);
            this._visibleDirty = true;
            this._blendModeDirty = true;
            this._colorDirty = true;
          }
          currentDisplay !== this._rawDisplay && currentDisplay !== this._meshDisplay || this._updateFrame();
          if (this._childArmature !== prevChildArmature) {
            if (null !== prevChildArmature) {
              prevChildArmature._parent = null;
              prevChildArmature.clock = null;
              prevChildArmature.inheritAnimation && prevChildArmature.animation.reset();
            }
            if (null !== this._childArmature) {
              this._childArmature._parent = this;
              this._childArmature.clock = this._armature.clock;
              if (this._childArmature.inheritAnimation) {
                if (0 === this._childArmature.cacheFrameRate) {
                  var cacheFrameRate = this._armature.cacheFrameRate;
                  0 !== cacheFrameRate && (this._childArmature.cacheFrameRate = cacheFrameRate);
                }
                var actions = null;
                if (null !== this._displayData && 1 === this._displayData.type) actions = this._displayData.actions; else if (this._displayIndex >= 0 && null !== this._rawDisplayDatas) {
                  var rawDisplayData = this._displayIndex < this._rawDisplayDatas.length ? this._rawDisplayDatas[this._displayIndex] : null;
                  null === rawDisplayData && (rawDisplayData = this._getDefaultRawDisplayData());
                  null !== rawDisplayData && 1 === rawDisplayData.type && (actions = rawDisplayData.actions);
                }
                if (null !== actions && actions.length > 0) for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
                  var action = actions_1[_i];
                  this._childArmature._bufferAction(action, false);
                } else this._childArmature.animation.play();
              }
            }
          }
        };
        Slot.prototype._updateGlobalTransformMatrix = function(isCache) {
          var parentMatrix = 0 === this._parent._boneData.type ? this._parent.globalTransformMatrix : this._parent._getGlobalTransformMatrix(this.global.x, this.global.y);
          this.globalTransformMatrix.copyFrom(this._localMatrix);
          this.globalTransformMatrix.concat(parentMatrix);
          isCache ? this.global.fromMatrix(this.globalTransformMatrix) : this._globalDirty = true;
        };
        Slot.prototype._isMeshBonesUpdate = function() {
          for (var _i = 0, _a = this._meshBones; _i < _a.length; _i++) {
            var bone = _a[_i];
            if (null !== bone && bone._childrenTransformDirty) return true;
          }
          return false;
        };
        Slot.prototype._setArmature = function(value) {
          if (this._armature === value) return;
          null !== this._armature && this._armature._removeSlotFromSlotList(this);
          this._armature = value;
          this._onUpdateDisplay();
          if (null !== this._armature) {
            this._armature._addSlotToSlotList(this);
            this._addDisplay();
          } else this._removeDisplay();
        };
        Slot.prototype._setDisplayIndex = function(value, isAnimation) {
          void 0 === isAnimation && (isAnimation = false);
          if (isAnimation) {
            if (this._animationDisplayIndex === value) return false;
            this._animationDisplayIndex = value;
          }
          if (this._displayIndex === value) return false;
          this._displayIndex = value;
          this._displayDirty = true;
          this._updateDisplayData();
          return this._displayDirty;
        };
        Slot.prototype._setZorder = function(value) {
          this._zOrder === value;
          this._zOrder = value;
          this._zOrderDirty = true;
          return this._zOrderDirty;
        };
        Slot.prototype._setColor = function(value) {
          this._colorTransform.copyFrom(value);
          this._colorDirty = true;
          return this._colorDirty;
        };
        Slot.prototype._setDisplayList = function(value) {
          if (null !== value && value.length > 0) {
            this._displayList.length !== value.length && (this._displayList.length = value.length);
            for (var i = 0, l = value.length; i < l; ++i) {
              var eachDisplay = value[i];
              null !== eachDisplay && eachDisplay !== this._rawDisplay && eachDisplay !== this._meshDisplay && !(eachDisplay instanceof dragonBones.Armature) && this._displayList.indexOf(eachDisplay) < 0 && this._initDisplay(eachDisplay, true);
              this._displayList[i] = eachDisplay;
            }
          } else this._displayList.length > 0 && (this._displayList.length = 0);
          this._displayIndex >= 0 && this._displayIndex < this._displayList.length ? this._displayDirty = this._display !== this._displayList[this._displayIndex] : this._displayDirty = null !== this._display;
          this._updateDisplayData();
          return this._displayDirty;
        };
        Slot.prototype.init = function(slotData, displayDatas, rawDisplay, meshDisplay) {
          if (null !== this._slotData) return;
          this._slotData = slotData;
          this._visibleDirty = true;
          this._blendModeDirty = true;
          this._colorDirty = true;
          this._blendMode = this._slotData.blendMode;
          this._zOrder = this._slotData.zOrder;
          this._colorTransform.copyFrom(this._slotData.color);
          this._rawDisplay = rawDisplay;
          this._meshDisplay = meshDisplay;
          this.rawDisplayDatas = displayDatas;
          this._initDisplay(this._rawDisplay, false);
          this._rawDisplay !== this._meshDisplay && this._initDisplay(this._meshDisplay, false);
        };
        Slot.prototype.update = function(cacheFrameIndex) {
          if (this._displayDirty) {
            this._displayDirty = false;
            this._updateDisplay();
            this._transformDirty && (null !== this.origin ? this.global.copyFrom(this.origin).add(this.offset).toMatrix(this._localMatrix) : this.global.copyFrom(this.offset).toMatrix(this._localMatrix));
          }
          if (this._zOrderDirty) {
            this._zOrderDirty = false;
            this._updateZOrder();
          }
          if (cacheFrameIndex >= 0 && null !== this._cachedFrameIndices) {
            var cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex];
            if (cachedFrameIndex >= 0 && this._cachedFrameIndex === cachedFrameIndex) this._transformDirty = false; else if (cachedFrameIndex >= 0) {
              this._transformDirty = true;
              this._cachedFrameIndex = cachedFrameIndex;
            } else if (this._transformDirty || this._parent._childrenTransformDirty) {
              this._transformDirty = true;
              this._cachedFrameIndex = -1;
            } else if (this._cachedFrameIndex >= 0) {
              this._transformDirty = false;
              this._cachedFrameIndices[cacheFrameIndex] = this._cachedFrameIndex;
            } else {
              this._transformDirty = true;
              this._cachedFrameIndex = -1;
            }
          } else if (this._transformDirty || this._parent._childrenTransformDirty) {
            cacheFrameIndex = -1;
            this._transformDirty = true;
            this._cachedFrameIndex = -1;
          }
          if (null === this._display) return;
          if (this._visibleDirty) {
            this._visibleDirty = false;
            this._updateVisible();
          }
          if (this._blendModeDirty) {
            this._blendModeDirty = false;
            this._updateBlendMode();
          }
          if (this._colorDirty) {
            this._colorDirty = false;
            this._updateColor();
          }
          if (null !== this._meshData && this._display === this._meshDisplay) {
            var isSkinned = null !== this._meshData.weight;
            var isSurface = 0 !== this._parent._boneData.type;
            var isGule = null !== this._meshData.glue;
            if (this._meshDirty || isSkinned && this._isMeshBonesUpdate() || isSurface && this._parent._childrenTransformDirty || isGule && this._parent._childrenTransformDirty) {
              this._meshDirty = false;
              this._updateMesh();
            }
            if (isSkinned || isSurface || isGule) return;
          }
          if (this._transformDirty) {
            this._transformDirty = false;
            if (this._cachedFrameIndex < 0) {
              var isCache = cacheFrameIndex >= 0;
              this._updateGlobalTransformMatrix(isCache);
              isCache && null !== this._cachedFrameIndices && (this._cachedFrameIndex = this._cachedFrameIndices[cacheFrameIndex] = this._armature._armatureData.setCacheFrame(this.globalTransformMatrix, this.global));
            } else this._armature._armatureData.getCacheFrame(this.globalTransformMatrix, this.global, this._cachedFrameIndex);
            this._updateTransform();
          }
        };
        Slot.prototype.updateTransformAndMatrix = function() {
          if (this._transformDirty) {
            this._transformDirty = false;
            this._updateGlobalTransformMatrix(false);
          }
        };
        Slot.prototype.replaceDisplayData = function(value, displayIndex) {
          void 0 === displayIndex && (displayIndex = -1);
          displayIndex < 0 && (displayIndex = this._displayIndex < 0 ? 0 : this._displayIndex);
          if (this._displayDatas.length <= displayIndex) {
            this._displayDatas.length = displayIndex + 1;
            for (var i = 0, l = this._displayDatas.length; i < l; ++i) this._displayDatas[i] || (this._displayDatas[i] = null);
          }
          this._displayDatas[displayIndex] = value;
        };
        Slot.prototype.containsPoint = function(x, y) {
          if (null === this._boundingBoxData) return false;
          this.updateTransformAndMatrix();
          Slot._helpMatrix.copyFrom(this.globalTransformMatrix);
          Slot._helpMatrix.invert();
          Slot._helpMatrix.transformPoint(x, y, Slot._helpPoint);
          return this._boundingBoxData.containsPoint(Slot._helpPoint.x, Slot._helpPoint.y);
        };
        Slot.prototype.intersectsSegment = function(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
          void 0 === intersectionPointA && (intersectionPointA = null);
          void 0 === intersectionPointB && (intersectionPointB = null);
          void 0 === normalRadians && (normalRadians = null);
          if (null === this._boundingBoxData) return 0;
          this.updateTransformAndMatrix();
          Slot._helpMatrix.copyFrom(this.globalTransformMatrix);
          Slot._helpMatrix.invert();
          Slot._helpMatrix.transformPoint(xA, yA, Slot._helpPoint);
          xA = Slot._helpPoint.x;
          yA = Slot._helpPoint.y;
          Slot._helpMatrix.transformPoint(xB, yB, Slot._helpPoint);
          xB = Slot._helpPoint.x;
          yB = Slot._helpPoint.y;
          var intersectionCount = this._boundingBoxData.intersectsSegment(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians);
          if (intersectionCount > 0) {
            if (1 === intersectionCount || 2 === intersectionCount) if (null !== intersectionPointA) {
              this.globalTransformMatrix.transformPoint(intersectionPointA.x, intersectionPointA.y, intersectionPointA);
              if (null !== intersectionPointB) {
                intersectionPointB.x = intersectionPointA.x;
                intersectionPointB.y = intersectionPointA.y;
              }
            } else null !== intersectionPointB && this.globalTransformMatrix.transformPoint(intersectionPointB.x, intersectionPointB.y, intersectionPointB); else {
              null !== intersectionPointA && this.globalTransformMatrix.transformPoint(intersectionPointA.x, intersectionPointA.y, intersectionPointA);
              null !== intersectionPointB && this.globalTransformMatrix.transformPoint(intersectionPointB.x, intersectionPointB.y, intersectionPointB);
            }
            if (null !== normalRadians) {
              this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.x), Math.sin(normalRadians.x), Slot._helpPoint, true);
              normalRadians.x = Math.atan2(Slot._helpPoint.y, Slot._helpPoint.x);
              this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.y), Math.sin(normalRadians.y), Slot._helpPoint, true);
              normalRadians.y = Math.atan2(Slot._helpPoint.y, Slot._helpPoint.x);
            }
          }
          return intersectionCount;
        };
        Slot.prototype.invalidUpdate = function() {
          this._displayDirty = true;
          this._transformDirty = true;
        };
        Object.defineProperty(Slot.prototype, "visible", {
          get: function() {
            return this._visible;
          },
          set: function(value) {
            if (this._visible === value) return;
            this._visible = value;
            this._updateVisible();
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "displayIndex", {
          get: function() {
            return this._displayIndex;
          },
          set: function(value) {
            this._setDisplayIndex(value) && this.update(-1);
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "name", {
          get: function() {
            return this._slotData.name;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "displayList", {
          get: function() {
            return this._displayList.concat();
          },
          set: function(value) {
            var backupDisplayList = this._displayList.concat();
            var disposeDisplayList = new Array();
            this._setDisplayList(value) && this.update(-1);
            for (var _i = 0, backupDisplayList_1 = backupDisplayList; _i < backupDisplayList_1.length; _i++) {
              var eachDisplay = backupDisplayList_1[_i];
              null !== eachDisplay && eachDisplay !== this._rawDisplay && eachDisplay !== this._meshDisplay && this._displayList.indexOf(eachDisplay) < 0 && disposeDisplayList.indexOf(eachDisplay) < 0 && disposeDisplayList.push(eachDisplay);
            }
            for (var _a = 0, disposeDisplayList_2 = disposeDisplayList; _a < disposeDisplayList_2.length; _a++) {
              var eachDisplay = disposeDisplayList_2[_a];
              eachDisplay instanceof dragonBones.Armature ? eachDisplay.dispose() : this._disposeDisplay(eachDisplay, true);
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "slotData", {
          get: function() {
            return this._slotData;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "rawDisplayDatas", {
          get: function() {
            return this._rawDisplayDatas;
          },
          set: function(value) {
            if (this._rawDisplayDatas === value) return;
            this._displayDirty = true;
            this._rawDisplayDatas = value;
            if (null !== this._rawDisplayDatas) {
              this._displayDatas.length = this._rawDisplayDatas.length;
              for (var i = 0, l = this._displayDatas.length; i < l; ++i) {
                var rawDisplayData = this._rawDisplayDatas[i];
                null === rawDisplayData && (rawDisplayData = this._getDefaultRawDisplayData());
                this._displayDatas[i] = rawDisplayData;
              }
            } else this._displayDatas.length = 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "boundingBoxData", {
          get: function() {
            return this._boundingBoxData;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "rawDisplay", {
          get: function() {
            return this._rawDisplay;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "meshDisplay", {
          get: function() {
            return this._meshDisplay;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "display", {
          get: function() {
            return this._display;
          },
          set: function(value) {
            if (this._display === value) return;
            var displayListLength = this._displayList.length;
            this._displayIndex < 0 && 0 === displayListLength && (this._displayIndex = 0);
            if (this._displayIndex < 0) return;
            var replaceDisplayList = this.displayList;
            displayListLength <= this._displayIndex && (replaceDisplayList.length = this._displayIndex + 1);
            replaceDisplayList[this._displayIndex] = value;
            this.displayList = replaceDisplayList;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Slot.prototype, "childArmature", {
          get: function() {
            return this._childArmature;
          },
          set: function(value) {
            if (this._childArmature === value) return;
            this.display = value;
          },
          enumerable: true,
          configurable: true
        });
        Slot.prototype.getDisplay = function() {
          return this.display;
        };
        Slot.prototype.setDisplay = function(value) {
          this.display = value;
        };
        return Slot;
      })(dragonBones.TransformObject);
      dragonBones.Slot = Slot;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Constraint = (function(_super) {
        __extends(Constraint, _super);
        function Constraint() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        Constraint.prototype._onClear = function() {
          this._armature = null;
          this._target = null;
          this._root = null;
          this._bone = null;
        };
        Object.defineProperty(Constraint.prototype, "name", {
          get: function() {
            return this._constraintData.name;
          },
          enumerable: true,
          configurable: true
        });
        Constraint._helpMatrix = new dragonBones.Matrix();
        Constraint._helpTransform = new dragonBones.Transform();
        Constraint._helpPoint = new dragonBones.Point();
        return Constraint;
      })(dragonBones.BaseObject);
      dragonBones.Constraint = Constraint;
      var IKConstraint = (function(_super) {
        __extends(IKConstraint, _super);
        function IKConstraint() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        IKConstraint.toString = function() {
          return "[class dragonBones.IKConstraint]";
        };
        IKConstraint.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this._scaleEnabled = false;
          this._bendPositive = false;
          this._weight = 1;
          this._constraintData = null;
        };
        IKConstraint.prototype._computeA = function() {
          var ikGlobal = this._target.global;
          var global = this._root.global;
          var globalTransformMatrix = this._root.globalTransformMatrix;
          var radian = Math.atan2(ikGlobal.y - global.y, ikGlobal.x - global.x);
          global.scaleX < 0 && (radian += Math.PI);
          global.rotation += (radian - global.rotation) * this._weight;
          global.toMatrix(globalTransformMatrix);
        };
        IKConstraint.prototype._computeB = function() {
          var boneLength = this._bone._boneData.length;
          var parent = this._root;
          var ikGlobal = this._target.global;
          var parentGlobal = parent.global;
          var global = this._bone.global;
          var globalTransformMatrix = this._bone.globalTransformMatrix;
          var x = globalTransformMatrix.a * boneLength;
          var y = globalTransformMatrix.b * boneLength;
          var lLL = x * x + y * y;
          var lL = Math.sqrt(lLL);
          var dX = global.x - parentGlobal.x;
          var dY = global.y - parentGlobal.y;
          var lPP = dX * dX + dY * dY;
          var lP = Math.sqrt(lPP);
          var rawRadian = global.rotation;
          var rawParentRadian = parentGlobal.rotation;
          var rawRadianA = Math.atan2(dY, dX);
          dX = ikGlobal.x - parentGlobal.x;
          dY = ikGlobal.y - parentGlobal.y;
          var lTT = dX * dX + dY * dY;
          var lT = Math.sqrt(lTT);
          var radianA = 0;
          if (lL + lP <= lT || lT + lL <= lP || lT + lP <= lL) {
            radianA = Math.atan2(ikGlobal.y - parentGlobal.y, ikGlobal.x - parentGlobal.x);
            lL + lP <= lT || lP < lL && (radianA += Math.PI);
          } else {
            var h = (lPP - lLL + lTT) / (2 * lTT);
            var r = Math.sqrt(lPP - h * h * lTT) / lT;
            var hX = parentGlobal.x + dX * h;
            var hY = parentGlobal.y + dY * h;
            var rX = -dY * r;
            var rY = dX * r;
            var isPPR = false;
            if (null !== parent._parent) {
              var parentParentMatrix = parent._parent.globalTransformMatrix;
              isPPR = parentParentMatrix.a * parentParentMatrix.d - parentParentMatrix.b * parentParentMatrix.c < 0;
            }
            if (isPPR !== this._bendPositive) {
              global.x = hX - rX;
              global.y = hY - rY;
            } else {
              global.x = hX + rX;
              global.y = hY + rY;
            }
            radianA = Math.atan2(global.y - parentGlobal.y, global.x - parentGlobal.x);
          }
          var dR = dragonBones.Transform.normalizeRadian(radianA - rawRadianA);
          parentGlobal.rotation = rawParentRadian + dR * this._weight;
          parentGlobal.toMatrix(parent.globalTransformMatrix);
          var currentRadianA = rawRadianA + dR * this._weight;
          global.x = parentGlobal.x + Math.cos(currentRadianA) * lP;
          global.y = parentGlobal.y + Math.sin(currentRadianA) * lP;
          var radianB = Math.atan2(ikGlobal.y - global.y, ikGlobal.x - global.x);
          global.scaleX < 0 && (radianB += Math.PI);
          global.rotation = parentGlobal.rotation + rawRadian - rawParentRadian + dragonBones.Transform.normalizeRadian(radianB - dR - rawRadian) * this._weight;
          global.toMatrix(globalTransformMatrix);
        };
        IKConstraint.prototype.init = function(constraintData, armature) {
          if (null !== this._constraintData) return;
          this._constraintData = constraintData;
          this._armature = armature;
          this._target = this._armature.getBone(this._constraintData.target.name);
          this._root = this._armature.getBone(this._constraintData.root.name);
          this._bone = null !== this._constraintData.bone ? this._armature.getBone(this._constraintData.bone.name) : null;
          var ikConstraintData = this._constraintData;
          this._scaleEnabled = ikConstraintData.scaleEnabled;
          this._scaleEnabled = this._scaleEnabled;
          this._bendPositive = ikConstraintData.bendPositive;
          this._weight = ikConstraintData.weight;
          this._root._hasConstraint = true;
        };
        IKConstraint.prototype.update = function() {
          this._root.updateByConstraint();
          if (null !== this._bone) {
            this._bone.updateByConstraint();
            this._computeB();
          } else this._computeA();
        };
        IKConstraint.prototype.invalidUpdate = function() {
          this._root.invalidUpdate();
          null !== this._bone && this._bone.invalidUpdate();
        };
        return IKConstraint;
      })(Constraint);
      dragonBones.IKConstraint = IKConstraint;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var WorldClock = (function() {
        function WorldClock(time) {
          void 0 === time && (time = -1);
          this.time = 0;
          this.timeScale = 1;
          this._animatebles = [];
          this._clock = null;
          this.time = time < 0 ? .001 * new Date().getTime() : time;
        }
        WorldClock.prototype.advanceTime = function(passedTime) {
          passedTime !== passedTime && (passedTime = 0);
          passedTime < 0 && (passedTime = .001 * new Date().getTime() - this.time);
          1 !== this.timeScale && (passedTime *= this.timeScale);
          passedTime < 0 ? this.time -= passedTime : this.time += passedTime;
          if (0 === passedTime) return;
          var i = 0, r = 0, l = this._animatebles.length;
          for (;i < l; ++i) {
            var animatable = this._animatebles[i];
            if (null !== animatable) {
              if (r > 0) {
                this._animatebles[i - r] = animatable;
                this._animatebles[i] = null;
              }
              animatable.advanceTime(passedTime);
            } else r++;
          }
          if (r > 0) {
            l = this._animatebles.length;
            for (;i < l; ++i) {
              var animateble = this._animatebles[i];
              null !== animateble ? this._animatebles[i - r] = animateble : r++;
            }
            this._animatebles.length -= r;
          }
        };
        WorldClock.prototype.contains = function(value) {
          if (value === this) return false;
          var ancestor = value;
          while (ancestor !== this && null !== ancestor) ancestor = ancestor.clock;
          return ancestor === this;
        };
        WorldClock.prototype.add = function(value) {
          if (this._animatebles.indexOf(value) < 0) {
            this._animatebles.push(value);
            value.clock = this;
          }
        };
        WorldClock.prototype.remove = function(value) {
          var index = this._animatebles.indexOf(value);
          if (index >= 0) {
            this._animatebles[index] = null;
            value.clock = null;
          }
        };
        WorldClock.prototype.clear = function() {
          for (var _i = 0, _a = this._animatebles; _i < _a.length; _i++) {
            var animatable = _a[_i];
            null !== animatable && (animatable.clock = null);
          }
        };
        Object.defineProperty(WorldClock.prototype, "clock", {
          get: function() {
            return this._clock;
          },
          set: function(value) {
            if (this._clock === value) return;
            null !== this._clock && this._clock.remove(this);
            this._clock = value;
            null !== this._clock && this._clock.add(this);
          },
          enumerable: true,
          configurable: true
        });
        WorldClock.clock = new WorldClock();
        return WorldClock;
      })();
      dragonBones.WorldClock = WorldClock;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var Animation = (function(_super) {
        __extends(Animation, _super);
        function Animation() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._animationNames = [];
          _this._animationStates = [];
          _this._animations = {};
          _this._animationConfig = null;
          return _this;
        }
        Animation.toString = function() {
          return "[class dragonBones.Animation]";
        };
        Animation.prototype._onClear = function() {
          for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
            var animationState = _a[_i];
            animationState.returnToPool();
          }
          for (var k in this._animations) delete this._animations[k];
          null !== this._animationConfig && this._animationConfig.returnToPool();
          this.timeScale = 1;
          this._lockUpdate = false;
          this._animationDirty = false;
          this._inheritTimeScale = 1;
          this._animationNames.length = 0;
          this._animationStates.length = 0;
          this._armature = null;
          this._animationConfig = null;
          this._lastAnimationState = null;
        };
        Animation.prototype._fadeOut = function(animationConfig) {
          switch (animationConfig.fadeOutMode) {
           case 1:
            for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
              var animationState = _a[_i];
              if (null !== animationState._parent) continue;
              animationState.layer === animationConfig.layer && animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
            }
            break;

           case 2:
            for (var _b = 0, _c = this._animationStates; _b < _c.length; _b++) {
              var animationState = _c[_b];
              if (null !== animationState._parent) continue;
              animationState.group === animationConfig.group && animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
            }
            break;

           case 3:
            for (var _d = 0, _e = this._animationStates; _d < _e.length; _d++) {
              var animationState = _e[_d];
              if (null !== animationState._parent) continue;
              animationState.layer === animationConfig.layer && animationState.group === animationConfig.group && animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
            }
            break;

           case 4:
            for (var _f = 0, _g = this._animationStates; _f < _g.length; _f++) {
              var animationState = _g[_f];
              if (null !== animationState._parent) continue;
              animationState.fadeOut(animationConfig.fadeOutTime, animationConfig.pauseFadeOut);
            }
          }
        };
        Animation.prototype.init = function(armature) {
          if (null !== this._armature) return;
          this._armature = armature;
          this._animationConfig = dragonBones.BaseObject.borrowObject(dragonBones.AnimationConfig);
        };
        Animation.prototype.advanceTime = function(passedTime) {
          passedTime < 0 && (passedTime = -passedTime);
          this._armature.inheritAnimation && null !== this._armature._parent ? this._inheritTimeScale = this._armature._parent._armature.animation._inheritTimeScale * this.timeScale : this._inheritTimeScale = this.timeScale;
          1 !== this._inheritTimeScale && (passedTime *= this._inheritTimeScale);
          var animationStateCount = this._animationStates.length;
          if (1 === animationStateCount) {
            var animationState = this._animationStates[0];
            if (animationState._fadeState > 0 && animationState._subFadeState > 0) {
              this._armature._dragonBones.bufferObject(animationState);
              this._animationStates.length = 0;
              this._lastAnimationState = null;
            } else {
              var animationData = animationState._animationData;
              var cacheFrameRate = animationData.cacheFrameRate;
              if (this._animationDirty && cacheFrameRate > 0) {
                this._animationDirty = false;
                for (var _i = 0, _a = this._armature.getBones(); _i < _a.length; _i++) {
                  var bone = _a[_i];
                  bone._cachedFrameIndices = animationData.getBoneCachedFrameIndices(bone.name);
                }
                for (var _b = 0, _c = this._armature.getSlots(); _b < _c.length; _b++) {
                  var slot = _c[_b];
                  slot._cachedFrameIndices = animationData.getSlotCachedFrameIndices(slot.name);
                }
              }
              animationState.advanceTime(passedTime, cacheFrameRate);
            }
          } else if (animationStateCount > 1) {
            for (var i = 0, r = 0; i < animationStateCount; ++i) {
              var animationState = this._animationStates[i];
              if (animationState._fadeState > 0 && animationState._subFadeState > 0) {
                r++;
                this._armature._dragonBones.bufferObject(animationState);
                this._animationDirty = true;
                this._lastAnimationState === animationState && (this._lastAnimationState = null);
              } else {
                r > 0 && (this._animationStates[i - r] = animationState);
                animationState.advanceTime(passedTime, 0);
              }
              if (i === animationStateCount - 1 && r > 0) {
                this._animationStates.length -= r;
                null === this._lastAnimationState && this._animationStates.length > 0 && (this._lastAnimationState = this._animationStates[this._animationStates.length - 1]);
              }
            }
            this._armature._cacheFrameIndex = -1;
          } else this._armature._cacheFrameIndex = -1;
        };
        Animation.prototype.reset = function() {
          for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
            var animationState = _a[_i];
            animationState.returnToPool();
          }
          this._animationDirty = false;
          this._animationConfig.clear();
          this._animationStates.length = 0;
          this._lastAnimationState = null;
        };
        Animation.prototype.stop = function(animationName) {
          void 0 === animationName && (animationName = null);
          if (null !== animationName) {
            var animationState = this.getState(animationName);
            null !== animationState && animationState.stop();
          } else for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
            var animationState = _a[_i];
            animationState.stop();
          }
        };
        Animation.prototype.playConfig = function(animationConfig) {
          var animationName = animationConfig.animation;
          if (!(animationName in this._animations)) {
            console.warn("Non-existent animation.\n", "DragonBones name: " + this._armature.armatureData.parent.name, "Armature name: " + this._armature.name, "Animation name: " + animationName);
            return null;
          }
          var animationData = this._animations[animationName];
          if (5 === animationConfig.fadeOutMode) for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
            var animationState_1 = _a[_i];
            if (animationState_1._animationData === animationData) return animationState_1;
          }
          0 === this._animationStates.length ? animationConfig.fadeInTime = 0 : animationConfig.fadeInTime < 0 && (animationConfig.fadeInTime = animationData.fadeInTime);
          animationConfig.fadeOutTime < 0 && (animationConfig.fadeOutTime = animationConfig.fadeInTime);
          animationConfig.timeScale <= -100 && (animationConfig.timeScale = 1 / animationData.scale);
          if (animationData.frameCount > 1) {
            if (animationConfig.position < 0) {
              animationConfig.position %= animationData.duration;
              animationConfig.position = animationData.duration - animationConfig.position;
            } else animationConfig.position === animationData.duration ? animationConfig.position -= 1e-6 : animationConfig.position > animationData.duration && (animationConfig.position %= animationData.duration);
            animationConfig.duration > 0 && animationConfig.position + animationConfig.duration > animationData.duration && (animationConfig.duration = animationData.duration - animationConfig.position);
            animationConfig.playTimes < 0 && (animationConfig.playTimes = animationData.playTimes);
          } else {
            animationConfig.playTimes = 1;
            animationConfig.position = 0;
            animationConfig.duration > 0 && (animationConfig.duration = 0);
          }
          0 === animationConfig.duration && (animationConfig.duration = -1);
          this._fadeOut(animationConfig);
          var animationState = dragonBones.BaseObject.borrowObject(dragonBones.AnimationState);
          animationState.init(this._armature, animationData, animationConfig);
          this._animationDirty = true;
          this._armature._cacheFrameIndex = -1;
          if (this._animationStates.length > 0) {
            var added = false;
            for (var i = 0, l = this._animationStates.length; i < l; ++i) {
              if (animationState.layer > this._animationStates[i].layer) {
                added = true;
                this._animationStates.splice(i, 0, animationState);
                break;
              }
              if (i !== l - 1 && animationState.layer > this._animationStates[i + 1].layer) {
                added = true;
                this._animationStates.splice(i + 1, 0, animationState);
                break;
              }
            }
            added || this._animationStates.push(animationState);
          } else this._animationStates.push(animationState);
          for (var _b = 0, _c = this._armature.getSlots(); _b < _c.length; _b++) {
            var slot = _c[_b];
            var childArmature = slot.childArmature;
            null !== childArmature && childArmature.inheritAnimation && childArmature.animation.hasAnimation(animationName) && null === childArmature.animation.getState(animationName) && childArmature.animation.fadeIn(animationName);
          }
          var isLocked = false;
          for (var k in animationData.animationTimelines) {
            if (!this._lockUpdate) {
              isLocked = true;
              this._lockUpdate = true;
            }
            var childAnimatiionState = this.fadeIn(k, animationConfig.fadeInTime, 1, animationState.layer, null, 0);
            if (null !== childAnimatiionState) {
              childAnimatiionState.resetToPose = false;
              childAnimatiionState._parent = animationState;
              childAnimatiionState.stop();
            }
          }
          isLocked && (this._lockUpdate = false);
          if (!this._lockUpdate) {
            animationConfig.fadeInTime <= 0 && this._armature.advanceTime(0);
            this._lastAnimationState = animationState;
          }
          return animationState;
        };
        Animation.prototype.play = function(animationName, playTimes) {
          void 0 === animationName && (animationName = null);
          void 0 === playTimes && (playTimes = -1);
          this._animationConfig.clear();
          this._animationConfig.resetToPose = true;
          this._animationConfig.playTimes = playTimes;
          this._animationConfig.fadeInTime = 0;
          this._animationConfig.animation = null !== animationName ? animationName : "";
          if (null !== animationName && animationName.length > 0) this.playConfig(this._animationConfig); else if (null === this._lastAnimationState) {
            var defaultAnimation = this._armature.armatureData.defaultAnimation;
            if (null !== defaultAnimation) {
              this._animationConfig.animation = defaultAnimation.name;
              this.playConfig(this._animationConfig);
            }
          } else if (this._lastAnimationState.isPlaying || this._lastAnimationState.isCompleted) {
            this._animationConfig.animation = this._lastAnimationState.name;
            this.playConfig(this._animationConfig);
          } else this._lastAnimationState.play();
          return this._lastAnimationState;
        };
        Animation.prototype.fadeIn = function(animationName, fadeInTime, playTimes, layer, group, fadeOutMode) {
          void 0 === fadeInTime && (fadeInTime = -1);
          void 0 === playTimes && (playTimes = -1);
          void 0 === layer && (layer = 0);
          void 0 === group && (group = null);
          void 0 === fadeOutMode && (fadeOutMode = 3);
          this._animationConfig.clear();
          this._animationConfig.fadeOutMode = fadeOutMode;
          this._animationConfig.playTimes = playTimes;
          this._animationConfig.layer = layer;
          this._animationConfig.fadeInTime = fadeInTime;
          this._animationConfig.animation = animationName;
          this._animationConfig.group = null !== group ? group : "";
          return this.playConfig(this._animationConfig);
        };
        Animation.prototype.gotoAndPlayByTime = function(animationName, time, playTimes) {
          void 0 === time && (time = 0);
          void 0 === playTimes && (playTimes = -1);
          this._animationConfig.clear();
          this._animationConfig.resetToPose = true;
          this._animationConfig.playTimes = playTimes;
          this._animationConfig.position = time;
          this._animationConfig.fadeInTime = 0;
          this._animationConfig.animation = animationName;
          return this.playConfig(this._animationConfig);
        };
        Animation.prototype.gotoAndPlayByFrame = function(animationName, frame, playTimes) {
          void 0 === frame && (frame = 0);
          void 0 === playTimes && (playTimes = -1);
          this._animationConfig.clear();
          this._animationConfig.resetToPose = true;
          this._animationConfig.playTimes = playTimes;
          this._animationConfig.fadeInTime = 0;
          this._animationConfig.animation = animationName;
          var animationData = animationName in this._animations ? this._animations[animationName] : null;
          null !== animationData && (this._animationConfig.position = animationData.duration * frame / animationData.frameCount);
          return this.playConfig(this._animationConfig);
        };
        Animation.prototype.gotoAndPlayByProgress = function(animationName, progress, playTimes) {
          void 0 === progress && (progress = 0);
          void 0 === playTimes && (playTimes = -1);
          this._animationConfig.clear();
          this._animationConfig.resetToPose = true;
          this._animationConfig.playTimes = playTimes;
          this._animationConfig.fadeInTime = 0;
          this._animationConfig.animation = animationName;
          var animationData = animationName in this._animations ? this._animations[animationName] : null;
          null !== animationData && (this._animationConfig.position = animationData.duration * (progress > 0 ? progress : 0));
          return this.playConfig(this._animationConfig);
        };
        Animation.prototype.gotoAndStopByTime = function(animationName, time) {
          void 0 === time && (time = 0);
          var animationState = this.gotoAndPlayByTime(animationName, time, 1);
          null !== animationState && animationState.stop();
          return animationState;
        };
        Animation.prototype.gotoAndStopByFrame = function(animationName, frame) {
          void 0 === frame && (frame = 0);
          var animationState = this.gotoAndPlayByFrame(animationName, frame, 1);
          null !== animationState && animationState.stop();
          return animationState;
        };
        Animation.prototype.gotoAndStopByProgress = function(animationName, progress) {
          void 0 === progress && (progress = 0);
          var animationState = this.gotoAndPlayByProgress(animationName, progress, 1);
          null !== animationState && animationState.stop();
          return animationState;
        };
        Animation.prototype.getState = function(animationName) {
          var i = this._animationStates.length;
          while (i--) {
            var animationState = this._animationStates[i];
            if (animationState.name === animationName) return animationState;
          }
          return null;
        };
        Animation.prototype.hasAnimation = function(animationName) {
          return animationName in this._animations;
        };
        Animation.prototype.getStates = function() {
          return this._animationStates;
        };
        Object.defineProperty(Animation.prototype, "isPlaying", {
          get: function() {
            for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
              var animationState = _a[_i];
              if (animationState.isPlaying) return true;
            }
            return false;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "isCompleted", {
          get: function() {
            for (var _i = 0, _a = this._animationStates; _i < _a.length; _i++) {
              var animationState = _a[_i];
              if (!animationState.isCompleted) return false;
            }
            return this._animationStates.length > 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationName", {
          get: function() {
            return null !== this._lastAnimationState ? this._lastAnimationState.name : "";
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "animationNames", {
          get: function() {
            return this._animationNames;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
          get: function() {
            return this._animations;
          },
          set: function(value) {
            if (this._animations === value) return;
            this._animationNames.length = 0;
            for (var k in this._animations) delete this._animations[k];
            for (var k in value) {
              this._animationNames.push(k);
              this._animations[k] = value[k];
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "animationConfig", {
          get: function() {
            this._animationConfig.clear();
            return this._animationConfig;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "lastAnimationState", {
          get: function() {
            return this._lastAnimationState;
          },
          enumerable: true,
          configurable: true
        });
        Animation.prototype.gotoAndPlay = function(animationName, fadeInTime, duration, playTimes, layer, group, fadeOutMode, pauseFadeOut, pauseFadeIn) {
          void 0 === fadeInTime && (fadeInTime = -1);
          void 0 === duration && (duration = -1);
          void 0 === playTimes && (playTimes = -1);
          void 0 === layer && (layer = 0);
          void 0 === group && (group = null);
          void 0 === fadeOutMode && (fadeOutMode = 3);
          void 0 === pauseFadeOut && (pauseFadeOut = true);
          void 0 === pauseFadeIn && (pauseFadeIn = true);
          pauseFadeOut;
          pauseFadeIn;
          this._animationConfig.clear();
          this._animationConfig.resetToPose = true;
          this._animationConfig.fadeOutMode = fadeOutMode;
          this._animationConfig.playTimes = playTimes;
          this._animationConfig.layer = layer;
          this._animationConfig.fadeInTime = fadeInTime;
          this._animationConfig.animation = animationName;
          this._animationConfig.group = null !== group ? group : "";
          var animationData = this._animations[animationName];
          animationData && duration > 0 && (this._animationConfig.timeScale = animationData.duration / duration);
          return this.playConfig(this._animationConfig);
        };
        Animation.prototype.gotoAndStop = function(animationName, time) {
          void 0 === time && (time = 0);
          return this.gotoAndStopByTime(animationName, time);
        };
        Object.defineProperty(Animation.prototype, "animationList", {
          get: function() {
            return this._animationNames;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(Animation.prototype, "animationDataList", {
          get: function() {
            var list = [];
            for (var i = 0, l = this._animationNames.length; i < l; ++i) list.push(this._animations[this._animationNames[i]]);
            return list;
          },
          enumerable: true,
          configurable: true
        });
        return Animation;
      })(dragonBones.BaseObject);
      dragonBones.Animation = Animation;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var AnimationState = (function(_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._blendState = new BlendState();
          _this._boneMask = [];
          _this._boneTimelines = [];
          _this._surfaceTimelines = [];
          _this._slotTimelines = [];
          _this._constraintTimelines = [];
          _this._animationTimelines = [];
          _this._poseTimelines = [];
          _this._bonePoses = {};
          _this._actionTimeline = null;
          _this._zOrderTimeline = null;
          _this._parent = null;
          return _this;
        }
        AnimationState.toString = function() {
          return "[class dragonBones.AnimationState]";
        };
        AnimationState.prototype._onClear = function() {
          for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
            var timeline = _a[_i];
            timeline.returnToPool();
          }
          for (var _b = 0, _c = this._surfaceTimelines; _b < _c.length; _b++) {
            var timeline = _c[_b];
            timeline.returnToPool();
          }
          for (var _d = 0, _e = this._slotTimelines; _d < _e.length; _d++) {
            var timeline = _e[_d];
            timeline.returnToPool();
          }
          for (var _f = 0, _g = this._constraintTimelines; _f < _g.length; _f++) {
            var timeline = _g[_f];
            timeline.returnToPool();
          }
          for (var _h = 0, _j = this._animationTimelines; _h < _j.length; _h++) {
            var timeline = _j[_h];
            timeline.returnToPool();
          }
          for (var k in this._bonePoses) {
            this._bonePoses[k].returnToPool();
            delete this._bonePoses[k];
          }
          null !== this._actionTimeline && this._actionTimeline.returnToPool();
          null !== this._zOrderTimeline && this._zOrderTimeline.returnToPool();
          this.actionEnabled = false;
          this.additiveBlending = false;
          this.displayControl = false;
          this.resetToPose = false;
          this.playTimes = 1;
          this.layer = 0;
          this.timeScale = 1;
          this.weight = 1;
          this.autoFadeOutTime = 0;
          this.fadeTotalTime = 0;
          this.name = "";
          this.group = "";
          this._timelineDirty = 2;
          this._playheadState = 0;
          this._fadeState = -1;
          this._subFadeState = -1;
          this._position = 0;
          this._duration = 0;
          this._fadeTime = 0;
          this._time = 0;
          this._fadeProgress = 0;
          this._weightResult = 0;
          this._blendState.clear();
          this._boneMask.length = 0;
          this._boneTimelines.length = 0;
          this._surfaceTimelines.length = 0;
          this._slotTimelines.length = 0;
          this._constraintTimelines.length = 0;
          this._animationTimelines.length = 0;
          this._poseTimelines.length = 0;
          this._animationData = null;
          this._armature = null;
          this._actionTimeline = null;
          this._zOrderTimeline = null;
          this._parent = null;
        };
        AnimationState.prototype._updateTimelines = function() {
          for (var _i = 0, _a = this._armature._constraints; _i < _a.length; _i++) {
            var constraint = _a[_i];
            var timelineDatas = this._animationData.getConstraintTimelines(constraint.name);
            if (null !== timelineDatas) for (var _b = 0, timelineDatas_1 = timelineDatas; _b < timelineDatas_1.length; _b++) {
              var timelineData = timelineDatas_1[_b];
              switch (timelineData.type) {
               case 30:
                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);
                timeline.constraint = constraint;
                timeline.init(this._armature, this, timelineData);
                this._constraintTimelines.push(timeline);
              }
            } else if (this.resetToPose) {
              var timeline = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintTimelineState);
              timeline.constraint = constraint;
              timeline.init(this._armature, this, null);
              this._constraintTimelines.push(timeline);
              this._poseTimelines.push(timeline);
            }
          }
          for (var _c = 0, _d = this._armature.animation.getStates(); _c < _d.length; _c++) {
            var animationState = _d[_c];
            if (animationState._parent !== this) continue;
            var timelineDatas = this._animationData.getAnimationTimelines(animationState.name);
            if (null === timelineDatas) continue;
            for (var _e = 0, timelineDatas_2 = timelineDatas; _e < timelineDatas_2.length; _e++) {
              var timelineData = timelineDatas_2[_e];
              switch (timelineData.type) {
               case 40:
                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.AnimationTimelineState);
                timeline.animationState = animationState;
                timeline.init(this._armature, this, timelineData);
                this._animationTimelines.push(timeline);
              }
            }
          }
        };
        AnimationState.prototype._updateBoneAndSlotTimelines = function() {
          var boneTimelines = {};
          for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
            var timeline = _a[_i];
            var timelineName = timeline.bone.name;
            timelineName in boneTimelines || (boneTimelines[timelineName] = []);
            boneTimelines[timelineName].push(timeline);
          }
          for (var _b = 0, _c = this._armature.getBones(); _b < _c.length; _b++) {
            var bone = _c[_b];
            var timelineName = bone.name;
            if (!this.containsBoneMask(timelineName)) continue;
            if (timelineName in boneTimelines) delete boneTimelines[timelineName]; else if (0 === bone._boneData.type) {
              var timelineDatas = this._animationData.getBoneTimelines(timelineName);
              var bonePose = timelineName in this._bonePoses ? this._bonePoses[timelineName] : this._bonePoses[timelineName] = dragonBones.BaseObject.borrowObject(BonePose);
              if (null !== timelineDatas) for (var _d = 0, timelineDatas_3 = timelineDatas; _d < timelineDatas_3.length; _d++) {
                var timelineData = timelineDatas_3[_d];
                switch (timelineData.type) {
                 case 10:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);
                  timeline.bone = bone;
                  timeline.bonePose = bonePose;
                  timeline.init(this._armature, this, timelineData);
                  this._boneTimelines.push(timeline);
                  break;

                 case 11:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneTranslateTimelineState);
                  timeline.bone = bone;
                  timeline.bonePose = bonePose;
                  timeline.init(this._armature, this, timelineData);
                  this._boneTimelines.push(timeline);
                  break;

                 case 12:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneRotateTimelineState);
                  timeline.bone = bone;
                  timeline.bonePose = bonePose;
                  timeline.init(this._armature, this, timelineData);
                  this._boneTimelines.push(timeline);
                  break;

                 case 13:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneScaleTimelineState);
                  timeline.bone = bone;
                  timeline.bonePose = bonePose;
                  timeline.init(this._armature, this, timelineData);
                  this._boneTimelines.push(timeline);
                }
              } else if (this.resetToPose) {
                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneAllTimelineState);
                timeline.bone = bone;
                timeline.bonePose = bonePose;
                timeline.init(this._armature, this, null);
                this._boneTimelines.push(timeline);
                this._poseTimelines.push(timeline);
              }
            } else if (1 === bone._boneData.type) {
              var timelineDatas = this._animationData.getSurfaceTimelines(timelineName);
              if (null !== timelineDatas) for (var _e = 0, timelineDatas_4 = timelineDatas; _e < timelineDatas_4.length; _e++) {
                var timelineData = timelineDatas_4[_e];
                switch (timelineData.type) {
                 case 50:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);
                  timeline.surface = bone;
                  timeline.init(this._armature, this, timelineData);
                  this._surfaceTimelines.push(timeline);
                }
              } else if (this.resetToPose) {
                var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SurfaceTimelineState);
                timeline.surface = bone;
                timeline.init(this._armature, this, null);
                this._surfaceTimelines.push(timeline);
                this._poseTimelines.push(timeline);
              }
            }
          }
          for (var k in boneTimelines) for (var _f = 0, _g = boneTimelines[k]; _f < _g.length; _f++) {
            var timeline = _g[_f];
            this._boneTimelines.splice(this._boneTimelines.indexOf(timeline), 1);
            timeline.returnToPool();
          }
          var slotTimelines = {};
          var ffdFlags = [];
          for (var _h = 0, _j = this._slotTimelines; _h < _j.length; _h++) {
            var timeline = _j[_h];
            var timelineName = timeline.slot.name;
            timelineName in slotTimelines || (slotTimelines[timelineName] = []);
            slotTimelines[timelineName].push(timeline);
          }
          for (var _k = 0, _l = this._armature.getSlots(); _k < _l.length; _k++) {
            var slot = _l[_k];
            var boneName = slot.parent.name;
            if (!this.containsBoneMask(boneName)) continue;
            var timelineName = slot.name;
            var timelineDatas = this._animationData.getSlotTimelines(timelineName);
            if (timelineName in slotTimelines) delete slotTimelines[timelineName]; else {
              var displayIndexFlag = false;
              var colorFlag = false;
              ffdFlags.length = 0;
              if (null !== timelineDatas) for (var _m = 0, timelineDatas_5 = timelineDatas; _m < timelineDatas_5.length; _m++) {
                var timelineData = timelineDatas_5[_m];
                switch (timelineData.type) {
                 case 20:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotDislayTimelineState);
                  timeline.slot = slot;
                  timeline.init(this._armature, this, timelineData);
                  this._slotTimelines.push(timeline);
                  displayIndexFlag = true;
                  break;

                 case 21:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);
                  timeline.slot = slot;
                  timeline.init(this._armature, this, timelineData);
                  this._slotTimelines.push(timeline);
                  colorFlag = true;
                  break;

                 case 22:
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotFFDTimelineState);
                  timeline.slot = slot;
                  timeline.init(this._armature, this, timelineData);
                  this._slotTimelines.push(timeline);
                  ffdFlags.push(timeline.meshOffset);
                }
              }
              if (this.resetToPose) {
                if (!displayIndexFlag) {
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotDislayTimelineState);
                  timeline.slot = slot;
                  timeline.init(this._armature, this, null);
                  this._slotTimelines.push(timeline);
                  this._poseTimelines.push(timeline);
                }
                if (!colorFlag) {
                  var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotColorTimelineState);
                  timeline.slot = slot;
                  timeline.init(this._armature, this, null);
                  this._slotTimelines.push(timeline);
                  this._poseTimelines.push(timeline);
                }
                if (null !== slot.rawDisplayDatas) for (var _o = 0, _p = slot.rawDisplayDatas; _o < _p.length; _o++) {
                  var displayData = _p[_o];
                  if (null !== displayData && 2 === displayData.type) {
                    var meshOffset = displayData.offset;
                    if (ffdFlags.indexOf(meshOffset) < 0) {
                      var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotFFDTimelineState);
                      timeline.meshOffset = meshOffset;
                      timeline.slot = slot;
                      timeline.init(this._armature, this, null);
                      this._slotTimelines.push(timeline);
                      this._poseTimelines.push(timeline);
                    }
                  }
                }
              }
            }
          }
          for (var k in slotTimelines) for (var _q = 0, _r = slotTimelines[k]; _q < _r.length; _q++) {
            var timeline = _r[_q];
            this._slotTimelines.splice(this._slotTimelines.indexOf(timeline), 1);
            timeline.returnToPool();
          }
        };
        AnimationState.prototype._advanceFadeTime = function(passedTime) {
          var isFadeOut = this._fadeState > 0;
          if (this._subFadeState < 0) {
            this._subFadeState = 0;
            var eventType = isFadeOut ? dragonBones.EventObject.FADE_OUT : dragonBones.EventObject.FADE_IN;
            if (this._armature.eventDispatcher.hasDBEventListener(eventType)) {
              var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
              eventObject.type = eventType;
              eventObject.armature = this._armature;
              eventObject.animationState = this;
              this._armature._dragonBones.bufferEvent(eventObject);
            }
          }
          passedTime < 0 && (passedTime = -passedTime);
          this._fadeTime += passedTime;
          if (this._fadeTime >= this.fadeTotalTime) {
            this._subFadeState = 1;
            this._fadeProgress = isFadeOut ? 0 : 1;
          } else this._fadeTime > 0 ? this._fadeProgress = isFadeOut ? 1 - this._fadeTime / this.fadeTotalTime : this._fadeTime / this.fadeTotalTime : this._fadeProgress = isFadeOut ? 1 : 0;
          if (this._subFadeState > 0) {
            if (!isFadeOut) {
              this._playheadState |= 1;
              this._fadeState = 0;
            }
            var eventType = isFadeOut ? dragonBones.EventObject.FADE_OUT_COMPLETE : dragonBones.EventObject.FADE_IN_COMPLETE;
            if (this._armature.eventDispatcher.hasDBEventListener(eventType)) {
              var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
              eventObject.type = eventType;
              eventObject.armature = this._armature;
              eventObject.animationState = this;
              this._armature._dragonBones.bufferEvent(eventObject);
            }
          }
        };
        AnimationState.prototype.init = function(armature, animationData, animationConfig) {
          if (null !== this._armature) return;
          this._armature = armature;
          this._animationData = animationData;
          this.resetToPose = animationConfig.resetToPose;
          this.additiveBlending = animationConfig.additiveBlending;
          this.displayControl = animationConfig.displayControl;
          this.actionEnabled = animationConfig.actionEnabled;
          this.layer = animationConfig.layer;
          this.playTimes = animationConfig.playTimes;
          this.timeScale = animationConfig.timeScale;
          this.fadeTotalTime = animationConfig.fadeInTime;
          this.autoFadeOutTime = animationConfig.autoFadeOutTime;
          this.weight = animationConfig.weight;
          this.name = animationConfig.name.length > 0 ? animationConfig.name : animationConfig.animation;
          this.group = animationConfig.group;
          animationConfig.pauseFadeIn ? this._playheadState = 2 : this._playheadState = 3;
          if (animationConfig.duration < 0) {
            this._position = 0;
            this._duration = this._animationData.duration;
            0 !== animationConfig.position ? this.timeScale >= 0 ? this._time = animationConfig.position : this._time = animationConfig.position - this._duration : this._time = 0;
          } else {
            this._position = animationConfig.position;
            this._duration = animationConfig.duration;
            this._time = 0;
          }
          this.timeScale < 0 && 0 === this._time && (this._time = -1e-6);
          this.fadeTotalTime <= 0 && (this._fadeProgress = .999999);
          if (animationConfig.boneMask.length > 0) {
            this._boneMask.length = animationConfig.boneMask.length;
            for (var i = 0, l = this._boneMask.length; i < l; ++i) this._boneMask[i] = animationConfig.boneMask[i];
          }
          this._actionTimeline = dragonBones.BaseObject.borrowObject(dragonBones.ActionTimelineState);
          this._actionTimeline.init(this._armature, this, this._animationData.actionTimeline);
          this._actionTimeline.currentTime = this._time;
          this._actionTimeline.currentTime < 0 && (this._actionTimeline.currentTime = this._duration - this._actionTimeline.currentTime);
          if (null !== this._animationData.zOrderTimeline) {
            this._zOrderTimeline = dragonBones.BaseObject.borrowObject(dragonBones.ZOrderTimelineState);
            this._zOrderTimeline.init(this._armature, this, this._animationData.zOrderTimeline);
          }
        };
        AnimationState.prototype.advanceTime = function(passedTime, cacheFrameRate) {
          this._blendState.dirty = false;
          0 === this._fadeState && 0 === this._subFadeState || this._advanceFadeTime(passedTime);
          if (3 === this._playheadState) {
            1 !== this.timeScale && (passedTime *= this.timeScale);
            this._time += passedTime;
          }
          if (0 !== this._timelineDirty) {
            2 === this._timelineDirty && this._updateTimelines();
            this._timelineDirty = 0;
            this._updateBoneAndSlotTimelines();
          }
          if (0 === this.weight) return;
          var isCacheEnabled = 0 === this._fadeState && cacheFrameRate > 0;
          var isUpdateTimeline = true;
          var isUpdateBoneTimeline = true;
          var time = this._time;
          this._weightResult = this.weight * this._fadeProgress;
          null !== this._parent && (this._weightResult *= this._parent._weightResult / this._parent._fadeProgress);
          this._actionTimeline.playState <= 0 && this._actionTimeline.update(time);
          if (isCacheEnabled) {
            var internval = 2 * cacheFrameRate;
            this._actionTimeline.currentTime = Math.floor(this._actionTimeline.currentTime * internval) / internval;
          }
          null !== this._zOrderTimeline && this._zOrderTimeline.playState <= 0 && this._zOrderTimeline.update(time);
          if (isCacheEnabled) {
            var cacheFrameIndex = Math.floor(this._actionTimeline.currentTime * cacheFrameRate);
            if (this._armature._cacheFrameIndex === cacheFrameIndex) {
              isUpdateTimeline = false;
              isUpdateBoneTimeline = false;
            } else {
              this._armature._cacheFrameIndex = cacheFrameIndex;
              this._animationData.cachedFrames[cacheFrameIndex] ? isUpdateBoneTimeline = false : this._animationData.cachedFrames[cacheFrameIndex] = true;
            }
          }
          if (isUpdateTimeline) {
            if (isUpdateBoneTimeline) for (var i = 0, l = this._boneTimelines.length; i < l; ++i) {
              var timeline = this._boneTimelines[i];
              timeline.playState <= 0 && timeline.update(time);
              if (i === l - 1 || timeline.bone !== this._boneTimelines[i + 1].bone) {
                var state = timeline.bone._blendState.update(this._weightResult, this.layer);
                0 !== state && timeline.blend(state);
              }
            }
            for (var i = 0, l = this._surfaceTimelines.length; i < l; ++i) {
              var timeline = this._surfaceTimelines[i];
              var state = timeline.surface._blendState.update(this._weightResult, this.layer);
              timeline.playState <= 0 && timeline.update(time);
              0 !== state && timeline.blend(state);
            }
            if (this.displayControl) for (var i = 0, l = this._slotTimelines.length; i < l; ++i) {
              var timeline = this._slotTimelines[i];
              var displayController = timeline.slot.displayController;
              null !== displayController && displayController !== this.name && displayController !== this.group || timeline.playState <= 0 && timeline.update(time);
            }
            for (var i = 0, l = this._constraintTimelines.length; i < l; ++i) {
              var timeline = this._constraintTimelines[i];
              timeline.playState <= 0 && timeline.update(time);
            }
            for (var i = 0, l = this._animationTimelines.length; i < l; ++i) {
              var timeline = this._animationTimelines[i];
              var state = timeline.animationState._blendState.update(this._weightResult, this.layer);
              timeline.playState <= 0 && timeline.update(time);
              0 !== state && timeline.blend(state);
            }
          }
          if (0 === this._fadeState) {
            if (this._subFadeState > 0) {
              this._subFadeState = 0;
              if (this._poseTimelines.length > 0) {
                for (var _i = 0, _a = this._poseTimelines; _i < _a.length; _i++) {
                  var timeline = _a[_i];
                  timeline instanceof dragonBones.BoneTimelineState ? this._boneTimelines.splice(this._boneTimelines.indexOf(timeline), 1) : timeline instanceof dragonBones.SurfaceTimelineState ? this._surfaceTimelines.splice(this._surfaceTimelines.indexOf(timeline), 1) : timeline instanceof dragonBones.SlotTimelineState ? this._slotTimelines.splice(this._slotTimelines.indexOf(timeline), 1) : timeline instanceof dragonBones.ConstraintTimelineState && this._constraintTimelines.splice(this._constraintTimelines.indexOf(timeline), 1);
                  timeline.returnToPool();
                }
                this._poseTimelines.length = 0;
              }
            }
            this._actionTimeline.playState > 0 && this.autoFadeOutTime >= 0 && this.fadeOut(this.autoFadeOutTime);
          }
        };
        AnimationState.prototype.play = function() {
          this._playheadState = 3;
        };
        AnimationState.prototype.stop = function() {
          this._playheadState &= 1;
        };
        AnimationState.prototype.fadeOut = function(fadeOutTime, pausePlayhead) {
          void 0 === pausePlayhead && (pausePlayhead = true);
          fadeOutTime < 0 && (fadeOutTime = 0);
          pausePlayhead && (this._playheadState &= 2);
          if (this._fadeState > 0) {
            if (fadeOutTime > this.fadeTotalTime - this._fadeTime) return;
          } else {
            this._fadeState = 1;
            this._subFadeState = -1;
            (fadeOutTime <= 0 || this._fadeProgress <= 0) && (this._fadeProgress = 1e-6);
            for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
              var timeline = _a[_i];
              timeline.fadeOut();
            }
            for (var _b = 0, _c = this._surfaceTimelines; _b < _c.length; _b++) {
              var timeline = _c[_b];
              timeline.fadeOut();
            }
            for (var _d = 0, _e = this._slotTimelines; _d < _e.length; _d++) {
              var timeline = _e[_d];
              timeline.fadeOut();
            }
            for (var _f = 0, _g = this._constraintTimelines; _f < _g.length; _f++) {
              var timeline = _g[_f];
              timeline.fadeOut();
            }
            for (var _h = 0, _j = this._animationTimelines; _h < _j.length; _h++) {
              var timeline = _j[_h];
              timeline.animationState.fadeOut(fadeOutTime, pausePlayhead);
              timeline.fadeOut();
            }
          }
          this.displayControl = false;
          this.fadeTotalTime = this._fadeProgress > 1e-6 ? fadeOutTime / this._fadeProgress : 0;
          this._fadeTime = this.fadeTotalTime * (1 - this._fadeProgress);
        };
        AnimationState.prototype.containsBoneMask = function(name) {
          return 0 === this._boneMask.length || this._boneMask.indexOf(name) >= 0;
        };
        AnimationState.prototype.addBoneMask = function(name, recursive) {
          void 0 === recursive && (recursive = true);
          var currentBone = this._armature.getBone(name);
          if (null === currentBone) return;
          this._boneMask.indexOf(name) < 0 && this._boneMask.push(name);
          if (recursive) for (var _i = 0, _a = this._armature.getBones(); _i < _a.length; _i++) {
            var bone = _a[_i];
            this._boneMask.indexOf(bone.name) < 0 && currentBone.contains(bone) && this._boneMask.push(bone.name);
          }
          this._timelineDirty = 1;
        };
        AnimationState.prototype.removeBoneMask = function(name, recursive) {
          void 0 === recursive && (recursive = true);
          var index = this._boneMask.indexOf(name);
          index >= 0 && this._boneMask.splice(index, 1);
          if (recursive) {
            var currentBone = this._armature.getBone(name);
            if (null !== currentBone) {
              var bones = this._armature.getBones();
              if (this._boneMask.length > 0) for (var _i = 0, bones_1 = bones; _i < bones_1.length; _i++) {
                var bone = bones_1[_i];
                var index_2 = this._boneMask.indexOf(bone.name);
                index_2 >= 0 && currentBone.contains(bone) && this._boneMask.splice(index_2, 1);
              } else for (var _a = 0, bones_2 = bones; _a < bones_2.length; _a++) {
                var bone = bones_2[_a];
                if (bone === currentBone) continue;
                currentBone.contains(bone) || this._boneMask.push(bone.name);
              }
            }
          }
          this._timelineDirty = 1;
        };
        AnimationState.prototype.removeAllBoneMask = function() {
          this._boneMask.length = 0;
          this._timelineDirty = 1;
        };
        Object.defineProperty(AnimationState.prototype, "isFadeIn", {
          get: function() {
            return this._fadeState < 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isFadeOut", {
          get: function() {
            return this._fadeState > 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isFadeComplete", {
          get: function() {
            return 0 === this._fadeState;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isPlaying", {
          get: function() {
            return 0 !== (2 & this._playheadState) && this._actionTimeline.playState <= 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "isCompleted", {
          get: function() {
            return this._actionTimeline.playState > 0;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentPlayTimes", {
          get: function() {
            return this._actionTimeline.currentPlayTimes;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "totalTime", {
          get: function() {
            return this._duration;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "currentTime", {
          get: function() {
            return this._actionTimeline.currentTime;
          },
          set: function(value) {
            var currentPlayTimes = this._actionTimeline.currentPlayTimes - (this._actionTimeline.playState > 0 ? 1 : 0);
            if (value < 0 || this._duration < value) {
              value = value % this._duration + currentPlayTimes * this._duration;
              value < 0 && (value += this._duration);
            }
            this.playTimes > 0 && currentPlayTimes === this.playTimes - 1 && value === this._duration && (value = this._duration - 1e-6);
            if (this._time === value) return;
            this._time = value;
            this._actionTimeline.setCurrentTime(this._time);
            null !== this._zOrderTimeline && (this._zOrderTimeline.playState = -1);
            for (var _i = 0, _a = this._boneTimelines; _i < _a.length; _i++) {
              var timeline = _a[_i];
              timeline.playState = -1;
            }
            for (var _b = 0, _c = this._slotTimelines; _b < _c.length; _b++) {
              var timeline = _c[_b];
              timeline.playState = -1;
            }
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(AnimationState.prototype, "animationData", {
          get: function() {
            return this._animationData;
          },
          enumerable: true,
          configurable: true
        });
        return AnimationState;
      })(dragonBones.BaseObject);
      dragonBones.AnimationState = AnimationState;
      var BonePose = (function(_super) {
        __extends(BonePose, _super);
        function BonePose() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.current = new dragonBones.Transform();
          _this.delta = new dragonBones.Transform();
          _this.result = new dragonBones.Transform();
          return _this;
        }
        BonePose.toString = function() {
          return "[class dragonBones.BonePose]";
        };
        BonePose.prototype._onClear = function() {
          this.current.identity();
          this.delta.identity();
          this.result.identity();
        };
        return BonePose;
      })(dragonBones.BaseObject);
      dragonBones.BonePose = BonePose;
      var BlendState = (function() {
        function BlendState() {}
        BlendState.prototype.update = function(weight, layer) {
          if (this.dirty) {
            if (!(this.leftWeight > 0)) return 0;
            if (this.layer !== layer) {
              if (this.layerWeight >= this.leftWeight) {
                this.leftWeight = 0;
                return 0;
              }
              this.layer = layer;
              this.leftWeight -= this.layerWeight;
              this.layerWeight = 0;
            }
            weight *= this.leftWeight;
            this.layerWeight += weight;
            this.blendWeight = weight;
            return 1;
          }
          this.dirty = true;
          this.layer = layer;
          this.layerWeight = weight;
          this.leftWeight = 1;
          this.blendWeight = weight;
          return -1;
        };
        BlendState.prototype.clear = function() {
          this.dirty = false;
          this.layer = 0;
          this.leftWeight = 0;
          this.layerWeight = 0;
          this.blendWeight = 0;
        };
        return BlendState;
      })();
      dragonBones.BlendState = BlendState;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var TimelineState = (function(_super) {
        __extends(TimelineState, _super);
        function TimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        TimelineState.prototype._onClear = function() {
          this.playState = -1;
          this.currentPlayTimes = -1;
          this.currentTime = -1;
          this._tweenState = 0;
          this._frameRate = 0;
          this._frameValueOffset = 0;
          this._frameCount = 0;
          this._frameOffset = 0;
          this._frameIndex = -1;
          this._frameRateR = 0;
          this._position = 0;
          this._duration = 0;
          this._timeScale = 1;
          this._timeOffset = 0;
          this._dragonBonesData = null;
          this._animationData = null;
          this._timelineData = null;
          this._armature = null;
          this._animationState = null;
          this._actionTimeline = null;
          this._frameArray = null;
          this._frameIntArray = null;
          this._frameFloatArray = null;
          this._timelineArray = null;
          this._frameIndices = null;
        };
        TimelineState.prototype._setCurrentTime = function(passedTime) {
          var prevState = this.playState;
          var prevPlayTimes = this.currentPlayTimes;
          var prevTime = this.currentTime;
          if (null !== this._actionTimeline && this._frameCount <= 1) {
            this.playState = this._actionTimeline.playState >= 0 ? 1 : -1;
            this.currentPlayTimes = 1;
            this.currentTime = this._actionTimeline.currentTime;
          } else if (null === this._actionTimeline || 1 !== this._timeScale || 0 !== this._timeOffset) {
            var playTimes = this._animationState.playTimes;
            var totalTime = playTimes * this._duration;
            passedTime *= this._timeScale;
            0 !== this._timeOffset && (passedTime += this._timeOffset * this._animationData.duration);
            if (playTimes > 0 && (passedTime >= totalTime || passedTime <= -totalTime)) {
              this.playState <= 0 && 3 === this._animationState._playheadState && (this.playState = 1);
              this.currentPlayTimes = playTimes;
              this.currentTime = passedTime < 0 ? 0 : this._duration + 1e-6;
            } else {
              0 !== this.playState && 3 === this._animationState._playheadState && (this.playState = 0);
              if (passedTime < 0) {
                passedTime = -passedTime;
                this.currentPlayTimes = Math.floor(passedTime / this._duration);
                this.currentTime = this._duration - passedTime % this._duration;
              } else {
                this.currentPlayTimes = Math.floor(passedTime / this._duration);
                this.currentTime = passedTime % this._duration;
              }
            }
            this.currentTime += this._position;
          } else {
            this.playState = this._actionTimeline.playState;
            this.currentPlayTimes = this._actionTimeline.currentPlayTimes;
            this.currentTime = this._actionTimeline.currentTime;
          }
          if (this.currentPlayTimes === prevPlayTimes && this.currentTime === prevTime) return false;
          (prevState < 0 && this.playState !== prevState || this.playState <= 0 && this.currentPlayTimes !== prevPlayTimes) && (this._frameIndex = -1);
          return true;
        };
        TimelineState.prototype.init = function(armature, animationState, timelineData) {
          this._armature = armature;
          this._animationState = animationState;
          this._timelineData = timelineData;
          this._actionTimeline = this._animationState._actionTimeline;
          this === this._actionTimeline && (this._actionTimeline = null);
          this._animationData = this._animationState._animationData;
          this._frameRate = this._animationData.parent.frameRate;
          this._frameRateR = 1 / this._frameRate;
          this._position = this._animationState._position;
          this._duration = this._animationState._duration;
          this._dragonBonesData = this._animationData.parent.parent;
          if (null !== this._timelineData) {
            this._frameIntArray = this._dragonBonesData.frameIntArray;
            this._frameFloatArray = this._dragonBonesData.frameFloatArray;
            this._frameArray = this._dragonBonesData.frameArray;
            this._timelineArray = this._dragonBonesData.timelineArray;
            this._frameIndices = this._dragonBonesData.frameIndices;
            this._frameCount = this._timelineArray[this._timelineData.offset + 2];
            this._frameValueOffset = this._timelineArray[this._timelineData.offset + 4];
            this._timeScale = 100 / this._timelineArray[this._timelineData.offset + 0];
            this._timeOffset = .01 * this._timelineArray[this._timelineData.offset + 1];
          }
        };
        TimelineState.prototype.fadeOut = function() {};
        TimelineState.prototype.update = function(passedTime) {
          if (this._setCurrentTime(passedTime)) {
            if (this._frameCount > 1) {
              var timelineFrameIndex = Math.floor(this.currentTime * this._frameRate);
              var frameIndex = this._frameIndices[this._timelineData.frameIndicesOffset + timelineFrameIndex];
              if (this._frameIndex !== frameIndex) {
                this._frameIndex = frameIndex;
                this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 + this._frameIndex];
                this._onArriveAtFrame();
              }
            } else if (this._frameIndex < 0) {
              this._frameIndex = 0;
              null !== this._timelineData && (this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5]);
              this._onArriveAtFrame();
            }
            0 !== this._tweenState && this._onUpdateFrame();
          }
        };
        return TimelineState;
      })(dragonBones.BaseObject);
      dragonBones.TimelineState = TimelineState;
      var TweenTimelineState = (function(_super) {
        __extends(TweenTimelineState, _super);
        function TweenTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        TweenTimelineState._getEasingValue = function(tweenType, progress, easing) {
          var value = progress;
          switch (tweenType) {
           case 3:
            value = Math.pow(progress, 2);
            break;

           case 4:
            value = 1 - Math.pow(1 - progress, 2);
            break;

           case 5:
            value = .5 * (1 - Math.cos(progress * Math.PI));
          }
          return (value - progress) * easing + progress;
        };
        TweenTimelineState._getEasingCurveValue = function(progress, samples, count, offset) {
          if (progress <= 0) return 0;
          if (progress >= 1) return 1;
          var segmentCount = count + 1;
          var valueIndex = Math.floor(progress * segmentCount);
          var fromValue = 0 === valueIndex ? 0 : samples[offset + valueIndex - 1];
          var toValue = valueIndex === segmentCount - 1 ? 1e4 : samples[offset + valueIndex];
          return 1e-4 * (fromValue + (toValue - fromValue) * (progress * segmentCount - valueIndex));
        };
        TweenTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this._tweenType = 0;
          this._curveCount = 0;
          this._framePosition = 0;
          this._frameDurationR = 0;
          this._tweenProgress = 0;
          this._tweenEasing = 0;
        };
        TweenTimelineState.prototype._onArriveAtFrame = function() {
          if (this._frameCount > 1 && (this._frameIndex !== this._frameCount - 1 || 0 === this._animationState.playTimes || this._animationState.currentPlayTimes < this._animationState.playTimes - 1)) {
            this._tweenType = this._frameArray[this._frameOffset + 1];
            this._tweenState = 0 === this._tweenType ? 1 : 2;
            2 === this._tweenType ? this._curveCount = this._frameArray[this._frameOffset + 2] : 0 !== this._tweenType && 1 !== this._tweenType && (this._tweenEasing = .01 * this._frameArray[this._frameOffset + 2]);
            this._framePosition = this._frameArray[this._frameOffset] * this._frameRateR;
            if (this._frameIndex === this._frameCount - 1) this._frameDurationR = 1 / (this._animationData.duration - this._framePosition); else {
              var nextFrameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 + this._frameIndex + 1];
              var frameDuration = this._frameArray[nextFrameOffset] * this._frameRateR - this._framePosition;
              this._frameDurationR = frameDuration > 0 ? 1 / frameDuration : 0;
            }
          } else this._tweenState = 1;
        };
        TweenTimelineState.prototype._onUpdateFrame = function() {
          if (2 === this._tweenState) {
            this._tweenProgress = (this.currentTime - this._framePosition) * this._frameDurationR;
            2 === this._tweenType ? this._tweenProgress = TweenTimelineState._getEasingCurveValue(this._tweenProgress, this._frameArray, this._curveCount, this._frameOffset + 3) : 1 !== this._tweenType && (this._tweenProgress = TweenTimelineState._getEasingValue(this._tweenType, this._tweenProgress, this._tweenEasing));
          } else this._tweenProgress = 0;
        };
        return TweenTimelineState;
      })(TimelineState);
      dragonBones.TweenTimelineState = TweenTimelineState;
      var BoneTimelineState = (function(_super) {
        __extends(BoneTimelineState, _super);
        function BoneTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        BoneTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.bone = null;
          this.bonePose = null;
        };
        BoneTimelineState.prototype.blend = function(state) {
          var blendWeight = this.bone._blendState.blendWeight;
          var animationPose = this.bone.animationPose;
          var result = this.bonePose.result;
          if (state > 0) {
            animationPose.x += result.x * blendWeight;
            animationPose.y += result.y * blendWeight;
            animationPose.rotation += result.rotation * blendWeight;
            animationPose.skew += result.skew * blendWeight;
            animationPose.scaleX += (result.scaleX - 1) * blendWeight;
            animationPose.scaleY += (result.scaleY - 1) * blendWeight;
          } else if (1 !== blendWeight) {
            animationPose.x = result.x * blendWeight;
            animationPose.y = result.y * blendWeight;
            animationPose.rotation = result.rotation * blendWeight;
            animationPose.skew = result.skew * blendWeight;
            animationPose.scaleX = (result.scaleX - 1) * blendWeight + 1;
            animationPose.scaleY = (result.scaleY - 1) * blendWeight + 1;
          } else {
            animationPose.x = result.x;
            animationPose.y = result.y;
            animationPose.rotation = result.rotation;
            animationPose.skew = result.skew;
            animationPose.scaleX = result.scaleX;
            animationPose.scaleY = result.scaleY;
          }
          0 === this._animationState._fadeState && 0 === this._animationState._subFadeState || (this.bone._transformDirty = true);
        };
        return BoneTimelineState;
      })(TweenTimelineState);
      dragonBones.BoneTimelineState = BoneTimelineState;
      var SlotTimelineState = (function(_super) {
        __extends(SlotTimelineState, _super);
        function SlotTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        SlotTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.slot = null;
        };
        return SlotTimelineState;
      })(TweenTimelineState);
      dragonBones.SlotTimelineState = SlotTimelineState;
      var ConstraintTimelineState = (function(_super) {
        __extends(ConstraintTimelineState, _super);
        function ConstraintTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        ConstraintTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.constraint = null;
        };
        return ConstraintTimelineState;
      })(TweenTimelineState);
      dragonBones.ConstraintTimelineState = ConstraintTimelineState;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var ActionTimelineState = (function(_super) {
        __extends(ActionTimelineState, _super);
        function ActionTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        ActionTimelineState.toString = function() {
          return "[class dragonBones.ActionTimelineState]";
        };
        ActionTimelineState.prototype._onCrossFrame = function(frameIndex) {
          var eventDispatcher = this._armature.eventDispatcher;
          if (this._animationState.actionEnabled) {
            var frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5 + frameIndex];
            var actionCount = this._frameArray[frameOffset + 1];
            var actions = this._animationData.parent.actions;
            for (var i = 0; i < actionCount; ++i) {
              var actionIndex = this._frameArray[frameOffset + 2 + i];
              var action = actions[actionIndex];
              if (0 === action.type) if (null !== action.slot) {
                var slot = this._armature.getSlot(action.slot.name);
                if (null !== slot) {
                  var childArmature = slot.childArmature;
                  null !== childArmature && childArmature._bufferAction(action, true);
                }
              } else if (null !== action.bone) for (var _i = 0, _a = this._armature.getSlots(); _i < _a.length; _i++) {
                var slot = _a[_i];
                var childArmature = slot.childArmature;
                null !== childArmature && slot.parent._boneData === action.bone && childArmature._bufferAction(action, true);
              } else this._armature._bufferAction(action, true); else {
                var eventType = 10 === action.type ? dragonBones.EventObject.FRAME_EVENT : dragonBones.EventObject.SOUND_EVENT;
                if (11 === action.type || eventDispatcher.hasDBEventListener(eventType)) {
                  var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                  eventObject.time = this._frameArray[frameOffset] / this._frameRate;
                  eventObject.type = eventType;
                  eventObject.name = action.name;
                  eventObject.data = action.data;
                  eventObject.armature = this._armature;
                  eventObject.animationState = this._animationState;
                  null !== action.bone && (eventObject.bone = this._armature.getBone(action.bone.name));
                  null !== action.slot && (eventObject.slot = this._armature.getSlot(action.slot.name));
                  this._armature._dragonBones.bufferEvent(eventObject);
                }
              }
            }
          }
        };
        ActionTimelineState.prototype._onArriveAtFrame = function() {};
        ActionTimelineState.prototype._onUpdateFrame = function() {};
        ActionTimelineState.prototype.update = function(passedTime) {
          var prevState = this.playState;
          var prevPlayTimes = this.currentPlayTimes;
          var prevTime = this.currentTime;
          if (this._setCurrentTime(passedTime)) {
            var eventDispatcher = this._armature.eventDispatcher;
            if (prevState < 0) {
              if (this.playState === prevState) return;
              this._animationState.displayControl && this._animationState.resetToPose && this._armature._sortZOrder(null, 0);
              prevPlayTimes = this.currentPlayTimes;
              if (eventDispatcher.hasDBEventListener(dragonBones.EventObject.START)) {
                var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                eventObject.type = dragonBones.EventObject.START;
                eventObject.armature = this._armature;
                eventObject.animationState = this._animationState;
                this._armature._dragonBones.bufferEvent(eventObject);
              }
            }
            var isReverse = this._animationState.timeScale < 0;
            var loopCompleteEvent = null;
            var completeEvent = null;
            if (this.currentPlayTimes !== prevPlayTimes) {
              if (eventDispatcher.hasDBEventListener(dragonBones.EventObject.LOOP_COMPLETE)) {
                loopCompleteEvent = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                loopCompleteEvent.type = dragonBones.EventObject.LOOP_COMPLETE;
                loopCompleteEvent.armature = this._armature;
                loopCompleteEvent.animationState = this._animationState;
              }
              if (this.playState > 0 && eventDispatcher.hasDBEventListener(dragonBones.EventObject.COMPLETE)) {
                completeEvent = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                completeEvent.type = dragonBones.EventObject.COMPLETE;
                completeEvent.armature = this._armature;
                completeEvent.animationState = this._animationState;
              }
            }
            if (this._frameCount > 1) {
              var timelineData = this._timelineData;
              var timelineFrameIndex = Math.floor(this.currentTime * this._frameRate);
              var frameIndex = this._frameIndices[timelineData.frameIndicesOffset + timelineFrameIndex];
              if (this._frameIndex !== frameIndex) {
                var crossedFrameIndex = this._frameIndex;
                this._frameIndex = frameIndex;
                if (null !== this._timelineArray) {
                  this._frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 + this._frameIndex];
                  if (isReverse) {
                    if (crossedFrameIndex < 0) {
                      var prevFrameIndex = Math.floor(prevTime * this._frameRate);
                      crossedFrameIndex = this._frameIndices[timelineData.frameIndicesOffset + prevFrameIndex];
                      this.currentPlayTimes === prevPlayTimes && crossedFrameIndex === frameIndex && (crossedFrameIndex = -1);
                    }
                    while (crossedFrameIndex >= 0) {
                      var frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 + crossedFrameIndex];
                      var framePosition = this._frameArray[frameOffset] / this._frameRate;
                      this._position <= framePosition && framePosition <= this._position + this._duration && this._onCrossFrame(crossedFrameIndex);
                      if (null !== loopCompleteEvent && 0 === crossedFrameIndex) {
                        this._armature._dragonBones.bufferEvent(loopCompleteEvent);
                        loopCompleteEvent = null;
                      }
                      crossedFrameIndex > 0 ? crossedFrameIndex-- : crossedFrameIndex = this._frameCount - 1;
                      if (crossedFrameIndex === frameIndex) break;
                    }
                  } else {
                    if (crossedFrameIndex < 0) {
                      var prevFrameIndex = Math.floor(prevTime * this._frameRate);
                      crossedFrameIndex = this._frameIndices[timelineData.frameIndicesOffset + prevFrameIndex];
                      var frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 + crossedFrameIndex];
                      var framePosition = this._frameArray[frameOffset] / this._frameRate;
                      this.currentPlayTimes === prevPlayTimes && (prevTime <= framePosition ? crossedFrameIndex > 0 ? crossedFrameIndex-- : crossedFrameIndex = this._frameCount - 1 : crossedFrameIndex === frameIndex && (crossedFrameIndex = -1));
                    }
                    while (crossedFrameIndex >= 0) {
                      crossedFrameIndex < this._frameCount - 1 ? crossedFrameIndex++ : crossedFrameIndex = 0;
                      var frameOffset = this._animationData.frameOffset + this._timelineArray[timelineData.offset + 5 + crossedFrameIndex];
                      var framePosition = this._frameArray[frameOffset] / this._frameRate;
                      this._position <= framePosition && framePosition <= this._position + this._duration && this._onCrossFrame(crossedFrameIndex);
                      if (null !== loopCompleteEvent && 0 === crossedFrameIndex) {
                        this._armature._dragonBones.bufferEvent(loopCompleteEvent);
                        loopCompleteEvent = null;
                      }
                      if (crossedFrameIndex === frameIndex) break;
                    }
                  }
                }
              }
            } else if (this._frameIndex < 0) {
              this._frameIndex = 0;
              if (null !== this._timelineData) {
                this._frameOffset = this._animationData.frameOffset + this._timelineArray[this._timelineData.offset + 5];
                var framePosition = this._frameArray[this._frameOffset] / this._frameRate;
                if (this.currentPlayTimes === prevPlayTimes) prevTime <= framePosition && this._onCrossFrame(this._frameIndex); else if (this._position <= framePosition) {
                  if (!isReverse && null !== loopCompleteEvent) {
                    this._armature._dragonBones.bufferEvent(loopCompleteEvent);
                    loopCompleteEvent = null;
                  }
                  this._onCrossFrame(this._frameIndex);
                }
              }
            }
            null !== loopCompleteEvent && this._armature._dragonBones.bufferEvent(loopCompleteEvent);
            null !== completeEvent && this._armature._dragonBones.bufferEvent(completeEvent);
          }
        };
        ActionTimelineState.prototype.setCurrentTime = function(value) {
          this._setCurrentTime(value);
          this._frameIndex = -1;
        };
        return ActionTimelineState;
      })(dragonBones.TimelineState);
      dragonBones.ActionTimelineState = ActionTimelineState;
      var ZOrderTimelineState = (function(_super) {
        __extends(ZOrderTimelineState, _super);
        function ZOrderTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        ZOrderTimelineState.toString = function() {
          return "[class dragonBones.ZOrderTimelineState]";
        };
        ZOrderTimelineState.prototype._onArriveAtFrame = function() {
          if (this.playState >= 0) {
            var count = this._frameArray[this._frameOffset + 1];
            count > 0 ? this._armature._sortZOrder(this._frameArray, this._frameOffset + 2) : this._armature._sortZOrder(null, 0);
          }
        };
        ZOrderTimelineState.prototype._onUpdateFrame = function() {};
        return ZOrderTimelineState;
      })(dragonBones.TimelineState);
      dragonBones.ZOrderTimelineState = ZOrderTimelineState;
      var BoneAllTimelineState = (function(_super) {
        __extends(BoneAllTimelineState, _super);
        function BoneAllTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        BoneAllTimelineState.toString = function() {
          return "[class dragonBones.BoneAllTimelineState]";
        };
        BoneAllTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null !== this._timelineData) {
            var valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset + 6 * this._frameIndex;
            var scale = this._armature._armatureData.scale;
            var frameFloatArray = this._frameFloatArray;
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.x = frameFloatArray[valueOffset++] * scale;
            current.y = frameFloatArray[valueOffset++] * scale;
            current.rotation = frameFloatArray[valueOffset++];
            current.skew = frameFloatArray[valueOffset++];
            current.scaleX = frameFloatArray[valueOffset++];
            current.scaleY = frameFloatArray[valueOffset++];
            if (2 === this._tweenState) {
              this._frameIndex === this._frameCount - 1 && (valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset);
              delta.x = frameFloatArray[valueOffset++] * scale - current.x;
              delta.y = frameFloatArray[valueOffset++] * scale - current.y;
              delta.rotation = frameFloatArray[valueOffset++] - current.rotation;
              delta.skew = frameFloatArray[valueOffset++] - current.skew;
              delta.scaleX = frameFloatArray[valueOffset++] - current.scaleX;
              delta.scaleY = frameFloatArray[valueOffset++] - current.scaleY;
            } else {
              delta.x = 0;
              delta.y = 0;
              delta.rotation = 0;
              delta.skew = 0;
              delta.scaleX = 0;
              delta.scaleY = 0;
            }
          } else {
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.x = 0;
            current.y = 0;
            current.rotation = 0;
            current.skew = 0;
            current.scaleX = 1;
            current.scaleY = 1;
            delta.x = 0;
            delta.y = 0;
            delta.rotation = 0;
            delta.skew = 0;
            delta.scaleX = 0;
            delta.scaleY = 0;
          }
        };
        BoneAllTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          var current = this.bonePose.current;
          var delta = this.bonePose.delta;
          var result = this.bonePose.result;
          this.bone._transformDirty = true;
          2 !== this._tweenState && (this._tweenState = 0);
          result.x = current.x + delta.x * this._tweenProgress;
          result.y = current.y + delta.y * this._tweenProgress;
          result.rotation = current.rotation + delta.rotation * this._tweenProgress;
          result.skew = current.skew + delta.skew * this._tweenProgress;
          result.scaleX = current.scaleX + delta.scaleX * this._tweenProgress;
          result.scaleY = current.scaleY + delta.scaleY * this._tweenProgress;
        };
        BoneAllTimelineState.prototype.fadeOut = function() {
          var result = this.bonePose.result;
          result.rotation = dragonBones.Transform.normalizeRadian(result.rotation);
          result.skew = dragonBones.Transform.normalizeRadian(result.skew);
        };
        return BoneAllTimelineState;
      })(dragonBones.BoneTimelineState);
      dragonBones.BoneAllTimelineState = BoneAllTimelineState;
      var BoneTranslateTimelineState = (function(_super) {
        __extends(BoneTranslateTimelineState, _super);
        function BoneTranslateTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        BoneTranslateTimelineState.toString = function() {
          return "[class dragonBones.BoneTranslateTimelineState]";
        };
        BoneTranslateTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null !== this._timelineData) {
            var valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset + 2 * this._frameIndex;
            var scale = this._armature._armatureData.scale;
            var frameFloatArray = this._frameFloatArray;
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.x = frameFloatArray[valueOffset++] * scale;
            current.y = frameFloatArray[valueOffset++] * scale;
            if (2 === this._tweenState) {
              this._frameIndex === this._frameCount - 1 && (valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset);
              delta.x = frameFloatArray[valueOffset++] * scale - current.x;
              delta.y = frameFloatArray[valueOffset++] * scale - current.y;
            } else {
              delta.x = 0;
              delta.y = 0;
            }
          } else {
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.x = 0;
            current.y = 0;
            delta.x = 0;
            delta.y = 0;
          }
        };
        BoneTranslateTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          var current = this.bonePose.current;
          var delta = this.bonePose.delta;
          var result = this.bonePose.result;
          this.bone._transformDirty = true;
          2 !== this._tweenState && (this._tweenState = 0);
          result.x = current.x + delta.x * this._tweenProgress;
          result.y = current.y + delta.y * this._tweenProgress;
        };
        return BoneTranslateTimelineState;
      })(dragonBones.BoneTimelineState);
      dragonBones.BoneTranslateTimelineState = BoneTranslateTimelineState;
      var BoneRotateTimelineState = (function(_super) {
        __extends(BoneRotateTimelineState, _super);
        function BoneRotateTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        BoneRotateTimelineState.toString = function() {
          return "[class dragonBones.BoneRotateTimelineState]";
        };
        BoneRotateTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null !== this._timelineData) {
            var valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset + 2 * this._frameIndex;
            var frameFloatArray = this._frameFloatArray;
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.rotation = frameFloatArray[valueOffset++];
            current.skew = frameFloatArray[valueOffset++];
            if (2 === this._tweenState) {
              this._frameIndex === this._frameCount - 1 && (valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset);
              delta.rotation = frameFloatArray[valueOffset++] - current.rotation;
              delta.skew = frameFloatArray[valueOffset++] - current.skew;
            } else {
              delta.rotation = 0;
              delta.skew = 0;
            }
          } else {
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.rotation = 0;
            current.skew = 0;
            delta.rotation = 0;
            delta.skew = 0;
          }
        };
        BoneRotateTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          var current = this.bonePose.current;
          var delta = this.bonePose.delta;
          var result = this.bonePose.result;
          this.bone._transformDirty = true;
          2 !== this._tweenState && (this._tweenState = 0);
          result.rotation = current.rotation + delta.rotation * this._tweenProgress;
          result.skew = current.skew + delta.skew * this._tweenProgress;
        };
        BoneRotateTimelineState.prototype.fadeOut = function() {
          var result = this.bonePose.result;
          result.rotation = dragonBones.Transform.normalizeRadian(result.rotation);
          result.skew = dragonBones.Transform.normalizeRadian(result.skew);
        };
        return BoneRotateTimelineState;
      })(dragonBones.BoneTimelineState);
      dragonBones.BoneRotateTimelineState = BoneRotateTimelineState;
      var BoneScaleTimelineState = (function(_super) {
        __extends(BoneScaleTimelineState, _super);
        function BoneScaleTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        BoneScaleTimelineState.toString = function() {
          return "[class dragonBones.BoneScaleTimelineState]";
        };
        BoneScaleTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null !== this._timelineData) {
            var valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset + 2 * this._frameIndex;
            var frameFloatArray = this._frameFloatArray;
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.scaleX = frameFloatArray[valueOffset++];
            current.scaleY = frameFloatArray[valueOffset++];
            if (2 === this._tweenState) {
              this._frameIndex === this._frameCount - 1 && (valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset);
              delta.scaleX = frameFloatArray[valueOffset++] - current.scaleX;
              delta.scaleY = frameFloatArray[valueOffset++] - current.scaleY;
            } else {
              delta.scaleX = 0;
              delta.scaleY = 0;
            }
          } else {
            var current = this.bonePose.current;
            var delta = this.bonePose.delta;
            current.scaleX = 1;
            current.scaleY = 1;
            delta.scaleX = 0;
            delta.scaleY = 0;
          }
        };
        BoneScaleTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          var current = this.bonePose.current;
          var delta = this.bonePose.delta;
          var result = this.bonePose.result;
          this.bone._transformDirty = true;
          2 !== this._tweenState && (this._tweenState = 0);
          result.scaleX = current.scaleX + delta.scaleX * this._tweenProgress;
          result.scaleY = current.scaleY + delta.scaleY * this._tweenProgress;
        };
        return BoneScaleTimelineState;
      })(dragonBones.BoneTimelineState);
      dragonBones.BoneScaleTimelineState = BoneScaleTimelineState;
      var SurfaceTimelineState = (function(_super) {
        __extends(SurfaceTimelineState, _super);
        function SurfaceTimelineState() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._current = [];
          _this._delta = [];
          _this._result = [];
          return _this;
        }
        SurfaceTimelineState.toString = function() {
          return "[class dragonBones.SurfaceTimelineState]";
        };
        SurfaceTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.surface = null;
          this._frameFloatOffset = 0;
          this._valueCount = 0;
          this._deformCount = 0;
          this._valueOffset = 0;
          this._current.length = 0;
          this._delta.length = 0;
          this._result.length = 0;
        };
        SurfaceTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null !== this._timelineData) {
            var valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset + this._frameIndex * this._valueCount;
            var scale = this._armature._armatureData.scale;
            var frameFloatArray = this._frameFloatArray;
            if (2 === this._tweenState) {
              var nextValueOffset = valueOffset + this._valueCount;
              this._frameIndex === this._frameCount - 1 && (nextValueOffset = this._animationData.frameFloatOffset + this._frameValueOffset);
              for (var i = 0; i < this._valueCount; ++i) this._delta[i] = frameFloatArray[nextValueOffset + i] * scale - (this._current[i] = frameFloatArray[valueOffset + i] * scale);
            } else for (var i = 0; i < this._valueCount; ++i) this._current[i] = frameFloatArray[valueOffset + i] * scale;
          } else for (var i = 0; i < this._valueCount; ++i) this._current[i] = 0;
        };
        SurfaceTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          this.surface._transformDirty = true;
          2 !== this._tweenState && (this._tweenState = 0);
          for (var i = 0; i < this._valueCount; ++i) this._result[i] = this._current[i] + this._delta[i] * this._tweenProgress;
        };
        SurfaceTimelineState.prototype.init = function(armature, animationState, timelineData) {
          _super.prototype.init.call(this, armature, animationState, timelineData);
          if (null !== this._timelineData) {
            var frameIntOffset = this._animationData.frameIntOffset + this._timelineArray[this._timelineData.offset + 3];
            this._deformCount = this._frameIntArray[frameIntOffset + 1];
            this._valueCount = this._frameIntArray[frameIntOffset + 2];
            this._valueOffset = this._frameIntArray[frameIntOffset + 3];
            this._frameFloatOffset = this._frameIntArray[frameIntOffset + 4] + this._animationData.frameFloatOffset;
          } else {
            this._deformCount = this.surface._deformVertices.length;
            this._valueCount = this._deformCount;
            this._valueOffset = 0;
            this._frameFloatOffset = 0;
          }
          this._current.length = this._valueCount;
          this._delta.length = this._valueCount;
          this._result.length = this._valueCount;
          for (var i = 0; i < this._valueCount; ++i) this._delta[i] = 0;
        };
        SurfaceTimelineState.prototype.blend = function(state) {
          var blendWeight = this.surface._blendState.blendWeight;
          var result = this.surface._deformVertices;
          for (var i = 0; i < this._deformCount; ++i) {
            var value = 0;
            value = i < this._valueOffset ? this._frameFloatArray[this._frameFloatOffset + i] : i < this._valueOffset + this._valueCount ? this._result[i - this._valueOffset] : this._frameFloatArray[this._frameFloatOffset + i - this._valueCount];
            state > 0 ? result[i] += value * blendWeight : result[i] = 1 !== blendWeight ? value * blendWeight : value;
          }
          0 === this._animationState._fadeState && 0 === this._animationState._subFadeState || (this.surface._transformDirty = true);
        };
        return SurfaceTimelineState;
      })(dragonBones.TweenTimelineState);
      dragonBones.SurfaceTimelineState = SurfaceTimelineState;
      var SlotDislayTimelineState = (function(_super) {
        __extends(SlotDislayTimelineState, _super);
        function SlotDislayTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        SlotDislayTimelineState.toString = function() {
          return "[class dragonBones.SlotDislayTimelineState]";
        };
        SlotDislayTimelineState.prototype._onArriveAtFrame = function() {
          if (this.playState >= 0) {
            var displayIndex = null !== this._timelineData ? this._frameArray[this._frameOffset + 1] : this.slot._slotData.displayIndex;
            this.slot.displayIndex !== displayIndex && this.slot._setDisplayIndex(displayIndex, true);
          }
        };
        return SlotDislayTimelineState;
      })(dragonBones.SlotTimelineState);
      dragonBones.SlotDislayTimelineState = SlotDislayTimelineState;
      var SlotColorTimelineState = (function(_super) {
        __extends(SlotColorTimelineState, _super);
        function SlotColorTimelineState() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._current = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
          _this._delta = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
          _this._result = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
          return _this;
        }
        SlotColorTimelineState.toString = function() {
          return "[class dragonBones.SlotColorTimelineState]";
        };
        SlotColorTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this._dirty = false;
        };
        SlotColorTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null !== this._timelineData) {
            var intArray = this._dragonBonesData.intArray;
            var frameIntArray = this._frameIntArray;
            var valueOffset = this._animationData.frameIntOffset + this._frameValueOffset + 1 * this._frameIndex;
            var colorOffset = frameIntArray[valueOffset];
            colorOffset < 0 && (colorOffset += 65536);
            this._current[0] = intArray[colorOffset++];
            this._current[1] = intArray[colorOffset++];
            this._current[2] = intArray[colorOffset++];
            this._current[3] = intArray[colorOffset++];
            this._current[4] = intArray[colorOffset++];
            this._current[5] = intArray[colorOffset++];
            this._current[6] = intArray[colorOffset++];
            this._current[7] = intArray[colorOffset++];
            if (2 === this._tweenState) {
              colorOffset = this._frameIndex === this._frameCount - 1 ? frameIntArray[this._animationData.frameIntOffset + this._frameValueOffset] : frameIntArray[valueOffset + 1];
              colorOffset < 0 && (colorOffset += 65536);
              this._delta[0] = intArray[colorOffset++] - this._current[0];
              this._delta[1] = intArray[colorOffset++] - this._current[1];
              this._delta[2] = intArray[colorOffset++] - this._current[2];
              this._delta[3] = intArray[colorOffset++] - this._current[3];
              this._delta[4] = intArray[colorOffset++] - this._current[4];
              this._delta[5] = intArray[colorOffset++] - this._current[5];
              this._delta[6] = intArray[colorOffset++] - this._current[6];
              this._delta[7] = intArray[colorOffset++] - this._current[7];
            }
          } else {
            var color = this.slot._slotData.color;
            this._current[0] = 100 * color.alphaMultiplier;
            this._current[1] = 100 * color.redMultiplier;
            this._current[2] = 100 * color.greenMultiplier;
            this._current[3] = 100 * color.blueMultiplier;
            this._current[4] = color.alphaOffset;
            this._current[5] = color.redOffset;
            this._current[6] = color.greenOffset;
            this._current[7] = color.blueOffset;
          }
        };
        SlotColorTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          this._dirty = true;
          2 !== this._tweenState && (this._tweenState = 0);
          this._result[0] = .01 * (this._current[0] + this._delta[0] * this._tweenProgress);
          this._result[1] = .01 * (this._current[1] + this._delta[1] * this._tweenProgress);
          this._result[2] = .01 * (this._current[2] + this._delta[2] * this._tweenProgress);
          this._result[3] = .01 * (this._current[3] + this._delta[3] * this._tweenProgress);
          this._result[4] = this._current[4] + this._delta[4] * this._tweenProgress;
          this._result[5] = this._current[5] + this._delta[5] * this._tweenProgress;
          this._result[6] = this._current[6] + this._delta[6] * this._tweenProgress;
          this._result[7] = this._current[7] + this._delta[7] * this._tweenProgress;
        };
        SlotColorTimelineState.prototype.fadeOut = function() {
          this._tweenState = 0;
          this._dirty = false;
        };
        SlotColorTimelineState.prototype.update = function(passedTime) {
          _super.prototype.update.call(this, passedTime);
          if (0 !== this._tweenState || this._dirty) {
            var result = this.slot._colorTransform;
            if (0 !== this._animationState._fadeState || 0 !== this._animationState._subFadeState) {
              if (result.alphaMultiplier !== this._result[0] || result.redMultiplier !== this._result[1] || result.greenMultiplier !== this._result[2] || result.blueMultiplier !== this._result[3] || result.alphaOffset !== this._result[4] || result.redOffset !== this._result[5] || result.greenOffset !== this._result[6] || result.blueOffset !== this._result[7]) {
                var fadeProgress = Math.pow(this._animationState._fadeProgress, 4);
                result.alphaMultiplier += (this._result[0] - result.alphaMultiplier) * fadeProgress;
                result.redMultiplier += (this._result[1] - result.redMultiplier) * fadeProgress;
                result.greenMultiplier += (this._result[2] - result.greenMultiplier) * fadeProgress;
                result.blueMultiplier += (this._result[3] - result.blueMultiplier) * fadeProgress;
                result.alphaOffset += (this._result[4] - result.alphaOffset) * fadeProgress;
                result.redOffset += (this._result[5] - result.redOffset) * fadeProgress;
                result.greenOffset += (this._result[6] - result.greenOffset) * fadeProgress;
                result.blueOffset += (this._result[7] - result.blueOffset) * fadeProgress;
                this.slot._colorDirty = true;
              }
            } else if (this._dirty) {
              this._dirty = false;
              if (result.alphaMultiplier !== this._result[0] || result.redMultiplier !== this._result[1] || result.greenMultiplier !== this._result[2] || result.blueMultiplier !== this._result[3] || result.alphaOffset !== this._result[4] || result.redOffset !== this._result[5] || result.greenOffset !== this._result[6] || result.blueOffset !== this._result[7]) {
                result.alphaMultiplier = this._result[0];
                result.redMultiplier = this._result[1];
                result.greenMultiplier = this._result[2];
                result.blueMultiplier = this._result[3];
                result.alphaOffset = this._result[4];
                result.redOffset = this._result[5];
                result.greenOffset = this._result[6];
                result.blueOffset = this._result[7];
                this.slot._colorDirty = true;
              }
            }
          }
        };
        return SlotColorTimelineState;
      })(dragonBones.SlotTimelineState);
      dragonBones.SlotColorTimelineState = SlotColorTimelineState;
      var SlotFFDTimelineState = (function(_super) {
        __extends(SlotFFDTimelineState, _super);
        function SlotFFDTimelineState() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._current = [];
          _this._delta = [];
          _this._result = [];
          return _this;
        }
        SlotFFDTimelineState.toString = function() {
          return "[class dragonBones.SlotFFDTimelineState]";
        };
        SlotFFDTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.meshOffset = 0;
          this._dirty = false;
          this._frameFloatOffset = 0;
          this._valueCount = 0;
          this._deformCount = 0;
          this._valueOffset = 0;
          this._current.length = 0;
          this._delta.length = 0;
          this._result.length = 0;
        };
        SlotFFDTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null !== this._timelineData) {
            var valueOffset = this._animationData.frameFloatOffset + this._frameValueOffset + this._frameIndex * this._valueCount;
            var scale = this._armature._armatureData.scale;
            var frameFloatArray = this._frameFloatArray;
            if (2 === this._tweenState) {
              var nextValueOffset = valueOffset + this._valueCount;
              this._frameIndex === this._frameCount - 1 && (nextValueOffset = this._animationData.frameFloatOffset + this._frameValueOffset);
              for (var i = 0; i < this._valueCount; ++i) this._delta[i] = frameFloatArray[nextValueOffset + i] * scale - (this._current[i] = frameFloatArray[valueOffset + i] * scale);
            } else for (var i = 0; i < this._valueCount; ++i) this._current[i] = frameFloatArray[valueOffset + i] * scale;
          } else for (var i = 0; i < this._valueCount; ++i) this._current[i] = 0;
        };
        SlotFFDTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          this._dirty = true;
          2 !== this._tweenState && (this._tweenState = 0);
          for (var i = 0; i < this._valueCount; ++i) this._result[i] = this._current[i] + this._delta[i] * this._tweenProgress;
        };
        SlotFFDTimelineState.prototype.init = function(armature, animationState, timelineData) {
          _super.prototype.init.call(this, armature, animationState, timelineData);
          if (null !== this._timelineData) {
            var frameIntOffset = this._animationData.frameIntOffset + this._timelineArray[this._timelineData.offset + 3];
            this.meshOffset = this._frameIntArray[frameIntOffset + 0];
            this.meshOffset < 0 && (this.meshOffset += 65536);
            this._deformCount = this._frameIntArray[frameIntOffset + 1];
            this._valueCount = this._frameIntArray[frameIntOffset + 2];
            this._valueOffset = this._frameIntArray[frameIntOffset + 3];
            this._frameFloatOffset = this._frameIntArray[frameIntOffset + 4] + this._animationData.frameFloatOffset;
          } else {
            this._deformCount = this.slot._deformVertices.length;
            this._valueCount = this._deformCount;
            this._valueOffset = 0;
            this._frameFloatOffset = 0;
          }
          this._current.length = this._valueCount;
          this._delta.length = this._valueCount;
          this._result.length = this._valueCount;
          for (var i = 0; i < this._valueCount; ++i) this._delta[i] = 0;
        };
        SlotFFDTimelineState.prototype.fadeOut = function() {
          this._tweenState = 0;
          this._dirty = false;
        };
        SlotFFDTimelineState.prototype.update = function(passedTime) {
          if (null === this.slot._meshData || this.slot._meshData.offset !== this.meshOffset) return;
          _super.prototype.update.call(this, passedTime);
          if (0 !== this._tweenState || this._dirty) {
            var result = this.slot._deformVertices;
            if (0 !== this._animationState._fadeState || 0 !== this._animationState._subFadeState) {
              var fadeProgress = Math.pow(this._animationState._fadeProgress, 2);
              for (var i = 0; i < this._deformCount; ++i) i < this._valueOffset ? result[i] += (this._frameFloatArray[this._frameFloatOffset + i] - result[i]) * fadeProgress : i < this._valueOffset + this._valueCount ? result[i] += (this._result[i - this._valueOffset] - result[i]) * fadeProgress : result[i] += (this._frameFloatArray[this._frameFloatOffset + i - this._valueCount] - result[i]) * fadeProgress;
              this.slot._meshDirty = true;
            } else if (this._dirty) {
              this._dirty = false;
              for (var i = 0; i < this._deformCount; ++i) i < this._valueOffset ? result[i] = this._frameFloatArray[this._frameFloatOffset + i] : i < this._valueOffset + this._valueCount ? result[i] = this._result[i - this._valueOffset] : result[i] = this._frameFloatArray[this._frameFloatOffset + i - this._valueCount];
              this.slot._meshDirty = true;
            }
          }
        };
        return SlotFFDTimelineState;
      })(dragonBones.SlotTimelineState);
      dragonBones.SlotFFDTimelineState = SlotFFDTimelineState;
      var IKConstraintTimelineState = (function(_super) {
        __extends(IKConstraintTimelineState, _super);
        function IKConstraintTimelineState() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        IKConstraintTimelineState.toString = function() {
          return "[class dragonBones.IKConstraintTimelineState]";
        };
        IKConstraintTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this._current = 0;
          this._delta = 0;
        };
        IKConstraintTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          var ikConstraint = this.constraint;
          if (null !== this._timelineData) {
            var valueOffset = this._animationData.frameIntOffset + this._frameValueOffset + 2 * this._frameIndex;
            var frameIntArray = this._frameIntArray;
            var bendPositive = 0 !== frameIntArray[valueOffset++];
            this._current = .01 * frameIntArray[valueOffset++];
            if (2 === this._tweenState) {
              this._frameIndex === this._frameCount - 1 && (valueOffset = this._animationData.frameIntOffset + this._frameValueOffset);
              this._delta = .01 * frameIntArray[valueOffset + 1] - this._current;
            } else this._delta = 0;
            ikConstraint._bendPositive = bendPositive;
          } else {
            var ikConstraintData = ikConstraint._constraintData;
            this._current = ikConstraintData.weight;
            this._delta = 0;
            ikConstraint._bendPositive = ikConstraintData.bendPositive;
          }
          ikConstraint.invalidUpdate();
        };
        IKConstraintTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          2 !== this._tweenState && (this._tweenState = 0);
          var ikConstraint = this.constraint;
          ikConstraint._weight = this._current + this._delta * this._tweenProgress;
          ikConstraint.invalidUpdate();
        };
        return IKConstraintTimelineState;
      })(dragonBones.ConstraintTimelineState);
      dragonBones.IKConstraintTimelineState = IKConstraintTimelineState;
      var AnimationTimelineState = (function(_super) {
        __extends(AnimationTimelineState, _super);
        function AnimationTimelineState() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._floats = [ 0, 0, 0, 0, 0, 0 ];
          return _this;
        }
        AnimationTimelineState.toString = function() {
          return "[class dragonBones.AnimationTimelineState]";
        };
        AnimationTimelineState.prototype._onClear = function() {
          _super.prototype._onClear.call(this);
          this.animationState = null;
        };
        AnimationTimelineState.prototype._onArriveAtFrame = function() {
          _super.prototype._onArriveAtFrame.call(this);
          if (null === this._timelineData) return;
          var valueOffset = this._animationData.frameIntOffset + this._frameValueOffset + 2 * this._frameIndex;
          var frameRateR = 1 / this.animationState._animationData.parent.frameRate;
          var frameIntArray = this._frameIntArray;
          this._floats[0] = frameIntArray[valueOffset++] * frameRateR;
          this._floats[3] = .01 * frameIntArray[valueOffset++];
          if (2 === this._tweenState) {
            this._frameIndex === this._frameCount - 1 && (valueOffset = this._animationData.frameIntOffset + this._frameValueOffset);
            this._floats[1] = frameIntArray[valueOffset++] * frameRateR - this._floats[0];
            this._floats[4] = .01 * frameIntArray[valueOffset++] - this._floats[3];
          } else {
            this._floats[1] = 0;
            this._floats[4] = 0;
          }
        };
        AnimationTimelineState.prototype._onUpdateFrame = function() {
          _super.prototype._onUpdateFrame.call(this);
          2 !== this._tweenState && (this._tweenState = 0);
          this._floats[0] >= 0 && (this._floats[2] = this._floats[0] + this._floats[1] * this._tweenProgress);
          this._floats[5] = this._floats[3] + this._floats[4] * this._tweenProgress;
        };
        AnimationTimelineState.prototype.blend = function(state) {
          var animationState = this.animationState;
          var blendWeight = animationState._blendState.blendWeight;
          if (state > 0) {
            animationState.weight += this._floats[5] * blendWeight;
            animationState.currentTime += this._floats[2] * blendWeight;
          } else {
            animationState.weight = this._floats[5] * blendWeight;
            animationState.currentTime = this._floats[2] * blendWeight;
          }
        };
        return AnimationTimelineState;
      })(dragonBones.TweenTimelineState);
      dragonBones.AnimationTimelineState = AnimationTimelineState;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var EventObject = (function(_super) {
        __extends(EventObject, _super);
        function EventObject() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        EventObject.toString = function() {
          return "[class dragonBones.EventObject]";
        };
        EventObject.prototype._onClear = function() {
          this.time = 0;
          this.type = "";
          this.name = "";
          this.armature = null;
          this.bone = null;
          this.slot = null;
          this.animationState = null;
          this.data = null;
        };
        EventObject.START = "start";
        EventObject.LOOP_COMPLETE = "loopComplete";
        EventObject.COMPLETE = "complete";
        EventObject.FADE_IN = "fadeIn";
        EventObject.FADE_IN_COMPLETE = "fadeInComplete";
        EventObject.FADE_OUT = "fadeOut";
        EventObject.FADE_OUT_COMPLETE = "fadeOutComplete";
        EventObject.FRAME_EVENT = "frameEvent";
        EventObject.SOUND_EVENT = "soundEvent";
        return EventObject;
      })(dragonBones.BaseObject);
      dragonBones.EventObject = EventObject;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var DataParser = (function() {
        function DataParser() {}
        DataParser._getArmatureType = function(value) {
          switch (value.toLowerCase()) {
           case "stage":
            return 2;

           case "armature":
            return 0;

           case "movieclip":
            return 1;

           default:
            return 0;
          }
        };
        DataParser._getBoneType = function(value) {
          switch (value.toLowerCase()) {
           case "bone":
            return 0;

           case "surface":
            return 1;

           default:
            return 0;
          }
        };
        DataParser._getDisplayType = function(value) {
          switch (value.toLowerCase()) {
           case "image":
            return 0;

           case "mesh":
            return 2;

           case "armature":
            return 1;

           case "boundingbox":
            return 3;

           default:
            return 0;
          }
        };
        DataParser._getBoundingBoxType = function(value) {
          switch (value.toLowerCase()) {
           case "rectangle":
            return 0;

           case "ellipse":
            return 1;

           case "polygon":
            return 2;

           default:
            return 0;
          }
        };
        DataParser._getActionType = function(value) {
          switch (value.toLowerCase()) {
           case "play":
            return 0;

           case "frame":
            return 10;

           case "sound":
            return 11;

           default:
            return 0;
          }
        };
        DataParser._getBlendMode = function(value) {
          switch (value.toLowerCase()) {
           case "normal":
            return 0;

           case "add":
            return 1;

           case "alpha":
            return 2;

           case "darken":
            return 3;

           case "difference":
            return 4;

           case "erase":
            return 5;

           case "hardlight":
            return 6;

           case "invert":
            return 7;

           case "layer":
            return 8;

           case "lighten":
            return 9;

           case "multiply":
            return 10;

           case "overlay":
            return 11;

           case "screen":
            return 12;

           case "subtract":
            return 13;

           default:
            return 0;
          }
        };
        DataParser.parseDragonBonesData = function(rawData) {
          return rawData instanceof ArrayBuffer ? dragonBones.BinaryDataParser.getInstance().parseDragonBonesData(rawData) : dragonBones.ObjectDataParser.getInstance().parseDragonBonesData(rawData);
        };
        DataParser.parseTextureAtlasData = function(rawData, scale) {
          void 0 === scale && (scale = 1);
          console.warn("\u5df2\u5e9f\u5f03");
          var textureAtlasData = {};
          var subTextureList = rawData[DataParser.SUB_TEXTURE];
          for (var i = 0, len = subTextureList.length; i < len; i++) {
            var subTextureObject = subTextureList[i];
            var subTextureName = subTextureObject[DataParser.NAME];
            var subTextureRegion = new dragonBones.Rectangle();
            var subTextureFrame = null;
            subTextureRegion.x = subTextureObject[DataParser.X] / scale;
            subTextureRegion.y = subTextureObject[DataParser.Y] / scale;
            subTextureRegion.width = subTextureObject[DataParser.WIDTH] / scale;
            subTextureRegion.height = subTextureObject[DataParser.HEIGHT] / scale;
            if (DataParser.FRAME_WIDTH in subTextureObject) {
              subTextureFrame = new dragonBones.Rectangle();
              subTextureFrame.x = subTextureObject[DataParser.FRAME_X] / scale;
              subTextureFrame.y = subTextureObject[DataParser.FRAME_Y] / scale;
              subTextureFrame.width = subTextureObject[DataParser.FRAME_WIDTH] / scale;
              subTextureFrame.height = subTextureObject[DataParser.FRAME_HEIGHT] / scale;
            }
            textureAtlasData[subTextureName] = {
              region: subTextureRegion,
              frame: subTextureFrame,
              rotated: false
            };
          }
          return textureAtlasData;
        };
        DataParser.DATA_VERSION_2_3 = "2.3";
        DataParser.DATA_VERSION_3_0 = "3.0";
        DataParser.DATA_VERSION_4_0 = "4.0";
        DataParser.DATA_VERSION_4_5 = "4.5";
        DataParser.DATA_VERSION_5_0 = "5.0";
        DataParser.DATA_VERSION_5_5 = "5.5";
        DataParser.DATA_VERSION = DataParser.DATA_VERSION_5_5;
        DataParser.DATA_VERSIONS = [ DataParser.DATA_VERSION_4_0, DataParser.DATA_VERSION_4_5, DataParser.DATA_VERSION_5_0, DataParser.DATA_VERSION_5_5 ];
        DataParser.TEXTURE_ATLAS = "textureAtlas";
        DataParser.SUB_TEXTURE = "SubTexture";
        DataParser.FORMAT = "format";
        DataParser.IMAGE_PATH = "imagePath";
        DataParser.WIDTH = "width";
        DataParser.HEIGHT = "height";
        DataParser.ROTATED = "rotated";
        DataParser.FRAME_X = "frameX";
        DataParser.FRAME_Y = "frameY";
        DataParser.FRAME_WIDTH = "frameWidth";
        DataParser.FRAME_HEIGHT = "frameHeight";
        DataParser.DRADON_BONES = "dragonBones";
        DataParser.USER_DATA = "userData";
        DataParser.ARMATURE = "armature";
        DataParser.BONE = "bone";
        DataParser.SURFACE = "surface";
        DataParser.SLOT = "slot";
        DataParser.CONSTRAINT = "constraint";
        DataParser.IK = "ik";
        DataParser.SKIN = "skin";
        DataParser.DISPLAY = "display";
        DataParser.ANIMATION = "animation";
        DataParser.Z_ORDER = "zOrder";
        DataParser.FFD = "ffd";
        DataParser.FRAME = "frame";
        DataParser.TRANSLATE_FRAME = "translateFrame";
        DataParser.ROTATE_FRAME = "rotateFrame";
        DataParser.SCALE_FRAME = "scaleFrame";
        DataParser.DISPLAY_FRAME = "displayFrame";
        DataParser.COLOR_FRAME = "colorFrame";
        DataParser.DEFAULT_ACTIONS = "defaultActions";
        DataParser.ACTIONS = "actions";
        DataParser.EVENTS = "events";
        DataParser.INTS = "ints";
        DataParser.FLOATS = "floats";
        DataParser.STRINGS = "strings";
        DataParser.CANVAS = "canvas";
        DataParser.TRANSFORM = "transform";
        DataParser.PIVOT = "pivot";
        DataParser.AABB = "aabb";
        DataParser.COLOR = "color";
        DataParser.VERSION = "version";
        DataParser.COMPATIBLE_VERSION = "compatibleVersion";
        DataParser.FRAME_RATE = "frameRate";
        DataParser.TYPE = "type";
        DataParser.SUB_TYPE = "subType";
        DataParser.NAME = "name";
        DataParser.PARENT = "parent";
        DataParser.TARGET = "target";
        DataParser.STAGE = "stage";
        DataParser.SHARE = "share";
        DataParser.PATH = "path";
        DataParser.LENGTH = "length";
        DataParser.DISPLAY_INDEX = "displayIndex";
        DataParser.BLEND_MODE = "blendMode";
        DataParser.INHERIT_TRANSLATION = "inheritTranslation";
        DataParser.INHERIT_ROTATION = "inheritRotation";
        DataParser.INHERIT_SCALE = "inheritScale";
        DataParser.INHERIT_REFLECTION = "inheritReflection";
        DataParser.INHERIT_ANIMATION = "inheritAnimation";
        DataParser.INHERIT_DEFORM = "inheritDeform";
        DataParser.SEGMENT_X = "segmentX";
        DataParser.SEGMENT_Y = "segmentY";
        DataParser.BEND_POSITIVE = "bendPositive";
        DataParser.CHAIN = "chain";
        DataParser.WEIGHT = "weight";
        DataParser.FADE_IN_TIME = "fadeInTime";
        DataParser.PLAY_TIMES = "playTimes";
        DataParser.SCALE = "scale";
        DataParser.OFFSET = "offset";
        DataParser.POSITION = "position";
        DataParser.DURATION = "duration";
        DataParser.TWEEN_EASING = "tweenEasing";
        DataParser.TWEEN_ROTATE = "tweenRotate";
        DataParser.TWEEN_SCALE = "tweenScale";
        DataParser.CLOCK_WISE = "clockwise";
        DataParser.CURVE = "curve";
        DataParser.SOUND = "sound";
        DataParser.EVENT = "event";
        DataParser.ACTION = "action";
        DataParser.X = "x";
        DataParser.Y = "y";
        DataParser.SKEW_X = "skX";
        DataParser.SKEW_Y = "skY";
        DataParser.SCALE_X = "scX";
        DataParser.SCALE_Y = "scY";
        DataParser.VALUE = "value";
        DataParser.ROTATE = "rotate";
        DataParser.SKEW = "skew";
        DataParser.ALPHA_OFFSET = "aO";
        DataParser.RED_OFFSET = "rO";
        DataParser.GREEN_OFFSET = "gO";
        DataParser.BLUE_OFFSET = "bO";
        DataParser.ALPHA_MULTIPLIER = "aM";
        DataParser.RED_MULTIPLIER = "rM";
        DataParser.GREEN_MULTIPLIER = "gM";
        DataParser.BLUE_MULTIPLIER = "bM";
        DataParser.UVS = "uvs";
        DataParser.VERTICES = "vertices";
        DataParser.TRIANGLES = "triangles";
        DataParser.WEIGHTS = "weights";
        DataParser.SLOT_POSE = "slotPose";
        DataParser.BONE_POSE = "bonePose";
        DataParser.GLUE_WEIGHTS = "glueWeights";
        DataParser.GLUE_MESHES = "glueMeshes";
        DataParser.GOTO_AND_PLAY = "gotoAndPlay";
        DataParser.DEFAULT_NAME = "default";
        return DataParser;
      })();
      dragonBones.DataParser = DataParser;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var ObjectDataParser = (function(_super) {
        __extends(ObjectDataParser, _super);
        function ObjectDataParser() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this._rawTextureAtlasIndex = 0;
          _this._rawBones = [];
          _this._data = null;
          _this._armature = null;
          _this._bone = null;
          _this._surface = null;
          _this._slot = null;
          _this._skin = null;
          _this._mesh = null;
          _this._animation = null;
          _this._timeline = null;
          _this._rawTextureAtlases = null;
          _this._defaultColorOffset = -1;
          _this._prevClockwise = 0;
          _this._prevRotation = 0;
          _this._helpMatrixA = new dragonBones.Matrix();
          _this._helpMatrixB = new dragonBones.Matrix();
          _this._helpTransform = new dragonBones.Transform();
          _this._helpColorTransform = new dragonBones.ColorTransform();
          _this._helpPoint = new dragonBones.Point();
          _this._helpArray = [];
          _this._intArray = [];
          _this._floatArray = [];
          _this._frameIntArray = [];
          _this._frameFloatArray = [];
          _this._frameArray = [];
          _this._timelineArray = [];
          _this._cacheRawMeshes = [];
          _this._cacheMeshes = [];
          _this._actionFrames = [];
          _this._weightSlotPose = {};
          _this._weightBonePoses = {};
          _this._cacheBones = {};
          _this._slotChildActions = {};
          return _this;
        }
        ObjectDataParser._getBoolean = function(rawData, key, defaultValue) {
          if (key in rawData) {
            var value = rawData[key];
            var type = typeof value;
            if ("boolean" === type) return value;
            if ("string" !== type) return !!value;
            switch (value) {
             case "0":
             case "NaN":
             case "":
             case "false":
             case "null":
             case "undefined":
              return false;

             default:
              return true;
            }
          }
          return defaultValue;
        };
        ObjectDataParser._getNumber = function(rawData, key, defaultValue) {
          if (key in rawData) {
            var value = rawData[key];
            if (null === value || "NaN" === value) return defaultValue;
            return +value || 0;
          }
          return defaultValue;
        };
        ObjectDataParser._getString = function(rawData, key, defaultValue) {
          if (key in rawData) {
            var value = rawData[key];
            var type = typeof value;
            if ("string" === type) {
              if (dragonBones.DragonBones.webAssembly) for (var i = 0, l = value.length; i < l; ++i) if (value.charCodeAt(i) > 255) return encodeURI(value);
              return value;
            }
            return String(value);
          }
          return defaultValue;
        };
        ObjectDataParser.prototype._getCurvePoint = function(x1, y1, x2, y2, x3, y3, x4, y4, t, result) {
          var l_t = 1 - t;
          var powA = l_t * l_t;
          var powB = t * t;
          var kA = l_t * powA;
          var kB = 3 * t * powA;
          var kC = 3 * l_t * powB;
          var kD = t * powB;
          result.x = kA * x1 + kB * x2 + kC * x3 + kD * x4;
          result.y = kA * y1 + kB * y2 + kC * y3 + kD * y4;
        };
        ObjectDataParser.prototype._samplingEasingCurve = function(curve, samples) {
          var curveCount = curve.length;
          var stepIndex = -2;
          for (var i = 0, l = samples.length; i < l; ++i) {
            var t = (i + 1) / (l + 1);
            while ((stepIndex + 6 < curveCount ? curve[stepIndex + 6] : 1) < t) stepIndex += 6;
            var isInCurve = stepIndex >= 0 && stepIndex + 6 < curveCount;
            var x1 = isInCurve ? curve[stepIndex] : 0;
            var y1 = isInCurve ? curve[stepIndex + 1] : 0;
            var x2 = curve[stepIndex + 2];
            var y2 = curve[stepIndex + 3];
            var x3 = curve[stepIndex + 4];
            var y3 = curve[stepIndex + 5];
            var x4 = isInCurve ? curve[stepIndex + 6] : 1;
            var y4 = isInCurve ? curve[stepIndex + 7] : 1;
            var lower = 0;
            var higher = 1;
            while (higher - lower > 1e-4) {
              var percentage = .5 * (higher + lower);
              this._getCurvePoint(x1, y1, x2, y2, x3, y3, x4, y4, percentage, this._helpPoint);
              t - this._helpPoint.x > 0 ? lower = percentage : higher = percentage;
            }
            samples[i] = this._helpPoint.y;
          }
        };
        ObjectDataParser.prototype._parseActionDataInFrame = function(rawData, frameStart, bone, slot) {
          dragonBones.DataParser.EVENT in rawData && this._mergeActionFrame(rawData[dragonBones.DataParser.EVENT], frameStart, 10, bone, slot);
          dragonBones.DataParser.SOUND in rawData && this._mergeActionFrame(rawData[dragonBones.DataParser.SOUND], frameStart, 11, bone, slot);
          dragonBones.DataParser.ACTION in rawData && this._mergeActionFrame(rawData[dragonBones.DataParser.ACTION], frameStart, 0, bone, slot);
          dragonBones.DataParser.EVENTS in rawData && this._mergeActionFrame(rawData[dragonBones.DataParser.EVENTS], frameStart, 10, bone, slot);
          dragonBones.DataParser.ACTIONS in rawData && this._mergeActionFrame(rawData[dragonBones.DataParser.ACTIONS], frameStart, 0, bone, slot);
        };
        ObjectDataParser.prototype._mergeActionFrame = function(rawData, frameStart, type, bone, slot) {
          var actionOffset = dragonBones.DragonBones.webAssembly ? this._armature.actions.size() : this._armature.actions.length;
          var actions = this._parseActionData(rawData, type, bone, slot);
          var frameIndex = 0;
          var frame = null;
          for (var _i = 0, actions_2 = actions; _i < actions_2.length; _i++) {
            var action = actions_2[_i];
            this._armature.addAction(action, false);
          }
          if (0 === this._actionFrames.length) {
            frame = new ActionFrame();
            frame.frameStart = 0;
            this._actionFrames.push(frame);
            frame = null;
          }
          for (var _a = 0, _b = this._actionFrames; _a < _b.length; _a++) {
            var eachFrame = _b[_a];
            if (eachFrame.frameStart === frameStart) {
              frame = eachFrame;
              break;
            }
            if (eachFrame.frameStart > frameStart) break;
            frameIndex++;
          }
          if (null === frame) {
            frame = new ActionFrame();
            frame.frameStart = frameStart;
            this._actionFrames.splice(frameIndex + 1, 0, frame);
          }
          for (var i = 0; i < actions.length; ++i) frame.actions.push(actionOffset + i);
        };
        ObjectDataParser.prototype._parseArmature = function(rawData, scale) {
          var armature = dragonBones.BaseObject.borrowObject(dragonBones.ArmatureData);
          armature.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
          armature.frameRate = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FRAME_RATE, this._data.frameRate);
          armature.scale = scale;
          dragonBones.DataParser.TYPE in rawData && "string" === typeof rawData[dragonBones.DataParser.TYPE] ? armature.type = dragonBones.DataParser._getArmatureType(rawData[dragonBones.DataParser.TYPE]) : armature.type = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TYPE, 0);
          0 === armature.frameRate && (armature.frameRate = 24);
          this._armature = armature;
          if (dragonBones.DataParser.CANVAS in rawData) {
            var rawCanvas = rawData[dragonBones.DataParser.CANVAS];
            var canvas = dragonBones.BaseObject.borrowObject(dragonBones.CanvasData);
            dragonBones.DataParser.COLOR in rawCanvas ? canvas.hasBackground = true : canvas.hasBackground = false;
            canvas.color = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.COLOR, 0);
            canvas.x = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.X, 0) * armature.scale;
            canvas.y = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.Y, 0) * armature.scale;
            canvas.width = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.WIDTH, 0) * armature.scale;
            canvas.height = ObjectDataParser._getNumber(rawCanvas, dragonBones.DataParser.HEIGHT, 0) * armature.scale;
            armature.canvas = canvas;
          }
          if (dragonBones.DataParser.AABB in rawData) {
            var rawAABB = rawData[dragonBones.DataParser.AABB];
            armature.aabb.x = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.X, 0) * armature.scale;
            armature.aabb.y = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.Y, 0) * armature.scale;
            armature.aabb.width = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.WIDTH, 0) * armature.scale;
            armature.aabb.height = ObjectDataParser._getNumber(rawAABB, dragonBones.DataParser.HEIGHT, 0) * armature.scale;
          }
          if (dragonBones.DataParser.BONE in rawData) {
            var rawBones = rawData[dragonBones.DataParser.BONE];
            for (var _i = 0, rawBones_1 = rawBones; _i < rawBones_1.length; _i++) {
              var rawBone = rawBones_1[_i];
              var parentName = ObjectDataParser._getString(rawBone, dragonBones.DataParser.PARENT, "");
              var bone = this._parseBone(rawBone);
              if (parentName.length > 0) {
                var parent_1 = armature.getBone(parentName);
                if (null !== parent_1) bone.parent = parent_1; else {
                  parentName in this._cacheBones || (this._cacheBones[parentName] = []);
                  this._cacheBones[parentName].push(bone);
                }
              }
              if (bone.name in this._cacheBones) {
                for (var _a = 0, _b = this._cacheBones[bone.name]; _a < _b.length; _a++) {
                  var child = _b[_a];
                  child.parent = bone;
                }
                delete this._cacheBones[bone.name];
              }
              armature.addBone(bone);
              this._rawBones.push(bone);
            }
          }
          if (dragonBones.DataParser.IK in rawData) {
            var rawIKS = rawData[dragonBones.DataParser.IK];
            for (var _c = 0, rawIKS_1 = rawIKS; _c < rawIKS_1.length; _c++) {
              var rawIK = rawIKS_1[_c];
              var constraint = this._parseIKConstraint(rawIK);
              constraint && armature.addConstraint(constraint);
            }
          }
          armature.sortBones();
          if (dragonBones.DataParser.SLOT in rawData) {
            var zOrder = 0;
            var rawSlots = rawData[dragonBones.DataParser.SLOT];
            for (var _d = 0, rawSlots_1 = rawSlots; _d < rawSlots_1.length; _d++) {
              var rawSlot = rawSlots_1[_d];
              armature.addSlot(this._parseSlot(rawSlot, zOrder++));
            }
          }
          if (dragonBones.DataParser.SKIN in rawData) {
            var rawSkins = rawData[dragonBones.DataParser.SKIN];
            for (var _e = 0, rawSkins_1 = rawSkins; _e < rawSkins_1.length; _e++) {
              var rawSkin = rawSkins_1[_e];
              armature.addSkin(this._parseSkin(rawSkin));
            }
          }
          for (var i = 0, l = this._cacheRawMeshes.length; i < l; ++i) {
            var rawData_1 = this._cacheRawMeshes[i];
            if (!(dragonBones.DataParser.GLUE_WEIGHTS in rawData_1) || !(dragonBones.DataParser.GLUE_MESHES in rawData_1)) continue;
            this._parseMeshGlue(rawData_1, this._cacheMeshes[i]);
          }
          for (var i = 0, l = this._cacheRawMeshes.length; i < l; ++i) {
            var rawData_2 = this._cacheRawMeshes[i];
            var shareName = ObjectDataParser._getString(rawData_2, dragonBones.DataParser.SHARE, "");
            if (0 === shareName.length) continue;
            var skinName = ObjectDataParser._getString(rawData_2, dragonBones.DataParser.SKIN, dragonBones.DataParser.DEFAULT_NAME);
            0 === skinName.length && (skinName = dragonBones.DataParser.DEFAULT_NAME);
            var shareMesh = armature.getMesh(skinName, "", shareName);
            if (null === shareMesh) continue;
            var mesh = this._cacheMeshes[i];
            mesh.offset = shareMesh.offset;
            mesh.weight = shareMesh.weight;
            mesh.glue = shareMesh.glue;
          }
          if (dragonBones.DataParser.ANIMATION in rawData) {
            var rawAnimations = rawData[dragonBones.DataParser.ANIMATION];
            for (var _f = 0, rawAnimations_1 = rawAnimations; _f < rawAnimations_1.length; _f++) {
              var rawAnimation = rawAnimations_1[_f];
              var animation = this._parseAnimation(rawAnimation);
              armature.addAnimation(animation);
            }
          }
          if (dragonBones.DataParser.DEFAULT_ACTIONS in rawData) {
            var actions = this._parseActionData(rawData[dragonBones.DataParser.DEFAULT_ACTIONS], 0, null, null);
            for (var _g = 0, actions_3 = actions; _g < actions_3.length; _g++) {
              var action = actions_3[_g];
              armature.addAction(action, true);
              if (0 === action.type) {
                var animation = armature.getAnimation(action.name);
                null !== animation && (armature.defaultAnimation = animation);
              }
            }
          }
          if (dragonBones.DataParser.ACTIONS in rawData) {
            var actions = this._parseActionData(rawData[dragonBones.DataParser.ACTIONS], 0, null, null);
            for (var _h = 0, actions_4 = actions; _h < actions_4.length; _h++) {
              var action = actions_4[_h];
              armature.addAction(action, false);
            }
          }
          this._rawBones.length = 0;
          this._cacheRawMeshes.length = 0;
          this._cacheMeshes.length = 0;
          this._armature = null;
          for (var k in this._weightSlotPose) delete this._weightSlotPose[k];
          for (var k in this._weightBonePoses) delete this._weightBonePoses[k];
          for (var k in this._cacheBones) delete this._cacheBones[k];
          for (var k in this._slotChildActions) delete this._slotChildActions[k];
          return armature;
        };
        ObjectDataParser.prototype._parseBone = function(rawData) {
          var type = 0;
          var scale = this._armature.scale;
          type = dragonBones.DataParser.TYPE in rawData && "string" === typeof rawData[dragonBones.DataParser.TYPE] ? dragonBones.DataParser._getBoneType(rawData[dragonBones.DataParser.TYPE]) : ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TYPE, 0);
          if (0 === type) {
            var bone = dragonBones.BaseObject.borrowObject(dragonBones.BoneData);
            bone.inheritTranslation = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_TRANSLATION, true);
            bone.inheritRotation = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_ROTATION, true);
            bone.inheritScale = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_SCALE, true);
            bone.inheritReflection = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_REFLECTION, true);
            bone.length = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.LENGTH, 0) * scale;
            bone.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            dragonBones.DataParser.TRANSFORM in rawData && this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM], bone.transform, scale);
            return bone;
          }
          var surface = dragonBones.BaseObject.borrowObject(dragonBones.SurfaceData);
          surface.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
          surface.segmentX = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SEGMENT_X, 0);
          surface.segmentY = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SEGMENT_Y, 0);
          surface.vertices.length = (surface.segmentX + 1) * (surface.segmentY + 1) * 2;
          if (dragonBones.DataParser.VERTICES in rawData) {
            var rawVertices = rawData[dragonBones.DataParser.VERTICES];
            for (var i = 0, l = surface.vertices.length; i < l; ++i) i < rawVertices.length ? surface.vertices[i] = rawVertices[i] * scale : surface.vertices[i] = 0;
          }
          return surface;
        };
        ObjectDataParser.prototype._parseIKConstraint = function(rawData) {
          var bone = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.BONE, ""));
          if (null === bone) return null;
          var target = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.TARGET, ""));
          if (null === target) return null;
          var constraint = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraintData);
          constraint.scaleEnabled = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.SCALE, false);
          constraint.bendPositive = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.BEND_POSITIVE, true);
          constraint.weight = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WEIGHT, 1);
          constraint.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
          constraint.target = target;
          var chain = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.CHAIN, 0);
          if (chain > 0 && null !== bone.parent) {
            constraint.root = bone.parent;
            constraint.bone = bone;
          } else {
            constraint.root = bone;
            constraint.bone = null;
          }
          return constraint;
        };
        ObjectDataParser.prototype._parseSlot = function(rawData, zOrder) {
          var slot = dragonBones.BaseObject.borrowObject(dragonBones.SlotData);
          slot.displayIndex = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DISPLAY_INDEX, 0);
          slot.zOrder = zOrder;
          slot.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
          slot.parent = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.PARENT, ""));
          dragonBones.DataParser.BLEND_MODE in rawData && "string" === typeof rawData[dragonBones.DataParser.BLEND_MODE] ? slot.blendMode = dragonBones.DataParser._getBlendMode(rawData[dragonBones.DataParser.BLEND_MODE]) : slot.blendMode = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.BLEND_MODE, 0);
          if (dragonBones.DataParser.COLOR in rawData) {
            slot.color = dragonBones.SlotData.createColor();
            this._parseColorTransform(rawData[dragonBones.DataParser.COLOR], slot.color);
          } else slot.color = dragonBones.SlotData.DEFAULT_COLOR;
          dragonBones.DataParser.ACTIONS in rawData && (this._slotChildActions[slot.name] = this._parseActionData(rawData[dragonBones.DataParser.ACTIONS], 0, null, null));
          return slot;
        };
        ObjectDataParser.prototype._parseSkin = function(rawData) {
          var skin = dragonBones.BaseObject.borrowObject(dragonBones.SkinData);
          skin.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, dragonBones.DataParser.DEFAULT_NAME);
          0 === skin.name.length && (skin.name = dragonBones.DataParser.DEFAULT_NAME);
          if (dragonBones.DataParser.SLOT in rawData) {
            var rawSlots = rawData[dragonBones.DataParser.SLOT];
            this._skin = skin;
            for (var _i = 0, rawSlots_2 = rawSlots; _i < rawSlots_2.length; _i++) {
              var rawSlot = rawSlots_2[_i];
              var slotName = ObjectDataParser._getString(rawSlot, dragonBones.DataParser.NAME, "");
              var slot = this._armature.getSlot(slotName);
              if (null !== slot) {
                this._slot = slot;
                if (dragonBones.DataParser.DISPLAY in rawSlot) {
                  var rawDisplays = rawSlot[dragonBones.DataParser.DISPLAY];
                  for (var _a = 0, rawDisplays_1 = rawDisplays; _a < rawDisplays_1.length; _a++) {
                    var rawDisplay = rawDisplays_1[_a];
                    rawDisplay ? skin.addDisplay(slotName, this._parseDisplay(rawDisplay)) : skin.addDisplay(slotName, null);
                  }
                }
                this._slot = null;
              }
            }
            this._skin = null;
          }
          return skin;
        };
        ObjectDataParser.prototype._parseDisplay = function(rawData) {
          var name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
          var path = ObjectDataParser._getString(rawData, dragonBones.DataParser.PATH, "");
          var type = 0;
          var display = null;
          type = dragonBones.DataParser.TYPE in rawData && "string" === typeof rawData[dragonBones.DataParser.TYPE] ? dragonBones.DataParser._getDisplayType(rawData[dragonBones.DataParser.TYPE]) : ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TYPE, type);
          switch (type) {
           case 0:
            var imageDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.ImageDisplayData);
            imageDisplay.name = name;
            imageDisplay.path = path.length > 0 ? path : name;
            this._parsePivot(rawData, imageDisplay);
            break;

           case 1:
            var armatureDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.ArmatureDisplayData);
            armatureDisplay.name = name;
            armatureDisplay.path = path.length > 0 ? path : name;
            armatureDisplay.inheritAnimation = true;
            if (dragonBones.DataParser.ACTIONS in rawData) {
              var actions = this._parseActionData(rawData[dragonBones.DataParser.ACTIONS], 0, null, null);
              for (var _i = 0, actions_5 = actions; _i < actions_5.length; _i++) {
                var action = actions_5[_i];
                armatureDisplay.addAction(action);
              }
            } else if (this._slot.name in this._slotChildActions) {
              var displays = this._skin.getDisplays(this._slot.name);
              if (null === displays ? 0 === this._slot.displayIndex : this._slot.displayIndex === displays.length) {
                for (var _a = 0, _b = this._slotChildActions[this._slot.name]; _a < _b.length; _a++) {
                  var action = _b[_a];
                  armatureDisplay.addAction(action);
                }
                delete this._slotChildActions[this._slot.name];
              }
            }
            break;

           case 2:
            var meshDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.MeshDisplayData);
            meshDisplay.inheritDeform = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.INHERIT_DEFORM, true);
            meshDisplay.name = name;
            meshDisplay.path = path.length > 0 ? path : name;
            if (dragonBones.DataParser.SHARE in rawData) {
              this._cacheRawMeshes.push(rawData);
              this._cacheRawMeshes.push(meshDisplay);
            } else this._parseMesh(rawData, meshDisplay);
            if (dragonBones.DataParser.GLUE_WEIGHTS in rawData && dragonBones.DataParser.GLUE_MESHES in rawData) {
              this._cacheRawMeshes.push(rawData);
              this._cacheRawMeshes.push(meshDisplay);
            }
            break;

           case 3:
            var boundingBox = this._parseBoundingBox(rawData);
            if (null !== boundingBox) {
              var boundingBoxDisplay = display = dragonBones.BaseObject.borrowObject(dragonBones.BoundingBoxDisplayData);
              boundingBoxDisplay.name = name;
              boundingBoxDisplay.path = path.length > 0 ? path : name;
              boundingBoxDisplay.boundingBox = boundingBox;
            }
          }
          null !== display && dragonBones.DataParser.TRANSFORM in rawData && this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM], display.transform, this._armature.scale);
          return display;
        };
        ObjectDataParser.prototype._parsePivot = function(rawData, display) {
          if (dragonBones.DataParser.PIVOT in rawData) {
            var rawPivot = rawData[dragonBones.DataParser.PIVOT];
            display.pivot.x = ObjectDataParser._getNumber(rawPivot, dragonBones.DataParser.X, 0);
            display.pivot.y = ObjectDataParser._getNumber(rawPivot, dragonBones.DataParser.Y, 0);
          } else {
            display.pivot.x = .5;
            display.pivot.y = .5;
          }
        };
        ObjectDataParser.prototype._parseMesh = function(rawData, mesh) {
          var rawVertices = rawData[dragonBones.DataParser.VERTICES];
          var rawUVs = rawData[dragonBones.DataParser.UVS];
          var rawTriangles = rawData[dragonBones.DataParser.TRIANGLES];
          var vertexCount = Math.floor(rawVertices.length / 2);
          var triangleCount = Math.floor(rawTriangles.length / 3);
          var vertexOffset = this._floatArray.length;
          var uvOffset = vertexOffset + 2 * vertexCount;
          var meshOffset = this._intArray.length;
          var meshName = this._skin.name + "_" + this._slot.name + "_" + mesh.name;
          mesh.offset = meshOffset;
          this._intArray.length += 4 + 3 * triangleCount;
          this._intArray[meshOffset + 0] = vertexCount;
          this._intArray[meshOffset + 1] = triangleCount;
          this._intArray[meshOffset + 2] = vertexOffset;
          for (var i = 0, l = 3 * triangleCount; i < l; ++i) this._intArray[meshOffset + 4 + i] = rawTriangles[i];
          this._floatArray.length += 2 * vertexCount + 2 * vertexCount;
          for (var i = 0, l = 2 * vertexCount; i < l; ++i) {
            this._floatArray[vertexOffset + i] = rawVertices[i];
            this._floatArray[uvOffset + i] = rawUVs[i];
          }
          if (dragonBones.DataParser.WEIGHTS in rawData) {
            var rawWeights = rawData[dragonBones.DataParser.WEIGHTS];
            var rawSlotPose = rawData[dragonBones.DataParser.SLOT_POSE];
            var rawBonePoses = rawData[dragonBones.DataParser.BONE_POSE];
            var sortedBones = this._armature.sortedBones;
            var weightBoneIndices = new Array();
            var weightBoneCount = Math.floor(rawBonePoses.length / 7);
            var floatOffset = this._floatArray.length;
            var weightCount = Math.floor(rawWeights.length - vertexCount) / 2;
            var weightOffset = this._intArray.length;
            var weight = dragonBones.BaseObject.borrowObject(dragonBones.WeightData);
            weight.count = weightCount;
            weight.offset = weightOffset;
            weightBoneIndices.length = weightBoneCount;
            this._intArray.length += 2 + weightBoneCount + vertexCount + weightCount;
            this._intArray[weightOffset + 1] = floatOffset;
            for (var i = 0; i < weightBoneCount; ++i) {
              var rawBoneIndex = rawBonePoses[7 * i];
              var bone = this._rawBones[rawBoneIndex];
              weight.addBone(bone);
              weightBoneIndices[i] = rawBoneIndex;
              this._intArray[weightOffset + 2 + i] = sortedBones.indexOf(bone);
            }
            this._floatArray.length += 3 * weightCount;
            this._helpMatrixA.copyFromArray(rawSlotPose, 0);
            for (var i = 0, iW = 0, iB = weightOffset + 2 + weightBoneCount, iV = floatOffset; i < vertexCount; ++i) {
              var iD = 2 * i;
              var vertexBoneCount = this._intArray[iB++] = rawWeights[iW++];
              var x = this._floatArray[vertexOffset + iD];
              var y = this._floatArray[vertexOffset + iD + 1];
              this._helpMatrixA.transformPoint(x, y, this._helpPoint);
              x = this._helpPoint.x;
              y = this._helpPoint.y;
              for (var j = 0; j < vertexBoneCount; ++j) {
                var rawBoneIndex = rawWeights[iW++];
                var boneIndex = weightBoneIndices.indexOf(rawBoneIndex);
                this._helpMatrixB.copyFromArray(rawBonePoses, 7 * boneIndex + 1);
                this._helpMatrixB.invert();
                this._helpMatrixB.transformPoint(x, y, this._helpPoint);
                this._intArray[iB++] = boneIndex;
                this._floatArray[iV++] = rawWeights[iW++];
                this._floatArray[iV++] = this._helpPoint.x;
                this._floatArray[iV++] = this._helpPoint.y;
              }
            }
            mesh.weight = weight;
            this._weightSlotPose[meshName] = rawSlotPose;
            this._weightBonePoses[meshName] = rawBonePoses;
          }
        };
        ObjectDataParser.prototype._parseMeshGlue = function(rawData, mesh) {
          var rawWeights = rawData[dragonBones.DataParser.GLUE_WEIGHTS];
          var rawMeshes = rawData[dragonBones.DataParser.GLUE_MESHES];
          mesh.glue = dragonBones.BaseObject.borrowObject(dragonBones.GlueData);
          mesh.glue.weights.length = rawWeights.length;
          for (var i = 0, l = rawWeights.length; i < l; ++i) mesh.glue.weights[i] = rawWeights[i];
          for (var i = 0, l = rawMeshes.length; i < l; i += 3) {
            var glueMesh = this._armature.getMesh(rawMeshes[i], rawMeshes[i + 1], rawMeshes[i + 2]);
            mesh.glue.addMesh(glueMesh);
          }
        };
        ObjectDataParser.prototype._parseBoundingBox = function(rawData) {
          var boundingBox = null;
          var type = 0;
          type = dragonBones.DataParser.SUB_TYPE in rawData && "string" === typeof rawData[dragonBones.DataParser.SUB_TYPE] ? dragonBones.DataParser._getBoundingBoxType(rawData[dragonBones.DataParser.SUB_TYPE]) : ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SUB_TYPE, type);
          switch (type) {
           case 0:
            boundingBox = dragonBones.BaseObject.borrowObject(dragonBones.RectangleBoundingBoxData);
            break;

           case 1:
            boundingBox = dragonBones.BaseObject.borrowObject(dragonBones.EllipseBoundingBoxData);
            break;

           case 2:
            boundingBox = this._parsePolygonBoundingBox(rawData);
          }
          if (null !== boundingBox) {
            boundingBox.color = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.COLOR, 0);
            if (0 === boundingBox.type || 1 === boundingBox.type) {
              boundingBox.width = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WIDTH, 0);
              boundingBox.height = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.HEIGHT, 0);
            }
          }
          return boundingBox;
        };
        ObjectDataParser.prototype._parsePolygonBoundingBox = function(rawData) {
          var polygonBoundingBox = dragonBones.BaseObject.borrowObject(dragonBones.PolygonBoundingBoxData);
          if (dragonBones.DataParser.VERTICES in rawData) {
            var scale = this._armature.scale;
            var rawVertices = rawData[dragonBones.DataParser.VERTICES];
            var vertices = polygonBoundingBox.vertices;
            dragonBones.DragonBones.webAssembly ? vertices.resize(rawVertices.length, 0) : vertices.length = rawVertices.length;
            for (var i = 0, l = rawVertices.length; i < l; i += 2) {
              var x = rawVertices[i] * scale;
              var y = rawVertices[i + 1] * scale;
              if (dragonBones.DragonBones.webAssembly) {
                vertices.set(i, x);
                vertices.set(i + 1, y);
              } else {
                vertices[i] = x;
                vertices[i + 1] = y;
              }
              if (0 === i) {
                polygonBoundingBox.x = x;
                polygonBoundingBox.y = y;
                polygonBoundingBox.width = x;
                polygonBoundingBox.height = y;
              } else {
                x < polygonBoundingBox.x ? polygonBoundingBox.x = x : x > polygonBoundingBox.width && (polygonBoundingBox.width = x);
                y < polygonBoundingBox.y ? polygonBoundingBox.y = y : y > polygonBoundingBox.height && (polygonBoundingBox.height = y);
              }
            }
            polygonBoundingBox.width -= polygonBoundingBox.x;
            polygonBoundingBox.height -= polygonBoundingBox.y;
          } else console.warn("Data error.\n Please reexport DragonBones Data to fixed the bug.");
          return polygonBoundingBox;
        };
        ObjectDataParser.prototype._parseAnimation = function(rawData) {
          var animation = dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);
          animation.frameCount = Math.max(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DURATION, 1), 1);
          animation.playTimes = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.PLAY_TIMES, 1);
          animation.duration = animation.frameCount / this._armature.frameRate;
          animation.fadeInTime = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FADE_IN_TIME, 0);
          animation.scale = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1);
          animation.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, dragonBones.DataParser.DEFAULT_NAME);
          0 === animation.name.length && (animation.name = dragonBones.DataParser.DEFAULT_NAME);
          animation.frameIntOffset = this._frameIntArray.length;
          animation.frameFloatOffset = this._frameFloatArray.length;
          animation.frameOffset = this._frameArray.length;
          this._animation = animation;
          if (dragonBones.DataParser.FRAME in rawData) {
            var rawFrames = rawData[dragonBones.DataParser.FRAME];
            var keyFrameCount = rawFrames.length;
            if (keyFrameCount > 0) for (var i = 0, frameStart = 0; i < keyFrameCount; ++i) {
              var rawFrame = rawFrames[i];
              this._parseActionDataInFrame(rawFrame, frameStart, null, null);
              frameStart += ObjectDataParser._getNumber(rawFrame, dragonBones.DataParser.DURATION, 1);
            }
          }
          dragonBones.DataParser.Z_ORDER in rawData && (this._animation.zOrderTimeline = this._parseTimeline(rawData[dragonBones.DataParser.Z_ORDER], null, dragonBones.DataParser.FRAME, 1, false, false, 0, this._parseZOrderFrame));
          if (dragonBones.DataParser.BONE in rawData) {
            var rawTimelines = rawData[dragonBones.DataParser.BONE];
            for (var _i = 0, rawTimelines_1 = rawTimelines; _i < rawTimelines_1.length; _i++) {
              var rawTimeline = rawTimelines_1[_i];
              this._parseBoneTimeline(rawTimeline);
            }
          }
          if (dragonBones.DataParser.SURFACE in rawData) {
            var rawTimelines = rawData[dragonBones.DataParser.SURFACE];
            for (var _a = 0, rawTimelines_2 = rawTimelines; _a < rawTimelines_2.length; _a++) {
              var rawTimeline = rawTimelines_2[_a];
              var surfaceName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
              this._surface = this._armature.getBone(surfaceName);
              if (null === this._surface) continue;
              var timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, 50, false, true, 0, this._parseSurfaceFrame);
              null !== timeline && this._animation.addSurfaceTimeline(this._surface, timeline);
              this._surface = null;
            }
          }
          if (dragonBones.DataParser.SLOT in rawData) {
            var rawTimelines = rawData[dragonBones.DataParser.SLOT];
            for (var _b = 0, rawTimelines_3 = rawTimelines; _b < rawTimelines_3.length; _b++) {
              var rawTimeline = rawTimelines_3[_b];
              this._parseSlotTimeline(rawTimeline);
            }
          }
          if (dragonBones.DataParser.FFD in rawData) {
            var rawTimelines = rawData[dragonBones.DataParser.FFD];
            for (var _c = 0, rawTimelines_4 = rawTimelines; _c < rawTimelines_4.length; _c++) {
              var rawTimeline = rawTimelines_4[_c];
              var skinName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.SKIN, dragonBones.DataParser.DEFAULT_NAME);
              var slotName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.SLOT, "");
              var displayName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
              0 === skinName.length && (skinName = dragonBones.DataParser.DEFAULT_NAME);
              this._slot = this._armature.getSlot(slotName);
              this._mesh = this._armature.getMesh(skinName, slotName, displayName);
              if (null === this._slot || null === this._mesh) continue;
              var timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, 22, false, true, 0, this._parseSlotFFDFrame);
              null !== timeline && this._animation.addSlotTimeline(this._slot, timeline);
              this._slot = null;
              this._mesh = null;
            }
          }
          if (dragonBones.DataParser.IK in rawData) {
            var rawTimelines = rawData[dragonBones.DataParser.IK];
            for (var _d = 0, rawTimelines_5 = rawTimelines; _d < rawTimelines_5.length; _d++) {
              var rawTimeline = rawTimelines_5[_d];
              var constraintName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
              var constraint = this._armature.getConstraint(constraintName);
              if (null === constraint) continue;
              var timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, 30, true, false, 2, this._parseIKConstraintFrame);
              null !== timeline && this._animation.addConstraintTimeline(constraint, timeline);
            }
          }
          if (dragonBones.DataParser.ANIMATION in rawData) {
            var rawTimelines = rawData[dragonBones.DataParser.ANIMATION];
            for (var _e = 0, rawTimelines_6 = rawTimelines; _e < rawTimelines_6.length; _e++) {
              var rawTimeline = rawTimelines_6[_e];
              var animationName = ObjectDataParser._getString(rawTimeline, dragonBones.DataParser.NAME, "");
              var timeline = this._parseTimeline(rawTimeline, null, dragonBones.DataParser.FRAME, 40, true, false, 2, this._parseAnimationFrame);
              null !== timeline && this._animation.addAnimationTimeline(animationName, timeline);
            }
          }
          if (this._actionFrames.length > 0) {
            this._animation.actionTimeline = this._parseTimeline(null, this._actionFrames, "", 0, false, false, 0, this._parseActionFrame);
            this._actionFrames.length = 0;
          }
          this._animation = null;
          return animation;
        };
        ObjectDataParser.prototype._parseTimeline = function(rawData, rawFrames, framesKey, type, addIntOffset, addFloatOffset, frameValueCount, frameParser) {
          null !== rawData && framesKey.length > 0 && framesKey in rawData && (rawFrames = rawData[framesKey]);
          if (null === rawFrames) return null;
          var keyFrameCount = rawFrames.length;
          if (0 === keyFrameCount) return null;
          var frameIntArrayLength = this._frameIntArray.length;
          var frameFloatArrayLength = this._frameFloatArray.length;
          var timeline = dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);
          var timelineOffset = this._timelineArray.length;
          this._timelineArray.length += 5 + keyFrameCount;
          if (null !== rawData) {
            this._timelineArray[timelineOffset + 0] = Math.round(100 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1));
            this._timelineArray[timelineOffset + 1] = Math.round(100 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.OFFSET, 0));
          } else {
            this._timelineArray[timelineOffset + 0] = 100;
            this._timelineArray[timelineOffset + 1] = 0;
          }
          this._timelineArray[timelineOffset + 2] = keyFrameCount;
          this._timelineArray[timelineOffset + 3] = frameValueCount;
          this._timelineArray[timelineOffset + 4] = addIntOffset ? frameIntArrayLength - this._animation.frameIntOffset : addFloatOffset ? frameFloatArrayLength - this._animation.frameFloatOffset : 0;
          this._timeline = timeline;
          timeline.type = type;
          timeline.offset = timelineOffset;
          if (1 === keyFrameCount) {
            timeline.frameIndicesOffset = -1;
            this._timelineArray[timelineOffset + 5 + 0] = frameParser.call(this, rawFrames[0], 0, 0) - this._animation.frameOffset;
          } else {
            var totalFrameCount = this._animation.frameCount + 1;
            var frameIndices = this._data.frameIndices;
            var frameIndicesOffset = 0;
            if (dragonBones.DragonBones.webAssembly) {
              frameIndicesOffset = frameIndices.size();
              frameIndices.resize(frameIndicesOffset + totalFrameCount, 0);
            } else {
              frameIndicesOffset = frameIndices.length;
              frameIndices.length += totalFrameCount;
            }
            timeline.frameIndicesOffset = frameIndicesOffset;
            for (var i = 0, iK = 0, frameStart = 0, frameCount = 0; i < totalFrameCount; ++i) {
              if (frameStart + frameCount <= i && iK < keyFrameCount) {
                var rawFrame = rawFrames[iK];
                frameStart = i;
                frameCount = iK === keyFrameCount - 1 ? this._animation.frameCount - frameStart : rawFrame instanceof ActionFrame ? this._actionFrames[iK + 1].frameStart - frameStart : ObjectDataParser._getNumber(rawFrame, dragonBones.DataParser.DURATION, 1);
                this._timelineArray[timelineOffset + 5 + iK] = frameParser.call(this, rawFrame, frameStart, frameCount) - this._animation.frameOffset;
                iK++;
              }
              dragonBones.DragonBones.webAssembly ? frameIndices.set(frameIndicesOffset + i, iK - 1) : frameIndices[frameIndicesOffset + i] = iK - 1;
            }
          }
          this._timeline = null;
          return timeline;
        };
        ObjectDataParser.prototype._parseBoneTimeline = function(rawData) {
          var bone = this._armature.getBone(ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, ""));
          if (null === bone) return;
          this._bone = bone;
          this._slot = this._armature.getSlot(this._bone.name);
          if (dragonBones.DataParser.TRANSLATE_FRAME in rawData) {
            var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.TRANSLATE_FRAME, 11, false, true, 2, this._parseBoneTranslateFrame);
            null !== timeline && this._animation.addBoneTimeline(bone, timeline);
          }
          if (dragonBones.DataParser.ROTATE_FRAME in rawData) {
            var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.ROTATE_FRAME, 12, false, true, 2, this._parseBoneRotateFrame);
            null !== timeline && this._animation.addBoneTimeline(bone, timeline);
          }
          if (dragonBones.DataParser.SCALE_FRAME in rawData) {
            var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.SCALE_FRAME, 13, false, true, 2, this._parseBoneScaleFrame);
            null !== timeline && this._animation.addBoneTimeline(bone, timeline);
          }
          if (dragonBones.DataParser.FRAME in rawData) {
            var timeline = this._parseTimeline(rawData, null, dragonBones.DataParser.FRAME, 10, false, true, 6, this._parseBoneAllFrame);
            null !== timeline && this._animation.addBoneTimeline(bone, timeline);
          }
          this._bone = null;
          this._slot = null;
        };
        ObjectDataParser.prototype._parseSlotTimeline = function(rawData) {
          var slot = this._armature.getSlot(ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, ""));
          if (null === slot) return;
          this._slot = slot;
          var displayTimeline = null;
          displayTimeline = dragonBones.DataParser.DISPLAY_FRAME in rawData ? this._parseTimeline(rawData, null, dragonBones.DataParser.DISPLAY_FRAME, 20, false, false, 0, this._parseSlotDisplayFrame) : this._parseTimeline(rawData, null, dragonBones.DataParser.FRAME, 20, false, false, 0, this._parseSlotDisplayFrame);
          null !== displayTimeline && this._animation.addSlotTimeline(slot, displayTimeline);
          var colorTimeline = null;
          colorTimeline = dragonBones.DataParser.COLOR_FRAME in rawData ? this._parseTimeline(rawData, null, dragonBones.DataParser.COLOR_FRAME, 21, true, false, 1, this._parseSlotColorFrame) : this._parseTimeline(rawData, null, dragonBones.DataParser.FRAME, 21, true, false, 1, this._parseSlotColorFrame);
          null !== colorTimeline && this._animation.addSlotTimeline(slot, colorTimeline);
          this._slot = null;
        };
        ObjectDataParser.prototype._parseFrame = function(rawData, frameStart, frameCount) {
          rawData;
          frameCount;
          var frameOffset = this._frameArray.length;
          this._frameArray.length += 1;
          this._frameArray[frameOffset + 0] = frameStart;
          return frameOffset;
        };
        ObjectDataParser.prototype._parseTweenFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseFrame(rawData, frameStart, frameCount);
          if (frameCount > 0) if (dragonBones.DataParser.CURVE in rawData) {
            var sampleCount = frameCount + 1;
            this._helpArray.length = sampleCount;
            this._samplingEasingCurve(rawData[dragonBones.DataParser.CURVE], this._helpArray);
            this._frameArray.length += 2 + this._helpArray.length;
            this._frameArray[frameOffset + 1] = 2;
            this._frameArray[frameOffset + 2] = sampleCount;
            for (var i = 0; i < sampleCount; ++i) this._frameArray[frameOffset + 3 + i] = Math.round(1e4 * this._helpArray[i]);
          } else {
            var noTween = -2;
            var tweenEasing = noTween;
            dragonBones.DataParser.TWEEN_EASING in rawData && (tweenEasing = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TWEEN_EASING, noTween));
            if (tweenEasing === noTween) {
              this._frameArray.length += 1;
              this._frameArray[frameOffset + 1] = 0;
            } else if (0 === tweenEasing) {
              this._frameArray.length += 1;
              this._frameArray[frameOffset + 1] = 1;
            } else if (tweenEasing < 0) {
              this._frameArray.length += 2;
              this._frameArray[frameOffset + 1] = 3;
              this._frameArray[frameOffset + 2] = Math.round(100 * -tweenEasing);
            } else if (tweenEasing <= 1) {
              this._frameArray.length += 2;
              this._frameArray[frameOffset + 1] = 4;
              this._frameArray[frameOffset + 2] = Math.round(100 * tweenEasing);
            } else {
              this._frameArray.length += 2;
              this._frameArray[frameOffset + 1] = 5;
              this._frameArray[frameOffset + 2] = Math.round(100 * tweenEasing - 100);
            }
          } else {
            this._frameArray.length += 1;
            this._frameArray[frameOffset + 1] = 0;
          }
          return frameOffset;
        };
        ObjectDataParser.prototype._parseActionFrame = function(frame, frameStart, frameCount) {
          frameCount;
          var frameOffset = this._frameArray.length;
          var actionCount = frame.actions.length;
          this._frameArray.length += 2 + actionCount;
          this._frameArray[frameOffset + 0] = frameStart;
          this._frameArray[frameOffset + 0 + 1] = actionCount;
          for (var i = 0; i < actionCount; ++i) this._frameArray[frameOffset + 0 + 2 + i] = frame.actions[i];
          return frameOffset;
        };
        ObjectDataParser.prototype._parseZOrderFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseFrame(rawData, frameStart, frameCount);
          if (dragonBones.DataParser.Z_ORDER in rawData) {
            var rawZOrder = rawData[dragonBones.DataParser.Z_ORDER];
            if (rawZOrder.length > 0) {
              var slotCount = this._armature.sortedSlots.length;
              var unchanged = new Array(slotCount - rawZOrder.length / 2);
              var zOrders = new Array(slotCount);
              for (var i_1 = 0; i_1 < unchanged.length; ++i_1) unchanged[i_1] = 0;
              for (var i_2 = 0; i_2 < slotCount; ++i_2) zOrders[i_2] = -1;
              var originalIndex = 0;
              var unchangedIndex = 0;
              for (var i_3 = 0, l = rawZOrder.length; i_3 < l; i_3 += 2) {
                var slotIndex = rawZOrder[i_3];
                var zOrderOffset = rawZOrder[i_3 + 1];
                while (originalIndex !== slotIndex) unchanged[unchangedIndex++] = originalIndex++;
                var index = originalIndex + zOrderOffset;
                zOrders[index] = originalIndex++;
              }
              while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;
              this._frameArray.length += 1 + slotCount;
              this._frameArray[frameOffset + 1] = slotCount;
              var i = slotCount;
              while (i--) -1 === zOrders[i] ? this._frameArray[frameOffset + 2 + i] = unchanged[--unchangedIndex] || 0 : this._frameArray[frameOffset + 2 + i] = zOrders[i] || 0;
              return frameOffset;
            }
          }
          this._frameArray.length += 1;
          this._frameArray[frameOffset + 1] = 0;
          return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneAllFrame = function(rawData, frameStart, frameCount) {
          this._helpTransform.identity();
          dragonBones.DataParser.TRANSFORM in rawData && this._parseTransform(rawData[dragonBones.DataParser.TRANSFORM], this._helpTransform, 1);
          var rotation = this._helpTransform.rotation;
          if (0 !== frameStart) if (0 === this._prevClockwise) rotation = this._prevRotation + dragonBones.Transform.normalizeRadian(rotation - this._prevRotation); else {
            (this._prevClockwise > 0 ? rotation >= this._prevRotation : rotation <= this._prevRotation) && (this._prevClockwise = this._prevClockwise > 0 ? this._prevClockwise - 1 : this._prevClockwise + 1);
            rotation = this._prevRotation + rotation - this._prevRotation + dragonBones.Transform.PI_D * this._prevClockwise;
          }
          this._prevClockwise = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.TWEEN_ROTATE, 0);
          this._prevRotation = rotation;
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var frameFloatOffset = this._frameFloatArray.length;
          this._frameFloatArray.length += 6;
          this._frameFloatArray[frameFloatOffset++] = this._helpTransform.x;
          this._frameFloatArray[frameFloatOffset++] = this._helpTransform.y;
          this._frameFloatArray[frameFloatOffset++] = rotation;
          this._frameFloatArray[frameFloatOffset++] = this._helpTransform.skew;
          this._frameFloatArray[frameFloatOffset++] = this._helpTransform.scaleX;
          this._frameFloatArray[frameFloatOffset++] = this._helpTransform.scaleY;
          this._parseActionDataInFrame(rawData, frameStart, this._bone, this._slot);
          return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneTranslateFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var frameFloatOffset = this._frameFloatArray.length;
          this._frameFloatArray.length += 2;
          this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, 0);
          this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, 0);
          return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneRotateFrame = function(rawData, frameStart, frameCount) {
          var rotation = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ROTATE, 0) * dragonBones.Transform.DEG_RAD;
          if (0 !== frameStart) if (0 === this._prevClockwise) rotation = this._prevRotation + dragonBones.Transform.normalizeRadian(rotation - this._prevRotation); else {
            (this._prevClockwise > 0 ? rotation >= this._prevRotation : rotation <= this._prevRotation) && (this._prevClockwise = this._prevClockwise > 0 ? this._prevClockwise - 1 : this._prevClockwise + 1);
            rotation = this._prevRotation + rotation - this._prevRotation + dragonBones.Transform.PI_D * this._prevClockwise;
          }
          this._prevClockwise = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.CLOCK_WISE, 0);
          this._prevRotation = rotation;
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var frameFloatOffset = this._frameFloatArray.length;
          this._frameFloatArray.length += 2;
          this._frameFloatArray[frameFloatOffset++] = rotation;
          this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW, 0) * dragonBones.Transform.DEG_RAD;
          return frameOffset;
        };
        ObjectDataParser.prototype._parseBoneScaleFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var frameFloatOffset = this._frameFloatArray.length;
          this._frameFloatArray.length += 2;
          this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, 1);
          this._frameFloatArray[frameFloatOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, 1);
          return frameOffset;
        };
        ObjectDataParser.prototype._parseSurfaceFrame = function(rawData, frameStart, frameCount) {
          var frameFloatOffset = this._frameFloatArray.length;
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var rawVertices = rawData[dragonBones.DataParser.VERTICES];
          var offset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.OFFSET, 0);
          var vertexCount = this._surface.vertices.length / 2;
          var x = 0;
          var y = 0;
          this._frameFloatArray.length += 2 * vertexCount;
          for (var i = 0; i < 2 * vertexCount; i += 2) {
            x = i < offset || i - offset >= rawVertices.length ? 0 : rawVertices[i - offset];
            y = i + 1 < offset || i + 1 - offset >= rawVertices.length ? 0 : rawVertices[i + 1 - offset];
            this._frameFloatArray[frameFloatOffset + i] = x;
            this._frameFloatArray[frameFloatOffset + i + 1] = y;
          }
          if (0 === frameStart) {
            var frameIntOffset = this._frameIntArray.length;
            this._frameIntArray.length += 5;
            this._frameIntArray[frameIntOffset + 0] = 0;
            this._frameIntArray[frameIntOffset + 1] = this._frameFloatArray.length - frameFloatOffset;
            this._frameIntArray[frameIntOffset + 2] = this._frameFloatArray.length - frameFloatOffset;
            this._frameIntArray[frameIntOffset + 3] = 0;
            this._frameIntArray[frameIntOffset + 4] = frameFloatOffset - this._animation.frameFloatOffset;
            this._timelineArray[this._timeline.offset + 3] = frameIntOffset - this._animation.frameIntOffset;
          }
          return frameOffset;
        };
        ObjectDataParser.prototype._parseSlotDisplayFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseFrame(rawData, frameStart, frameCount);
          this._frameArray.length += 1;
          dragonBones.DataParser.VALUE in rawData ? this._frameArray[frameOffset + 1] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.VALUE, 0) : this._frameArray[frameOffset + 1] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DISPLAY_INDEX, 0);
          this._parseActionDataInFrame(rawData, frameStart, this._slot.parent, this._slot);
          return frameOffset;
        };
        ObjectDataParser.prototype._parseSlotColorFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var colorOffset = -1;
          if (dragonBones.DataParser.VALUE in rawData || dragonBones.DataParser.COLOR in rawData) {
            var rawColor = dragonBones.DataParser.VALUE in rawData ? rawData[dragonBones.DataParser.VALUE] : rawData[dragonBones.DataParser.COLOR];
            for (var k in rawColor) {
              k;
              this._parseColorTransform(rawColor, this._helpColorTransform);
              colorOffset = this._intArray.length;
              this._intArray.length += 8;
              this._intArray[colorOffset++] = Math.round(100 * this._helpColorTransform.alphaMultiplier);
              this._intArray[colorOffset++] = Math.round(100 * this._helpColorTransform.redMultiplier);
              this._intArray[colorOffset++] = Math.round(100 * this._helpColorTransform.greenMultiplier);
              this._intArray[colorOffset++] = Math.round(100 * this._helpColorTransform.blueMultiplier);
              this._intArray[colorOffset++] = Math.round(this._helpColorTransform.alphaOffset);
              this._intArray[colorOffset++] = Math.round(this._helpColorTransform.redOffset);
              this._intArray[colorOffset++] = Math.round(this._helpColorTransform.greenOffset);
              this._intArray[colorOffset++] = Math.round(this._helpColorTransform.blueOffset);
              colorOffset -= 8;
              break;
            }
          }
          if (colorOffset < 0) {
            if (this._defaultColorOffset < 0) {
              this._defaultColorOffset = colorOffset = this._intArray.length;
              this._intArray.length += 8;
              this._intArray[colorOffset++] = 100;
              this._intArray[colorOffset++] = 100;
              this._intArray[colorOffset++] = 100;
              this._intArray[colorOffset++] = 100;
              this._intArray[colorOffset++] = 0;
              this._intArray[colorOffset++] = 0;
              this._intArray[colorOffset++] = 0;
              this._intArray[colorOffset++] = 0;
            }
            colorOffset = this._defaultColorOffset;
          }
          var frameIntOffset = this._frameIntArray.length;
          this._frameIntArray.length += 1;
          this._frameIntArray[frameIntOffset] = colorOffset;
          return frameOffset;
        };
        ObjectDataParser.prototype._parseSlotFFDFrame = function(rawData, frameStart, frameCount) {
          var frameFloatOffset = this._frameFloatArray.length;
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var rawVertices = dragonBones.DataParser.VERTICES in rawData ? rawData[dragonBones.DataParser.VERTICES] : null;
          var offset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.OFFSET, 0);
          var vertexCount = this._intArray[this._mesh.offset + 0];
          var meshName = this._mesh.parent.name + "_" + this._slot.name + "_" + this._mesh.name;
          var x = 0;
          var y = 0;
          var iB = 0;
          var iV = 0;
          if (null !== this._mesh.weight) {
            var rawSlotPose = this._weightSlotPose[meshName];
            this._helpMatrixA.copyFromArray(rawSlotPose, 0);
            this._frameFloatArray.length += 2 * this._mesh.weight.count;
            iB = this._mesh.weight.offset + 2 + this._mesh.weight.bones.length;
          } else this._frameFloatArray.length += 2 * vertexCount;
          for (var i = 0; i < 2 * vertexCount; i += 2) {
            if (null === rawVertices) {
              x = 0;
              y = 0;
            } else {
              x = i < offset || i - offset >= rawVertices.length ? 0 : rawVertices[i - offset];
              y = i + 1 < offset || i + 1 - offset >= rawVertices.length ? 0 : rawVertices[i + 1 - offset];
            }
            if (null !== this._mesh.weight) {
              var rawBonePoses = this._weightBonePoses[meshName];
              var vertexBoneCount = this._intArray[iB++];
              this._helpMatrixA.transformPoint(x, y, this._helpPoint, true);
              x = this._helpPoint.x;
              y = this._helpPoint.y;
              for (var j = 0; j < vertexBoneCount; ++j) {
                var boneIndex = this._intArray[iB++];
                this._helpMatrixB.copyFromArray(rawBonePoses, 7 * boneIndex + 1);
                this._helpMatrixB.invert();
                this._helpMatrixB.transformPoint(x, y, this._helpPoint, true);
                this._frameFloatArray[frameFloatOffset + iV++] = this._helpPoint.x;
                this._frameFloatArray[frameFloatOffset + iV++] = this._helpPoint.y;
              }
            } else {
              this._frameFloatArray[frameFloatOffset + i] = x;
              this._frameFloatArray[frameFloatOffset + i + 1] = y;
            }
          }
          if (0 === frameStart) {
            var frameIntOffset = this._frameIntArray.length;
            this._frameIntArray.length += 5;
            this._frameIntArray[frameIntOffset + 0] = this._mesh.offset;
            this._frameIntArray[frameIntOffset + 1] = this._frameFloatArray.length - frameFloatOffset;
            this._frameIntArray[frameIntOffset + 2] = this._frameFloatArray.length - frameFloatOffset;
            this._frameIntArray[frameIntOffset + 3] = 0;
            this._frameIntArray[frameIntOffset + 4] = frameFloatOffset - this._animation.frameFloatOffset;
            this._timelineArray[this._timeline.offset + 3] = frameIntOffset - this._animation.frameIntOffset;
          }
          return frameOffset;
        };
        ObjectDataParser.prototype._parseIKConstraintFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var frameIntOffset = this._frameIntArray.length;
          this._frameIntArray.length += 2;
          this._frameIntArray[frameIntOffset++] = ObjectDataParser._getBoolean(rawData, dragonBones.DataParser.BEND_POSITIVE, true) ? 1 : 0;
          this._frameIntArray[frameIntOffset++] = Math.round(100 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WEIGHT, 1));
          return frameOffset;
        };
        ObjectDataParser.prototype._parseAnimationFrame = function(rawData, frameStart, frameCount) {
          var frameOffset = this._parseTweenFrame(rawData, frameStart, frameCount);
          var frameIntOffset = this._frameIntArray.length;
          this._frameIntArray.length += 2;
          this._frameIntArray[frameIntOffset++] = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.VALUE, 0);
          this._frameIntArray[frameIntOffset++] = Math.round(100 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WEIGHT, 1));
          return frameOffset;
        };
        ObjectDataParser.prototype._parseActionData = function(rawData, type, bone, slot) {
          var actions = new Array();
          if ("string" === typeof rawData) {
            var action = dragonBones.BaseObject.borrowObject(dragonBones.ActionData);
            action.type = type;
            action.name = rawData;
            action.bone = bone;
            action.slot = slot;
            actions.push(action);
          } else if (rawData instanceof Array) for (var _i = 0, rawData_3 = rawData; _i < rawData_3.length; _i++) {
            var rawAction = rawData_3[_i];
            var action = dragonBones.BaseObject.borrowObject(dragonBones.ActionData);
            if (dragonBones.DataParser.GOTO_AND_PLAY in rawAction) {
              action.type = 0;
              action.name = ObjectDataParser._getString(rawAction, dragonBones.DataParser.GOTO_AND_PLAY, "");
            } else {
              dragonBones.DataParser.TYPE in rawAction && "string" === typeof rawAction[dragonBones.DataParser.TYPE] ? action.type = dragonBones.DataParser._getActionType(rawAction[dragonBones.DataParser.TYPE]) : action.type = ObjectDataParser._getNumber(rawAction, dragonBones.DataParser.TYPE, type);
              action.name = ObjectDataParser._getString(rawAction, dragonBones.DataParser.NAME, "");
            }
            if (dragonBones.DataParser.BONE in rawAction) {
              var boneName = ObjectDataParser._getString(rawAction, dragonBones.DataParser.BONE, "");
              action.bone = this._armature.getBone(boneName);
            } else action.bone = bone;
            if (dragonBones.DataParser.SLOT in rawAction) {
              var slotName = ObjectDataParser._getString(rawAction, dragonBones.DataParser.SLOT, "");
              action.slot = this._armature.getSlot(slotName);
            } else action.slot = slot;
            var userData = null;
            if (dragonBones.DataParser.INTS in rawAction) {
              null === userData && (userData = dragonBones.BaseObject.borrowObject(dragonBones.UserData));
              var rawInts = rawAction[dragonBones.DataParser.INTS];
              for (var _a = 0, rawInts_1 = rawInts; _a < rawInts_1.length; _a++) {
                var rawValue = rawInts_1[_a];
                userData.addInt(rawValue);
              }
            }
            if (dragonBones.DataParser.FLOATS in rawAction) {
              null === userData && (userData = dragonBones.BaseObject.borrowObject(dragonBones.UserData));
              var rawFloats = rawAction[dragonBones.DataParser.FLOATS];
              for (var _b = 0, rawFloats_1 = rawFloats; _b < rawFloats_1.length; _b++) {
                var rawValue = rawFloats_1[_b];
                userData.addFloat(rawValue);
              }
            }
            if (dragonBones.DataParser.STRINGS in rawAction) {
              null === userData && (userData = dragonBones.BaseObject.borrowObject(dragonBones.UserData));
              var rawStrings = rawAction[dragonBones.DataParser.STRINGS];
              for (var _c = 0, rawStrings_1 = rawStrings; _c < rawStrings_1.length; _c++) {
                var rawValue = rawStrings_1[_c];
                userData.addString(rawValue);
              }
            }
            action.data = userData;
            actions.push(action);
          }
          return actions;
        };
        ObjectDataParser.prototype._parseTransform = function(rawData, transform, scale) {
          transform.x = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.X, 0) * scale;
          transform.y = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.Y, 0) * scale;
          if (dragonBones.DataParser.ROTATE in rawData || dragonBones.DataParser.SKEW in rawData) {
            transform.rotation = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ROTATE, 0) * dragonBones.Transform.DEG_RAD);
            transform.skew = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW, 0) * dragonBones.Transform.DEG_RAD);
          } else if (dragonBones.DataParser.SKEW_X in rawData || dragonBones.DataParser.SKEW_Y in rawData) {
            transform.rotation = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW_Y, 0) * dragonBones.Transform.DEG_RAD);
            transform.skew = dragonBones.Transform.normalizeRadian(ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SKEW_X, 0) * dragonBones.Transform.DEG_RAD) - transform.rotation;
          }
          transform.scaleX = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE_X, 1);
          transform.scaleY = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE_Y, 1);
        };
        ObjectDataParser.prototype._parseColorTransform = function(rawData, color) {
          color.alphaMultiplier = .01 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ALPHA_MULTIPLIER, 100);
          color.redMultiplier = .01 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.RED_MULTIPLIER, 100);
          color.greenMultiplier = .01 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.GREEN_MULTIPLIER, 100);
          color.blueMultiplier = .01 * ObjectDataParser._getNumber(rawData, dragonBones.DataParser.BLUE_MULTIPLIER, 100);
          color.alphaOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.ALPHA_OFFSET, 0);
          color.redOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.RED_OFFSET, 0);
          color.greenOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.GREEN_OFFSET, 0);
          color.blueOffset = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.BLUE_OFFSET, 0);
        };
        ObjectDataParser.prototype._parseArray = function(rawData) {
          rawData;
          this._intArray.length = 0;
          this._floatArray.length = 0;
          this._frameIntArray.length = 0;
          this._frameFloatArray.length = 0;
          this._frameArray.length = 0;
          this._timelineArray.length = 0;
        };
        ObjectDataParser.prototype._modifyArray = function() {
          this._intArray.length % Int16Array.BYTES_PER_ELEMENT !== 0 && this._intArray.push(0);
          this._frameIntArray.length % Int16Array.BYTES_PER_ELEMENT !== 0 && this._frameIntArray.push(0);
          this._frameArray.length % Int16Array.BYTES_PER_ELEMENT !== 0 && this._frameArray.push(0);
          this._timelineArray.length % Uint16Array.BYTES_PER_ELEMENT !== 0 && this._timelineArray.push(0);
          var l1 = this._intArray.length * Int16Array.BYTES_PER_ELEMENT;
          var l2 = this._floatArray.length * Float32Array.BYTES_PER_ELEMENT;
          var l3 = this._frameIntArray.length * Int16Array.BYTES_PER_ELEMENT;
          var l4 = this._frameFloatArray.length * Float32Array.BYTES_PER_ELEMENT;
          var l5 = this._frameArray.length * Int16Array.BYTES_PER_ELEMENT;
          var l6 = this._timelineArray.length * Uint16Array.BYTES_PER_ELEMENT;
          var lTotal = l1 + l2 + l3 + l4 + l5 + l6;
          if (dragonBones.DragonBones.webAssembly) {
            var shareBuffer = dragonBones.webAssemblyModule.HEAP16.buffer;
            var bufferPointer = dragonBones.webAssemblyModule._malloc(lTotal);
            var intArray = new Int16Array(shareBuffer, bufferPointer, this._intArray.length);
            var floatArray = new Float32Array(shareBuffer, bufferPointer + l1, this._floatArray.length);
            var frameIntArray = new Int16Array(shareBuffer, bufferPointer + l1 + l2, this._frameIntArray.length);
            var frameFloatArray = new Float32Array(shareBuffer, bufferPointer + l1 + l2 + l3, this._frameFloatArray.length);
            var frameArray = new Int16Array(shareBuffer, bufferPointer + l1 + l2 + l3 + l4, this._frameArray.length);
            var timelineArray = new Uint16Array(shareBuffer, bufferPointer + l1 + l2 + l3 + l4 + l5, this._timelineArray.length);
            for (var i = 0, l = this._intArray.length; i < l; ++i) intArray[i] = this._intArray[i];
            for (var i = 0, l = this._floatArray.length; i < l; ++i) floatArray[i] = this._floatArray[i];
            for (var i = 0, l = this._frameIntArray.length; i < l; ++i) frameIntArray[i] = this._frameIntArray[i];
            for (var i = 0, l = this._frameFloatArray.length; i < l; ++i) frameFloatArray[i] = this._frameFloatArray[i];
            for (var i = 0, l = this._frameArray.length; i < l; ++i) frameArray[i] = this._frameArray[i];
            for (var i = 0, l = this._timelineArray.length; i < l; ++i) timelineArray[i] = this._timelineArray[i];
            dragonBones.webAssemblyModule.setDataBinary(this._data, bufferPointer, l1, l2, l3, l4, l5, l6);
          } else {
            var binary = new ArrayBuffer(lTotal);
            var intArray = new Int16Array(binary, 0, this._intArray.length);
            var floatArray = new Float32Array(binary, l1, this._floatArray.length);
            var frameIntArray = new Int16Array(binary, l1 + l2, this._frameIntArray.length);
            var frameFloatArray = new Float32Array(binary, l1 + l2 + l3, this._frameFloatArray.length);
            var frameArray = new Int16Array(binary, l1 + l2 + l3 + l4, this._frameArray.length);
            var timelineArray = new Uint16Array(binary, l1 + l2 + l3 + l4 + l5, this._timelineArray.length);
            for (var i = 0, l = this._intArray.length; i < l; ++i) intArray[i] = this._intArray[i];
            for (var i = 0, l = this._floatArray.length; i < l; ++i) floatArray[i] = this._floatArray[i];
            for (var i = 0, l = this._frameIntArray.length; i < l; ++i) frameIntArray[i] = this._frameIntArray[i];
            for (var i = 0, l = this._frameFloatArray.length; i < l; ++i) frameFloatArray[i] = this._frameFloatArray[i];
            for (var i = 0, l = this._frameArray.length; i < l; ++i) frameArray[i] = this._frameArray[i];
            for (var i = 0, l = this._timelineArray.length; i < l; ++i) timelineArray[i] = this._timelineArray[i];
            this._data.binary = binary;
            this._data.intArray = intArray;
            this._data.floatArray = floatArray;
            this._data.frameIntArray = frameIntArray;
            this._data.frameFloatArray = frameFloatArray;
            this._data.frameArray = frameArray;
            this._data.timelineArray = timelineArray;
          }
          this._defaultColorOffset = -1;
        };
        ObjectDataParser.prototype.parseDragonBonesData = function(rawData, scale) {
          void 0 === scale && (scale = 1);
          console.assert(null !== rawData && void 0 !== rawData, "Data error.");
          var version = ObjectDataParser._getString(rawData, dragonBones.DataParser.VERSION, "");
          var compatibleVersion = ObjectDataParser._getString(rawData, dragonBones.DataParser.COMPATIBLE_VERSION, "");
          if (dragonBones.DataParser.DATA_VERSIONS.indexOf(version) >= 0 || dragonBones.DataParser.DATA_VERSIONS.indexOf(compatibleVersion) >= 0) {
            var data = dragonBones.BaseObject.borrowObject(dragonBones.DragonBonesData);
            data.version = version;
            data.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
            data.frameRate = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FRAME_RATE, 24);
            0 === data.frameRate && (data.frameRate = 24);
            if (dragonBones.DataParser.ARMATURE in rawData) {
              this._data = data;
              this._parseArray(rawData);
              var rawArmatures = rawData[dragonBones.DataParser.ARMATURE];
              for (var _i = 0, rawArmatures_1 = rawArmatures; _i < rawArmatures_1.length; _i++) {
                var rawArmature = rawArmatures_1[_i];
                data.addArmature(this._parseArmature(rawArmature, scale));
              }
              this._data.binary || this._modifyArray();
              dragonBones.DataParser.STAGE in rawData ? data.stage = data.getArmature(ObjectDataParser._getString(rawData, dragonBones.DataParser.STAGE, "")) : data.armatureNames.length > 0 && (data.stage = data.getArmature(data.armatureNames[0]));
              this._data = null;
            }
            dragonBones.DataParser.TEXTURE_ATLAS in rawData && (this._rawTextureAtlases = rawData[dragonBones.DataParser.TEXTURE_ATLAS]);
            return data;
          }
          console.assert(false, "Nonsupport data version: " + version + "\nPlease convert DragonBones data to support version.\nRead more: https://github.com/DragonBones/Tools/");
          return null;
        };
        ObjectDataParser.prototype.parseTextureAtlasData = function(rawData, textureAtlasData, scale) {
          void 0 === scale && (scale = 1);
          console.assert(void 0 !== rawData);
          if (null === rawData) {
            if (null === this._rawTextureAtlases || 0 === this._rawTextureAtlases.length) return false;
            var rawTextureAtlas = this._rawTextureAtlases[this._rawTextureAtlasIndex++];
            this.parseTextureAtlasData(rawTextureAtlas, textureAtlasData, scale);
            if (this._rawTextureAtlasIndex >= this._rawTextureAtlases.length) {
              this._rawTextureAtlasIndex = 0;
              this._rawTextureAtlases = null;
            }
            return true;
          }
          textureAtlasData.width = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.WIDTH, 0);
          textureAtlasData.height = ObjectDataParser._getNumber(rawData, dragonBones.DataParser.HEIGHT, 0);
          textureAtlasData.scale = 1 === scale ? 1 / ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1) : scale;
          textureAtlasData.name = ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, "");
          textureAtlasData.imagePath = ObjectDataParser._getString(rawData, dragonBones.DataParser.IMAGE_PATH, "");
          if (dragonBones.DataParser.SUB_TEXTURE in rawData) {
            var rawTextures = rawData[dragonBones.DataParser.SUB_TEXTURE];
            for (var i = 0, l = rawTextures.length; i < l; ++i) {
              var rawTexture = rawTextures[i];
              var textureData = textureAtlasData.createTexture();
              textureData.rotated = ObjectDataParser._getBoolean(rawTexture, dragonBones.DataParser.ROTATED, false);
              textureData.name = ObjectDataParser._getString(rawTexture, dragonBones.DataParser.NAME, "");
              textureData.region.x = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.X, 0);
              textureData.region.y = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.Y, 0);
              textureData.region.width = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.WIDTH, 0);
              textureData.region.height = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.HEIGHT, 0);
              var frameWidth = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_WIDTH, -1);
              var frameHeight = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_HEIGHT, -1);
              if (frameWidth > 0 && frameHeight > 0) {
                textureData.frame = dragonBones.TextureData.createRectangle();
                textureData.frame.x = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_X, 0);
                textureData.frame.y = ObjectDataParser._getNumber(rawTexture, dragonBones.DataParser.FRAME_Y, 0);
                textureData.frame.width = frameWidth;
                textureData.frame.height = frameHeight;
              }
              textureAtlasData.addTexture(textureData);
            }
          }
          return true;
        };
        ObjectDataParser.getInstance = function() {
          null === ObjectDataParser._objectDataParserInstance && (ObjectDataParser._objectDataParserInstance = new ObjectDataParser());
          return ObjectDataParser._objectDataParserInstance;
        };
        ObjectDataParser._objectDataParserInstance = null;
        return ObjectDataParser;
      })(dragonBones.DataParser);
      dragonBones.ObjectDataParser = ObjectDataParser;
      var ActionFrame = (function() {
        function ActionFrame() {
          this.frameStart = 0;
          this.actions = [];
        }
        return ActionFrame;
      })();
      dragonBones.ActionFrame = ActionFrame;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var BinaryDataParser = (function(_super) {
        __extends(BinaryDataParser, _super);
        function BinaryDataParser() {
          return null !== _super && _super.apply(this, arguments) || this;
        }
        BinaryDataParser.prototype._inRange = function(a, min, max) {
          return min <= a && a <= max;
        };
        BinaryDataParser.prototype._decodeUTF8 = function(data) {
          var EOF_byte = -1;
          var EOF_code_point = -1;
          var FATAL_POINT = 65533;
          var pos = 0;
          var result = "";
          var code_point;
          var utf8_code_point = 0;
          var utf8_bytes_needed = 0;
          var utf8_bytes_seen = 0;
          var utf8_lower_boundary = 0;
          while (data.length > pos) {
            var _byte = data[pos++];
            if (_byte === EOF_byte) code_point = 0 !== utf8_bytes_needed ? FATAL_POINT : EOF_code_point; else if (0 === utf8_bytes_needed) if (this._inRange(_byte, 0, 127)) code_point = _byte; else {
              if (this._inRange(_byte, 194, 223)) {
                utf8_bytes_needed = 1;
                utf8_lower_boundary = 128;
                utf8_code_point = _byte - 192;
              } else if (this._inRange(_byte, 224, 239)) {
                utf8_bytes_needed = 2;
                utf8_lower_boundary = 2048;
                utf8_code_point = _byte - 224;
              } else if (this._inRange(_byte, 240, 244)) {
                utf8_bytes_needed = 3;
                utf8_lower_boundary = 65536;
                utf8_code_point = _byte - 240;
              }
              utf8_code_point *= Math.pow(64, utf8_bytes_needed);
              code_point = null;
            } else if (this._inRange(_byte, 128, 191)) {
              utf8_bytes_seen += 1;
              utf8_code_point += (_byte - 128) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
              if (utf8_bytes_seen !== utf8_bytes_needed) code_point = null; else {
                var cp = utf8_code_point;
                var lower_boundary = utf8_lower_boundary;
                utf8_code_point = 0;
                utf8_bytes_needed = 0;
                utf8_bytes_seen = 0;
                utf8_lower_boundary = 0;
                code_point = this._inRange(cp, lower_boundary, 1114111) && !this._inRange(cp, 55296, 57343) ? cp : _byte;
              }
            } else {
              utf8_code_point = 0;
              utf8_bytes_needed = 0;
              utf8_bytes_seen = 0;
              utf8_lower_boundary = 0;
              pos--;
              code_point = _byte;
            }
            if (null !== code_point && code_point !== EOF_code_point) if (code_point <= 65535) code_point > 0 && (result += String.fromCharCode(code_point)); else {
              code_point -= 65536;
              result += String.fromCharCode(55296 + (code_point >> 10 & 1023));
              result += String.fromCharCode(56320 + (1023 & code_point));
            }
          }
          return result;
        };
        BinaryDataParser.prototype._getUTF16Key = function(value) {
          for (var i = 0, l = value.length; i < l; ++i) if (value.charCodeAt(i) > 255) return encodeURI(value);
          return value;
        };
        BinaryDataParser.prototype._parseBinaryTimeline = function(type, offset, timelineData) {
          void 0 === timelineData && (timelineData = null);
          var timeline = null !== timelineData ? timelineData : dragonBones.BaseObject.borrowObject(dragonBones.TimelineData);
          timeline.type = type;
          timeline.offset = offset;
          this._timeline = timeline;
          var keyFrameCount = this._timelineArrayBuffer[timeline.offset + 2];
          if (1 === keyFrameCount) timeline.frameIndicesOffset = -1; else {
            var frameIndicesOffset = 0;
            var totalFrameCount = this._animation.frameCount + 1;
            var frameIndices = this._data.frameIndices;
            if (dragonBones.DragonBones.webAssembly) {
              frameIndicesOffset = frameIndices.size();
              frameIndices.resize(frameIndicesOffset + totalFrameCount, 0);
            } else {
              frameIndicesOffset = frameIndices.length;
              frameIndices.length += totalFrameCount;
            }
            timeline.frameIndicesOffset = frameIndicesOffset;
            for (var i = 0, iK = 0, frameStart = 0, frameCount = 0; i < totalFrameCount; ++i) {
              if (frameStart + frameCount <= i && iK < keyFrameCount) {
                frameStart = this._frameArrayBuffer[this._animation.frameOffset + this._timelineArrayBuffer[timeline.offset + 5 + iK]];
                frameCount = iK === keyFrameCount - 1 ? this._animation.frameCount - frameStart : this._frameArrayBuffer[this._animation.frameOffset + this._timelineArrayBuffer[timeline.offset + 5 + iK + 1]] - frameStart;
                iK++;
              }
              dragonBones.DragonBones.webAssembly ? frameIndices.set(frameIndicesOffset + i, iK - 1) : frameIndices[frameIndicesOffset + i] = iK - 1;
            }
          }
          this._timeline = null;
          return timeline;
        };
        BinaryDataParser.prototype._parseMesh = function(rawData, mesh) {
          mesh.offset = rawData[dragonBones.DataParser.OFFSET];
          var weightOffset = this._intArrayBuffer[mesh.offset + 3];
          if (weightOffset >= 0) {
            var weight = dragonBones.BaseObject.borrowObject(dragonBones.WeightData);
            var vertexCount = this._intArrayBuffer[mesh.offset + 0];
            var boneCount = this._intArrayBuffer[weightOffset + 0];
            weight.offset = weightOffset;
            for (var i = 0; i < boneCount; ++i) {
              var boneIndex = this._intArrayBuffer[weightOffset + 2 + i];
              weight.addBone(this._rawBones[boneIndex]);
            }
            var boneIndicesOffset = weightOffset + 2 + boneCount;
            var weightCount = 0;
            for (var i = 0, l = vertexCount; i < l; ++i) {
              var vertexBoneCount = this._intArrayBuffer[boneIndicesOffset++];
              weightCount += vertexBoneCount;
              boneIndicesOffset += vertexBoneCount;
            }
            weight.count = weightCount;
            mesh.weight = weight;
          }
        };
        BinaryDataParser.prototype._parseAnimation = function(rawData) {
          var animation = dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);
          animation.frameCount = Math.max(dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.DURATION, 1), 1);
          animation.playTimes = dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.PLAY_TIMES, 1);
          animation.duration = animation.frameCount / this._armature.frameRate;
          animation.fadeInTime = dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.FADE_IN_TIME, 0);
          animation.scale = dragonBones.ObjectDataParser._getNumber(rawData, dragonBones.DataParser.SCALE, 1);
          animation.name = dragonBones.ObjectDataParser._getString(rawData, dragonBones.DataParser.NAME, dragonBones.DataParser.DEFAULT_NAME);
          0 === animation.name.length && (animation.name = dragonBones.DataParser.DEFAULT_NAME);
          var offsets = rawData[dragonBones.DataParser.OFFSET];
          animation.frameIntOffset = offsets[0];
          animation.frameFloatOffset = offsets[1];
          animation.frameOffset = offsets[2];
          this._animation = animation;
          dragonBones.DataParser.ACTION in rawData && (animation.actionTimeline = this._parseBinaryTimeline(0, rawData[dragonBones.DataParser.ACTION]));
          dragonBones.DataParser.Z_ORDER in rawData && (animation.zOrderTimeline = this._parseBinaryTimeline(1, rawData[dragonBones.DataParser.Z_ORDER]));
          if (dragonBones.DataParser.BONE in rawData) {
            var rawTimeliness = rawData[dragonBones.DataParser.BONE];
            for (var k in rawTimeliness) {
              var rawTimelines = rawTimeliness[k];
              dragonBones.DragonBones.webAssembly && (k = this._getUTF16Key(k));
              var bone = this._armature.getBone(k);
              if (null === bone) continue;
              for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                var timelineType = rawTimelines[i];
                var timelineOffset = rawTimelines[i + 1];
                var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                this._animation.addBoneTimeline(bone, timeline);
              }
            }
          }
          if (dragonBones.DataParser.SURFACE in rawData) {
            var rawTimeliness = rawData[dragonBones.DataParser.SURFACE];
            for (var k in rawTimeliness) {
              var rawTimelines = rawTimeliness[k];
              dragonBones.DragonBones.webAssembly && (k = this._getUTF16Key(k));
              var surface = this._armature.getBone(k);
              if (null === surface) continue;
              for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                var timelineType = rawTimelines[i];
                var timelineOffset = rawTimelines[i + 1];
                var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                this._animation.addSurfaceTimeline(surface, timeline);
              }
            }
          }
          if (dragonBones.DataParser.SLOT in rawData) {
            var rawTimeliness = rawData[dragonBones.DataParser.SLOT];
            for (var k in rawTimeliness) {
              var rawTimelines = rawTimeliness[k];
              dragonBones.DragonBones.webAssembly && (k = this._getUTF16Key(k));
              var slot = this._armature.getSlot(k);
              if (null === slot) continue;
              for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                var timelineType = rawTimelines[i];
                var timelineOffset = rawTimelines[i + 1];
                var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                this._animation.addSlotTimeline(slot, timeline);
              }
            }
          }
          if (dragonBones.DataParser.CONSTRAINT in rawData) {
            var rawTimeliness = rawData[dragonBones.DataParser.CONSTRAINT];
            for (var k in rawTimeliness) {
              var rawTimelines = rawTimeliness[k];
              dragonBones.DragonBones.webAssembly && (k = this._getUTF16Key(k));
              var constraint = this._armature.getConstraint(k);
              if (null === constraint) continue;
              for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                var timelineType = rawTimelines[i];
                var timelineOffset = rawTimelines[i + 1];
                var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                this._animation.addConstraintTimeline(constraint, timeline);
              }
            }
          }
          if (dragonBones.DataParser.ANIMATION in rawData) {
            var rawTimeliness = rawData[dragonBones.DataParser.ANIMATION];
            for (var k in rawTimeliness) {
              var rawTimelines = rawTimeliness[k];
              dragonBones.DragonBones.webAssembly && (k = this._getUTF16Key(k));
              for (var i = 0, l = rawTimelines.length; i < l; i += 2) {
                var timelineType = rawTimelines[i];
                var timelineOffset = rawTimelines[i + 1];
                var timeline = this._parseBinaryTimeline(timelineType, timelineOffset);
                this._animation.addAnimationTimeline(k, timeline);
              }
            }
          }
          this._animation = null;
          return animation;
        };
        BinaryDataParser.prototype._parseArray = function(rawData) {
          var offsets = rawData[dragonBones.DataParser.OFFSET];
          var l1 = offsets[1];
          var l2 = offsets[3];
          var l3 = offsets[5];
          var l4 = offsets[7];
          var l5 = offsets[9];
          var l6 = offsets[11];
          var intArray = new Int16Array(this._binary, this._binaryOffset + offsets[0], l1 / Int16Array.BYTES_PER_ELEMENT);
          var floatArray = new Float32Array(this._binary, this._binaryOffset + offsets[2], l2 / Float32Array.BYTES_PER_ELEMENT);
          var frameIntArray = new Int16Array(this._binary, this._binaryOffset + offsets[4], l3 / Int16Array.BYTES_PER_ELEMENT);
          var frameFloatArray = new Float32Array(this._binary, this._binaryOffset + offsets[6], l4 / Float32Array.BYTES_PER_ELEMENT);
          var frameArray = new Int16Array(this._binary, this._binaryOffset + offsets[8], l5 / Int16Array.BYTES_PER_ELEMENT);
          var timelineArray = new Uint16Array(this._binary, this._binaryOffset + offsets[10], l6 / Uint16Array.BYTES_PER_ELEMENT);
          if (dragonBones.DragonBones.webAssembly) {
            var lTotal = l1 + l2 + l3 + l4 + l5 + l6;
            var bufferPointer = dragonBones.webAssemblyModule._malloc(lTotal);
            var rawArray = new Uint8Array(this._binary, this._binaryOffset, lTotal / Uint8Array.BYTES_PER_ELEMENT);
            var copyArray = new Uint8Array(dragonBones.webAssemblyModule.HEAP16.buffer, bufferPointer, rawArray.length);
            for (var i = 0, l = rawArray.length; i < l; ++i) copyArray[i] = rawArray[i];
            dragonBones.webAssemblyModule.setDataBinary(this._data, bufferPointer, l1, l2, l3, l4, l5, l6);
            this._intArrayBuffer = intArray;
            this._floatArrayBuffer = floatArray;
            this._frameIntArrayBuffer = frameIntArray;
            this._frameFloatArrayBuffer = frameFloatArray;
            this._frameArrayBuffer = frameArray;
            this._timelineArrayBuffer = timelineArray;
          } else {
            this._data.binary = this._binary;
            this._data.intArray = this._intArrayBuffer = intArray;
            this._data.floatArray = this._floatArrayBuffer = floatArray;
            this._data.frameIntArray = this._frameIntArrayBuffer = frameIntArray;
            this._data.frameFloatArray = this._frameFloatArrayBuffer = frameFloatArray;
            this._data.frameArray = this._frameArrayBuffer = frameArray;
            this._data.timelineArray = this._timelineArrayBuffer = timelineArray;
          }
        };
        BinaryDataParser.prototype.parseDragonBonesData = function(rawData, scale) {
          void 0 === scale && (scale = 1);
          console.assert(null !== rawData && void 0 !== rawData && rawData instanceof ArrayBuffer, "Data error.");
          var tag = new Uint8Array(rawData, 0, 8);
          if (tag[0] !== "D".charCodeAt(0) || tag[1] !== "B".charCodeAt(0) || tag[2] !== "D".charCodeAt(0) || tag[3] !== "T".charCodeAt(0)) {
            console.assert(false, "Nonsupport data.");
            return null;
          }
          var headerLength = new Uint32Array(rawData, 8, 1)[0];
          var headerBytes = new Uint8Array(rawData, 12, headerLength);
          var headerString = this._decodeUTF8(headerBytes);
          var header = JSON.parse(headerString);
          this._binaryOffset = 12 + headerLength;
          this._binary = rawData;
          return _super.prototype.parseDragonBonesData.call(this, header, scale);
        };
        BinaryDataParser.getInstance = function() {
          null === BinaryDataParser._binaryDataParserInstance && (BinaryDataParser._binaryDataParserInstance = new BinaryDataParser());
          return BinaryDataParser._binaryDataParserInstance;
        };
        BinaryDataParser._binaryDataParserInstance = null;
        return BinaryDataParser;
      })(dragonBones.ObjectDataParser);
      dragonBones.BinaryDataParser = BinaryDataParser;
    })(dragonBones || (dragonBones = {}));
    var dragonBones;
    (function(dragonBones) {
      var BaseFactory = (function() {
        function BaseFactory(dataParser) {
          void 0 === dataParser && (dataParser = null);
          this.autoSearch = false;
          this._dragonBonesDataMap = {};
          this._textureAtlasDataMap = {};
          this._dragonBones = null;
          this._dataParser = null;
          null === BaseFactory._objectParser && (BaseFactory._objectParser = new dragonBones.ObjectDataParser());
          null === BaseFactory._binaryParser && (BaseFactory._binaryParser = new dragonBones.BinaryDataParser());
          this._dataParser = null !== dataParser ? dataParser : BaseFactory._objectParser;
        }
        BaseFactory.prototype._isSupportMesh = function() {
          return true;
        };
        BaseFactory.prototype._getTextureData = function(textureAtlasName, textureName) {
          if (textureAtlasName in this._textureAtlasDataMap) for (var _i = 0, _a = this._textureAtlasDataMap[textureAtlasName]; _i < _a.length; _i++) {
            var textureAtlasData = _a[_i];
            var textureData = textureAtlasData.getTexture(textureName);
            if (null !== textureData) return textureData;
          }
          if (this.autoSearch) for (var k in this._textureAtlasDataMap) for (var _b = 0, _c = this._textureAtlasDataMap[k]; _b < _c.length; _b++) {
            var textureAtlasData = _c[_b];
            if (textureAtlasData.autoSearch) {
              var textureData = textureAtlasData.getTexture(textureName);
              if (null !== textureData) return textureData;
            }
          }
          return null;
        };
        BaseFactory.prototype._fillBuildArmaturePackage = function(dataPackage, dragonBonesName, armatureName, skinName, textureAtlasName) {
          var dragonBonesData = null;
          var armatureData = null;
          if (dragonBonesName.length > 0 && dragonBonesName in this._dragonBonesDataMap) {
            dragonBonesData = this._dragonBonesDataMap[dragonBonesName];
            armatureData = dragonBonesData.getArmature(armatureName);
          }
          if (null === armatureData && (0 === dragonBonesName.length || this.autoSearch)) for (var k in this._dragonBonesDataMap) {
            dragonBonesData = this._dragonBonesDataMap[k];
            if (0 === dragonBonesName.length || dragonBonesData.autoSearch) {
              armatureData = dragonBonesData.getArmature(armatureName);
              if (null !== armatureData) {
                dragonBonesName = k;
                break;
              }
            }
          }
          if (null !== armatureData) {
            dataPackage.dataName = dragonBonesName;
            dataPackage.textureAtlasName = textureAtlasName;
            dataPackage.data = dragonBonesData;
            dataPackage.armature = armatureData;
            dataPackage.skin = null;
            if (skinName.length > 0) {
              dataPackage.skin = armatureData.getSkin(skinName);
              if (null === dataPackage.skin && this.autoSearch) for (var k in this._dragonBonesDataMap) {
                var skinDragonBonesData = this._dragonBonesDataMap[k];
                var skinArmatureData = skinDragonBonesData.getArmature(skinName);
                if (null !== skinArmatureData) {
                  dataPackage.skin = skinArmatureData.defaultSkin;
                  break;
                }
              }
            }
            null === dataPackage.skin && (dataPackage.skin = armatureData.defaultSkin);
            return true;
          }
          return false;
        };
        BaseFactory.prototype._buildBones = function(dataPackage, armature) {
          for (var _i = 0, _a = dataPackage.armature.sortedBones; _i < _a.length; _i++) {
            var boneData = _a[_i];
            var bone = dragonBones.BaseObject.borrowObject(0 === boneData.type ? dragonBones.Bone : dragonBones.Surface);
            bone.init(boneData);
            null !== boneData.parent ? armature.addBone(bone, boneData.parent.name) : armature.addBone(bone, "");
          }
          var constraints = dataPackage.armature.constraints;
          for (var k in constraints) {
            var constraintData = constraints[k];
            var constraint = dragonBones.BaseObject.borrowObject(dragonBones.IKConstraint);
            constraint.init(constraintData, armature);
            armature.addConstraint(constraint);
          }
        };
        BaseFactory.prototype._buildSlots = function(dataPackage, armature) {
          var currentSkin = dataPackage.skin;
          var defaultSkin = dataPackage.armature.defaultSkin;
          if (null === currentSkin || null === defaultSkin) return;
          var skinSlots = {};
          for (var k in defaultSkin.displays) {
            var displays = defaultSkin.getDisplays(k);
            skinSlots[k] = displays;
          }
          if (currentSkin !== defaultSkin) for (var k in currentSkin.displays) {
            var displays = currentSkin.getDisplays(k);
            skinSlots[k] = displays;
          }
          for (var _i = 0, _a = dataPackage.armature.sortedSlots; _i < _a.length; _i++) {
            var slotData = _a[_i];
            var displays = slotData.name in skinSlots ? skinSlots[slotData.name] : null;
            var slot = this._buildSlot(dataPackage, slotData, displays, armature);
            armature.addSlot(slot, slotData.parent.name);
            if (null !== displays) {
              var displayList = new Array();
              for (var i = 0, l = dragonBones.DragonBones.webAssembly ? displays.size() : displays.length; i < l; ++i) {
                var displayData = dragonBones.DragonBones.webAssembly ? displays.get(i) : displays[i];
                null !== displayData ? displayList.push(this._getSlotDisplay(dataPackage, displayData, null, slot)) : displayList.push(null);
              }
              slot._setDisplayList(displayList);
            }
            slot._setDisplayIndex(slotData.displayIndex, true);
          }
        };
        BaseFactory.prototype._buildChildArmature = function(dataPackage, slot, displayData) {
          slot;
          return this.buildArmature(displayData.path, null !== dataPackage ? dataPackage.dataName : "", "", null !== dataPackage ? dataPackage.textureAtlasName : "");
        };
        BaseFactory.prototype._getSlotDisplay = function(dataPackage, displayData, rawDisplayData, slot) {
          var dataName = null !== dataPackage ? dataPackage.dataName : displayData.parent.parent.parent.name;
          var display = null;
          switch (displayData.type) {
           case 0:
            var imageDisplayData = displayData;
            null === imageDisplayData.texture ? imageDisplayData.texture = this._getTextureData(dataName, displayData.path) : null !== dataPackage && dataPackage.textureAtlasName.length > 0 && (imageDisplayData.texture = this._getTextureData(dataPackage.textureAtlasName, displayData.path));
            display = null !== rawDisplayData && 2 === rawDisplayData.type && this._isSupportMesh() ? slot.meshDisplay : slot.rawDisplay;
            break;

           case 2:
            var meshDisplayData = displayData;
            null === meshDisplayData.texture ? meshDisplayData.texture = this._getTextureData(dataName, meshDisplayData.path) : null !== dataPackage && dataPackage.textureAtlasName.length > 0 && (meshDisplayData.texture = this._getTextureData(dataPackage.textureAtlasName, meshDisplayData.path));
            display = this._isSupportMesh() ? slot.meshDisplay : slot.rawDisplay;
            break;

           case 1:
            var armatureDisplayData = displayData;
            var childArmature = this._buildChildArmature(dataPackage, slot, displayData);
            if (null !== childArmature) {
              childArmature.inheritAnimation = armatureDisplayData.inheritAnimation;
              if (!childArmature.inheritAnimation) {
                var actions = armatureDisplayData.actions.length > 0 ? armatureDisplayData.actions : childArmature.armatureData.defaultActions;
                if (actions.length > 0) for (var _i = 0, actions_6 = actions; _i < actions_6.length; _i++) {
                  var action = actions_6[_i];
                  childArmature._bufferAction(action, true);
                } else childArmature.animation.play();
              }
              armatureDisplayData.armature = childArmature.armatureData;
            }
            display = childArmature;
          }
          return display;
        };
        BaseFactory.prototype.parseDragonBonesData = function(rawData, name, scale) {
          void 0 === name && (name = null);
          void 0 === scale && (scale = 1);
          var dataParser = rawData instanceof ArrayBuffer ? BaseFactory._binaryParser : this._dataParser;
          var dragonBonesData = dataParser.parseDragonBonesData(rawData, scale);
          while (true) {
            var textureAtlasData = this._buildTextureAtlasData(null, null);
            if (!dataParser.parseTextureAtlasData(null, textureAtlasData, scale)) {
              textureAtlasData.returnToPool();
              break;
            }
            this.addTextureAtlasData(textureAtlasData, name);
          }
          null !== dragonBonesData && this.addDragonBonesData(dragonBonesData, name);
          return dragonBonesData;
        };
        BaseFactory.prototype.parseTextureAtlasData = function(rawData, textureAtlas, name, scale) {
          void 0 === name && (name = null);
          void 0 === scale && (scale = 1);
          var textureAtlasData = this._buildTextureAtlasData(null, null);
          this._dataParser.parseTextureAtlasData(rawData, textureAtlasData, scale);
          this._buildTextureAtlasData(textureAtlasData, textureAtlas || null);
          this.addTextureAtlasData(textureAtlasData, name);
          return textureAtlasData;
        };
        BaseFactory.prototype.updateTextureAtlasData = function(name, textureAtlases) {
          var textureAtlasDatas = this.getTextureAtlasData(name);
          if (null !== textureAtlasDatas) for (var i = 0, l = textureAtlasDatas.length; i < l; ++i) i < textureAtlases.length && this._buildTextureAtlasData(textureAtlasDatas[i], textureAtlases[i]);
        };
        BaseFactory.prototype.getDragonBonesData = function(name) {
          return name in this._dragonBonesDataMap ? this._dragonBonesDataMap[name] : null;
        };
        BaseFactory.prototype.addDragonBonesData = function(data, name) {
          void 0 === name && (name = null);
          name = null !== name ? name : data.name;
          if (name in this._dragonBonesDataMap) {
            if (this._dragonBonesDataMap[name] === data) return;
            console.warn("Can not add same name data: " + name);
            return;
          }
          this._dragonBonesDataMap[name] = data;
        };
        BaseFactory.prototype.removeDragonBonesData = function(name, disposeData) {
          void 0 === disposeData && (disposeData = true);
          if (name in this._dragonBonesDataMap) {
            disposeData && this._dragonBones.bufferObject(this._dragonBonesDataMap[name]);
            delete this._dragonBonesDataMap[name];
          }
        };
        BaseFactory.prototype.getTextureAtlasData = function(name) {
          return name in this._textureAtlasDataMap ? this._textureAtlasDataMap[name] : null;
        };
        BaseFactory.prototype.addTextureAtlasData = function(data, name) {
          void 0 === name && (name = null);
          name = null !== name ? name : data.name;
          var textureAtlasList = name in this._textureAtlasDataMap ? this._textureAtlasDataMap[name] : this._textureAtlasDataMap[name] = [];
          textureAtlasList.indexOf(data) < 0 && textureAtlasList.push(data);
        };
        BaseFactory.prototype.removeTextureAtlasData = function(name, disposeData) {
          void 0 === disposeData && (disposeData = true);
          if (name in this._textureAtlasDataMap) {
            var textureAtlasDataList = this._textureAtlasDataMap[name];
            if (disposeData) for (var _i = 0, textureAtlasDataList_1 = textureAtlasDataList; _i < textureAtlasDataList_1.length; _i++) {
              var textureAtlasData = textureAtlasDataList_1[_i];
              this._dragonBones.bufferObject(textureAtlasData);
            }
            delete this._textureAtlasDataMap[name];
          }
        };
        BaseFactory.prototype.getArmatureData = function(name, dragonBonesName) {
          void 0 === dragonBonesName && (dragonBonesName = "");
          var dataPackage = new BuildArmaturePackage();
          if (!this._fillBuildArmaturePackage(dataPackage, dragonBonesName, name, "", "")) return null;
          return dataPackage.armature;
        };
        BaseFactory.prototype.clear = function(disposeData) {
          void 0 === disposeData && (disposeData = true);
          for (var k in this._dragonBonesDataMap) {
            disposeData && this._dragonBones.bufferObject(this._dragonBonesDataMap[k]);
            delete this._dragonBonesDataMap[k];
          }
          for (var k in this._textureAtlasDataMap) {
            if (disposeData) {
              var textureAtlasDataList = this._textureAtlasDataMap[k];
              for (var _i = 0, textureAtlasDataList_2 = textureAtlasDataList; _i < textureAtlasDataList_2.length; _i++) {
                var textureAtlasData = textureAtlasDataList_2[_i];
                this._dragonBones.bufferObject(textureAtlasData);
              }
            }
            delete this._textureAtlasDataMap[k];
          }
        };
        BaseFactory.prototype.buildArmature = function(armatureName, dragonBonesName, skinName, textureAtlasName) {
          void 0 === dragonBonesName && (dragonBonesName = "");
          void 0 === skinName && (skinName = "");
          void 0 === textureAtlasName && (textureAtlasName = "");
          var dataPackage = new BuildArmaturePackage();
          if (!this._fillBuildArmaturePackage(dataPackage, dragonBonesName || "", armatureName, skinName || "", textureAtlasName || "")) {
            console.warn("No armature data: " + armatureName + ", " + (null !== dragonBonesName ? dragonBonesName : ""));
            return null;
          }
          var armature = this._buildArmature(dataPackage);
          this._buildBones(dataPackage, armature);
          this._buildSlots(dataPackage, armature);
          armature.invalidUpdate(null, true);
          armature.advanceTime(0);
          return armature;
        };
        BaseFactory.prototype.replaceDisplay = function(slot, displayData, displayIndex) {
          void 0 === displayIndex && (displayIndex = -1);
          displayIndex < 0 && (displayIndex = slot.displayIndex);
          displayIndex < 0 && (displayIndex = 0);
          slot.replaceDisplayData(displayData, displayIndex);
          var displayList = slot.displayList;
          if (displayList.length <= displayIndex) {
            displayList.length = displayIndex + 1;
            for (var i = 0, l = displayList.length; i < l; ++i) displayList[i] || (displayList[i] = null);
          }
          if (null !== displayData) {
            var rawDisplayDatas = slot.rawDisplayDatas;
            var rawDisplayData = null;
            rawDisplayDatas && (dragonBones.DragonBones.webAssembly ? displayIndex < rawDisplayDatas.size() && (rawDisplayData = rawDisplayDatas.get(displayIndex)) : displayIndex < rawDisplayDatas.length && (rawDisplayData = rawDisplayDatas[displayIndex]));
            displayList[displayIndex] = this._getSlotDisplay(null, displayData, rawDisplayData, slot);
          } else displayList[displayIndex] = null;
          slot.displayList = displayList;
        };
        BaseFactory.prototype.replaceSlotDisplay = function(dragonBonesName, armatureName, slotName, displayName, slot, displayIndex) {
          void 0 === displayIndex && (displayIndex = -1);
          var armatureData = this.getArmatureData(armatureName, dragonBonesName || "");
          if (!armatureData || !armatureData.defaultSkin) return false;
          var displayData = armatureData.defaultSkin.getDisplay(slotName, displayName);
          if (!displayData) return false;
          this.replaceDisplay(slot, displayData, displayIndex);
          return true;
        };
        BaseFactory.prototype.replaceSlotDisplayList = function(dragonBonesName, armatureName, slotName, slot) {
          var armatureData = this.getArmatureData(armatureName, dragonBonesName || "");
          if (!armatureData || !armatureData.defaultSkin) return false;
          var displays = armatureData.defaultSkin.getDisplays(slotName);
          if (!displays) return false;
          var displayIndex = 0;
          for (var i = 0, l = dragonBones.DragonBones.webAssembly ? displays.size() : displays.length; i < l; ++i) {
            var displayData = dragonBones.DragonBones.webAssembly ? displays.get(i) : displays[i];
            this.replaceDisplay(slot, displayData, displayIndex++);
          }
          return true;
        };
        BaseFactory.prototype.replaceSkin = function(armature, skin, isOverride, exclude) {
          void 0 === isOverride && (isOverride = false);
          void 0 === exclude && (exclude = null);
          var success = false;
          var defaultSkin = skin.parent.defaultSkin;
          for (var _i = 0, _a = armature.getSlots(); _i < _a.length; _i++) {
            var slot = _a[_i];
            if (null !== exclude && exclude.indexOf(slot.name) >= 0) continue;
            var displays = skin.getDisplays(slot.name);
            if (!displays) {
              null !== defaultSkin && skin !== defaultSkin && (displays = defaultSkin.getDisplays(slot.name));
              if (!displays) {
                if (isOverride) {
                  slot.rawDisplayDatas = null;
                  slot.displayList = [];
                }
                continue;
              }
            }
            var displayCount = dragonBones.DragonBones.webAssembly ? displays.size() : displays.length;
            var displayList = slot.displayList;
            displayList.length = displayCount;
            for (var i = 0, l = displayCount; i < l; ++i) {
              var displayData = dragonBones.DragonBones.webAssembly ? displays.get(i) : displays[i];
              displayList[i] = null !== displayData ? this._getSlotDisplay(null, displayData, null, slot) : null;
            }
            success = true;
            slot.rawDisplayDatas = displays;
            slot.displayList = displayList;
          }
          return success;
        };
        BaseFactory.prototype.replaceAnimation = function(armature, armatureData, isOverride) {
          void 0 === isOverride && (isOverride = true);
          var skinData = armatureData.defaultSkin;
          if (null === skinData) return false;
          if (isOverride) armature.animation.animations = armatureData.animations; else {
            var rawAnimations = armature.animation.animations;
            var animations = {};
            for (var k in rawAnimations) animations[k] = rawAnimations[k];
            for (var k in armatureData.animations) animations[k] = armatureData.animations[k];
            armature.animation.animations = animations;
          }
          for (var _i = 0, _a = armature.getSlots(); _i < _a.length; _i++) {
            var slot = _a[_i];
            var index = 0;
            for (var _b = 0, _c = slot.displayList; _b < _c.length; _b++) {
              var display = _c[_b];
              if (display instanceof dragonBones.Armature) {
                var displayDatas = skinData.getDisplays(slot.name);
                if (null !== displayDatas && index < (dragonBones.DragonBones.webAssembly ? displayDatas.size() : displayDatas.length)) {
                  var displayData = dragonBones.DragonBones.webAssembly ? displayDatas.get(index) : displayDatas[index];
                  if (null !== displayData && 1 === displayData.type) {
                    var childArmatureData = this.getArmatureData(displayData.path, displayData.parent.parent.parent.name);
                    childArmatureData && this.replaceAnimation(display, childArmatureData, isOverride);
                  }
                }
              }
              index++;
            }
          }
          return true;
        };
        BaseFactory.prototype.getAllDragonBonesData = function() {
          return this._dragonBonesDataMap;
        };
        BaseFactory.prototype.getAllTextureAtlasData = function() {
          return this._textureAtlasDataMap;
        };
        Object.defineProperty(BaseFactory.prototype, "clock", {
          get: function() {
            return this._dragonBones.clock;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(BaseFactory.prototype, "dragonBones", {
          get: function() {
            return this._dragonBones;
          },
          enumerable: true,
          configurable: true
        });
        BaseFactory.prototype.changeSkin = function(armature, skin, exclude) {
          void 0 === exclude && (exclude = null);
          return this.replaceSkin(armature, skin, false, exclude);
        };
        BaseFactory.prototype.copyAnimationsToArmature = function(toArmature, fromArmatreName, fromSkinName, fromDragonBonesDataName, replaceOriginalAnimation) {
          void 0 === fromSkinName && (fromSkinName = "");
          void 0 === fromDragonBonesDataName && (fromDragonBonesDataName = "");
          void 0 === replaceOriginalAnimation && (replaceOriginalAnimation = true);
          fromSkinName;
          var armatureData = this.getArmatureData(fromArmatreName, fromDragonBonesDataName);
          if (!armatureData) return false;
          return this.replaceAnimation(toArmature, armatureData, replaceOriginalAnimation);
        };
        BaseFactory._objectParser = null;
        BaseFactory._binaryParser = null;
        return BaseFactory;
      })();
      dragonBones.BaseFactory = BaseFactory;
      var BuildArmaturePackage = (function() {
        function BuildArmaturePackage() {
          this.dataName = "";
          this.textureAtlasName = "";
          this.skin = null;
        }
        return BuildArmaturePackage;
      })();
      dragonBones.BuildArmaturePackage = BuildArmaturePackage;
    })(dragonBones || (dragonBones = {}));
    module.exports = dragonBones;
  }), {} ],
  282: [ (function(require, module, exports) {
    var Armature = require("./ArmatureDisplay");
    var renderEngine = require("../../cocos2d/core/renderer/render-engine");
    var math = renderEngine.math;
    var js = require("../../cocos2d/core/platform/js");
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var vfmtPosUvColor = require("../../cocos2d/core/renderer/webgl/vertex-format").vfmtPosUvColor;
    var _matrix = math.mat4.create();
    var _v3 = cc.v3();
    var _vbuf = void 0, _uintbuf = void 0, _vertexId = void 0, _ibuf = void 0, _vertexOffset = void 0, _indiceOffset = void 0, _a = void 0, _b = void 0, _c = void 0, _d = void 0, _tx = void 0, _ty = void 0, _renderData = void 0, _worldMatrix = void 0;
    var armatureAssembler = {
      updateRenderData: function(comp) {
        var armature = comp._armature;
        if (!armature || comp._isChildArmature) return;
        var renderData = comp._renderData;
        renderData || (renderData = comp._renderData = comp.requestRenderData());
        var size = comp.node._contentSize;
        var anchor = comp.node._anchorPoint;
        renderData.updateSizeNPivot(size.width, size.height, anchor.x, anchor.y);
        renderData.material = comp.getMaterial();
        renderData.vertexCount = 0;
        renderData.indiceCount = 0;
        this.calcBufferCount(renderData, armature);
      },
      calcBufferCount: function(renderData, armature) {
        var slots = armature._slots;
        for (var i = 0, l = slots.length; i < l; i++) {
          var slot = slots[i];
          if (!slot._visible || !slot._displayData) continue;
          if (slot.childArmature) {
            this.calcBufferCount(renderData, slot.childArmature);
            continue;
          }
          renderData.vertexCount += slot._vertices.length;
          renderData.indiceCount += slot._indices.length;
        }
      },
      fillBuffers: function(comp, renderer) {
        var armature = comp._armature;
        if (!armature || comp._isChildArmature) return;
        var buffer = renderer.getBuffer("mesh", vfmtPosUvColor), renderData = comp._renderData;
        _vertexOffset = buffer.byteOffset >> 2;
        _vbuf = buffer._vData;
        _uintbuf = buffer._uintVData;
        _ibuf = buffer._iData;
        _indiceOffset = buffer.indiceOffset;
        _vertexId = buffer.vertexOffset;
        buffer.request(renderData.vertexCount, renderData.indiceCount);
        var node = comp.node;
        _worldMatrix = node._worldMatrix;
        _a = _worldMatrix.m00;
        _b = _worldMatrix.m01;
        _c = _worldMatrix.m04;
        _d = _worldMatrix.m05;
        _tx = _worldMatrix.m12;
        _ty = _worldMatrix.m13;
        this.fillIndexBufferWithArmature(armature);
        this.fillVertexBufferWithArmature(armature);
        comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
        _worldMatrix = _ibuf = _vbuf = _uintbuf = null;
      },
      fillVertexBufferWithArmature: function(armature) {
        var slots = armature._slots;
        for (var i = 0, l = slots.length; i < l; i++) {
          var slot = slots[i];
          if (!slot._visible || !slot._displayData) continue;
          if (slot.childArmature) {
            math.mat4.mul(_matrix, _worldMatrix, slot._matrix);
            _a = _matrix.m00;
            _b = _matrix.m01;
            _c = _matrix.m04;
            _d = _matrix.m05;
            _tx = _matrix.m12;
            _ty = _matrix.m13;
            this.fillVertexBufferWithArmature(slot.childArmature);
            _a = _worldMatrix.m00;
            _b = _worldMatrix.m01;
            _c = _worldMatrix.m04;
            _d = _worldMatrix.m05;
            _tx = _worldMatrix.m12;
            _ty = _worldMatrix.m13;
            continue;
          }
          var vertices = slot._vertices;
          var color = slot._color;
          for (var j = 0, vl = vertices.length; j < vl; j++) {
            var vertex = vertices[j];
            _vbuf[_vertexOffset++] = vertex.x * _a + vertex.y * _c + _tx;
            _vbuf[_vertexOffset++] = vertex.x * _b + vertex.y * _d + _ty;
            _vbuf[_vertexOffset++] = vertex.u;
            _vbuf[_vertexOffset++] = vertex.v;
            _uintbuf[_vertexOffset++] = color;
          }
        }
      },
      fillIndexBufferWithArmature: function(armature) {
        var slots = armature._slots;
        for (var i = 0, l = slots.length; i < l; i++) {
          var slot = slots[i];
          if (!slot._visible || !slot._displayData) continue;
          if (slot.childArmature) {
            this.fillIndexBufferWithArmature(slot.childArmature);
            continue;
          }
          var indices = slot._indices;
          for (var j = 0, il = indices.length; j < il; j++) _ibuf[_indiceOffset++] = _vertexId + indices[j];
          _vertexId += slot._vertices.length;
        }
      }
    };
    module.exports = Armature._assembler = armatureAssembler;
  }), {
    "../../cocos2d/core/platform/js": 175,
    "../../cocos2d/core/renderer/render-engine": 197,
    "../../cocos2d/core/renderer/render-flow": 198,
    "../../cocos2d/core/renderer/webgl/vertex-format": 223,
    "./ArmatureDisplay": 273
  } ],
  283: [ (function(require, module, exports) {
    var _global = "undefined" === typeof window ? global : window;
    _global.sp = {};
    sp.ATTACHMENT_TYPE = {
      REGION: 0,
      BOUNDING_BOX: 1,
      MESH: 2,
      SKINNED_MESH: 3
    };
    sp.AnimationEventType = cc.Enum({
      START: 0,
      INTERRUPT: 1,
      END: 2,
      DISPOSE: 3,
      COMPLETE: 4,
      EVENT: 5
    });
    true;
    sp.spine = require("./lib/spine");
    require("./skeleton-texture");
    require("./skeleton-data");
    require("./skeleton");
    require("./spine-assembler");
  }), {
    "./lib/spine": 284,
    "./skeleton": 287,
    "./skeleton-data": 285,
    "./skeleton-texture": 286,
    "./spine-assembler": 288
  } ],
  284: [ (function(require, module, exports) {
    var __extends = this && this.__extends || function(d, b) {
      for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
      function __() {
        this.constructor = d;
      }
      d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var spine;
    (function(spine) {
      var Animation = (function() {
        function Animation(name, timelines, duration) {
          if (null == name) throw new Error("name cannot be null.");
          if (null == timelines) throw new Error("timelines cannot be null.");
          this.name = name;
          this.timelines = timelines;
          this.duration = duration;
        }
        Animation.prototype.apply = function(skeleton, lastTime, time, loop, events, alpha, setupPose, mixingOut) {
          if (null == skeleton) throw new Error("skeleton cannot be null.");
          if (loop && 0 != this.duration) {
            time %= this.duration;
            lastTime > 0 && (lastTime %= this.duration);
          }
          var timelines = this.timelines;
          for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, setupPose, mixingOut);
        };
        Animation.binarySearch = function(values, target, step) {
          void 0 === step && (step = 1);
          var low = 0;
          var high = values.length / step - 2;
          if (0 == high) return step;
          var current = high >>> 1;
          while (true) {
            values[(current + 1) * step] <= target ? low = current + 1 : high = current;
            if (low == high) return (low + 1) * step;
            current = low + high >>> 1;
          }
        };
        Animation.linearSearch = function(values, target, step) {
          for (var i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;
          return -1;
        };
        return Animation;
      })();
      spine.Animation = Animation;
      (function(TimelineType) {
        TimelineType[TimelineType["rotate"] = 0] = "rotate";
        TimelineType[TimelineType["translate"] = 1] = "translate";
        TimelineType[TimelineType["scale"] = 2] = "scale";
        TimelineType[TimelineType["shear"] = 3] = "shear";
        TimelineType[TimelineType["attachment"] = 4] = "attachment";
        TimelineType[TimelineType["color"] = 5] = "color";
        TimelineType[TimelineType["deform"] = 6] = "deform";
        TimelineType[TimelineType["event"] = 7] = "event";
        TimelineType[TimelineType["drawOrder"] = 8] = "drawOrder";
        TimelineType[TimelineType["ikConstraint"] = 9] = "ikConstraint";
        TimelineType[TimelineType["transformConstraint"] = 10] = "transformConstraint";
        TimelineType[TimelineType["pathConstraintPosition"] = 11] = "pathConstraintPosition";
        TimelineType[TimelineType["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
        TimelineType[TimelineType["pathConstraintMix"] = 13] = "pathConstraintMix";
      })(spine.TimelineType || (spine.TimelineType = {}));
      var TimelineType = spine.TimelineType;
      var CurveTimeline = (function() {
        function CurveTimeline(frameCount) {
          if (frameCount <= 0) throw new Error("frameCount must be > 0: " + frameCount);
          this.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);
        }
        CurveTimeline.prototype.getFrameCount = function() {
          return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;
        };
        CurveTimeline.prototype.setLinear = function(frameIndex) {
          this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;
        };
        CurveTimeline.prototype.setStepped = function(frameIndex) {
          this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;
        };
        CurveTimeline.prototype.getCurveType = function(frameIndex) {
          var index = frameIndex * CurveTimeline.BEZIER_SIZE;
          if (index == this.curves.length) return CurveTimeline.LINEAR;
          var type = this.curves[index];
          if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;
          if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;
          return CurveTimeline.BEZIER;
        };
        CurveTimeline.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
          var tmpx = .03 * (2 * -cx1 + cx2), tmpy = .03 * (2 * -cy1 + cy2);
          var dddfx = .006 * (3 * (cx1 - cx2) + 1), dddfy = .006 * (3 * (cy1 - cy2) + 1);
          var ddfx = 2 * tmpx + dddfx, ddfy = 2 * tmpy + dddfy;
          var dfx = .3 * cx1 + tmpx + .16666667 * dddfx, dfy = .3 * cy1 + tmpy + .16666667 * dddfy;
          var i = frameIndex * CurveTimeline.BEZIER_SIZE;
          var curves = this.curves;
          curves[i++] = CurveTimeline.BEZIER;
          var x = dfx, y = dfy;
          for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
            curves[i] = x;
            curves[i + 1] = y;
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            x += dfx;
            y += dfy;
          }
        };
        CurveTimeline.prototype.getCurvePercent = function(frameIndex, percent) {
          percent = spine.MathUtils.clamp(percent, 0, 1);
          var curves = this.curves;
          var i = frameIndex * CurveTimeline.BEZIER_SIZE;
          var type = curves[i];
          if (type == CurveTimeline.LINEAR) return percent;
          if (type == CurveTimeline.STEPPED) return 0;
          i++;
          var x = 0;
          for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
            x = curves[i];
            if (x >= percent) {
              var prevX = void 0, prevY = void 0;
              if (i == start) {
                prevX = 0;
                prevY = 0;
              } else {
                prevX = curves[i - 2];
                prevY = curves[i - 1];
              }
              return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
            }
          }
          var y = curves[i - 1];
          return y + (1 - y) * (percent - x) / (1 - x);
        };
        CurveTimeline.LINEAR = 0;
        CurveTimeline.STEPPED = 1;
        CurveTimeline.BEZIER = 2;
        CurveTimeline.BEZIER_SIZE = 19;
        return CurveTimeline;
      })();
      spine.CurveTimeline = CurveTimeline;
      var RotateTimeline = (function(_super) {
        __extends(RotateTimeline, _super);
        function RotateTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount << 1);
        }
        RotateTimeline.prototype.getPropertyId = function() {
          return (TimelineType.rotate << 24) + this.boneIndex;
        };
        RotateTimeline.prototype.setFrame = function(frameIndex, time, degrees) {
          frameIndex <<= 1;
          this.frames[frameIndex] = time;
          this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;
        };
        RotateTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var bone = skeleton.bones[this.boneIndex];
          if (time < frames[0]) {
            setupPose && (bone.rotation = bone.data.rotation);
            return;
          }
          if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {
            if (setupPose) bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha; else {
              var r_1 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;
              r_1 -= 360 * (16384 - (16384.499999999996 - r_1 / 360 | 0));
              bone.rotation += r_1 * alpha;
            }
            return;
          }
          var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
          var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
          var frameTime = frames[frame];
          var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
          var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;
          r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0));
          r = prevRotation + r * percent;
          if (setupPose) {
            r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0));
            bone.rotation = bone.data.rotation + r * alpha;
          } else {
            r = bone.data.rotation + r - bone.rotation;
            r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0));
            bone.rotation += r * alpha;
          }
        };
        RotateTimeline.ENTRIES = 2;
        RotateTimeline.PREV_TIME = -2;
        RotateTimeline.PREV_ROTATION = -1;
        RotateTimeline.ROTATION = 1;
        return RotateTimeline;
      })(CurveTimeline);
      spine.RotateTimeline = RotateTimeline;
      var TranslateTimeline = (function(_super) {
        __extends(TranslateTimeline, _super);
        function TranslateTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);
        }
        TranslateTimeline.prototype.getPropertyId = function() {
          return (TimelineType.translate << 24) + this.boneIndex;
        };
        TranslateTimeline.prototype.setFrame = function(frameIndex, time, x, y) {
          frameIndex *= TranslateTimeline.ENTRIES;
          this.frames[frameIndex] = time;
          this.frames[frameIndex + TranslateTimeline.X] = x;
          this.frames[frameIndex + TranslateTimeline.Y] = y;
        };
        TranslateTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var bone = skeleton.bones[this.boneIndex];
          if (time < frames[0]) {
            if (setupPose) {
              bone.x = bone.data.x;
              bone.y = bone.data.y;
            }
            return;
          }
          var x = 0, y = 0;
          if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {
            x = frames[frames.length + TranslateTimeline.PREV_X];
            y = frames[frames.length + TranslateTimeline.PREV_Y];
          } else {
            var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);
            x = frames[frame + TranslateTimeline.PREV_X];
            y = frames[frame + TranslateTimeline.PREV_Y];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));
            x += (frames[frame + TranslateTimeline.X] - x) * percent;
            y += (frames[frame + TranslateTimeline.Y] - y) * percent;
          }
          if (setupPose) {
            bone.x = bone.data.x + x * alpha;
            bone.y = bone.data.y + y * alpha;
          } else {
            bone.x += (bone.data.x + x - bone.x) * alpha;
            bone.y += (bone.data.y + y - bone.y) * alpha;
          }
        };
        TranslateTimeline.ENTRIES = 3;
        TranslateTimeline.PREV_TIME = -3;
        TranslateTimeline.PREV_X = -2;
        TranslateTimeline.PREV_Y = -1;
        TranslateTimeline.X = 1;
        TranslateTimeline.Y = 2;
        return TranslateTimeline;
      })(CurveTimeline);
      spine.TranslateTimeline = TranslateTimeline;
      var ScaleTimeline = (function(_super) {
        __extends(ScaleTimeline, _super);
        function ScaleTimeline(frameCount) {
          _super.call(this, frameCount);
        }
        ScaleTimeline.prototype.getPropertyId = function() {
          return (TimelineType.scale << 24) + this.boneIndex;
        };
        ScaleTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var bone = skeleton.bones[this.boneIndex];
          if (time < frames[0]) {
            if (setupPose) {
              bone.scaleX = bone.data.scaleX;
              bone.scaleY = bone.data.scaleY;
            }
            return;
          }
          var x = 0, y = 0;
          if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
            x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
            y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
          } else {
            var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
            x = frames[frame + ScaleTimeline.PREV_X];
            y = frames[frame + ScaleTimeline.PREV_Y];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
            x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
            y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
          }
          if (1 == alpha) {
            bone.scaleX = x;
            bone.scaleY = y;
          } else {
            var bx = 0, by = 0;
            if (setupPose) {
              bx = bone.data.scaleX;
              by = bone.data.scaleY;
            } else {
              bx = bone.scaleX;
              by = bone.scaleY;
            }
            if (mixingOut) {
              x = Math.abs(x) * spine.MathUtils.signum(bx);
              y = Math.abs(y) * spine.MathUtils.signum(by);
            } else {
              bx = Math.abs(bx) * spine.MathUtils.signum(x);
              by = Math.abs(by) * spine.MathUtils.signum(y);
            }
            bone.scaleX = bx + (x - bx) * alpha;
            bone.scaleY = by + (y - by) * alpha;
          }
        };
        return ScaleTimeline;
      })(TranslateTimeline);
      spine.ScaleTimeline = ScaleTimeline;
      var ShearTimeline = (function(_super) {
        __extends(ShearTimeline, _super);
        function ShearTimeline(frameCount) {
          _super.call(this, frameCount);
        }
        ShearTimeline.prototype.getPropertyId = function() {
          return (TimelineType.shear << 24) + this.boneIndex;
        };
        ShearTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var bone = skeleton.bones[this.boneIndex];
          if (time < frames[0]) {
            if (setupPose) {
              bone.shearX = bone.data.shearX;
              bone.shearY = bone.data.shearY;
            }
            return;
          }
          var x = 0, y = 0;
          if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
            x = frames[frames.length + ShearTimeline.PREV_X];
            y = frames[frames.length + ShearTimeline.PREV_Y];
          } else {
            var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
            x = frames[frame + ShearTimeline.PREV_X];
            y = frames[frame + ShearTimeline.PREV_Y];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
            x += (frames[frame + ShearTimeline.X] - x) * percent;
            y += (frames[frame + ShearTimeline.Y] - y) * percent;
          }
          if (setupPose) {
            bone.shearX = bone.data.shearX + x * alpha;
            bone.shearY = bone.data.shearY + y * alpha;
          } else {
            bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
            bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
          }
        };
        return ShearTimeline;
      })(TranslateTimeline);
      spine.ShearTimeline = ShearTimeline;
      var ColorTimeline = (function(_super) {
        __extends(ColorTimeline, _super);
        function ColorTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);
        }
        ColorTimeline.prototype.getPropertyId = function() {
          return (TimelineType.color << 24) + this.slotIndex;
        };
        ColorTimeline.prototype.setFrame = function(frameIndex, time, r, g, b, a) {
          frameIndex *= ColorTimeline.ENTRIES;
          this.frames[frameIndex] = time;
          this.frames[frameIndex + ColorTimeline.R] = r;
          this.frames[frameIndex + ColorTimeline.G] = g;
          this.frames[frameIndex + ColorTimeline.B] = b;
          this.frames[frameIndex + ColorTimeline.A] = a;
        };
        ColorTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
          var slot = skeleton.slots[this.slotIndex];
          var frames = this.frames;
          if (time < frames[0]) {
            setupPose && slot.color.setFromColor(slot.data.color);
            return;
          }
          var r = 0, g = 0, b = 0, a = 0;
          if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {
            var i = frames.length;
            r = frames[i + ColorTimeline.PREV_R];
            g = frames[i + ColorTimeline.PREV_G];
            b = frames[i + ColorTimeline.PREV_B];
            a = frames[i + ColorTimeline.PREV_A];
          } else {
            var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);
            r = frames[frame + ColorTimeline.PREV_R];
            g = frames[frame + ColorTimeline.PREV_G];
            b = frames[frame + ColorTimeline.PREV_B];
            a = frames[frame + ColorTimeline.PREV_A];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));
            r += (frames[frame + ColorTimeline.R] - r) * percent;
            g += (frames[frame + ColorTimeline.G] - g) * percent;
            b += (frames[frame + ColorTimeline.B] - b) * percent;
            a += (frames[frame + ColorTimeline.A] - a) * percent;
          }
          if (1 == alpha) slot.color.set(r, g, b, a); else {
            var color = slot.color;
            setupPose && color.setFromColor(slot.data.color);
            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
          }
        };
        ColorTimeline.ENTRIES = 5;
        ColorTimeline.PREV_TIME = -5;
        ColorTimeline.PREV_R = -4;
        ColorTimeline.PREV_G = -3;
        ColorTimeline.PREV_B = -2;
        ColorTimeline.PREV_A = -1;
        ColorTimeline.R = 1;
        ColorTimeline.G = 2;
        ColorTimeline.B = 3;
        ColorTimeline.A = 4;
        return ColorTimeline;
      })(CurveTimeline);
      spine.ColorTimeline = ColorTimeline;
      var AttachmentTimeline = (function() {
        function AttachmentTimeline(frameCount) {
          this.frames = spine.Utils.newFloatArray(frameCount);
          this.attachmentNames = new Array(frameCount);
        }
        AttachmentTimeline.prototype.getPropertyId = function() {
          return (TimelineType.attachment << 24) + this.slotIndex;
        };
        AttachmentTimeline.prototype.getFrameCount = function() {
          return this.frames.length;
        };
        AttachmentTimeline.prototype.setFrame = function(frameIndex, time, attachmentName) {
          this.frames[frameIndex] = time;
          this.attachmentNames[frameIndex] = attachmentName;
        };
        AttachmentTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
          var slot = skeleton.slots[this.slotIndex];
          if (mixingOut && setupPose) {
            var attachmentName_1 = slot.data.attachmentName;
            slot.setAttachment(null == attachmentName_1 ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
            return;
          }
          var frames = this.frames;
          if (time < frames[0]) {
            if (setupPose) {
              var attachmentName_2 = slot.data.attachmentName;
              slot.setAttachment(null == attachmentName_2 ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
            }
            return;
          }
          var frameIndex = 0;
          frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : Animation.binarySearch(frames, time, 1) - 1;
          var attachmentName = this.attachmentNames[frameIndex];
          skeleton.slots[this.slotIndex].setAttachment(null == attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
        };
        return AttachmentTimeline;
      })();
      spine.AttachmentTimeline = AttachmentTimeline;
      var DeformTimeline = (function(_super) {
        __extends(DeformTimeline, _super);
        function DeformTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount);
          this.frameVertices = new Array(frameCount);
        }
        DeformTimeline.prototype.getPropertyId = function() {
          return (TimelineType.deform << 24) + this.slotIndex;
        };
        DeformTimeline.prototype.setFrame = function(frameIndex, time, vertices) {
          this.frames[frameIndex] = time;
          this.frameVertices[frameIndex] = vertices;
        };
        DeformTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          var slot = skeleton.slots[this.slotIndex];
          var slotAttachment = slot.getAttachment();
          if (!(slotAttachment instanceof spine.VertexAttachment) || !slotAttachment.applyDeform(this.attachment)) return;
          var frames = this.frames;
          var verticesArray = slot.attachmentVertices;
          if (time < frames[0]) {
            setupPose && spine.Utils.setArraySize(verticesArray, 0);
            return;
          }
          var frameVertices = this.frameVertices;
          var vertexCount = frameVertices[0].length;
          verticesArray.length != vertexCount && (alpha = 1);
          var vertices = spine.Utils.setArraySize(verticesArray, vertexCount);
          if (time >= frames[frames.length - 1]) {
            var lastVertices = frameVertices[frames.length - 1];
            if (1 == alpha) spine.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount); else if (setupPose) {
              var vertexAttachment = slotAttachment;
              if (null == vertexAttachment.bones) {
                var setupVertices = vertexAttachment.vertices;
                for (var i = 0; i < vertexCount; i++) {
                  var setup = setupVertices[i];
                  vertices[i] = setup + (lastVertices[i] - setup) * alpha;
                }
              } else for (var i = 0; i < vertexCount; i++) vertices[i] = lastVertices[i] * alpha;
            } else for (var i = 0; i < vertexCount; i++) vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
            return;
          }
          var frame = Animation.binarySearch(frames, time);
          var prevVertices = frameVertices[frame - 1];
          var nextVertices = frameVertices[frame];
          var frameTime = frames[frame];
          var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
          if (1 == alpha) for (var i = 0; i < vertexCount; i++) {
            var prev = prevVertices[i];
            vertices[i] = prev + (nextVertices[i] - prev) * percent;
          } else if (setupPose) {
            var vertexAttachment = slotAttachment;
            if (null == vertexAttachment.bones) {
              var setupVertices = vertexAttachment.vertices;
              for (var i = 0; i < vertexCount; i++) {
                var prev = prevVertices[i], setup = setupVertices[i];
                vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
              }
            } else for (var i = 0; i < vertexCount; i++) {
              var prev = prevVertices[i];
              vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
            }
          } else for (var i = 0; i < vertexCount; i++) {
            var prev = prevVertices[i];
            vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
          }
        };
        return DeformTimeline;
      })(CurveTimeline);
      spine.DeformTimeline = DeformTimeline;
      var EventTimeline = (function() {
        function EventTimeline(frameCount) {
          this.frames = spine.Utils.newFloatArray(frameCount);
          this.events = new Array(frameCount);
        }
        EventTimeline.prototype.getPropertyId = function() {
          return TimelineType.event << 24;
        };
        EventTimeline.prototype.getFrameCount = function() {
          return this.frames.length;
        };
        EventTimeline.prototype.setFrame = function(frameIndex, event) {
          this.frames[frameIndex] = event.time;
          this.events[frameIndex] = event;
        };
        EventTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          if (null == firedEvents) return;
          var frames = this.frames;
          var frameCount = this.frames.length;
          if (lastTime > time) {
            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, setupPose, mixingOut);
            lastTime = -1;
          } else if (lastTime >= frames[frameCount - 1]) return;
          if (time < frames[0]) return;
          var frame = 0;
          if (lastTime < frames[0]) frame = 0; else {
            frame = Animation.binarySearch(frames, lastTime);
            var frameTime = frames[frame];
            while (frame > 0) {
              if (frames[frame - 1] != frameTime) break;
              frame--;
            }
          }
          for (;frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);
        };
        return EventTimeline;
      })();
      spine.EventTimeline = EventTimeline;
      var DrawOrderTimeline = (function() {
        function DrawOrderTimeline(frameCount) {
          this.frames = spine.Utils.newFloatArray(frameCount);
          this.drawOrders = new Array(frameCount);
        }
        DrawOrderTimeline.prototype.getPropertyId = function() {
          return TimelineType.drawOrder << 24;
        };
        DrawOrderTimeline.prototype.getFrameCount = function() {
          return this.frames.length;
        };
        DrawOrderTimeline.prototype.setFrame = function(frameIndex, time, drawOrder) {
          this.frames[frameIndex] = time;
          this.drawOrders[frameIndex] = drawOrder;
        };
        DrawOrderTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          var drawOrder = skeleton.drawOrder;
          var slots = skeleton.slots;
          if (mixingOut && setupPose) {
            spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
            return;
          }
          var frames = this.frames;
          if (time < frames[0]) {
            setupPose && spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
            return;
          }
          var frame = 0;
          frame = time >= frames[frames.length - 1] ? frames.length - 1 : Animation.binarySearch(frames, time) - 1;
          var drawOrderToSetupIndex = this.drawOrders[frame];
          if (null == drawOrderToSetupIndex) spine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length); else for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];
        };
        return DrawOrderTimeline;
      })();
      spine.DrawOrderTimeline = DrawOrderTimeline;
      var IkConstraintTimeline = (function(_super) {
        __extends(IkConstraintTimeline, _super);
        function IkConstraintTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);
        }
        IkConstraintTimeline.prototype.getPropertyId = function() {
          return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
        };
        IkConstraintTimeline.prototype.setFrame = function(frameIndex, time, mix, bendDirection) {
          frameIndex *= IkConstraintTimeline.ENTRIES;
          this.frames[frameIndex] = time;
          this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;
          this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
        };
        IkConstraintTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
          if (time < frames[0]) {
            if (setupPose) {
              constraint.mix = constraint.data.mix;
              constraint.bendDirection = constraint.data.bendDirection;
            }
            return;
          }
          if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {
            if (setupPose) {
              constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
              constraint.bendDirection = mixingOut ? constraint.data.bendDirection : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
            } else {
              constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
              mixingOut || (constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]);
            }
            return;
          }
          var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);
          var mix = frames[frame + IkConstraintTimeline.PREV_MIX];
          var frameTime = frames[frame];
          var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));
          if (setupPose) {
            constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
            constraint.bendDirection = mixingOut ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
          } else {
            constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
            mixingOut || (constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);
          }
        };
        IkConstraintTimeline.ENTRIES = 3;
        IkConstraintTimeline.PREV_TIME = -3;
        IkConstraintTimeline.PREV_MIX = -2;
        IkConstraintTimeline.PREV_BEND_DIRECTION = -1;
        IkConstraintTimeline.MIX = 1;
        IkConstraintTimeline.BEND_DIRECTION = 2;
        return IkConstraintTimeline;
      })(CurveTimeline);
      spine.IkConstraintTimeline = IkConstraintTimeline;
      var TransformConstraintTimeline = (function(_super) {
        __extends(TransformConstraintTimeline, _super);
        function TransformConstraintTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);
        }
        TransformConstraintTimeline.prototype.getPropertyId = function() {
          return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
        };
        TransformConstraintTimeline.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
          frameIndex *= TransformConstraintTimeline.ENTRIES;
          this.frames[frameIndex] = time;
          this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;
          this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;
          this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;
          this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;
        };
        TransformConstraintTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
          if (time < frames[0]) {
            if (setupPose) {
              var data = constraint.data;
              constraint.rotateMix = data.rotateMix;
              constraint.translateMix = data.rotateMix;
              constraint.scaleMix = data.scaleMix;
              constraint.shearMix = data.shearMix;
            }
            return;
          }
          var rotate = 0, translate = 0, scale = 0, shear = 0;
          if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {
            var i = frames.length;
            rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];
            translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];
            scale = frames[i + TransformConstraintTimeline.PREV_SCALE];
            shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];
          } else {
            var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);
            rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];
            translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];
            scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];
            shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));
            rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;
            translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;
            scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;
            shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;
          }
          if (setupPose) {
            var data = constraint.data;
            constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
            constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
            constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
            constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
          } else {
            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
            constraint.translateMix += (translate - constraint.translateMix) * alpha;
            constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
            constraint.shearMix += (shear - constraint.shearMix) * alpha;
          }
        };
        TransformConstraintTimeline.ENTRIES = 5;
        TransformConstraintTimeline.PREV_TIME = -5;
        TransformConstraintTimeline.PREV_ROTATE = -4;
        TransformConstraintTimeline.PREV_TRANSLATE = -3;
        TransformConstraintTimeline.PREV_SCALE = -2;
        TransformConstraintTimeline.PREV_SHEAR = -1;
        TransformConstraintTimeline.ROTATE = 1;
        TransformConstraintTimeline.TRANSLATE = 2;
        TransformConstraintTimeline.SCALE = 3;
        TransformConstraintTimeline.SHEAR = 4;
        return TransformConstraintTimeline;
      })(CurveTimeline);
      spine.TransformConstraintTimeline = TransformConstraintTimeline;
      var PathConstraintPositionTimeline = (function(_super) {
        __extends(PathConstraintPositionTimeline, _super);
        function PathConstraintPositionTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);
        }
        PathConstraintPositionTimeline.prototype.getPropertyId = function() {
          return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
        };
        PathConstraintPositionTimeline.prototype.setFrame = function(frameIndex, time, value) {
          frameIndex *= PathConstraintPositionTimeline.ENTRIES;
          this.frames[frameIndex] = time;
          this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;
        };
        PathConstraintPositionTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
          if (time < frames[0]) {
            setupPose && (constraint.position = constraint.data.position);
            return;
          }
          var position = 0;
          if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE]; else {
            var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);
            position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));
            position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;
          }
          setupPose ? constraint.position = constraint.data.position + (position - constraint.data.position) * alpha : constraint.position += (position - constraint.position) * alpha;
        };
        PathConstraintPositionTimeline.ENTRIES = 2;
        PathConstraintPositionTimeline.PREV_TIME = -2;
        PathConstraintPositionTimeline.PREV_VALUE = -1;
        PathConstraintPositionTimeline.VALUE = 1;
        return PathConstraintPositionTimeline;
      })(CurveTimeline);
      spine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
      var PathConstraintSpacingTimeline = (function(_super) {
        __extends(PathConstraintSpacingTimeline, _super);
        function PathConstraintSpacingTimeline(frameCount) {
          _super.call(this, frameCount);
        }
        PathConstraintSpacingTimeline.prototype.getPropertyId = function() {
          return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
        };
        PathConstraintSpacingTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
          if (time < frames[0]) {
            setupPose && (constraint.spacing = constraint.data.spacing);
            return;
          }
          var spacing = 0;
          if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE]; else {
            var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
            spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));
            spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
          }
          setupPose ? constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha : constraint.spacing += (spacing - constraint.spacing) * alpha;
        };
        return PathConstraintSpacingTimeline;
      })(PathConstraintPositionTimeline);
      spine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
      var PathConstraintMixTimeline = (function(_super) {
        __extends(PathConstraintMixTimeline, _super);
        function PathConstraintMixTimeline(frameCount) {
          _super.call(this, frameCount);
          this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);
        }
        PathConstraintMixTimeline.prototype.getPropertyId = function() {
          return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
        };
        PathConstraintMixTimeline.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
          frameIndex *= PathConstraintMixTimeline.ENTRIES;
          this.frames[frameIndex] = time;
          this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;
          this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;
        };
        PathConstraintMixTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
          var frames = this.frames;
          var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
          if (time < frames[0]) {
            if (setupPose) {
              constraint.rotateMix = constraint.data.rotateMix;
              constraint.translateMix = constraint.data.translateMix;
            }
            return;
          }
          var rotate = 0, translate = 0;
          if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {
            rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];
            translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];
          } else {
            var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);
            rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];
            translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];
            var frameTime = frames[frame];
            var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));
            rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;
            translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
          }
          if (setupPose) {
            constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
            constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
          } else {
            constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
            constraint.translateMix += (translate - constraint.translateMix) * alpha;
          }
        };
        PathConstraintMixTimeline.ENTRIES = 3;
        PathConstraintMixTimeline.PREV_TIME = -3;
        PathConstraintMixTimeline.PREV_ROTATE = -2;
        PathConstraintMixTimeline.PREV_TRANSLATE = -1;
        PathConstraintMixTimeline.ROTATE = 1;
        PathConstraintMixTimeline.TRANSLATE = 2;
        return PathConstraintMixTimeline;
      })(CurveTimeline);
      spine.PathConstraintMixTimeline = PathConstraintMixTimeline;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var AnimationState = (function() {
        function AnimationState(data) {
          this.tracks = new Array();
          this.events = new Array();
          this.listeners = new Array();
          this.queue = new EventQueue(this);
          this.propertyIDs = new spine.IntSet();
          this.animationsChanged = false;
          this.timeScale = 1;
          this.trackEntryPool = new spine.Pool(function() {
            return new TrackEntry();
          });
          this.data = data;
        }
        AnimationState.prototype.update = function(delta) {
          delta *= this.timeScale;
          var tracks = this.tracks;
          for (var i = 0, n = tracks.length; i < n; i++) {
            var current = tracks[i];
            if (null == current) continue;
            current.animationLast = current.nextAnimationLast;
            current.trackLast = current.nextTrackLast;
            var currentDelta = delta * current.timeScale;
            if (current.delay > 0) {
              current.delay -= currentDelta;
              if (current.delay > 0) continue;
              currentDelta = -current.delay;
              current.delay = 0;
            }
            var next = current.next;
            if (null != next) {
              var nextTime = current.trackLast - next.delay;
              if (nextTime >= 0) {
                next.delay = 0;
                next.trackTime = nextTime + delta * next.timeScale;
                current.trackTime += currentDelta;
                this.setCurrent(i, next, true);
                while (null != next.mixingFrom) {
                  next.mixTime += currentDelta;
                  next = next.mixingFrom;
                }
                continue;
              }
            } else if (current.trackLast >= current.trackEnd && null == current.mixingFrom) {
              tracks[i] = null;
              this.queue.end(current);
              this.disposeNext(current);
              continue;
            }
            this.updateMixingFrom(current, delta);
            current.trackTime += currentDelta;
          }
          this.queue.drain();
        };
        AnimationState.prototype.updateMixingFrom = function(entry, delta) {
          var from = entry.mixingFrom;
          if (null == from) return;
          this.updateMixingFrom(from, delta);
          if (entry.mixTime >= entry.mixDuration && null != from.mixingFrom && entry.mixTime > 0) {
            entry.mixingFrom = null;
            this.queue.end(from);
            return;
          }
          from.animationLast = from.nextAnimationLast;
          from.trackLast = from.nextTrackLast;
          from.trackTime += delta * from.timeScale;
          entry.mixTime += delta * from.timeScale;
        };
        AnimationState.prototype.apply = function(skeleton) {
          if (null == skeleton) throw new Error("skeleton cannot be null.");
          this.animationsChanged && this._animationsChanged();
          var events = this.events;
          var tracks = this.tracks;
          for (var i = 0, n = tracks.length; i < n; i++) {
            var current = tracks[i];
            if (null == current || current.delay > 0) continue;
            var mix = current.alpha;
            null != current.mixingFrom ? mix *= this.applyMixingFrom(current, skeleton) : current.trackTime >= current.trackEnd && (mix = 0);
            var animationLast = current.animationLast, animationTime = current.getAnimationTime();
            var timelineCount = current.animation.timelines.length;
            var timelines = current.animation.timelines;
            if (1 == mix) for (var ii = 0; ii < timelineCount; ii++) timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, true, false); else {
              var firstFrame = 0 == current.timelinesRotation.length;
              firstFrame && spine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
              var timelinesRotation = current.timelinesRotation;
              var timelinesFirst = current.timelinesFirst;
              for (var ii = 0; ii < timelineCount; ii++) {
                var timeline = timelines[ii];
                timeline instanceof spine.RotateTimeline ? this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelinesFirst[ii], timelinesRotation, ii << 1, firstFrame) : timeline.apply(skeleton, animationLast, animationTime, events, mix, timelinesFirst[ii], false);
              }
            }
            this.queueEvents(current, animationTime);
            events.length = 0;
            current.nextAnimationLast = animationTime;
            current.nextTrackLast = current.trackTime;
          }
          this.queue.drain();
        };
        AnimationState.prototype.applyMixingFrom = function(entry, skeleton) {
          var from = entry.mixingFrom;
          null != from.mixingFrom && this.applyMixingFrom(from, skeleton);
          var mix = 0;
          if (0 == entry.mixDuration) mix = 1; else {
            mix = entry.mixTime / entry.mixDuration;
            mix > 1 && (mix = 1);
          }
          var events = mix < from.eventThreshold ? this.events : null;
          var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
          var animationLast = from.animationLast, animationTime = from.getAnimationTime();
          var timelineCount = from.animation.timelines.length;
          var timelines = from.animation.timelines;
          var timelinesFirst = from.timelinesFirst;
          var alpha = from.alpha * entry.mixAlpha * (1 - mix);
          var firstFrame = 0 == from.timelinesRotation.length;
          firstFrame && spine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
          var timelinesRotation = from.timelinesRotation;
          for (var i = 0; i < timelineCount; i++) {
            var timeline = timelines[i];
            var setupPose = timelinesFirst[i];
            if (timeline instanceof spine.RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, setupPose, timelinesRotation, i << 1, firstFrame); else {
              if (!setupPose) {
                if (!attachments && timeline instanceof spine.AttachmentTimeline) continue;
                if (!drawOrder && timeline instanceof spine.DrawOrderTimeline) continue;
              }
              timeline.apply(skeleton, animationLast, animationTime, events, alpha, setupPose, true);
            }
          }
          entry.mixDuration > 0 && this.queueEvents(from, animationTime);
          this.events.length = 0;
          from.nextAnimationLast = animationTime;
          from.nextTrackLast = from.trackTime;
          return mix;
        };
        AnimationState.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha, setupPose, timelinesRotation, i, firstFrame) {
          firstFrame && (timelinesRotation[i] = 0);
          if (1 == alpha) {
            timeline.apply(skeleton, 0, time, null, 1, setupPose, false);
            return;
          }
          var rotateTimeline = timeline;
          var frames = rotateTimeline.frames;
          var bone = skeleton.bones[rotateTimeline.boneIndex];
          if (time < frames[0]) {
            setupPose && (bone.rotation = bone.data.rotation);
            return;
          }
          var r2 = 0;
          if (time >= frames[frames.length - spine.RotateTimeline.ENTRIES]) r2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION]; else {
            var frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);
            var prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];
            var frameTime = frames[frame];
            var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));
            r2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;
            r2 -= 360 * (16384 - (16384.499999999996 - r2 / 360 | 0));
            r2 = prevRotation + r2 * percent + bone.data.rotation;
            r2 -= 360 * (16384 - (16384.499999999996 - r2 / 360 | 0));
          }
          var r1 = setupPose ? bone.data.rotation : bone.rotation;
          var total = 0, diff = r2 - r1;
          if (0 == diff) total = timelinesRotation[i]; else {
            diff -= 360 * (16384 - (16384.499999999996 - diff / 360 | 0));
            var lastTotal = 0, lastDiff = 0;
            if (firstFrame) {
              lastTotal = 0;
              lastDiff = diff;
            } else {
              lastTotal = timelinesRotation[i];
              lastDiff = timelinesRotation[i + 1];
            }
            var current = diff > 0, dir = lastTotal >= 0;
            if (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
              Math.abs(lastTotal) > 180 && (lastTotal += 360 * spine.MathUtils.signum(lastTotal));
              dir = current;
            }
            total = diff + lastTotal - lastTotal % 360;
            dir != current && (total += 360 * spine.MathUtils.signum(lastTotal));
            timelinesRotation[i] = total;
          }
          timelinesRotation[i + 1] = diff;
          r1 += total * alpha;
          bone.rotation = r1 - 360 * (16384 - (16384.499999999996 - r1 / 360 | 0));
        };
        AnimationState.prototype.queueEvents = function(entry, animationTime) {
          var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
          var duration = animationEnd - animationStart;
          var trackLastWrapped = entry.trackLast % duration;
          var events = this.events;
          var i = 0, n = events.length;
          for (;i < n; i++) {
            var event_1 = events[i];
            if (event_1.time < trackLastWrapped) break;
            if (event_1.time > animationEnd) continue;
            this.queue.event(entry, event_1);
          }
          (entry.loop ? trackLastWrapped > entry.trackTime % duration : animationTime >= animationEnd && entry.animationLast < animationEnd) && this.queue.complete(entry);
          for (;i < n; i++) {
            var event_2 = events[i];
            if (event_2.time < animationStart) continue;
            this.queue.event(entry, events[i]);
          }
        };
        AnimationState.prototype.clearTracks = function() {
          this.queue.drainDisabled = true;
          for (var i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);
          this.tracks.length = 0;
          this.queue.drainDisabled = false;
          this.queue.drain();
        };
        AnimationState.prototype.clearTrack = function(trackIndex) {
          if (trackIndex >= this.tracks.length) return;
          var current = this.tracks[trackIndex];
          if (null == current) return;
          this.queue.end(current);
          this.disposeNext(current);
          var entry = current;
          while (true) {
            var from = entry.mixingFrom;
            if (null == from) break;
            this.queue.end(from);
            entry.mixingFrom = null;
            entry = from;
          }
          this.tracks[current.trackIndex] = null;
          this.queue.drain();
        };
        AnimationState.prototype.setCurrent = function(index, current, interrupt) {
          var from = this.expandToIndex(index);
          this.tracks[index] = current;
          if (null != from) {
            interrupt && this.queue.interrupt(from);
            current.mixingFrom = from;
            current.mixTime = 0;
            from.timelinesRotation.length = 0;
            null != from.mixingFrom && from.mixDuration > 0 && (current.mixAlpha *= Math.min(from.mixTime / from.mixDuration, 1));
          }
          this.queue.start(current);
        };
        AnimationState.prototype.setAnimation = function(trackIndex, animationName, loop) {
          var animation = this.data.skeletonData.findAnimation(animationName);
          if (null == animation) throw new Error("Animation not found: " + animationName);
          return this.setAnimationWith(trackIndex, animation, loop);
        };
        AnimationState.prototype.setAnimationWith = function(trackIndex, animation, loop) {
          if (null == animation) throw new Error("animation cannot be null.");
          var interrupt = true;
          var current = this.expandToIndex(trackIndex);
          if (null != current) if (-1 == current.nextTrackLast) {
            this.tracks[trackIndex] = current.mixingFrom;
            this.queue.interrupt(current);
            this.queue.end(current);
            this.disposeNext(current);
            current = current.mixingFrom;
            interrupt = false;
          } else this.disposeNext(current);
          var entry = this.trackEntry(trackIndex, animation, loop, current);
          this.setCurrent(trackIndex, entry, interrupt);
          this.queue.drain();
          return entry;
        };
        AnimationState.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
          var animation = this.data.skeletonData.findAnimation(animationName);
          if (null == animation) throw new Error("Animation not found: " + animationName);
          return this.addAnimationWith(trackIndex, animation, loop, delay);
        };
        AnimationState.prototype.addAnimationWith = function(trackIndex, animation, loop, delay) {
          if (null == animation) throw new Error("animation cannot be null.");
          var last = this.expandToIndex(trackIndex);
          if (null != last) while (null != last.next) last = last.next;
          var entry = this.trackEntry(trackIndex, animation, loop, last);
          if (null == last) {
            this.setCurrent(trackIndex, entry, true);
            this.queue.drain();
          } else {
            last.next = entry;
            if (delay <= 0) {
              var duration = last.animationEnd - last.animationStart;
              0 != duration ? delay += duration * (1 + (last.trackTime / duration | 0)) - this.data.getMix(last.animation, animation) : delay = 0;
            }
          }
          entry.delay = delay;
          return entry;
        };
        AnimationState.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
          var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);
          entry.mixDuration = mixDuration;
          entry.trackEnd = mixDuration;
          return entry;
        };
        AnimationState.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
          delay <= 0 && (delay -= mixDuration);
          var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);
          entry.mixDuration = mixDuration;
          entry.trackEnd = mixDuration;
          return entry;
        };
        AnimationState.prototype.setEmptyAnimations = function(mixDuration) {
          this.queue.drainDisabled = true;
          for (var i = 0, n = this.tracks.length; i < n; i++) {
            var current = this.tracks[i];
            null != current && this.setEmptyAnimation(current.trackIndex, mixDuration);
          }
          this.queue.drainDisabled = false;
          this.queue.drain();
        };
        AnimationState.prototype.expandToIndex = function(index) {
          if (index < this.tracks.length) return this.tracks[index];
          spine.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
          this.tracks.length = index + 1;
          return null;
        };
        AnimationState.prototype.trackEntry = function(trackIndex, animation, loop, last) {
          var entry = this.trackEntryPool.obtain();
          entry.trackIndex = trackIndex;
          entry.animation = animation;
          entry.loop = loop;
          entry.eventThreshold = 0;
          entry.attachmentThreshold = 0;
          entry.drawOrderThreshold = 0;
          entry.animationStart = 0;
          entry.animationEnd = animation.duration;
          entry.animationLast = -1;
          entry.nextAnimationLast = -1;
          entry.delay = 0;
          entry.trackTime = 0;
          entry.trackLast = -1;
          entry.nextTrackLast = -1;
          entry.trackEnd = Number.MAX_VALUE;
          entry.timeScale = 1;
          entry.alpha = 1;
          entry.mixAlpha = 1;
          entry.mixTime = 0;
          entry.mixDuration = null == last ? 0 : this.data.getMix(last.animation, animation);
          return entry;
        };
        AnimationState.prototype.disposeNext = function(entry) {
          var next = entry.next;
          while (null != next) {
            this.queue.dispose(next);
            next = next.next;
          }
          entry.next = null;
        };
        AnimationState.prototype._animationsChanged = function() {
          this.animationsChanged = false;
          var propertyIDs = this.propertyIDs;
          var i = 0, n = this.tracks.length;
          propertyIDs.clear();
          for (;i < n; i++) {
            var entry = this.tracks[i];
            if (null == entry) continue;
            this.setTimelinesFirst(entry);
            i++;
            break;
          }
          for (;i < n; i++) {
            var entry = this.tracks[i];
            null != entry && this.checkTimelinesFirst(entry);
          }
        };
        AnimationState.prototype.setTimelinesFirst = function(entry) {
          if (null != entry.mixingFrom) {
            this.setTimelinesFirst(entry.mixingFrom);
            this.checkTimelinesUsage(entry, entry.timelinesFirst);
            return;
          }
          var propertyIDs = this.propertyIDs;
          var timelines = entry.animation.timelines;
          var n = timelines.length;
          var usage = spine.Utils.setArraySize(entry.timelinesFirst, n, false);
          for (var i = 0; i < n; i++) {
            propertyIDs.add(timelines[i].getPropertyId());
            usage[i] = true;
          }
        };
        AnimationState.prototype.checkTimelinesFirst = function(entry) {
          null != entry.mixingFrom && this.checkTimelinesFirst(entry.mixingFrom);
          this.checkTimelinesUsage(entry, entry.timelinesFirst);
        };
        AnimationState.prototype.checkTimelinesUsage = function(entry, usageArray) {
          var propertyIDs = this.propertyIDs;
          var timelines = entry.animation.timelines;
          var n = timelines.length;
          var usage = spine.Utils.setArraySize(usageArray, n);
          for (var i = 0; i < n; i++) usage[i] = propertyIDs.add(timelines[i].getPropertyId());
        };
        AnimationState.prototype.getCurrent = function(trackIndex) {
          if (trackIndex >= this.tracks.length) return null;
          return this.tracks[trackIndex];
        };
        AnimationState.prototype.addListener = function(listener) {
          if (null == listener) throw new Error("listener cannot be null.");
          this.listeners.push(listener);
        };
        AnimationState.prototype.removeListener = function(listener) {
          var index = this.listeners.indexOf(listener);
          index >= 0 && this.listeners.splice(index, 1);
        };
        AnimationState.prototype.clearListeners = function() {
          this.listeners.length = 0;
        };
        AnimationState.prototype.clearListenerNotifications = function() {
          this.queue.clear();
        };
        AnimationState.emptyAnimation = new spine.Animation("<empty>", [], 0);
        return AnimationState;
      })();
      spine.AnimationState = AnimationState;
      var TrackEntry = (function() {
        function TrackEntry() {
          this.timelinesFirst = new Array();
          this.timelinesRotation = new Array();
        }
        TrackEntry.prototype.reset = function() {
          this.next = null;
          this.mixingFrom = null;
          this.animation = null;
          this.listener = null;
          this.timelinesFirst.length = 0;
          this.timelinesRotation.length = 0;
        };
        TrackEntry.prototype.getAnimationTime = function() {
          if (this.loop) {
            var duration = this.animationEnd - this.animationStart;
            if (0 == duration) return this.animationStart;
            return this.trackTime % duration + this.animationStart;
          }
          return Math.min(this.trackTime + this.animationStart, this.animationEnd);
        };
        TrackEntry.prototype.setAnimationLast = function(animationLast) {
          this.animationLast = animationLast;
          this.nextAnimationLast = animationLast;
        };
        TrackEntry.prototype.isComplete = function() {
          return this.trackTime >= this.animationEnd - this.animationStart;
        };
        TrackEntry.prototype.resetRotationDirections = function() {
          this.timelinesRotation.length = 0;
        };
        return TrackEntry;
      })();
      spine.TrackEntry = TrackEntry;
      var EventQueue = (function() {
        function EventQueue(animState) {
          this.objects = [];
          this.drainDisabled = false;
          this.animState = animState;
        }
        EventQueue.prototype.start = function(entry) {
          this.objects.push(EventType.start);
          this.objects.push(entry);
          this.animState.animationsChanged = true;
        };
        EventQueue.prototype.interrupt = function(entry) {
          this.objects.push(EventType.interrupt);
          this.objects.push(entry);
        };
        EventQueue.prototype.end = function(entry) {
          this.objects.push(EventType.end);
          this.objects.push(entry);
          this.animState.animationsChanged = true;
        };
        EventQueue.prototype.dispose = function(entry) {
          this.objects.push(EventType.dispose);
          this.objects.push(entry);
        };
        EventQueue.prototype.complete = function(entry) {
          this.objects.push(EventType.complete);
          this.objects.push(entry);
        };
        EventQueue.prototype.event = function(entry, event) {
          this.objects.push(EventType.event);
          this.objects.push(entry);
          this.objects.push(event);
        };
        EventQueue.prototype.drain = function() {
          if (this.drainDisabled) return;
          this.drainDisabled = true;
          var objects = this.objects;
          var listeners = this.animState.listeners;
          for (var i = 0; i < objects.length; i += 2) {
            var type = objects[i];
            var entry = objects[i + 1];
            switch (type) {
             case EventType.start:
              null != entry.listener && entry.listener.start && entry.listener.start(entry);
              for (var ii = 0; ii < listeners.length; ii++) listeners[ii].start && listeners[ii].start(entry);
              break;

             case EventType.interrupt:
              null != entry.listener && entry.listener.interrupt && entry.listener.interrupt(entry);
              for (var ii = 0; ii < listeners.length; ii++) listeners[ii].interrupt && listeners[ii].interrupt(entry);
              break;

             case EventType.end:
              null != entry.listener && entry.listener.end && entry.listener.end(entry);
              for (var ii = 0; ii < listeners.length; ii++) listeners[ii].end && listeners[ii].end(entry);

             case EventType.dispose:
              null != entry.listener && entry.listener.dispose && entry.listener.dispose(entry);
              for (var ii = 0; ii < listeners.length; ii++) listeners[ii].dispose && listeners[ii].dispose(entry);
              this.animState.trackEntryPool.free(entry);
              break;

             case EventType.complete:
              null != entry.listener && entry.listener.complete && entry.listener.complete(entry);
              for (var ii = 0; ii < listeners.length; ii++) listeners[ii].complete && listeners[ii].complete(entry);
              break;

             case EventType.event:
              var event_3 = objects[2 + i++];
              null != entry.listener && entry.listener.event && entry.listener.event(entry, event_3);
              for (var ii = 0; ii < listeners.length; ii++) listeners[ii].event && listeners[ii].event(entry, event_3);
            }
          }
          this.clear();
          this.drainDisabled = false;
        };
        EventQueue.prototype.clear = function() {
          this.objects.length = 0;
        };
        return EventQueue;
      })();
      spine.EventQueue = EventQueue;
      (function(EventType) {
        EventType[EventType["start"] = 0] = "start";
        EventType[EventType["interrupt"] = 1] = "interrupt";
        EventType[EventType["end"] = 2] = "end";
        EventType[EventType["dispose"] = 3] = "dispose";
        EventType[EventType["complete"] = 4] = "complete";
        EventType[EventType["event"] = 5] = "event";
      })(spine.EventType || (spine.EventType = {}));
      var EventType = spine.EventType;
      var AnimationStateAdapter2 = (function() {
        function AnimationStateAdapter2() {}
        AnimationStateAdapter2.prototype.start = function(entry) {};
        AnimationStateAdapter2.prototype.interrupt = function(entry) {};
        AnimationStateAdapter2.prototype.end = function(entry) {};
        AnimationStateAdapter2.prototype.dispose = function(entry) {};
        AnimationStateAdapter2.prototype.complete = function(entry) {};
        AnimationStateAdapter2.prototype.event = function(entry, event) {};
        return AnimationStateAdapter2;
      })();
      spine.AnimationStateAdapter2 = AnimationStateAdapter2;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var AnimationStateData = (function() {
        function AnimationStateData(skeletonData) {
          this.animationToMixTime = {};
          this.defaultMix = 0;
          if (null == skeletonData) throw new Error("skeletonData cannot be null.");
          this.skeletonData = skeletonData;
        }
        AnimationStateData.prototype.setMix = function(fromName, toName, duration) {
          var from = this.skeletonData.findAnimation(fromName);
          if (null == from) throw new Error("Animation not found: " + fromName);
          var to = this.skeletonData.findAnimation(toName);
          if (null == to) throw new Error("Animation not found: " + toName);
          this.setMixWith(from, to, duration);
        };
        AnimationStateData.prototype.setMixWith = function(from, to, duration) {
          if (null == from) throw new Error("from cannot be null.");
          if (null == to) throw new Error("to cannot be null.");
          var key = from.name + to.name;
          this.animationToMixTime[key] = duration;
        };
        AnimationStateData.prototype.getMix = function(from, to) {
          var key = from.name + to.name;
          var value = this.animationToMixTime[key];
          return void 0 === value ? this.defaultMix : value;
        };
        return AnimationStateData;
      })();
      spine.AnimationStateData = AnimationStateData;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var AssetManager = (function() {
        function AssetManager(textureLoader, pathPrefix) {
          void 0 === pathPrefix && (pathPrefix = "");
          this.assets = {};
          this.errors = {};
          this.toLoad = 0;
          this.loaded = 0;
          this.textureLoader = textureLoader;
          this.pathPrefix = pathPrefix;
        }
        AssetManager.prototype.loadText = function(path, success, error) {
          var _this = this;
          void 0 === success && (success = null);
          void 0 === error && (error = null);
          path = this.pathPrefix + path;
          this.toLoad++;
          var request = new XMLHttpRequest();
          request.onreadystatechange = function() {
            if (request.readyState == XMLHttpRequest.DONE) {
              if (request.status >= 200 && request.status < 300) {
                _this.assets[path] = request.responseText;
                success && success(path, request.responseText);
              } else {
                _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
                error && error(path, "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
              }
              _this.toLoad--;
              _this.loaded++;
            }
          };
          request.open("GET", path, true);
          request.send();
        };
        AssetManager.prototype.loadTexture = function(path, success, error) {
          var _this = this;
          void 0 === success && (success = null);
          void 0 === error && (error = null);
          path = this.pathPrefix + path;
          this.toLoad++;
          var img = new Image();
          img.crossOrigin = "anonymous";
          img.src = path;
          img.onload = function(ev) {
            var texture = _this.textureLoader(img);
            _this.assets[path] = texture;
            _this.toLoad--;
            _this.loaded++;
            success && success(path, img);
          };
          img.onerror = function(ev) {
            _this.errors[path] = "Couldn't load image " + path;
            _this.toLoad--;
            _this.loaded++;
            error && error(path, "Couldn't load image " + path);
          };
        };
        AssetManager.prototype.get = function(path) {
          path = this.pathPrefix + path;
          return this.assets[path];
        };
        AssetManager.prototype.remove = function(path) {
          path = this.pathPrefix + path;
          var asset = this.assets[path];
          asset.dispose && asset.dispose();
          this.assets[path] = null;
        };
        AssetManager.prototype.removeAll = function() {
          for (var key in this.assets) {
            var asset = this.assets[key];
            asset.dispose && asset.dispose();
          }
          this.assets = {};
        };
        AssetManager.prototype.isLoadingComplete = function() {
          return 0 == this.toLoad;
        };
        AssetManager.prototype.getToLoad = function() {
          return this.toLoad;
        };
        AssetManager.prototype.getLoaded = function() {
          return this.loaded;
        };
        AssetManager.prototype.dispose = function() {
          this.removeAll();
        };
        AssetManager.prototype.hasErrors = function() {
          return Object.keys(this.errors).length > 0;
        };
        AssetManager.prototype.getErrors = function() {
          return this.errors;
        };
        return AssetManager;
      })();
      spine.AssetManager = AssetManager;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var AtlasAttachmentLoader = (function() {
        function AtlasAttachmentLoader(atlas) {
          this.atlas = atlas;
        }
        AtlasAttachmentLoader.prototype.newRegionAttachment = function(skin, name, path) {
          var region = this.atlas.findRegion(path);
          if (null == region) throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
          region.renderObject = region;
          var attachment = new spine.RegionAttachment(name);
          attachment.setRegion(region);
          return attachment;
        };
        AtlasAttachmentLoader.prototype.newMeshAttachment = function(skin, name, path) {
          var region = this.atlas.findRegion(path);
          if (null == region) throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
          region.renderObject = region;
          var attachment = new spine.MeshAttachment(name);
          attachment.region = region;
          return attachment;
        };
        AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function(skin, name) {
          return new spine.BoundingBoxAttachment(name);
        };
        AtlasAttachmentLoader.prototype.newPathAttachment = function(skin, name) {
          return new spine.PathAttachment(name);
        };
        return AtlasAttachmentLoader;
      })();
      spine.AtlasAttachmentLoader = AtlasAttachmentLoader;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Attachment = (function() {
        function Attachment(name) {
          if (null == name) throw new Error("name cannot be null.");
          this.name = name;
        }
        return Attachment;
      })();
      spine.Attachment = Attachment;
      var VertexAttachment = (function(_super) {
        __extends(VertexAttachment, _super);
        function VertexAttachment(name) {
          _super.call(this, name);
          this.worldVerticesLength = 0;
        }
        VertexAttachment.prototype.computeWorldVertices = function(slot, worldVertices) {
          this.computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);
        };
        VertexAttachment.prototype.computeWorldVerticesWith = function(slot, start, count, worldVertices, offset) {
          count += offset;
          var skeleton = slot.bone.skeleton;
          var deformArray = slot.attachmentVertices;
          var vertices = this.vertices;
          var bones = this.bones;
          if (null == bones) {
            deformArray.length > 0 && (vertices = deformArray);
            var bone = slot.bone;
            var x = bone.worldX;
            var y = bone.worldY;
            var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
            for (var v_1 = start, w = offset; w < count; v_1 += 2, w += 2) {
              var vx = vertices[v_1], vy = vertices[v_1 + 1];
              worldVertices[w] = vx * a + vy * b + x;
              worldVertices[w + 1] = vx * c + vy * d + y;
            }
            return;
          }
          var v = 0, skip = 0;
          for (var i = 0; i < start; i += 2) {
            var n = bones[v];
            v += n + 1;
            skip += n;
          }
          var skeletonBones = skeleton.bones;
          if (0 == deformArray.length) for (var w = offset, b = 3 * skip; w < count; w += 2) {
            var wx = 0, wy = 0;
            var n = bones[v++];
            n += v;
            for (;v < n; v++, b += 3) {
              var bone = skeletonBones[bones[v]];
              var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
              wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
              wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
            }
            worldVertices[w] = wx;
            worldVertices[w + 1] = wy;
          } else {
            var deform = deformArray;
            for (var w = offset, b = 3 * skip, f = skip << 1; w < count; w += 2) {
              var wx = 0, wy = 0;
              var n = bones[v++];
              n += v;
              for (;v < n; v++, b += 3, f += 2) {
                var bone = skeletonBones[bones[v]];
                var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
                wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
              }
              worldVertices[w] = wx;
              worldVertices[w + 1] = wy;
            }
          }
        };
        VertexAttachment.prototype.applyDeform = function(sourceAttachment) {
          return this == sourceAttachment;
        };
        return VertexAttachment;
      })(Attachment);
      spine.VertexAttachment = VertexAttachment;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      (function(AttachmentType) {
        AttachmentType[AttachmentType["Region"] = 0] = "Region";
        AttachmentType[AttachmentType["BoundingBox"] = 1] = "BoundingBox";
        AttachmentType[AttachmentType["Mesh"] = 2] = "Mesh";
        AttachmentType[AttachmentType["LinkedMesh"] = 3] = "LinkedMesh";
        AttachmentType[AttachmentType["Path"] = 4] = "Path";
      })(spine.AttachmentType || (spine.AttachmentType = {}));
      var AttachmentType = spine.AttachmentType;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var BoundingBoxAttachment = (function(_super) {
        __extends(BoundingBoxAttachment, _super);
        function BoundingBoxAttachment(name) {
          _super.call(this, name);
          this.color = new spine.Color(1, 1, 1, 1);
        }
        return BoundingBoxAttachment;
      })(spine.VertexAttachment);
      spine.BoundingBoxAttachment = BoundingBoxAttachment;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var MeshAttachment = (function(_super) {
        __extends(MeshAttachment, _super);
        function MeshAttachment(name) {
          _super.call(this, name);
          this.color = new spine.Color(1, 1, 1, 1);
          this.inheritDeform = false;
          this.tempColor = new spine.Color(0, 0, 0, 0);
        }
        MeshAttachment.prototype.updateUVs = function() {
          var regionUVs = this.regionUVs;
          var verticesLength = regionUVs.length;
          var worldVerticesLength = 8 * (verticesLength >> 1);
          null != this.worldVertices && this.worldVertices.length == worldVerticesLength || (this.worldVertices = spine.Utils.newFloatArray(worldVerticesLength));
          var u = 0, v = 0, width = 0, height = 0;
          if (null == this.region) {
            u = v = 0;
            width = height = 1;
          } else {
            u = this.region.u;
            v = this.region.v;
            width = this.region.u2 - u;
            height = this.region.v2 - v;
          }
          if (this.region.rotate) for (var i = 0, w = 6; i < verticesLength; i += 2, w += 8) {
            this.worldVertices[w] = u + regionUVs[i + 1] * width;
            this.worldVertices[w + 1] = v + height - regionUVs[i] * height;
          } else for (var i = 0, w = 6; i < verticesLength; i += 2, w += 8) {
            this.worldVertices[w] = u + regionUVs[i] * width;
            this.worldVertices[w + 1] = v + regionUVs[i + 1] * height;
          }
        };
        MeshAttachment.prototype.updateWorldVertices = function(slot, premultipliedAlpha) {
          var skeleton = slot.bone.skeleton;
          var skeletonColor = skeleton.color, slotColor = slot.color, meshColor = this.color;
          var alpha = skeletonColor.a * slotColor.a * meshColor.a;
          var multiplier = premultipliedAlpha ? alpha : 1;
          var color = this.tempColor;
          color.set(skeletonColor.r * slotColor.r * meshColor.r * multiplier, skeletonColor.g * slotColor.g * meshColor.g * multiplier, skeletonColor.b * slotColor.b * meshColor.b * multiplier, alpha);
          var deformArray = slot.attachmentVertices;
          var vertices = this.vertices, worldVertices = this.worldVertices;
          var bones = this.bones;
          if (null == bones) {
            var verticesLength = vertices.length;
            deformArray.length > 0 && (vertices = deformArray);
            var bone = slot.bone;
            var x = bone.worldX;
            var y = bone.worldY;
            var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
            for (var v = 0, w = 0; v < verticesLength; v += 2, w += 8) {
              var vx = vertices[v], vy = vertices[v + 1];
              worldVertices[w] = vx * a + vy * b + x;
              worldVertices[w + 1] = vx * c + vy * d + y;
              worldVertices[w + 2] = color.r;
              worldVertices[w + 3] = color.g;
              worldVertices[w + 4] = color.b;
              worldVertices[w + 5] = color.a;
            }
            return worldVertices;
          }
          var skeletonBones = skeleton.bones;
          if (0 == deformArray.length) for (var w = 0, v = 0, b = 0, n = bones.length; v < n; w += 8) {
            var wx = 0, wy = 0;
            var nn = bones[v++] + v;
            for (;v < nn; v++, b += 3) {
              var bone = skeletonBones[bones[v]];
              var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
              wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
              wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
            }
            worldVertices[w] = wx;
            worldVertices[w + 1] = wy;
            worldVertices[w + 2] = color.r;
            worldVertices[w + 3] = color.g;
            worldVertices[w + 4] = color.b;
            worldVertices[w + 5] = color.a;
          } else {
            var deform = deformArray;
            for (var w = 0, v = 0, b = 0, f = 0, n = bones.length; v < n; w += 8) {
              var wx = 0, wy = 0;
              var nn = bones[v++] + v;
              for (;v < nn; v++, b += 3, f += 2) {
                var bone = skeletonBones[bones[v]];
                var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
                wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
              }
              worldVertices[w] = wx;
              worldVertices[w + 1] = wy;
              worldVertices[w + 2] = color.r;
              worldVertices[w + 3] = color.g;
              worldVertices[w + 4] = color.b;
              worldVertices[w + 5] = color.a;
            }
          }
          return worldVertices;
        };
        MeshAttachment.prototype.applyDeform = function(sourceAttachment) {
          return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;
        };
        MeshAttachment.prototype.getParentMesh = function() {
          return this.parentMesh;
        };
        MeshAttachment.prototype.setParentMesh = function(parentMesh) {
          this.parentMesh = parentMesh;
          if (null != parentMesh) {
            this.bones = parentMesh.bones;
            this.vertices = parentMesh.vertices;
            this.regionUVs = parentMesh.regionUVs;
            this.triangles = parentMesh.triangles;
            this.hullLength = parentMesh.hullLength;
          }
        };
        return MeshAttachment;
      })(spine.VertexAttachment);
      spine.MeshAttachment = MeshAttachment;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var PathAttachment = (function(_super) {
        __extends(PathAttachment, _super);
        function PathAttachment(name) {
          _super.call(this, name);
          this.closed = false;
          this.constantSpeed = false;
          this.color = new spine.Color(1, 1, 1, 1);
        }
        return PathAttachment;
      })(spine.VertexAttachment);
      spine.PathAttachment = PathAttachment;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var RegionAttachment = (function(_super) {
        __extends(RegionAttachment, _super);
        function RegionAttachment(name) {
          _super.call(this, name);
          this.x = 0;
          this.y = 0;
          this.scaleX = 1;
          this.scaleY = 1;
          this.rotation = 0;
          this.width = 0;
          this.height = 0;
          this.color = new spine.Color(1, 1, 1, 1);
          this.offset = spine.Utils.newFloatArray(8);
          this.vertices = spine.Utils.newFloatArray(32);
          this.tempColor = new spine.Color(1, 1, 1, 1);
        }
        RegionAttachment.prototype.setRegion = function(region) {
          var vertices = this.vertices;
          if (region.rotate) {
            vertices[RegionAttachment.U2] = region.u;
            vertices[RegionAttachment.V2] = region.v2;
            vertices[RegionAttachment.U3] = region.u;
            vertices[RegionAttachment.V3] = region.v;
            vertices[RegionAttachment.U4] = region.u2;
            vertices[RegionAttachment.V4] = region.v;
            vertices[RegionAttachment.U1] = region.u2;
            vertices[RegionAttachment.V1] = region.v2;
          } else {
            vertices[RegionAttachment.U1] = region.u;
            vertices[RegionAttachment.V1] = region.v2;
            vertices[RegionAttachment.U2] = region.u;
            vertices[RegionAttachment.V2] = region.v;
            vertices[RegionAttachment.U3] = region.u2;
            vertices[RegionAttachment.V3] = region.v;
            vertices[RegionAttachment.U4] = region.u2;
            vertices[RegionAttachment.V4] = region.v2;
          }
          this.region = region;
        };
        RegionAttachment.prototype.updateOffset = function() {
          var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
          var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
          var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
          var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
          var localX2 = localX + this.region.width * regionScaleX;
          var localY2 = localY + this.region.height * regionScaleY;
          var radians = this.rotation * Math.PI / 180;
          var cos = Math.cos(radians);
          var sin = Math.sin(radians);
          var localXCos = localX * cos + this.x;
          var localXSin = localX * sin;
          var localYCos = localY * cos + this.y;
          var localYSin = localY * sin;
          var localX2Cos = localX2 * cos + this.x;
          var localX2Sin = localX2 * sin;
          var localY2Cos = localY2 * cos + this.y;
          var localY2Sin = localY2 * sin;
          var offset = this.offset;
          offset[RegionAttachment.OX1] = localXCos - localYSin;
          offset[RegionAttachment.OY1] = localYCos + localXSin;
          offset[RegionAttachment.OX2] = localXCos - localY2Sin;
          offset[RegionAttachment.OY2] = localY2Cos + localXSin;
          offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;
          offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;
          offset[RegionAttachment.OX4] = localX2Cos - localYSin;
          offset[RegionAttachment.OY4] = localYCos + localX2Sin;
        };
        RegionAttachment.prototype.updateWorldVertices = function(slot, premultipliedAlpha) {
          var skeleton = slot.bone.skeleton;
          var skeletonColor = skeleton.color;
          var slotColor = slot.color;
          var regionColor = this.color;
          var alpha = skeletonColor.a * slotColor.a * regionColor.a;
          var multiplier = premultipliedAlpha ? alpha : 1;
          var color = this.tempColor;
          color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);
          var vertices = this.vertices;
          var offset = this.offset;
          var bone = slot.bone;
          var x = bone.worldX, y = bone.worldY;
          var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
          var offsetX = 0, offsetY = 0;
          offsetX = offset[RegionAttachment.OX1];
          offsetY = offset[RegionAttachment.OY1];
          vertices[RegionAttachment.X1] = offsetX * a + offsetY * b + x;
          vertices[RegionAttachment.Y1] = offsetX * c + offsetY * d + y;
          vertices[RegionAttachment.C1R] = color.r;
          vertices[RegionAttachment.C1G] = color.g;
          vertices[RegionAttachment.C1B] = color.b;
          vertices[RegionAttachment.C1A] = color.a;
          offsetX = offset[RegionAttachment.OX2];
          offsetY = offset[RegionAttachment.OY2];
          vertices[RegionAttachment.X2] = offsetX * a + offsetY * b + x;
          vertices[RegionAttachment.Y2] = offsetX * c + offsetY * d + y;
          vertices[RegionAttachment.C2R] = color.r;
          vertices[RegionAttachment.C2G] = color.g;
          vertices[RegionAttachment.C2B] = color.b;
          vertices[RegionAttachment.C2A] = color.a;
          offsetX = offset[RegionAttachment.OX3];
          offsetY = offset[RegionAttachment.OY3];
          vertices[RegionAttachment.X3] = offsetX * a + offsetY * b + x;
          vertices[RegionAttachment.Y3] = offsetX * c + offsetY * d + y;
          vertices[RegionAttachment.C3R] = color.r;
          vertices[RegionAttachment.C3G] = color.g;
          vertices[RegionAttachment.C3B] = color.b;
          vertices[RegionAttachment.C3A] = color.a;
          offsetX = offset[RegionAttachment.OX4];
          offsetY = offset[RegionAttachment.OY4];
          vertices[RegionAttachment.X4] = offsetX * a + offsetY * b + x;
          vertices[RegionAttachment.Y4] = offsetX * c + offsetY * d + y;
          vertices[RegionAttachment.C4R] = color.r;
          vertices[RegionAttachment.C4G] = color.g;
          vertices[RegionAttachment.C4B] = color.b;
          vertices[RegionAttachment.C4A] = color.a;
          return vertices;
        };
        RegionAttachment.OX1 = 0;
        RegionAttachment.OY1 = 1;
        RegionAttachment.OX2 = 2;
        RegionAttachment.OY2 = 3;
        RegionAttachment.OX3 = 4;
        RegionAttachment.OY3 = 5;
        RegionAttachment.OX4 = 6;
        RegionAttachment.OY4 = 7;
        RegionAttachment.X1 = 0;
        RegionAttachment.Y1 = 1;
        RegionAttachment.C1R = 2;
        RegionAttachment.C1G = 3;
        RegionAttachment.C1B = 4;
        RegionAttachment.C1A = 5;
        RegionAttachment.U1 = 6;
        RegionAttachment.V1 = 7;
        RegionAttachment.X2 = 8;
        RegionAttachment.Y2 = 9;
        RegionAttachment.C2R = 10;
        RegionAttachment.C2G = 11;
        RegionAttachment.C2B = 12;
        RegionAttachment.C2A = 13;
        RegionAttachment.U2 = 14;
        RegionAttachment.V2 = 15;
        RegionAttachment.X3 = 16;
        RegionAttachment.Y3 = 17;
        RegionAttachment.C3R = 18;
        RegionAttachment.C3G = 19;
        RegionAttachment.C3B = 20;
        RegionAttachment.C3A = 21;
        RegionAttachment.U3 = 22;
        RegionAttachment.V3 = 23;
        RegionAttachment.X4 = 24;
        RegionAttachment.Y4 = 25;
        RegionAttachment.C4R = 26;
        RegionAttachment.C4G = 27;
        RegionAttachment.C4B = 28;
        RegionAttachment.C4A = 29;
        RegionAttachment.U4 = 30;
        RegionAttachment.V4 = 31;
        return RegionAttachment;
      })(spine.Attachment);
      spine.RegionAttachment = RegionAttachment;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      (function(BlendMode) {
        BlendMode[BlendMode["Normal"] = 0] = "Normal";
        BlendMode[BlendMode["Additive"] = 1] = "Additive";
        BlendMode[BlendMode["Multiply"] = 2] = "Multiply";
        BlendMode[BlendMode["Screen"] = 3] = "Screen";
      })(spine.BlendMode || (spine.BlendMode = {}));
      var BlendMode = spine.BlendMode;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Bone = (function() {
        function Bone(data, skeleton, parent) {
          this.children = new Array();
          this.x = 0;
          this.y = 0;
          this.rotation = 0;
          this.scaleX = 0;
          this.scaleY = 0;
          this.shearX = 0;
          this.shearY = 0;
          this.ax = 0;
          this.ay = 0;
          this.arotation = 0;
          this.ascaleX = 0;
          this.ascaleY = 0;
          this.ashearX = 0;
          this.ashearY = 0;
          this.appliedValid = false;
          this.a = 0;
          this.b = 0;
          this.worldX = 0;
          this.c = 0;
          this.d = 0;
          this.worldY = 0;
          this.sorted = false;
          if (null == data) throw new Error("data cannot be null.");
          if (null == skeleton) throw new Error("skeleton cannot be null.");
          this.data = data;
          this.skeleton = skeleton;
          this.parent = parent;
          this.setToSetupPose();
        }
        Bone.prototype.update = function() {
          this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
        };
        Bone.prototype.updateWorldTransform = function() {
          this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
        };
        Bone.prototype.updateWorldTransformWith = function(x, y, rotation, scaleX, scaleY, shearX, shearY) {
          this.ax = x;
          this.ay = y;
          this.arotation = rotation;
          this.ascaleX = scaleX;
          this.ascaleY = scaleY;
          this.ashearX = shearX;
          this.ashearY = shearY;
          this.appliedValid = true;
          var parent = this.parent;
          if (null == parent) {
            var rotationY = rotation + 90 + shearY;
            var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
            var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
            var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
            var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
            var skeleton = this.skeleton;
            if (skeleton.flipX) {
              x = -x;
              la = -la;
              lb = -lb;
            }
            if (skeleton.flipY) {
              y = -y;
              lc = -lc;
              ld = -ld;
            }
            this.a = la;
            this.b = lb;
            this.c = lc;
            this.d = ld;
            this.worldX = x + skeleton.x;
            this.worldY = y + skeleton.y;
            return;
          }
          var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
          this.worldX = pa * x + pb * y + parent.worldX;
          this.worldY = pc * x + pd * y + parent.worldY;
          switch (this.data.transformMode) {
           case spine.TransformMode.Normal:
            var rotationY = rotation + 90 + shearY;
            var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
            var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
            var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
            var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
            this.a = pa * la + pb * lc;
            this.b = pa * lb + pb * ld;
            this.c = pc * la + pd * lc;
            this.d = pc * lb + pd * ld;
            return;

           case spine.TransformMode.OnlyTranslation:
            var rotationY = rotation + 90 + shearY;
            this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
            this.b = spine.MathUtils.cosDeg(rotationY) * scaleY;
            this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
            this.d = spine.MathUtils.sinDeg(rotationY) * scaleY;
            break;

           case spine.TransformMode.NoRotationOrReflection:
            var s = pa * pa + pc * pc;
            var prx = 0;
            if (s > 1e-4) {
              s = Math.abs(pa * pd - pb * pc) / s;
              pb = pc * s;
              pd = pa * s;
              prx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;
            } else {
              pa = 0;
              pc = 0;
              prx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;
            }
            var rx = rotation + shearX - prx;
            var ry = rotation + shearY - prx + 90;
            var la = spine.MathUtils.cosDeg(rx) * scaleX;
            var lb = spine.MathUtils.cosDeg(ry) * scaleY;
            var lc = spine.MathUtils.sinDeg(rx) * scaleX;
            var ld = spine.MathUtils.sinDeg(ry) * scaleY;
            this.a = pa * la - pb * lc;
            this.b = pa * lb - pb * ld;
            this.c = pc * la + pd * lc;
            this.d = pc * lb + pd * ld;
            break;

           case spine.TransformMode.NoScale:
           case spine.TransformMode.NoScaleOrReflection:
            var cos = spine.MathUtils.cosDeg(rotation);
            var sin = spine.MathUtils.sinDeg(rotation);
            var za = pa * cos + pb * sin;
            var zc = pc * cos + pd * sin;
            var s = Math.sqrt(za * za + zc * zc);
            s > 1e-5 && (s = 1 / s);
            za *= s;
            zc *= s;
            s = Math.sqrt(za * za + zc * zc);
            var r = Math.PI / 2 + Math.atan2(zc, za);
            var zb = Math.cos(r) * s;
            var zd = Math.sin(r) * s;
            var la = spine.MathUtils.cosDeg(shearX) * scaleX;
            var lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;
            var lc = spine.MathUtils.sinDeg(shearX) * scaleX;
            var ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;
            this.a = za * la + zb * lc;
            this.b = za * lb + zb * ld;
            this.c = zc * la + zd * lc;
            this.d = zc * lb + zd * ld;
            if (this.data.transformMode != spine.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY) {
              this.b = -this.b;
              this.d = -this.d;
            }
            return;
          }
          if (this.skeleton.flipX) {
            this.a = -this.a;
            this.b = -this.b;
          }
          if (this.skeleton.flipY) {
            this.c = -this.c;
            this.d = -this.d;
          }
        };
        Bone.prototype.setToSetupPose = function() {
          var data = this.data;
          this.x = data.x;
          this.y = data.y;
          this.rotation = data.rotation;
          this.scaleX = data.scaleX;
          this.scaleY = data.scaleY;
          this.shearX = data.shearX;
          this.shearY = data.shearY;
        };
        Bone.prototype.getWorldRotationX = function() {
          return Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
        };
        Bone.prototype.getWorldRotationY = function() {
          return Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;
        };
        Bone.prototype.getWorldScaleX = function() {
          return Math.sqrt(this.a * this.a + this.c * this.c);
        };
        Bone.prototype.getWorldScaleY = function() {
          return Math.sqrt(this.b * this.b + this.d * this.d);
        };
        Bone.prototype.worldToLocalRotationX = function() {
          var parent = this.parent;
          if (null == parent) return this.arotation;
          var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, a = this.a, c = this.c;
          return Math.atan2(pa * c - pc * a, pd * a - pb * c) * spine.MathUtils.radDeg;
        };
        Bone.prototype.worldToLocalRotationY = function() {
          var parent = this.parent;
          if (null == parent) return this.arotation;
          var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, b = this.b, d = this.d;
          return Math.atan2(pa * d - pc * b, pd * b - pb * d) * spine.MathUtils.radDeg;
        };
        Bone.prototype.rotateWorld = function(degrees) {
          var a = this.a, b = this.b, c = this.c, d = this.d;
          var cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);
          this.a = cos * a - sin * c;
          this.b = cos * b - sin * d;
          this.c = sin * a + cos * c;
          this.d = sin * b + cos * d;
          this.appliedValid = false;
        };
        Bone.prototype.updateAppliedTransform = function() {
          this.appliedValid = true;
          var parent = this.parent;
          if (null == parent) {
            this.ax = this.worldX;
            this.ay = this.worldY;
            this.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
            this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
            this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
            this.ashearX = 0;
            this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;
            return;
          }
          var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
          var pid = 1 / (pa * pd - pb * pc);
          var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
          this.ax = dx * pd * pid - dy * pb * pid;
          this.ay = dy * pa * pid - dx * pc * pid;
          var ia = pid * pd;
          var id = pid * pa;
          var ib = pid * pb;
          var ic = pid * pc;
          var ra = ia * this.a - ib * this.c;
          var rb = ia * this.b - ib * this.d;
          var rc = id * this.c - ic * this.a;
          var rd = id * this.d - ic * this.b;
          this.ashearX = 0;
          this.ascaleX = Math.sqrt(ra * ra + rc * rc);
          if (this.ascaleX > 1e-4) {
            var det = ra * rd - rb * rc;
            this.ascaleY = det / this.ascaleX;
            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;
            this.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;
          } else {
            this.ascaleX = 0;
            this.ascaleY = Math.sqrt(rb * rb + rd * rd);
            this.ashearY = 0;
            this.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;
          }
        };
        Bone.prototype.worldToLocal = function(world) {
          var a = this.a, b = this.b, c = this.c, d = this.d;
          var invDet = 1 / (a * d - b * c);
          var x = world.x - this.worldX, y = world.y - this.worldY;
          world.x = x * d * invDet - y * b * invDet;
          world.y = y * a * invDet - x * c * invDet;
          return world;
        };
        Bone.prototype.localToWorld = function(local) {
          var x = local.x, y = local.y;
          local.x = x * this.a + y * this.b + this.worldX;
          local.y = x * this.c + y * this.d + this.worldY;
          return local;
        };
        return Bone;
      })();
      spine.Bone = Bone;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var BoneData = (function() {
        function BoneData(index, name, parent) {
          this.x = 0;
          this.y = 0;
          this.rotation = 0;
          this.scaleX = 1;
          this.scaleY = 1;
          this.shearX = 0;
          this.shearY = 0;
          this.transformMode = TransformMode.Normal;
          if (index < 0) throw new Error("index must be >= 0.");
          if (null == name) throw new Error("name cannot be null.");
          this.index = index;
          this.name = name;
          this.parent = parent;
        }
        return BoneData;
      })();
      spine.BoneData = BoneData;
      (function(TransformMode) {
        TransformMode[TransformMode["Normal"] = 0] = "Normal";
        TransformMode[TransformMode["OnlyTranslation"] = 1] = "OnlyTranslation";
        TransformMode[TransformMode["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
        TransformMode[TransformMode["NoScale"] = 3] = "NoScale";
        TransformMode[TransformMode["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
      })(spine.TransformMode || (spine.TransformMode = {}));
      var TransformMode = spine.TransformMode;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Event = (function() {
        function Event(time, data) {
          if (null == data) throw new Error("data cannot be null.");
          this.time = time;
          this.data = data;
        }
        return Event;
      })();
      spine.Event = Event;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var EventData = (function() {
        function EventData(name) {
          this.name = name;
        }
        return EventData;
      })();
      spine.EventData = EventData;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var IkConstraint = (function() {
        function IkConstraint(data, skeleton) {
          this.mix = 1;
          this.bendDirection = 0;
          if (null == data) throw new Error("data cannot be null.");
          if (null == skeleton) throw new Error("skeleton cannot be null.");
          this.data = data;
          this.mix = data.mix;
          this.bendDirection = data.bendDirection;
          this.bones = new Array();
          for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
          this.target = skeleton.findBone(data.target.name);
        }
        IkConstraint.prototype.getOrder = function() {
          return this.data.order;
        };
        IkConstraint.prototype.apply = function() {
          this.update();
        };
        IkConstraint.prototype.update = function() {
          var target = this.target;
          var bones = this.bones;
          switch (bones.length) {
           case 1:
            this.apply1(bones[0], target.worldX, target.worldY, this.mix);
            break;

           case 2:
            this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
          }
        };
        IkConstraint.prototype.apply1 = function(bone, targetX, targetY, alpha) {
          bone.appliedValid || bone.updateAppliedTransform();
          var p = bone.parent;
          var id = 1 / (p.a * p.d - p.b * p.c);
          var x = targetX - p.worldX, y = targetY - p.worldY;
          var tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;
          var rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;
          bone.ascaleX < 0 && (rotationIK += 180);
          rotationIK > 180 ? rotationIK -= 360 : rotationIK < -180 && (rotationIK += 360);
          bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);
        };
        IkConstraint.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, alpha) {
          if (0 == alpha) {
            child.updateWorldTransform();
            return;
          }
          parent.appliedValid || parent.updateAppliedTransform();
          child.appliedValid || child.updateAppliedTransform();
          var px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;
          var os1 = 0, os2 = 0, s2 = 0;
          if (psx < 0) {
            psx = -psx;
            os1 = 180;
            s2 = -1;
          } else {
            os1 = 0;
            s2 = 1;
          }
          if (psy < 0) {
            psy = -psy;
            s2 = -s2;
          }
          if (csx < 0) {
            csx = -csx;
            os2 = 180;
          } else os2 = 0;
          var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;
          var u = Math.abs(psx - psy) <= 1e-4;
          if (u) {
            cy = child.ay;
            cwx = a * cx + b * cy + parent.worldX;
            cwy = c * cx + d * cy + parent.worldY;
          } else {
            cy = 0;
            cwx = a * cx + parent.worldX;
            cwy = c * cx + parent.worldY;
          }
          var pp = parent.parent;
          a = pp.a;
          b = pp.b;
          c = pp.c;
          d = pp.d;
          var id = 1 / (a * d - b * c), x = targetX - pp.worldX, y = targetY - pp.worldY;
          var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;
          x = cwx - pp.worldX;
          y = cwy - pp.worldY;
          var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
          var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;
          outer: if (u) {
            l2 *= psx;
            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
            cos < -1 ? cos = -1 : cos > 1 && (cos = 1);
            a2 = Math.acos(cos) * bendDir;
            a = l1 + l2 * cos;
            b = l2 * Math.sin(a2);
            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
          } else {
            a = psx * l2;
            b = psy * l2;
            var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);
            c = bb * l1 * l1 + aa * dd - aa * bb;
            var c1 = -2 * bb * l1, c2 = bb - aa;
            d = c1 * c1 - 4 * c2 * c;
            if (d >= 0) {
              var q = Math.sqrt(d);
              c1 < 0 && (q = -q);
              q = -(c1 + q) / 2;
              var r0 = q / c2, r1 = c / q;
              var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
              if (r * r <= dd) {
                y = Math.sqrt(dd - r * r) * bendDir;
                a1 = ta - Math.atan2(y, r);
                a2 = Math.atan2(y / psy, (r - l1) / psx);
                break outer;
              }
            }
            var minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;
            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;
            x = l1 + a;
            d = x * x;
            if (d > maxDist) {
              maxAngle = 0;
              maxDist = d;
              maxX = x;
            }
            x = l1 - a;
            d = x * x;
            if (d < minDist) {
              minAngle = spine.MathUtils.PI;
              minDist = d;
              minX = x;
            }
            var angle = Math.acos(-a * l1 / (aa - bb));
            x = a * Math.cos(angle) + l1;
            y = b * Math.sin(angle);
            d = x * x + y * y;
            if (d < minDist) {
              minAngle = angle;
              minDist = d;
              minX = x;
              minY = y;
            }
            if (d > maxDist) {
              maxAngle = angle;
              maxDist = d;
              maxX = x;
              maxY = y;
            }
            if (dd <= (minDist + maxDist) / 2) {
              a1 = ta - Math.atan2(minY * bendDir, minX);
              a2 = minAngle * bendDir;
            } else {
              a1 = ta - Math.atan2(maxY * bendDir, maxX);
              a2 = maxAngle * bendDir;
            }
          }
          var os = Math.atan2(cy, cx) * s2;
          var rotation = parent.arotation;
          a1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;
          a1 > 180 ? a1 -= 360 : a1 < -180 && (a1 += 360);
          parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);
          rotation = child.arotation;
          a2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
          a2 > 180 ? a2 -= 360 : a2 < -180 && (a2 += 360);
          child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
        };
        return IkConstraint;
      })();
      spine.IkConstraint = IkConstraint;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var IkConstraintData = (function() {
        function IkConstraintData(name) {
          this.order = 0;
          this.bones = new Array();
          this.bendDirection = 1;
          this.mix = 1;
          this.name = name;
        }
        return IkConstraintData;
      })();
      spine.IkConstraintData = IkConstraintData;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var PathConstraint = (function() {
        function PathConstraint(data, skeleton) {
          this.position = 0;
          this.spacing = 0;
          this.rotateMix = 0;
          this.translateMix = 0;
          this.spaces = new Array();
          this.positions = new Array();
          this.world = new Array();
          this.curves = new Array();
          this.lengths = new Array();
          this.segments = new Array();
          if (null == data) throw new Error("data cannot be null.");
          if (null == skeleton) throw new Error("skeleton cannot be null.");
          this.data = data;
          this.bones = new Array();
          for (var i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
          this.target = skeleton.findSlot(data.target.name);
          this.position = data.position;
          this.spacing = data.spacing;
          this.rotateMix = data.rotateMix;
          this.translateMix = data.translateMix;
        }
        PathConstraint.prototype.apply = function() {
          this.update();
        };
        PathConstraint.prototype.update = function() {
          var attachment = this.target.getAttachment();
          if (!(attachment instanceof spine.PathAttachment)) return;
          var rotateMix = this.rotateMix, translateMix = this.translateMix;
          var translate = translateMix > 0, rotate = rotateMix > 0;
          if (!translate && !rotate) return;
          var data = this.data;
          var spacingMode = data.spacingMode;
          var lengthSpacing = spacingMode == spine.SpacingMode.Length;
          var rotateMode = data.rotateMode;
          var tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;
          var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
          var bones = this.bones;
          var spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;
          var spacing = this.spacing;
          if (scale || lengthSpacing) {
            scale && (lengths = spine.Utils.setArraySize(this.lengths, boneCount));
            for (var i = 0, n = spacesCount - 1; i < n; ) {
              var bone = bones[i];
              var length_1 = bone.data.length, x = length_1 * bone.a, y = length_1 * bone.c;
              length_1 = Math.sqrt(x * x + y * y);
              scale && (lengths[i] = length_1);
              spaces[++i] = lengthSpacing ? Math.max(0, length_1 + spacing) : spacing;
            }
          } else for (var i = 1; i < spacesCount; i++) spaces[i] = spacing;
          var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, spacingMode == spine.SpacingMode.Percent);
          var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
          var tip = false;
          if (0 == offsetRotation) tip = rotateMode == spine.RotateMode.Chain; else {
            tip = false;
            var p = this.target.bone;
            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
          }
          for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
            var bone = bones[i];
            bone.worldX += (boneX - bone.worldX) * translateMix;
            bone.worldY += (boneY - bone.worldY) * translateMix;
            var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
            if (scale) {
              var length_2 = lengths[i];
              if (0 != length_2) {
                var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
                bone.a *= s;
                bone.c *= s;
              }
            }
            boneX = x;
            boneY = y;
            if (rotate) {
              var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;
              r = tangents ? positions[p - 1] : 0 == spaces[i + 1] ? positions[p + 2] : Math.atan2(dy, dx);
              r -= Math.atan2(c, a);
              if (tip) {
                cos = Math.cos(r);
                sin = Math.sin(r);
                var length_3 = bone.data.length;
                boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;
                boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;
              } else r += offsetRotation;
              r > spine.MathUtils.PI ? r -= spine.MathUtils.PI2 : r < -spine.MathUtils.PI && (r += spine.MathUtils.PI2);
              r *= rotateMix;
              cos = Math.cos(r);
              sin = Math.sin(r);
              bone.a = cos * a - sin * c;
              bone.b = cos * b - sin * d;
              bone.c = sin * a + cos * c;
              bone.d = sin * b + cos * d;
            }
            bone.appliedValid = false;
          }
        };
        PathConstraint.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
          var target = this.target;
          var position = this.position;
          var spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, 3 * spacesCount + 2), world = null;
          var closed = path.closed;
          var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;
          if (!path.constantSpeed) {
            var lengths = path.lengths;
            curveCount -= closed ? 1 : 2;
            var pathLength_1 = lengths[curveCount];
            percentPosition && (position *= pathLength_1);
            if (percentSpacing) for (var i = 0; i < spacesCount; i++) spaces[i] *= pathLength_1;
            world = spine.Utils.setArraySize(this.world, 8);
            for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
              var space = spaces[i];
              position += space;
              var p = position;
              if (closed) {
                p %= pathLength_1;
                p < 0 && (p += pathLength_1);
                curve = 0;
              } else {
                if (p < 0) {
                  if (prevCurve != PathConstraint.BEFORE) {
                    prevCurve = PathConstraint.BEFORE;
                    path.computeWorldVerticesWith(target, 2, 4, world, 0);
                  }
                  this.addBeforePosition(p, world, 0, out, o);
                  continue;
                }
                if (p > pathLength_1) {
                  if (prevCurve != PathConstraint.AFTER) {
                    prevCurve = PathConstraint.AFTER;
                    path.computeWorldVerticesWith(target, verticesLength - 6, 4, world, 0);
                  }
                  this.addAfterPosition(p - pathLength_1, world, 0, out, o);
                  continue;
                }
              }
              for (;;curve++) {
                var length_4 = lengths[curve];
                if (p > length_4) continue;
                if (0 == curve) p /= length_4; else {
                  var prev = lengths[curve - 1];
                  p = (p - prev) / (length_4 - prev);
                }
                break;
              }
              if (curve != prevCurve) {
                prevCurve = curve;
                if (closed && curve == curveCount) {
                  path.computeWorldVerticesWith(target, verticesLength - 4, 4, world, 0);
                  path.computeWorldVerticesWith(target, 0, 4, world, 4);
                } else path.computeWorldVerticesWith(target, 6 * curve + 2, 8, world, 0);
              }
              this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && 0 == space);
            }
            return out;
          }
          if (closed) {
            verticesLength += 2;
            world = spine.Utils.setArraySize(this.world, verticesLength);
            path.computeWorldVerticesWith(target, 2, verticesLength - 4, world, 0);
            path.computeWorldVerticesWith(target, 0, 2, world, verticesLength - 4);
            world[verticesLength - 2] = world[0];
            world[verticesLength - 1] = world[1];
          } else {
            curveCount--;
            verticesLength -= 4;
            world = spine.Utils.setArraySize(this.world, verticesLength);
            path.computeWorldVerticesWith(target, 2, verticesLength, world, 0);
          }
          var curves = spine.Utils.setArraySize(this.curves, curveCount);
          var pathLength = 0;
          var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
          var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
          for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
            cx1 = world[w];
            cy1 = world[w + 1];
            cx2 = world[w + 2];
            cy2 = world[w + 3];
            x2 = world[w + 4];
            y2 = world[w + 5];
            tmpx = .1875 * (x1 - 2 * cx1 + cx2);
            tmpy = .1875 * (y1 - 2 * cy1 + cy2);
            dddfx = .09375 * (3 * (cx1 - cx2) - x1 + x2);
            dddfy = .09375 * (3 * (cy1 - cy2) - y1 + y2);
            ddfx = 2 * tmpx + dddfx;
            ddfy = 2 * tmpy + dddfy;
            dfx = .75 * (cx1 - x1) + tmpx + .16666667 * dddfx;
            dfy = .75 * (cy1 - y1) + tmpy + .16666667 * dddfy;
            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
            dfx += ddfx;
            dfy += ddfy;
            ddfx += dddfx;
            ddfy += dddfy;
            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
            dfx += ddfx;
            dfy += ddfy;
            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
            dfx += ddfx + dddfx;
            dfy += ddfy + dddfy;
            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
            curves[i] = pathLength;
            x1 = x2;
            y1 = y2;
          }
          percentPosition && (position *= pathLength);
          if (percentSpacing) for (var i = 0; i < spacesCount; i++) spaces[i] *= pathLength;
          var segments = this.segments;
          var curveLength = 0;
          for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
            var space = spaces[i];
            position += space;
            var p = position;
            if (closed) {
              p %= pathLength;
              p < 0 && (p += pathLength);
              curve = 0;
            } else {
              if (p < 0) {
                this.addBeforePosition(p, world, 0, out, o);
                continue;
              }
              if (p > pathLength) {
                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
                continue;
              }
            }
            for (;;curve++) {
              var length_5 = curves[curve];
              if (p > length_5) continue;
              if (0 == curve) p /= length_5; else {
                var prev = curves[curve - 1];
                p = (p - prev) / (length_5 - prev);
              }
              break;
            }
            if (curve != prevCurve) {
              prevCurve = curve;
              var ii = 6 * curve;
              x1 = world[ii];
              y1 = world[ii + 1];
              cx1 = world[ii + 2];
              cy1 = world[ii + 3];
              cx2 = world[ii + 4];
              cy2 = world[ii + 5];
              x2 = world[ii + 6];
              y2 = world[ii + 7];
              tmpx = .03 * (x1 - 2 * cx1 + cx2);
              tmpy = .03 * (y1 - 2 * cy1 + cy2);
              dddfx = .006 * (3 * (cx1 - cx2) - x1 + x2);
              dddfy = .006 * (3 * (cy1 - cy2) - y1 + y2);
              ddfx = 2 * tmpx + dddfx;
              ddfy = 2 * tmpy + dddfy;
              dfx = .3 * (cx1 - x1) + tmpx + .16666667 * dddfx;
              dfy = .3 * (cy1 - y1) + tmpy + .16666667 * dddfy;
              curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
              segments[0] = curveLength;
              for (ii = 1; ii < 8; ii++) {
                dfx += ddfx;
                dfy += ddfy;
                ddfx += dddfx;
                ddfy += dddfy;
                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                segments[ii] = curveLength;
              }
              dfx += ddfx;
              dfy += ddfy;
              curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
              segments[8] = curveLength;
              dfx += ddfx + dddfx;
              dfy += ddfy + dddfy;
              curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
              segments[9] = curveLength;
              segment = 0;
            }
            p *= curveLength;
            for (;;segment++) {
              var length_6 = segments[segment];
              if (p > length_6) continue;
              if (0 == segment) p /= length_6; else {
                var prev = segments[segment - 1];
                p = segment + (p - prev) / (length_6 - prev);
              }
              break;
            }
            this.addCurvePosition(.1 * p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && 0 == space);
          }
          return out;
        };
        PathConstraint.prototype.addBeforePosition = function(p, temp, i, out, o) {
          var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
          out[o] = x1 + p * Math.cos(r);
          out[o + 1] = y1 + p * Math.sin(r);
          out[o + 2] = r;
        };
        PathConstraint.prototype.addAfterPosition = function(p, temp, i, out, o) {
          var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
          out[o] = x1 + p * Math.cos(r);
          out[o + 1] = y1 + p * Math.sin(r);
          out[o + 2] = r;
        };
        PathConstraint.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
          (0 == p || isNaN(p)) && (p = 1e-4);
          var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
          var ut = u * p, ut3 = 3 * ut, uut3 = u * ut3, utt3 = ut3 * p;
          var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
          out[o] = x;
          out[o + 1] = y;
          tangents && (out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt)));
        };
        PathConstraint.prototype.getOrder = function() {
          return this.data.order;
        };
        PathConstraint.NONE = -1;
        PathConstraint.BEFORE = -2;
        PathConstraint.AFTER = -3;
        return PathConstraint;
      })();
      spine.PathConstraint = PathConstraint;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var PathConstraintData = (function() {
        function PathConstraintData(name) {
          this.order = 0;
          this.bones = new Array();
          this.name = name;
        }
        return PathConstraintData;
      })();
      spine.PathConstraintData = PathConstraintData;
      (function(PositionMode) {
        PositionMode[PositionMode["Fixed"] = 0] = "Fixed";
        PositionMode[PositionMode["Percent"] = 1] = "Percent";
      })(spine.PositionMode || (spine.PositionMode = {}));
      var PositionMode = spine.PositionMode;
      (function(SpacingMode) {
        SpacingMode[SpacingMode["Length"] = 0] = "Length";
        SpacingMode[SpacingMode["Fixed"] = 1] = "Fixed";
        SpacingMode[SpacingMode["Percent"] = 2] = "Percent";
      })(spine.SpacingMode || (spine.SpacingMode = {}));
      var SpacingMode = spine.SpacingMode;
      (function(RotateMode) {
        RotateMode[RotateMode["Tangent"] = 0] = "Tangent";
        RotateMode[RotateMode["Chain"] = 1] = "Chain";
        RotateMode[RotateMode["ChainScale"] = 2] = "ChainScale";
      })(spine.RotateMode || (spine.RotateMode = {}));
      var RotateMode = spine.RotateMode;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Assets = (function() {
        function Assets(clientId) {
          this.toLoad = new Array();
          this.assets = {};
          this.clientId = clientId;
        }
        Assets.prototype.loaded = function() {
          var i = 0;
          for (var v in this.assets) i++;
          return i;
        };
        return Assets;
      })();
      var SharedAssetManager = (function() {
        function SharedAssetManager(pathPrefix) {
          void 0 === pathPrefix && (pathPrefix = "");
          this.clientAssets = {};
          this.queuedAssets = {};
          this.rawAssets = {};
          this.errors = {};
          this.pathPrefix = pathPrefix;
        }
        SharedAssetManager.prototype.queueAsset = function(clientId, textureLoader, path) {
          var clientAssets = this.clientAssets[clientId];
          if (null === clientAssets || void 0 === clientAssets) {
            clientAssets = new Assets(clientId);
            this.clientAssets[clientId] = clientAssets;
          }
          null !== textureLoader && (clientAssets.textureLoader = textureLoader);
          clientAssets.toLoad.push(path);
          if (this.queuedAssets[path] === path) return false;
          this.queuedAssets[path] = path;
          return true;
        };
        SharedAssetManager.prototype.loadText = function(clientId, path) {
          var _this = this;
          path = this.pathPrefix + path;
          if (!this.queueAsset(clientId, null, path)) return;
          var request = new XMLHttpRequest();
          request.onreadystatechange = function() {
            request.readyState == XMLHttpRequest.DONE && (request.status >= 200 && request.status < 300 ? _this.rawAssets[path] = request.responseText : _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
          };
          request.open("GET", path, true);
          request.send();
        };
        SharedAssetManager.prototype.loadJson = function(clientId, path) {
          var _this = this;
          path = this.pathPrefix + path;
          if (!this.queueAsset(clientId, null, path)) return;
          var request = new XMLHttpRequest();
          request.onreadystatechange = function() {
            request.readyState == XMLHttpRequest.DONE && (request.status >= 200 && request.status < 300 ? _this.rawAssets[path] = JSON.parse(request.responseText) : _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
          };
          request.open("GET", path, true);
          request.send();
        };
        SharedAssetManager.prototype.loadTexture = function(clientId, textureLoader, path) {
          var _this = this;
          path = this.pathPrefix + path;
          if (!this.queueAsset(clientId, textureLoader, path)) return;
          var img = new Image();
          img.src = path;
          img.crossOrigin = "anonymous";
          img.onload = function(ev) {
            _this.rawAssets[path] = img;
          };
          img.onerror = function(ev) {
            _this.errors[path] = "Couldn't load image " + path;
          };
        };
        SharedAssetManager.prototype.get = function(clientId, path) {
          path = this.pathPrefix + path;
          var clientAssets = this.clientAssets[clientId];
          if (null === clientAssets || void 0 === clientAssets) return true;
          return clientAssets.assets[path];
        };
        SharedAssetManager.prototype.updateClientAssets = function(clientAssets) {
          for (var i = 0; i < clientAssets.toLoad.length; i++) {
            var path = clientAssets.toLoad[i];
            var asset = clientAssets.assets[path];
            if (null === asset || void 0 === asset) {
              var rawAsset = this.rawAssets[path];
              if (null === rawAsset || void 0 === rawAsset) continue;
              rawAsset instanceof HTMLImageElement ? clientAssets.assets[path] = clientAssets.textureLoader(rawAsset) : clientAssets.assets[path] = rawAsset;
            }
          }
        };
        SharedAssetManager.prototype.isLoadingComplete = function(clientId) {
          var clientAssets = this.clientAssets[clientId];
          if (null === clientAssets || void 0 === clientAssets) return true;
          this.updateClientAssets(clientAssets);
          return clientAssets.toLoad.length == clientAssets.loaded();
        };
        SharedAssetManager.prototype.dispose = function() {};
        SharedAssetManager.prototype.hasErrors = function() {
          return Object.keys(this.errors).length > 0;
        };
        SharedAssetManager.prototype.getErrors = function() {
          return this.errors;
        };
        return SharedAssetManager;
      })();
      spine.SharedAssetManager = SharedAssetManager;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Skeleton = (function() {
        function Skeleton(data) {
          this._updateCache = new Array();
          this.updateCacheReset = new Array();
          this.time = 0;
          this.flipX = false;
          this.flipY = false;
          this.x = 0;
          this.y = 0;
          if (null == data) throw new Error("data cannot be null.");
          this.data = data;
          this.bones = new Array();
          for (var i = 0; i < data.bones.length; i++) {
            var boneData = data.bones[i];
            var bone = void 0;
            if (null == boneData.parent) bone = new spine.Bone(boneData, this, null); else {
              var parent_1 = this.bones[boneData.parent.index];
              bone = new spine.Bone(boneData, this, parent_1);
              parent_1.children.push(bone);
            }
            this.bones.push(bone);
          }
          this.slots = new Array();
          this.drawOrder = new Array();
          for (var i = 0; i < data.slots.length; i++) {
            var slotData = data.slots[i];
            var bone = this.bones[slotData.boneData.index];
            var slot = new spine.Slot(slotData, bone);
            this.slots.push(slot);
            this.drawOrder.push(slot);
          }
          this.ikConstraints = new Array();
          for (var i = 0; i < data.ikConstraints.length; i++) {
            var ikConstraintData = data.ikConstraints[i];
            this.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));
          }
          this.transformConstraints = new Array();
          for (var i = 0; i < data.transformConstraints.length; i++) {
            var transformConstraintData = data.transformConstraints[i];
            this.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));
          }
          this.pathConstraints = new Array();
          for (var i = 0; i < data.pathConstraints.length; i++) {
            var pathConstraintData = data.pathConstraints[i];
            this.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));
          }
          this.color = new spine.Color(1, 1, 1, 1);
          this.updateCache();
        }
        Skeleton.prototype.updateCache = function() {
          var updateCache = this._updateCache;
          updateCache.length = 0;
          var bones = this.bones;
          for (var i = 0, n = bones.length; i < n; i++) bones[i].sorted = false;
          var ikConstraints = this.ikConstraints;
          var transformConstraints = this.transformConstraints;
          var pathConstraints = this.pathConstraints;
          var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
          var constraintCount = ikCount + transformCount + pathCount;
          outer: for (var i = 0; i < constraintCount; i++) {
            for (var ii = 0; ii < ikCount; ii++) {
              var constraint = ikConstraints[ii];
              if (constraint.data.order == i) {
                this.sortIkConstraint(constraint);
                continue outer;
              }
            }
            for (var ii = 0; ii < transformCount; ii++) {
              var constraint = transformConstraints[ii];
              if (constraint.data.order == i) {
                this.sortTransformConstraint(constraint);
                continue outer;
              }
            }
            for (var ii = 0; ii < pathCount; ii++) {
              var constraint = pathConstraints[ii];
              if (constraint.data.order == i) {
                this.sortPathConstraint(constraint);
                continue outer;
              }
            }
          }
          for (var i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);
        };
        Skeleton.prototype.sortIkConstraint = function(constraint) {
          var target = constraint.target;
          this.sortBone(target);
          var constrained = constraint.bones;
          var parent = constrained[0];
          this.sortBone(parent);
          if (constrained.length > 1) {
            var child = constrained[constrained.length - 1];
            this._updateCache.indexOf(child) > -1 || this.updateCacheReset.push(child);
          }
          this._updateCache.push(constraint);
          this.sortReset(parent.children);
          constrained[constrained.length - 1].sorted = true;
        };
        Skeleton.prototype.sortPathConstraint = function(constraint) {
          var slot = constraint.target;
          var slotIndex = slot.data.index;
          var slotBone = slot.bone;
          null != this.skin && this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
          null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
          for (var ii = 0, nn = this.data.skins.length; ii < nn; ii++) this.sortPathConstraintAttachment(this.data.skins[ii], slotIndex, slotBone);
          var attachment = slot.getAttachment();
          attachment instanceof spine.PathAttachment && this.sortPathConstraintAttachmentWith(attachment, slotBone);
          var constrained = constraint.bones;
          var boneCount = constrained.length;
          for (var ii = 0; ii < boneCount; ii++) this.sortBone(constrained[ii]);
          this._updateCache.push(constraint);
          for (var ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);
          for (var ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;
        };
        Skeleton.prototype.sortTransformConstraint = function(constraint) {
          this.sortBone(constraint.target);
          var constrained = constraint.bones;
          var boneCount = constrained.length;
          for (var ii = 0; ii < boneCount; ii++) this.sortBone(constrained[ii]);
          this._updateCache.push(constraint);
          for (var ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);
          for (var ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;
        };
        Skeleton.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
          var attachments = skin.attachments[slotIndex];
          if (!attachments) return;
          for (var key in attachments) this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
        };
        Skeleton.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
          if (!(attachment instanceof spine.PathAttachment)) return;
          var pathBones = attachment.bones;
          if (null == pathBones) this.sortBone(slotBone); else {
            var bones = this.bones;
            var i = 0;
            while (i < pathBones.length) {
              var boneCount = pathBones[i++];
              for (var n = i + boneCount; i < n; i++) {
                var boneIndex = pathBones[i];
                this.sortBone(bones[boneIndex]);
              }
            }
          }
        };
        Skeleton.prototype.sortBone = function(bone) {
          if (bone.sorted) return;
          var parent = bone.parent;
          null != parent && this.sortBone(parent);
          bone.sorted = true;
          this._updateCache.push(bone);
        };
        Skeleton.prototype.sortReset = function(bones) {
          for (var i = 0, n = bones.length; i < n; i++) {
            var bone = bones[i];
            bone.sorted && this.sortReset(bone.children);
            bone.sorted = false;
          }
        };
        Skeleton.prototype.updateWorldTransform = function() {
          var updateCacheReset = this.updateCacheReset;
          for (var i = 0, n = updateCacheReset.length; i < n; i++) {
            var bone = updateCacheReset[i];
            bone.ax = bone.x;
            bone.ay = bone.y;
            bone.arotation = bone.rotation;
            bone.ascaleX = bone.scaleX;
            bone.ascaleY = bone.scaleY;
            bone.ashearX = bone.shearX;
            bone.ashearY = bone.shearY;
            bone.appliedValid = true;
          }
          var updateCache = this._updateCache;
          for (var i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();
        };
        Skeleton.prototype.setToSetupPose = function() {
          this.setBonesToSetupPose();
          this.setSlotsToSetupPose();
        };
        Skeleton.prototype.setBonesToSetupPose = function() {
          var bones = this.bones;
          for (var i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();
          var ikConstraints = this.ikConstraints;
          for (var i = 0, n = ikConstraints.length; i < n; i++) {
            var constraint = ikConstraints[i];
            constraint.bendDirection = constraint.data.bendDirection;
            constraint.mix = constraint.data.mix;
          }
          var transformConstraints = this.transformConstraints;
          for (var i = 0, n = transformConstraints.length; i < n; i++) {
            var constraint = transformConstraints[i];
            var data = constraint.data;
            constraint.rotateMix = data.rotateMix;
            constraint.translateMix = data.translateMix;
            constraint.scaleMix = data.scaleMix;
            constraint.shearMix = data.shearMix;
          }
          var pathConstraints = this.pathConstraints;
          for (var i = 0, n = pathConstraints.length; i < n; i++) {
            var constraint = pathConstraints[i];
            var data = constraint.data;
            constraint.position = data.position;
            constraint.spacing = data.spacing;
            constraint.rotateMix = data.rotateMix;
            constraint.translateMix = data.translateMix;
          }
        };
        Skeleton.prototype.setSlotsToSetupPose = function() {
          var slots = this.slots;
          spine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
          for (var i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();
        };
        Skeleton.prototype.getRootBone = function() {
          if (0 == this.bones.length) return null;
          return this.bones[0];
        };
        Skeleton.prototype.findBone = function(boneName) {
          if (null == boneName) throw new Error("boneName cannot be null.");
          var bones = this.bones;
          for (var i = 0, n = bones.length; i < n; i++) {
            var bone = bones[i];
            if (bone.data.name == boneName) return bone;
          }
          return null;
        };
        Skeleton.prototype.findBoneIndex = function(boneName) {
          if (null == boneName) throw new Error("boneName cannot be null.");
          var bones = this.bones;
          for (var i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;
          return -1;
        };
        Skeleton.prototype.findSlot = function(slotName) {
          if (null == slotName) throw new Error("slotName cannot be null.");
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) {
            var slot = slots[i];
            if (slot.data.name == slotName) return slot;
          }
          return null;
        };
        Skeleton.prototype.findSlotIndex = function(slotName) {
          if (null == slotName) throw new Error("slotName cannot be null.");
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;
          return -1;
        };
        Skeleton.prototype.setSkinByName = function(skinName) {
          var skin = this.data.findSkin(skinName);
          if (null == skin) throw new Error("Skin not found: " + skinName);
          this.setSkin(skin);
        };
        Skeleton.prototype.setSkin = function(newSkin) {
          if (null != newSkin) if (null != this.skin) newSkin.attachAll(this, this.skin); else {
            var slots = this.slots;
            for (var i = 0, n = slots.length; i < n; i++) {
              var slot = slots[i];
              var name_1 = slot.data.attachmentName;
              if (null != name_1) {
                var attachment = newSkin.getAttachment(i, name_1);
                null != attachment && slot.setAttachment(attachment);
              }
            }
          }
          this.skin = newSkin;
        };
        Skeleton.prototype.getAttachmentByName = function(slotName, attachmentName) {
          return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
        };
        Skeleton.prototype.getAttachment = function(slotIndex, attachmentName) {
          if (null == attachmentName) throw new Error("attachmentName cannot be null.");
          if (null != this.skin) {
            var attachment = this.skin.getAttachment(slotIndex, attachmentName);
            if (null != attachment) return attachment;
          }
          if (null != this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
          return null;
        };
        Skeleton.prototype.setAttachment = function(slotName, attachmentName) {
          if (null == slotName) throw new Error("slotName cannot be null.");
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) {
            var slot = slots[i];
            if (slot.data.name == slotName) {
              var attachment = null;
              if (null != attachmentName) {
                attachment = this.getAttachment(i, attachmentName);
                if (null == attachment) throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
              }
              slot.setAttachment(attachment);
              return;
            }
          }
          throw new Error("Slot not found: " + slotName);
        };
        Skeleton.prototype.findIkConstraint = function(constraintName) {
          if (null == constraintName) throw new Error("constraintName cannot be null.");
          var ikConstraints = this.ikConstraints;
          for (var i = 0, n = ikConstraints.length; i < n; i++) {
            var ikConstraint = ikConstraints[i];
            if (ikConstraint.data.name == constraintName) return ikConstraint;
          }
          return null;
        };
        Skeleton.prototype.findTransformConstraint = function(constraintName) {
          if (null == constraintName) throw new Error("constraintName cannot be null.");
          var transformConstraints = this.transformConstraints;
          for (var i = 0, n = transformConstraints.length; i < n; i++) {
            var constraint = transformConstraints[i];
            if (constraint.data.name == constraintName) return constraint;
          }
          return null;
        };
        Skeleton.prototype.findPathConstraint = function(constraintName) {
          if (null == constraintName) throw new Error("constraintName cannot be null.");
          var pathConstraints = this.pathConstraints;
          for (var i = 0, n = pathConstraints.length; i < n; i++) {
            var constraint = pathConstraints[i];
            if (constraint.data.name == constraintName) return constraint;
          }
          return null;
        };
        Skeleton.prototype.getBounds = function(offset, size) {
          if (null == offset) throw new Error("offset cannot be null.");
          if (null == size) throw new Error("size cannot be null.");
          var drawOrder = this.drawOrder;
          var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
          for (var i = 0, n = drawOrder.length; i < n; i++) {
            var slot = drawOrder[i];
            var vertices = null;
            var attachment = slot.getAttachment();
            attachment instanceof spine.RegionAttachment ? vertices = attachment.updateWorldVertices(slot, false) : attachment instanceof spine.MeshAttachment && (vertices = attachment.updateWorldVertices(slot, true));
            if (null != vertices) for (var ii = 0, nn = vertices.length; ii < nn; ii += 8) {
              var x = vertices[ii], y = vertices[ii + 1];
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
            }
          }
          offset.set(minX, minY);
          size.set(maxX - minX, maxY - minY);
        };
        Skeleton.prototype.update = function(delta) {
          this.time += delta;
        };
        return Skeleton;
      })();
      spine.Skeleton = Skeleton;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var SkeletonBounds = (function() {
        function SkeletonBounds() {
          this.minX = 0;
          this.minY = 0;
          this.maxX = 0;
          this.maxY = 0;
          this.boundingBoxes = new Array();
          this.polygons = new Array();
          this.polygonPool = new spine.Pool(function() {
            return spine.Utils.newFloatArray(16);
          });
        }
        SkeletonBounds.prototype.update = function(skeleton, updateAabb) {
          if (null == skeleton) throw new Error("skeleton cannot be null.");
          var boundingBoxes = this.boundingBoxes;
          var polygons = this.polygons;
          var polygonPool = this.polygonPool;
          var slots = skeleton.slots;
          var slotCount = slots.length;
          boundingBoxes.length = 0;
          polygonPool.freeAll(polygons);
          polygons.length = 0;
          for (var i = 0; i < slotCount; i++) {
            var slot = slots[i];
            var attachment = slot.getAttachment();
            if (attachment instanceof spine.BoundingBoxAttachment) {
              var boundingBox = attachment;
              boundingBoxes.push(boundingBox);
              var polygon = polygonPool.obtain();
              polygon.length != boundingBox.worldVerticesLength && (polygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength));
              polygons.push(polygon);
              boundingBox.computeWorldVertices(slot, polygon);
            }
          }
          if (updateAabb) this.aabbCompute(); else {
            this.minX = Number.POSITIVE_INFINITY;
            this.minY = Number.POSITIVE_INFINITY;
            this.maxX = Number.NEGATIVE_INFINITY;
            this.maxY = Number.NEGATIVE_INFINITY;
          }
        };
        SkeletonBounds.prototype.aabbCompute = function() {
          var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
          var polygons = this.polygons;
          for (var i = 0, n = polygons.length; i < n; i++) {
            var polygon = polygons[i];
            var vertices = polygon;
            for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
              var x = vertices[ii];
              var y = vertices[ii + 1];
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
            }
          }
          this.minX = minX;
          this.minY = minY;
          this.maxX = maxX;
          this.maxY = maxY;
        };
        SkeletonBounds.prototype.aabbContainsPoint = function(x, y) {
          return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
        };
        SkeletonBounds.prototype.aabbIntersectsSegment = function(x1, y1, x2, y2) {
          var minX = this.minX;
          var minY = this.minY;
          var maxX = this.maxX;
          var maxY = this.maxY;
          if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;
          var m = (y2 - y1) / (x2 - x1);
          var y = m * (minX - x1) + y1;
          if (y > minY && y < maxY) return true;
          y = m * (maxX - x1) + y1;
          if (y > minY && y < maxY) return true;
          var x = (minY - y1) / m + x1;
          if (x > minX && x < maxX) return true;
          x = (maxY - y1) / m + x1;
          if (x > minX && x < maxX) return true;
          return false;
        };
        SkeletonBounds.prototype.aabbIntersectsSkeleton = function(bounds) {
          return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
        };
        SkeletonBounds.prototype.containsPoint = function(x, y) {
          var polygons = this.polygons;
          for (var i = 0, n = polygons.length; i < n; i++) if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];
          return null;
        };
        SkeletonBounds.prototype.containsPointPolygon = function(polygon, x, y) {
          var vertices = polygon;
          var nn = polygon.length;
          var prevIndex = nn - 2;
          var inside = false;
          for (var ii = 0; ii < nn; ii += 2) {
            var vertexY = vertices[ii + 1];
            var prevY = vertices[prevIndex + 1];
            if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
              var vertexX = vertices[ii];
              vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x && (inside = !inside);
            }
            prevIndex = ii;
          }
          return inside;
        };
        SkeletonBounds.prototype.intersectsSegment = function(x1, y1, x2, y2) {
          var polygons = this.polygons;
          for (var i = 0, n = polygons.length; i < n; i++) if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];
          return null;
        };
        SkeletonBounds.prototype.intersectsSegmentPolygon = function(polygon, x1, y1, x2, y2) {
          var vertices = polygon;
          var nn = polygon.length;
          var width12 = x1 - x2, height12 = y1 - y2;
          var det1 = x1 * y2 - y1 * x2;
          var x3 = vertices[nn - 2], y3 = vertices[nn - 1];
          for (var ii = 0; ii < nn; ii += 2) {
            var x4 = vertices[ii], y4 = vertices[ii + 1];
            var det2 = x3 * y4 - y3 * x4;
            var width34 = x3 - x4, height34 = y3 - y4;
            var det3 = width12 * height34 - height12 * width34;
            var x = (det1 * width34 - width12 * det2) / det3;
            if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
              var y = (det1 * height34 - height12 * det2) / det3;
              if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;
            }
            x3 = x4;
            y3 = y4;
          }
          return false;
        };
        SkeletonBounds.prototype.getPolygon = function(boundingBox) {
          if (null == boundingBox) throw new Error("boundingBox cannot be null.");
          var index = this.boundingBoxes.indexOf(boundingBox);
          return -1 == index ? null : this.polygons[index];
        };
        SkeletonBounds.prototype.getWidth = function() {
          return this.maxX - this.minX;
        };
        SkeletonBounds.prototype.getHeight = function() {
          return this.maxY - this.minY;
        };
        return SkeletonBounds;
      })();
      spine.SkeletonBounds = SkeletonBounds;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var SkeletonData = (function() {
        function SkeletonData() {
          this.bones = new Array();
          this.slots = new Array();
          this.skins = new Array();
          this.events = new Array();
          this.animations = new Array();
          this.ikConstraints = new Array();
          this.transformConstraints = new Array();
          this.pathConstraints = new Array();
          this.fps = 0;
        }
        SkeletonData.prototype.findBone = function(boneName) {
          if (null == boneName) throw new Error("boneName cannot be null.");
          var bones = this.bones;
          for (var i = 0, n = bones.length; i < n; i++) {
            var bone = bones[i];
            if (bone.name == boneName) return bone;
          }
          return null;
        };
        SkeletonData.prototype.findBoneIndex = function(boneName) {
          if (null == boneName) throw new Error("boneName cannot be null.");
          var bones = this.bones;
          for (var i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;
          return -1;
        };
        SkeletonData.prototype.findSlot = function(slotName) {
          if (null == slotName) throw new Error("slotName cannot be null.");
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) {
            var slot = slots[i];
            if (slot.name == slotName) return slot;
          }
          return null;
        };
        SkeletonData.prototype.findSlotIndex = function(slotName) {
          if (null == slotName) throw new Error("slotName cannot be null.");
          var slots = this.slots;
          for (var i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;
          return -1;
        };
        SkeletonData.prototype.findSkin = function(skinName) {
          if (null == skinName) throw new Error("skinName cannot be null.");
          var skins = this.skins;
          for (var i = 0, n = skins.length; i < n; i++) {
            var skin = skins[i];
            if (skin.name == skinName) return skin;
          }
          return null;
        };
        SkeletonData.prototype.findEvent = function(eventDataName) {
          if (null == eventDataName) throw new Error("eventDataName cannot be null.");
          var events = this.events;
          for (var i = 0, n = events.length; i < n; i++) {
            var event_4 = events[i];
            if (event_4.name == eventDataName) return event_4;
          }
          return null;
        };
        SkeletonData.prototype.findAnimation = function(animationName) {
          if (null == animationName) throw new Error("animationName cannot be null.");
          var animations = this.animations;
          for (var i = 0, n = animations.length; i < n; i++) {
            var animation = animations[i];
            if (animation.name == animationName) return animation;
          }
          return null;
        };
        SkeletonData.prototype.findIkConstraint = function(constraintName) {
          if (null == constraintName) throw new Error("constraintName cannot be null.");
          var ikConstraints = this.ikConstraints;
          for (var i = 0, n = ikConstraints.length; i < n; i++) {
            var constraint = ikConstraints[i];
            if (constraint.name == constraintName) return constraint;
          }
          return null;
        };
        SkeletonData.prototype.findTransformConstraint = function(constraintName) {
          if (null == constraintName) throw new Error("constraintName cannot be null.");
          var transformConstraints = this.transformConstraints;
          for (var i = 0, n = transformConstraints.length; i < n; i++) {
            var constraint = transformConstraints[i];
            if (constraint.name == constraintName) return constraint;
          }
          return null;
        };
        SkeletonData.prototype.findPathConstraint = function(constraintName) {
          if (null == constraintName) throw new Error("constraintName cannot be null.");
          var pathConstraints = this.pathConstraints;
          for (var i = 0, n = pathConstraints.length; i < n; i++) {
            var constraint = pathConstraints[i];
            if (constraint.name == constraintName) return constraint;
          }
          return null;
        };
        SkeletonData.prototype.findPathConstraintIndex = function(pathConstraintName) {
          if (null == pathConstraintName) throw new Error("pathConstraintName cannot be null.");
          var pathConstraints = this.pathConstraints;
          for (var i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;
          return -1;
        };
        return SkeletonData;
      })();
      spine.SkeletonData = SkeletonData;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var SkeletonJson = (function() {
        function SkeletonJson(attachmentLoader) {
          this.scale = 1;
          this.linkedMeshes = new Array();
          this.attachmentLoader = attachmentLoader;
        }
        SkeletonJson.prototype.readSkeletonData = function(json) {
          var scale = this.scale;
          var skeletonData = new spine.SkeletonData();
          var root = "string" === typeof json ? JSON.parse(json) : json;
          var skeletonMap = root.skeleton;
          if (null != skeletonMap) {
            skeletonData.hash = skeletonMap.hash;
            skeletonData.version = skeletonMap.spine;
            skeletonData.width = skeletonMap.width;
            skeletonData.height = skeletonMap.height;
            skeletonData.fps = skeletonMap.fps;
            skeletonData.imagesPath = skeletonMap.images;
          }
          if (root.bones) for (var i = 0; i < root.bones.length; i++) {
            var boneMap = root.bones[i];
            var parent_2 = null;
            var parentName = this.getValue(boneMap, "parent", null);
            if (null != parentName) {
              parent_2 = skeletonData.findBone(parentName);
              if (null == parent_2) throw new Error("Parent bone not found: " + parentName);
            }
            var data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_2);
            data.length = this.getValue(boneMap, "length", 0) * scale;
            data.x = this.getValue(boneMap, "x", 0) * scale;
            data.y = this.getValue(boneMap, "y", 0) * scale;
            data.rotation = this.getValue(boneMap, "rotation", 0);
            data.scaleX = this.getValue(boneMap, "scaleX", 1);
            data.scaleY = this.getValue(boneMap, "scaleY", 1);
            data.shearX = this.getValue(boneMap, "shearX", 0);
            data.shearY = this.getValue(boneMap, "shearY", 0);
            data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
            skeletonData.bones.push(data);
          }
          if (root.slots) for (var i = 0; i < root.slots.length; i++) {
            var slotMap = root.slots[i];
            var slotName = slotMap.name;
            var boneName = slotMap.bone;
            var boneData = skeletonData.findBone(boneName);
            if (null == boneData) throw new Error("Slot bone not found: " + boneName);
            var data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);
            var color = this.getValue(slotMap, "color", null);
            null != color && data.color.setFromString(color);
            data.attachmentName = this.getValue(slotMap, "attachment", null);
            data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
            skeletonData.slots.push(data);
          }
          if (root.ik) for (var i = 0; i < root.ik.length; i++) {
            var constraintMap = root.ik[i];
            var data = new spine.IkConstraintData(constraintMap.name);
            data.order = this.getValue(constraintMap, "order", 0);
            for (var j = 0; j < constraintMap.bones.length; j++) {
              var boneName = constraintMap.bones[j];
              var bone = skeletonData.findBone(boneName);
              if (null == bone) throw new Error("IK bone not found: " + boneName);
              data.bones.push(bone);
            }
            var targetName = constraintMap.target;
            data.target = skeletonData.findBone(targetName);
            if (null == data.target) throw new Error("IK target bone not found: " + targetName);
            data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
            data.mix = this.getValue(constraintMap, "mix", 1);
            skeletonData.ikConstraints.push(data);
          }
          if (root.transform) for (var i = 0; i < root.transform.length; i++) {
            var constraintMap = root.transform[i];
            var data = new spine.TransformConstraintData(constraintMap.name);
            data.order = this.getValue(constraintMap, "order", 0);
            for (var j = 0; j < constraintMap.bones.length; j++) {
              var boneName = constraintMap.bones[j];
              var bone = skeletonData.findBone(boneName);
              if (null == bone) throw new Error("Transform constraint bone not found: " + boneName);
              data.bones.push(bone);
            }
            var targetName = constraintMap.target;
            data.target = skeletonData.findBone(targetName);
            if (null == data.target) throw new Error("Transform constraint target bone not found: " + targetName);
            data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
            data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
            data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
            data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
            data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
            data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
            data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
            data.translateMix = this.getValue(constraintMap, "translateMix", 1);
            data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
            data.shearMix = this.getValue(constraintMap, "shearMix", 1);
            skeletonData.transformConstraints.push(data);
          }
          if (root.path) for (var i = 0; i < root.path.length; i++) {
            var constraintMap = root.path[i];
            var data = new spine.PathConstraintData(constraintMap.name);
            data.order = this.getValue(constraintMap, "order", 0);
            for (var j = 0; j < constraintMap.bones.length; j++) {
              var boneName = constraintMap.bones[j];
              var bone = skeletonData.findBone(boneName);
              if (null == bone) throw new Error("Transform constraint bone not found: " + boneName);
              data.bones.push(bone);
            }
            var targetName = constraintMap.target;
            data.target = skeletonData.findSlot(targetName);
            if (null == data.target) throw new Error("Path target slot not found: " + targetName);
            data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
            data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
            data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
            data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
            data.position = this.getValue(constraintMap, "position", 0);
            data.positionMode == spine.PositionMode.Fixed && (data.position *= scale);
            data.spacing = this.getValue(constraintMap, "spacing", 0);
            data.spacingMode != spine.SpacingMode.Length && data.spacingMode != spine.SpacingMode.Fixed || (data.spacing *= scale);
            data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
            data.translateMix = this.getValue(constraintMap, "translateMix", 1);
            skeletonData.pathConstraints.push(data);
          }
          if (root.skins) for (var skinName in root.skins) {
            var skinMap = root.skins[skinName];
            var skin = new spine.Skin(skinName);
            for (var slotName in skinMap) {
              var slotIndex = skeletonData.findSlotIndex(slotName);
              if (-1 == slotIndex) throw new Error("Slot not found: " + slotName);
              var slotMap = skinMap[slotName];
              for (var entryName in slotMap) {
                var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName);
                null != attachment && skin.addAttachment(slotIndex, entryName, attachment);
              }
            }
            skeletonData.skins.push(skin);
            "default" == skin.name && (skeletonData.defaultSkin = skin);
          }
          for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
            var linkedMesh = this.linkedMeshes[i];
            var skin = null == linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
            if (null == skin) throw new Error("Skin not found: " + linkedMesh.skin);
            var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
            if (null == parent_3) throw new Error("Parent mesh not found: " + linkedMesh.parent);
            linkedMesh.mesh.setParentMesh(parent_3);
            linkedMesh.mesh.updateUVs();
          }
          this.linkedMeshes.length = 0;
          if (root.events) for (var eventName in root.events) {
            var eventMap = root.events[eventName];
            var data = new spine.EventData(eventName);
            data.intValue = this.getValue(eventMap, "int", 0);
            data.floatValue = this.getValue(eventMap, "float", 0);
            data.stringValue = this.getValue(eventMap, "string", "");
            skeletonData.events.push(data);
          }
          if (root.animations) for (var animationName in root.animations) {
            var animationMap = root.animations[animationName];
            this.readAnimation(animationMap, animationName, skeletonData);
          }
          return skeletonData;
        };
        SkeletonJson.prototype.readAttachment = function(map, skin, slotIndex, name) {
          var scale = this.scale;
          name = this.getValue(map, "name", name);
          var type = this.getValue(map, "type", "region");
          switch (type) {
           case "region":
            var path = this.getValue(map, "path", name);
            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
            if (null == region) return null;
            region.path = path;
            region.x = this.getValue(map, "x", 0) * scale;
            region.y = this.getValue(map, "y", 0) * scale;
            region.scaleX = this.getValue(map, "scaleX", 1);
            region.scaleY = this.getValue(map, "scaleY", 1);
            region.rotation = this.getValue(map, "rotation", 0);
            region.width = map.width * scale;
            region.height = map.height * scale;
            var color = this.getValue(map, "color", null);
            null != color && region.color.setFromString(color);
            region.updateOffset();
            return region;

           case "boundingbox":
            var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
            if (null == box) return null;
            this.readVertices(map, box, map.vertexCount << 1);
            var color = this.getValue(map, "color", null);
            null != color && box.color.setFromString(color);
            return box;

           case "mesh":
           case "linkedmesh":
            var path = this.getValue(map, "path", name);
            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
            if (null == mesh) return null;
            mesh.path = path;
            var color = this.getValue(map, "color", null);
            null != color && mesh.color.setFromString(color);
            var parent_4 = this.getValue(map, "parent", null);
            if (null != parent_4) {
              mesh.inheritDeform = this.getValue(map, "deform", true);
              this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_4));
              return mesh;
            }
            var uvs = map.uvs;
            this.readVertices(map, mesh, uvs.length);
            mesh.triangles = map.triangles;
            mesh.regionUVs = uvs;
            mesh.updateUVs();
            mesh.hullLength = 2 * this.getValue(map, "hull", 0);
            return mesh;

           case "path":
            var path = this.attachmentLoader.newPathAttachment(skin, name);
            if (null == path) return null;
            path.closed = this.getValue(map, "closed", false);
            path.constantSpeed = this.getValue(map, "constantSpeed", true);
            var vertexCount = map.vertexCount;
            this.readVertices(map, path, vertexCount << 1);
            var lengths = spine.Utils.newArray(vertexCount / 3, 0);
            for (var i = 0; i < map.lengths.length; i++) lengths[i++] = map.lengths[i] * scale;
            path.lengths = lengths;
            var color = this.getValue(map, "color", null);
            null != color && path.color.setFromString(color);
            return path;
          }
          return null;
        };
        SkeletonJson.prototype.readVertices = function(map, attachment, verticesLength) {
          var scale = this.scale;
          attachment.worldVerticesLength = verticesLength;
          var vertices = map.vertices;
          if (verticesLength == vertices.length) {
            if (1 != scale) for (var i = 0, n = vertices.length; i < n; i++) vertices[i] *= scale;
            attachment.vertices = spine.Utils.toFloatArray(vertices);
            return;
          }
          var weights = new Array();
          var bones = new Array();
          for (var i = 0, n = vertices.length; i < n; ) {
            var boneCount = vertices[i++];
            bones.push(boneCount);
            for (var nn = i + 4 * boneCount; i < nn; i += 4) {
              bones.push(vertices[i]);
              weights.push(vertices[i + 1] * scale);
              weights.push(vertices[i + 2] * scale);
              weights.push(vertices[i + 3]);
            }
          }
          attachment.bones = bones;
          attachment.vertices = spine.Utils.toFloatArray(weights);
        };
        SkeletonJson.prototype.readAnimation = function(map, name, skeletonData) {
          var scale = this.scale;
          var timelines = new Array();
          var duration = 0;
          if (map.slots) for (var slotName in map.slots) {
            var slotMap = map.slots[slotName];
            var slotIndex = skeletonData.findSlotIndex(slotName);
            if (-1 == slotIndex) throw new Error("Slot not found: " + slotName);
            for (var timelineName in slotMap) {
              var timelineMap = slotMap[timelineName];
              if ("color" == timelineName) {
                var timeline = new spine.ColorTimeline(timelineMap.length);
                timeline.slotIndex = slotIndex;
                var frameIndex = 0;
                for (var i = 0; i < timelineMap.length; i++) {
                  var valueMap = timelineMap[i];
                  var color = new spine.Color();
                  color.setFromString(valueMap.color);
                  timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
                  this.readCurve(valueMap, timeline, frameIndex);
                  frameIndex++;
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);
              } else {
                if (!(timelineName = "attachment")) throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
                var timeline = new spine.AttachmentTimeline(timelineMap.length);
                timeline.slotIndex = slotIndex;
                var frameIndex = 0;
                for (var i = 0; i < timelineMap.length; i++) {
                  var valueMap = timelineMap[i];
                  timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
              }
            }
          }
          if (map.bones) for (var boneName in map.bones) {
            var boneMap = map.bones[boneName];
            var boneIndex = skeletonData.findBoneIndex(boneName);
            if (-1 == boneIndex) throw new Error("Bone not found: " + boneName);
            for (var timelineName in boneMap) {
              var timelineMap = boneMap[timelineName];
              if ("rotate" === timelineName) {
                var timeline = new spine.RotateTimeline(timelineMap.length);
                timeline.boneIndex = boneIndex;
                var frameIndex = 0;
                for (var i = 0; i < timelineMap.length; i++) {
                  var valueMap = timelineMap[i];
                  timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
                  this.readCurve(valueMap, timeline, frameIndex);
                  frameIndex++;
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);
              } else {
                if ("translate" !== timelineName && "scale" !== timelineName && "shear" !== timelineName) throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
                var timeline = null;
                var timelineScale = 1;
                if ("scale" === timelineName) timeline = new spine.ScaleTimeline(timelineMap.length); else if ("shear" === timelineName) timeline = new spine.ShearTimeline(timelineMap.length); else {
                  timeline = new spine.TranslateTimeline(timelineMap.length);
                  timelineScale = scale;
                }
                timeline.boneIndex = boneIndex;
                var frameIndex = 0;
                for (var i = 0; i < timelineMap.length; i++) {
                  var valueMap = timelineMap[i];
                  var x = this.getValue(valueMap, "x", 0), y = this.getValue(valueMap, "y", 0);
                  timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
                  this.readCurve(valueMap, timeline, frameIndex);
                  frameIndex++;
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);
              }
            }
          }
          if (map.ik) for (var constraintName in map.ik) {
            var constraintMap = map.ik[constraintName];
            var constraint = skeletonData.findIkConstraint(constraintName);
            var timeline = new spine.IkConstraintTimeline(constraintMap.length);
            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
            var frameIndex = 0;
            for (var i = 0; i < constraintMap.length; i++) {
              var valueMap = constraintMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "bendPositive", true) ? 1 : -1);
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);
          }
          if (map.transform) for (var constraintName in map.transform) {
            var constraintMap = map.transform[constraintName];
            var constraint = skeletonData.findTransformConstraint(constraintName);
            var timeline = new spine.TransformConstraintTimeline(constraintMap.length);
            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
            var frameIndex = 0;
            for (var i = 0; i < constraintMap.length; i++) {
              var valueMap = constraintMap[i];
              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
              this.readCurve(valueMap, timeline, frameIndex);
              frameIndex++;
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);
          }
          if (map.paths) for (var constraintName in map.paths) {
            var constraintMap = map.paths[constraintName];
            var index = skeletonData.findPathConstraintIndex(constraintName);
            if (-1 == index) throw new Error("Path constraint not found: " + constraintName);
            var data = skeletonData.pathConstraints[index];
            for (var timelineName in constraintMap) {
              var timelineMap = constraintMap[timelineName];
              if ("position" === timelineName || "spacing" === timelineName) {
                var timeline = null;
                var timelineScale = 1;
                if ("spacing" === timelineName) {
                  timeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);
                  data.spacingMode != spine.SpacingMode.Length && data.spacingMode != spine.SpacingMode.Fixed || (timelineScale = scale);
                } else {
                  timeline = new spine.PathConstraintPositionTimeline(timelineMap.length);
                  data.positionMode == spine.PositionMode.Fixed && (timelineScale = scale);
                }
                timeline.pathConstraintIndex = index;
                var frameIndex = 0;
                for (var i = 0; i < timelineMap.length; i++) {
                  var valueMap = timelineMap[i];
                  timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
                  this.readCurve(valueMap, timeline, frameIndex);
                  frameIndex++;
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);
              } else if ("mix" === timelineName) {
                var timeline = new spine.PathConstraintMixTimeline(timelineMap.length);
                timeline.pathConstraintIndex = index;
                var frameIndex = 0;
                for (var i = 0; i < timelineMap.length; i++) {
                  var valueMap = timelineMap[i];
                  timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                  this.readCurve(valueMap, timeline, frameIndex);
                  frameIndex++;
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);
              }
            }
          }
          if (map.deform) for (var deformName in map.deform) {
            var deformMap = map.deform[deformName];
            var skin = skeletonData.findSkin(deformName);
            if (null == skin) throw new Error("Skin not found: " + deformName);
            for (var slotName in deformMap) {
              var slotMap = deformMap[slotName];
              var slotIndex = skeletonData.findSlotIndex(slotName);
              if (-1 == slotIndex) throw new Error("Slot not found: " + slotMap.name);
              for (var timelineName in slotMap) {
                var timelineMap = slotMap[timelineName];
                var attachment = skin.getAttachment(slotIndex, timelineName);
                if (null == attachment) throw new Error("Deform attachment not found: " + timelineMap.name);
                var weighted = null != attachment.bones;
                var vertices = attachment.vertices;
                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                var timeline = new spine.DeformTimeline(timelineMap.length);
                timeline.slotIndex = slotIndex;
                timeline.attachment = attachment;
                var frameIndex = 0;
                for (var j = 0; j < timelineMap.length; j++) {
                  var valueMap = timelineMap[j];
                  var deform = void 0;
                  var verticesValue = this.getValue(valueMap, "vertices", null);
                  if (null == verticesValue) deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices; else {
                    deform = spine.Utils.newFloatArray(deformLength);
                    var start = this.getValue(valueMap, "offset", 0);
                    spine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                    if (1 != scale) for (var i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;
                    if (!weighted) for (var i = 0; i < deformLength; i++) deform[i] += vertices[i];
                  }
                  timeline.setFrame(frameIndex, valueMap.time, deform);
                  this.readCurve(valueMap, timeline, frameIndex);
                  frameIndex++;
                }
                timelines.push(timeline);
                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
              }
            }
          }
          var drawOrderNode = map.drawOrder;
          null == drawOrderNode && (drawOrderNode = map.draworder);
          if (null != drawOrderNode) {
            var timeline = new spine.DrawOrderTimeline(drawOrderNode.length);
            var slotCount = skeletonData.slots.length;
            var frameIndex = 0;
            for (var j = 0; j < drawOrderNode.length; j++) {
              var drawOrderMap = drawOrderNode[j];
              var drawOrder = null;
              var offsets = this.getValue(drawOrderMap, "offsets", null);
              if (null != offsets) {
                drawOrder = spine.Utils.newArray(slotCount, -1);
                var unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);
                var originalIndex = 0, unchangedIndex = 0;
                for (var i = 0; i < offsets.length; i++) {
                  var offsetMap = offsets[i];
                  var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
                  if (-1 == slotIndex) throw new Error("Slot not found: " + offsetMap.slot);
                  while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;
                  drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
                }
                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;
                for (var i = slotCount - 1; i >= 0; i--) -1 == drawOrder[i] && (drawOrder[i] = unchanged[--unchangedIndex]);
              }
              timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
          if (map.events) {
            var timeline = new spine.EventTimeline(map.events.length);
            var frameIndex = 0;
            for (var i = 0; i < map.events.length; i++) {
              var eventMap = map.events[i];
              var eventData = skeletonData.findEvent(eventMap.name);
              if (null == eventData) throw new Error("Event not found: " + eventMap.name);
              var event_5 = new spine.Event(eventMap.time, eventData);
              event_5.intValue = this.getValue(eventMap, "int", eventData.intValue);
              event_5.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
              event_5.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
              timeline.setFrame(frameIndex++, event_5);
            }
            timelines.push(timeline);
            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
          }
          if (isNaN(duration)) throw new Error("Error while parsing animation, duration is NaN");
          skeletonData.animations.push(new spine.Animation(name, timelines, duration));
        };
        SkeletonJson.prototype.readCurve = function(map, timeline, frameIndex) {
          if (!map.curve) return;
          if ("stepped" === map.curve) timeline.setStepped(frameIndex); else if ("[object Array]" === Object.prototype.toString.call(map.curve)) {
            var curve = map.curve;
            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
          }
        };
        SkeletonJson.prototype.getValue = function(map, prop, defaultValue) {
          return void 0 !== map[prop] ? map[prop] : defaultValue;
        };
        SkeletonJson.blendModeFromString = function(str) {
          str = str.toLowerCase();
          if ("normal" == str) return spine.BlendMode.Normal;
          if ("additive" == str) return spine.BlendMode.Additive;
          if ("multiply" == str) return spine.BlendMode.Multiply;
          if ("screen" == str) return spine.BlendMode.Screen;
          throw new Error("Unknown blend mode: " + str);
        };
        SkeletonJson.positionModeFromString = function(str) {
          str = str.toLowerCase();
          if ("fixed" == str) return spine.PositionMode.Fixed;
          if ("percent" == str) return spine.PositionMode.Percent;
          throw new Error("Unknown position mode: " + str);
        };
        SkeletonJson.spacingModeFromString = function(str) {
          str = str.toLowerCase();
          if ("length" == str) return spine.SpacingMode.Length;
          if ("fixed" == str) return spine.SpacingMode.Fixed;
          if ("percent" == str) return spine.SpacingMode.Percent;
          throw new Error("Unknown position mode: " + str);
        };
        SkeletonJson.rotateModeFromString = function(str) {
          str = str.toLowerCase();
          if ("tangent" == str) return spine.RotateMode.Tangent;
          if ("chain" == str) return spine.RotateMode.Chain;
          if ("chainscale" == str) return spine.RotateMode.ChainScale;
          throw new Error("Unknown rotate mode: " + str);
        };
        SkeletonJson.transformModeFromString = function(str) {
          str = str.toLowerCase();
          if ("normal" == str) return spine.TransformMode.Normal;
          if ("onlytranslation" == str) return spine.TransformMode.OnlyTranslation;
          if ("norotationorreflection" == str) return spine.TransformMode.NoRotationOrReflection;
          if ("noscale" == str) return spine.TransformMode.NoScale;
          if ("noscaleorreflection" == str) return spine.TransformMode.NoScaleOrReflection;
          throw new Error("Unknown transform mode: " + str);
        };
        return SkeletonJson;
      })();
      spine.SkeletonJson = SkeletonJson;
      var LinkedMesh = (function() {
        function LinkedMesh(mesh, skin, slotIndex, parent) {
          this.mesh = mesh;
          this.skin = skin;
          this.slotIndex = slotIndex;
          this.parent = parent;
        }
        return LinkedMesh;
      })();
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Skin = (function() {
        function Skin(name) {
          this.attachments = new Array();
          if (null == name) throw new Error("name cannot be null.");
          this.name = name;
        }
        Skin.prototype.addAttachment = function(slotIndex, name, attachment) {
          if (null == attachment) throw new Error("attachment cannot be null.");
          var attachments = this.attachments;
          slotIndex >= attachments.length && (attachments.length = slotIndex + 1);
          attachments[slotIndex] || (attachments[slotIndex] = {});
          attachments[slotIndex][name] = attachment;
        };
        Skin.prototype.getAttachment = function(slotIndex, name) {
          var dictionary = this.attachments[slotIndex];
          return dictionary ? dictionary[name] : null;
        };
        Skin.prototype.attachAll = function(skeleton, oldSkin) {
          var slotIndex = 0;
          for (var i = 0; i < skeleton.slots.length; i++) {
            var slot = skeleton.slots[i];
            var slotAttachment = slot.getAttachment();
            if (slotAttachment && slotIndex < oldSkin.attachments.length) {
              var dictionary = oldSkin.attachments[slotIndex];
              for (var key in dictionary) {
                var skinAttachment = dictionary[key];
                if (slotAttachment == skinAttachment) {
                  var attachment = this.getAttachment(slotIndex, key);
                  null != attachment && slot.setAttachment(attachment);
                  break;
                }
              }
            }
            slotIndex++;
          }
        };
        return Skin;
      })();
      spine.Skin = Skin;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Slot = (function() {
        function Slot(data, bone) {
          this.attachmentVertices = new Array();
          if (null == data) throw new Error("data cannot be null.");
          if (null == bone) throw new Error("bone cannot be null.");
          this.data = data;
          this.bone = bone;
          this.color = new spine.Color();
          this.setToSetupPose();
        }
        Slot.prototype.getAttachment = function() {
          return this.attachment;
        };
        Slot.prototype.setAttachment = function(attachment) {
          if (this.attachment == attachment) return;
          this.attachment = attachment;
          this.attachmentTime = this.bone.skeleton.time;
          this.attachmentVertices.length = 0;
        };
        Slot.prototype.setAttachmentTime = function(time) {
          this.attachmentTime = this.bone.skeleton.time - time;
        };
        Slot.prototype.getAttachmentTime = function() {
          return this.bone.skeleton.time - this.attachmentTime;
        };
        Slot.prototype.setToSetupPose = function() {
          this.color.setFromColor(this.data.color);
          if (null == this.data.attachmentName) this.attachment = null; else {
            this.attachment = null;
            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
          }
        };
        return Slot;
      })();
      spine.Slot = Slot;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var SlotData = (function() {
        function SlotData(index, name, boneData) {
          this.color = new spine.Color(1, 1, 1, 1);
          if (index < 0) throw new Error("index must be >= 0.");
          if (null == name) throw new Error("name cannot be null.");
          if (null == boneData) throw new Error("boneData cannot be null.");
          this.index = index;
          this.name = name;
          this.boneData = boneData;
        }
        return SlotData;
      })();
      spine.SlotData = SlotData;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var Texture = (function() {
        function Texture(image) {
          this._image = image;
        }
        Texture.prototype.getImage = function() {
          return this._image;
        };
        Texture.filterFromString = function(text) {
          switch (text.toLowerCase()) {
           case "nearest":
            return TextureFilter.Nearest;

           case "linear":
            return TextureFilter.Linear;

           case "mipmap":
            return TextureFilter.MipMap;

           case "mipmapnearestnearest":
            return TextureFilter.MipMapNearestNearest;

           case "mipmaplinearnearest":
            return TextureFilter.MipMapLinearNearest;

           case "mipmapnearestlinear":
            return TextureFilter.MipMapNearestLinear;

           case "mipmaplinearlinear":
            return TextureFilter.MipMapLinearLinear;

           default:
            throw new Error("Unknown texture filter " + text);
          }
        };
        Texture.wrapFromString = function(text) {
          switch (text.toLowerCase()) {
           case "mirroredtepeat":
            return TextureWrap.MirroredRepeat;

           case "clamptoedge":
            return TextureWrap.ClampToEdge;

           case "repeat":
            return TextureWrap.Repeat;

           default:
            throw new Error("Unknown texture wrap " + text);
          }
        };
        return Texture;
      })();
      spine.Texture = Texture;
      (function(TextureFilter) {
        TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
        TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
        TextureFilter[TextureFilter["MipMap"] = 9987] = "MipMap";
        TextureFilter[TextureFilter["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
        TextureFilter[TextureFilter["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
        TextureFilter[TextureFilter["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
        TextureFilter[TextureFilter["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
      })(spine.TextureFilter || (spine.TextureFilter = {}));
      var TextureFilter = spine.TextureFilter;
      (function(TextureWrap) {
        TextureWrap[TextureWrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
        TextureWrap[TextureWrap["ClampToEdge"] = 33071] = "ClampToEdge";
        TextureWrap[TextureWrap["Repeat"] = 10497] = "Repeat";
      })(spine.TextureWrap || (spine.TextureWrap = {}));
      var TextureWrap = spine.TextureWrap;
      var TextureRegion = (function() {
        function TextureRegion() {
          this.u = 0;
          this.v = 0;
          this.u2 = 0;
          this.v2 = 0;
          this.width = 0;
          this.height = 0;
          this.rotate = false;
          this.offsetX = 0;
          this.offsetY = 0;
          this.originalWidth = 0;
          this.originalHeight = 0;
        }
        return TextureRegion;
      })();
      spine.TextureRegion = TextureRegion;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var TextureAtlas = (function() {
        function TextureAtlas(atlasText, textureLoader) {
          this.pages = new Array();
          this.regions = new Array();
          this.load(atlasText, textureLoader);
        }
        TextureAtlas.prototype.load = function(atlasText, textureLoader) {
          if (null == textureLoader) throw new Error("textureLoader cannot be null.");
          var reader = new TextureAtlasReader(atlasText);
          var tuple = new Array(4);
          var page = null;
          while (true) {
            var line = reader.readLine();
            if (null == line) break;
            line = line.trim();
            if (0 == line.length) page = null; else if (page) {
              var region = new TextureAtlasRegion();
              region.name = line;
              region.page = page;
              region.rotate = "true" == reader.readValue();
              reader.readTuple(tuple);
              var x = parseInt(tuple[0]);
              var y = parseInt(tuple[1]);
              reader.readTuple(tuple);
              var width = parseInt(tuple[0]);
              var height = parseInt(tuple[1]);
              region.u = x / page.width;
              region.v = y / page.height;
              if (region.rotate) {
                region.u2 = (x + height) / page.width;
                region.v2 = (y + width) / page.height;
              } else {
                region.u2 = (x + width) / page.width;
                region.v2 = (y + height) / page.height;
              }
              region.x = x;
              region.y = y;
              region.width = Math.abs(width);
              region.height = Math.abs(height);
              4 == reader.readTuple(tuple) && 4 == reader.readTuple(tuple) && reader.readTuple(tuple);
              region.originalWidth = parseInt(tuple[0]);
              region.originalHeight = parseInt(tuple[1]);
              reader.readTuple(tuple);
              region.offsetX = parseInt(tuple[0]);
              region.offsetY = parseInt(tuple[1]);
              region.index = parseInt(reader.readValue());
              region.texture = page.texture;
              this.regions.push(region);
            } else {
              page = new TextureAtlasPage();
              page.name = line;
              if (2 == reader.readTuple(tuple)) {
                page.width = parseInt(tuple[0]);
                page.height = parseInt(tuple[1]);
                reader.readTuple(tuple);
              }
              reader.readTuple(tuple);
              page.minFilter = spine.Texture.filterFromString(tuple[0]);
              page.magFilter = spine.Texture.filterFromString(tuple[1]);
              var direction = reader.readValue();
              page.uWrap = spine.TextureWrap.ClampToEdge;
              page.vWrap = spine.TextureWrap.ClampToEdge;
              "x" == direction ? page.uWrap = spine.TextureWrap.Repeat : "y" == direction ? page.vWrap = spine.TextureWrap.Repeat : "xy" == direction && (page.uWrap = page.vWrap = spine.TextureWrap.Repeat);
              page.texture = textureLoader(line);
              page.texture.setFilters(page.minFilter, page.magFilter);
              page.texture.setWraps(page.uWrap, page.vWrap);
              page.width = page.texture.getImage().width;
              page.height = page.texture.getImage().height;
              this.pages.push(page);
            }
          }
        };
        TextureAtlas.prototype.findRegion = function(name) {
          for (var i = 0; i < this.regions.length; i++) if (this.regions[i].name == name) return this.regions[i];
          return null;
        };
        TextureAtlas.prototype.dispose = function() {
          for (var i = 0; i < this.pages.length; i++) this.pages[i].texture.dispose();
        };
        return TextureAtlas;
      })();
      spine.TextureAtlas = TextureAtlas;
      var TextureAtlasReader = (function() {
        function TextureAtlasReader(text) {
          this.index = 0;
          this.lines = text.split(/\r\n|\r|\n/);
        }
        TextureAtlasReader.prototype.readLine = function() {
          if (this.index >= this.lines.length) return null;
          return this.lines[this.index++];
        };
        TextureAtlasReader.prototype.readValue = function() {
          var line = this.readLine();
          var colon = line.indexOf(":");
          if (-1 == colon) throw new Error("Invalid line: " + line);
          return line.substring(colon + 1).trim();
        };
        TextureAtlasReader.prototype.readTuple = function(tuple) {
          var line = this.readLine();
          var colon = line.indexOf(":");
          if (-1 == colon) throw new Error("Invalid line: " + line);
          var i = 0, lastMatch = colon + 1;
          for (;i < 3; i++) {
            var comma = line.indexOf(",", lastMatch);
            if (-1 == comma) break;
            tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();
            lastMatch = comma + 1;
          }
          tuple[i] = line.substring(lastMatch).trim();
          return i + 1;
        };
        return TextureAtlasReader;
      })();
      var TextureAtlasPage = (function() {
        function TextureAtlasPage() {}
        return TextureAtlasPage;
      })();
      spine.TextureAtlasPage = TextureAtlasPage;
      var TextureAtlasRegion = (function(_super) {
        __extends(TextureAtlasRegion, _super);
        function TextureAtlasRegion() {
          _super.apply(this, arguments);
        }
        return TextureAtlasRegion;
      })(spine.TextureRegion);
      spine.TextureAtlasRegion = TextureAtlasRegion;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var TransformConstraint = (function() {
        function TransformConstraint(data, skeleton) {
          this.rotateMix = 0;
          this.translateMix = 0;
          this.scaleMix = 0;
          this.shearMix = 0;
          this.temp = new spine.Vector2();
          if (null == data) throw new Error("data cannot be null.");
          if (null == skeleton) throw new Error("skeleton cannot be null.");
          this.data = data;
          this.rotateMix = data.rotateMix;
          this.translateMix = data.translateMix;
          this.scaleMix = data.scaleMix;
          this.shearMix = data.shearMix;
          this.bones = new Array();
          for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));
          this.target = skeleton.findBone(data.target.name);
        }
        TransformConstraint.prototype.apply = function() {
          this.update();
        };
        TransformConstraint.prototype.update = function() {
          var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
          var target = this.target;
          var ta = target.a, tb = target.b, tc = target.c, td = target.d;
          var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
          var offsetRotation = this.data.offsetRotation * degRadReflect;
          var offsetShearY = this.data.offsetShearY * degRadReflect;
          var bones = this.bones;
          for (var i = 0, n = bones.length; i < n; i++) {
            var bone = bones[i];
            var modified = false;
            if (0 != rotateMix) {
              var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
              var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
              r > spine.MathUtils.PI ? r -= spine.MathUtils.PI2 : r < -spine.MathUtils.PI && (r += spine.MathUtils.PI2);
              r *= rotateMix;
              var cos = Math.cos(r), sin = Math.sin(r);
              bone.a = cos * a - sin * c;
              bone.b = cos * b - sin * d;
              bone.c = sin * a + cos * c;
              bone.d = sin * b + cos * d;
              modified = true;
            }
            if (0 != translateMix) {
              var temp = this.temp;
              target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
              bone.worldX += (temp.x - bone.worldX) * translateMix;
              bone.worldY += (temp.y - bone.worldY) * translateMix;
              modified = true;
            }
            if (scaleMix > 0) {
              var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
              var ts = Math.sqrt(ta * ta + tc * tc);
              s > 1e-5 && (s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s);
              bone.a *= s;
              bone.c *= s;
              s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
              ts = Math.sqrt(tb * tb + td * td);
              s > 1e-5 && (s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s);
              bone.b *= s;
              bone.d *= s;
              modified = true;
            }
            if (shearMix > 0) {
              var b = bone.b, d = bone.d;
              var by = Math.atan2(d, b);
              var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));
              r > spine.MathUtils.PI ? r -= spine.MathUtils.PI2 : r < -spine.MathUtils.PI && (r += spine.MathUtils.PI2);
              r = by + (r + offsetShearY) * shearMix;
              var s = Math.sqrt(b * b + d * d);
              bone.b = Math.cos(r) * s;
              bone.d = Math.sin(r) * s;
              modified = true;
            }
            modified && (bone.appliedValid = false);
          }
        };
        TransformConstraint.prototype.getOrder = function() {
          return this.data.order;
        };
        return TransformConstraint;
      })();
      spine.TransformConstraint = TransformConstraint;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var TransformConstraintData = (function() {
        function TransformConstraintData(name) {
          this.order = 0;
          this.bones = new Array();
          this.rotateMix = 0;
          this.translateMix = 0;
          this.scaleMix = 0;
          this.shearMix = 0;
          this.offsetRotation = 0;
          this.offsetX = 0;
          this.offsetY = 0;
          this.offsetScaleX = 0;
          this.offsetScaleY = 0;
          this.offsetShearY = 0;
          if (null == name) throw new Error("name cannot be null.");
          this.name = name;
        }
        return TransformConstraintData;
      })();
      spine.TransformConstraintData = TransformConstraintData;
    })(spine || (spine = {}));
    var spine;
    (function(spine) {
      var IntSet = (function() {
        function IntSet() {
          this.array = new Array();
        }
        IntSet.prototype.add = function(value) {
          var contains = this.contains(value);
          this.array[0 | value] = 0 | value;
          return !contains;
        };
        IntSet.prototype.contains = function(value) {
          return void 0 != this.array[0 | value];
        };
        IntSet.prototype.remove = function(value) {
          this.array[0 | value] = void 0;
        };
        IntSet.prototype.clear = function() {
          this.array.length = 0;
        };
        return IntSet;
      })();
      spine.IntSet = IntSet;
      var Color = (function() {
        function Color(r, g, b, a) {
          void 0 === r && (r = 0);
          void 0 === g && (g = 0);
          void 0 === b && (b = 0);
          void 0 === a && (a = 0);
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
        }
        Color.prototype.set = function(r, g, b, a) {
          this.r = r;
          this.g = g;
          this.b = b;
          this.a = a;
          this.clamp();
          return this;
        };
        Color.prototype.setFromColor = function(c) {
          this.r = c.r;
          this.g = c.g;
          this.b = c.b;
          this.a = c.a;
          return this;
        };
        Color.prototype.setFromString = function(hex) {
          hex = "#" == hex.charAt(0) ? hex.substr(1) : hex;
          this.r = parseInt(hex.substr(0, 2), 16) / 255;
          this.g = parseInt(hex.substr(2, 2), 16) / 255;
          this.b = parseInt(hex.substr(4, 2), 16) / 255;
          this.a = (8 != hex.length ? 255 : parseInt(hex.substr(6, 2), 16)) / 255;
          return this;
        };
        Color.prototype.add = function(r, g, b, a) {
          this.r += r;
          this.g += g;
          this.b += b;
          this.a += a;
          this.clamp();
          return this;
        };
        Color.prototype.clamp = function() {
          this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1);
          this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1);
          this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1);
          this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1);
          return this;
        };
        Color.WHITE = new Color(1, 1, 1, 1);
        Color.RED = new Color(1, 0, 0, 1);
        Color.GREEN = new Color(0, 1, 0, 1);
        Color.BLUE = new Color(0, 0, 1, 1);
        Color.MAGENTA = new Color(1, 0, 1, 1);
        return Color;
      })();
      spine.Color = Color;
      var MathUtils = (function() {
        function MathUtils() {}
        MathUtils.clamp = function(value, min, max) {
          if (value < min) return min;
          if (value > max) return max;
          return value;
        };
        MathUtils.cosDeg = function(degrees) {
          return Math.cos(degrees * MathUtils.degRad);
        };
        MathUtils.sinDeg = function(degrees) {
          return Math.sin(degrees * MathUtils.degRad);
        };
        MathUtils.signum = function(value) {
          return value > 0 ? 1 : value < 0 ? -1 : 0;
        };
        MathUtils.toInt = function(x) {
          return x > 0 ? Math.floor(x) : Math.ceil(x);
        };
        MathUtils.cbrt = function(x) {
          var y = Math.pow(Math.abs(x), 1 / 3);
          return x < 0 ? -y : y;
        };
        MathUtils.PI = 3.1415927;
        MathUtils.PI2 = 2 * MathUtils.PI;
        MathUtils.radiansToDegrees = 180 / MathUtils.PI;
        MathUtils.radDeg = MathUtils.radiansToDegrees;
        MathUtils.degreesToRadians = MathUtils.PI / 180;
        MathUtils.degRad = MathUtils.degreesToRadians;
        return MathUtils;
      })();
      spine.MathUtils = MathUtils;
      var Utils = (function() {
        function Utils() {}
        Utils.arrayCopy = function(source, sourceStart, dest, destStart, numElements) {
          for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) dest[j] = source[i];
        };
        Utils.setArraySize = function(array, size, value) {
          void 0 === value && (value = 0);
          var oldSize = array.length;
          if (oldSize == size) return array;
          array.length = size;
          if (oldSize < size) for (var i = oldSize; i < size; i++) array[i] = value;
          return array;
        };
        Utils.ensureArrayCapacity = function(array, size, value) {
          void 0 === value && (value = 0);
          if (array.length >= size) return array;
          return Utils.setArraySize(array, size, value);
        };
        Utils.newArray = function(size, defaultValue) {
          var array = new Array(size);
          for (var i = 0; i < size; i++) array[i] = defaultValue;
          return array;
        };
        Utils.newFloatArray = function(size) {
          if (Utils.SUPPORTS_TYPED_ARRAYS) return new Float32Array(size);
          var array = new Array(size);
          for (var i = 0; i < array.length; i++) array[i] = 0;
          return array;
        };
        Utils.toFloatArray = function(array) {
          return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
        };
        Utils.SUPPORTS_TYPED_ARRAYS = "undefined" !== typeof Float32Array;
        return Utils;
      })();
      spine.Utils = Utils;
      var DebugUtils = (function() {
        function DebugUtils() {}
        DebugUtils.logBones = function(skeleton) {
          for (var i = 0; i < skeleton.bones.length; i++) {
            var bone = skeleton.bones[i];
            console.log(bone.data.name + ", " + bone.a + ", " + bone.b + ", " + bone.c + ", " + bone.d + ", " + bone.worldX + ", " + bone.worldY);
          }
        };
        return DebugUtils;
      })();
      spine.DebugUtils = DebugUtils;
      var Pool = (function() {
        function Pool(instantiator) {
          this.items = new Array();
          this.instantiator = instantiator;
        }
        Pool.prototype.obtain = function() {
          return this.items.length > 0 ? this.items.pop() : this.instantiator();
        };
        Pool.prototype.free = function(item) {
          item.reset && item.reset();
          this.items.push(item);
        };
        Pool.prototype.freeAll = function(items) {
          for (var i = 0; i < items.length; i++) {
            items[i].reset && items[i].reset();
            this.items[i] = items[i];
          }
        };
        Pool.prototype.clear = function() {
          this.items.length = 0;
        };
        return Pool;
      })();
      spine.Pool = Pool;
      var Vector2 = (function() {
        function Vector2(x, y) {
          void 0 === x && (x = 0);
          void 0 === y && (y = 0);
          this.x = x;
          this.y = y;
        }
        Vector2.prototype.set = function(x, y) {
          this.x = x;
          this.y = y;
          return this;
        };
        Vector2.prototype.length = function() {
          var x = this.x;
          var y = this.y;
          return Math.sqrt(x * x + y * y);
        };
        Vector2.prototype.normalize = function() {
          var len = this.length();
          if (0 != len) {
            this.x /= len;
            this.y /= len;
          }
          return this;
        };
        return Vector2;
      })();
      spine.Vector2 = Vector2;
      var TimeKeeper = (function() {
        function TimeKeeper() {
          this.maxDelta = .064;
          this.framesPerSecond = 0;
          this.delta = 0;
          this.totalTime = 0;
          this.lastTime = Date.now() / 1e3;
          this.frameCount = 0;
          this.frameTime = 0;
        }
        TimeKeeper.prototype.update = function() {
          var now = Date.now() / 1e3;
          this.delta = now - this.lastTime;
          this.frameTime += this.delta;
          this.totalTime += this.delta;
          this.delta > this.maxDelta && (this.delta = this.maxDelta);
          this.lastTime = now;
          this.frameCount++;
          if (this.frameTime > 1) {
            this.framesPerSecond = this.frameCount / this.frameTime;
            this.frameTime = 0;
            this.frameCount = 0;
          }
        };
        return TimeKeeper;
      })();
      spine.TimeKeeper = TimeKeeper;
    })(spine || (spine = {}));
    module.exports = spine;
  }), {} ],
  285: [ (function(require, module, exports) {
    var SkeletonData = cc.Class({
      name: "sp.SkeletonData",
      extends: cc.Asset,
      ctor: function() {
        this.reset();
      },
      properties: {
        _skeletonJson: null,
        skeletonJson: {
          get: function() {
            return this._skeletonJson;
          },
          set: function(value) {
            this._skeletonJson = value;
            this.reset();
          }
        },
        _atlasText: "",
        atlasText: {
          get: function() {
            return this._atlasText;
          },
          set: function(value) {
            this._atlasText = value;
            this.reset();
          }
        },
        textures: {
          default: [],
          type: [ cc.Texture2D ]
        },
        textureNames: {
          default: [],
          type: [ cc.String ]
        },
        scale: 1
      },
      statics: {
        preventDeferredLoadDependents: true,
        preventPreloadNativeObject: true
      },
      createNode: false,
      reset: function() {
        this._skeletonCache = null;
        this._atlasCache = null;
        false;
      },
      getRuntimeData: function(quiet) {
        if (this._skeletonCache) return this._skeletonCache;
        if (!(this.textures && this.textures.length > 0) && this.textureNames && this.textureNames.length > 0) {
          quiet || cc.errorID(7507, this.name);
          return null;
        }
        var atlas = this._getAtlas(quiet);
        if (!atlas) return null;
        var attachmentLoader = new sp.spine.AtlasAttachmentLoader(atlas);
        var jsonReader = new sp.spine.SkeletonJson(attachmentLoader);
        jsonReader.scale = this.scale;
        var json = this.skeletonJson;
        this._skeletonCache = jsonReader.readSkeletonData(json);
        atlas.dispose(jsonReader);
        return this._skeletonCache;
      },
      getSkinsEnum: false,
      getAnimsEnum: false,
      _getTexture: function(line) {
        var names = this.textureNames;
        for (var i = 0; i < names.length; i++) if (names[i] === line) {
          var texture = this.textures[i];
          var tex = new sp.SkeletonTexture({
            width: texture.width,
            height: texture.height
          });
          tex.setRealTexture(texture);
          return tex;
        }
        cc.errorID(7506, line);
        return null;
      },
      _getAtlas: function(quiet) {
        if (this._atlasCache) return this._atlasCache;
        if (!this.atlasText) {
          quiet || cc.errorID(7508, this.name);
          return null;
        }
        return this._atlasCache = new sp.spine.TextureAtlas(this.atlasText, this._getTexture.bind(this));
      }
    });
    sp.SkeletonData = module.exports = SkeletonData;
  }), {} ],
  286: [ (function(require, module, exports) {
    sp.SkeletonTexture = cc.Class({
      name: "sp.SkeletonTexture",
      extends: sp.spine.Texture,
      _texture: null,
      _material: null,
      setRealTexture: function(tex) {
        this._texture = tex;
      },
      getRealTexture: function() {
        return this._texture;
      },
      setFilters: function(minFilter, magFilter) {
        this._texture && this._texture.setFilters(minFilter, magFilter);
      },
      setWraps: function(uWrap, vWrap) {
        this._texture && this._texture.setWrapMode(uWrap, vWrap);
      },
      dispose: function() {}
    });
  }), {} ],
  287: [ (function(require, module, exports) {
    var TrackEntryListeners = require("./track-entry-listeners");
    var RenderComponent = require("../../cocos2d/core/components/CCRenderComponent");
    var spine = require("./lib/spine");
    var renderEngine = require("../../cocos2d/core/renderer/render-engine");
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var Node = require("../../cocos2d/core/CCNode");
    var Graphics = require("../../cocos2d/core/graphics/graphics");
    var DefaultSkinsEnum = cc.Enum({
      default: -1
    });
    var DefaultAnimsEnum = cc.Enum({
      "<None>": 0
    });
    function setEnumAttr(obj, propName, enumDef) {
      cc.Class.attr(obj, propName, {
        type: "Enum",
        enumList: cc.Enum.getList(enumDef)
      });
    }
    sp.Skeleton = cc.Class({
      name: "sp.Skeleton",
      extends: RenderComponent,
      editor: false,
      properties: {
        paused: {
          default: false,
          visible: false
        },
        skeletonData: {
          default: null,
          type: sp.SkeletonData,
          notify: function() {
            this.defaultSkin = "";
            this.defaultAnimation = "";
            false;
            this._updateSkeletonData();
          },
          tooltip: false
        },
        defaultSkin: {
          default: "",
          visible: false
        },
        defaultAnimation: {
          default: "",
          visible: false
        },
        animation: {
          get: function() {
            var entry = this.getCurrent(0);
            return entry && entry.animation.name || "";
          },
          set: function(value) {
            this.defaultAnimation = value;
            if (value) this.setAnimation(0, value, this.loop); else {
              this.clearTrack(0);
              this.setToSetupPose();
            }
          },
          visible: false
        },
        _defaultSkinIndex: {
          get: function() {
            if (this.skeletonData && this.defaultSkin) {
              var skinsEnum = this.skeletonData.getSkinsEnum();
              if (skinsEnum) {
                var skinIndex = skinsEnum[this.defaultSkin];
                if (void 0 !== skinIndex) return skinIndex;
              }
            }
            return 0;
          },
          set: function(value) {
            var skinsEnum;
            this.skeletonData && (skinsEnum = this.skeletonData.getSkinsEnum());
            if (!skinsEnum) return cc.errorID("", this.name);
            var skinName = skinsEnum[value];
            if (void 0 !== skinName) {
              this.defaultSkin = skinName;
              false;
            } else cc.errorID(7501, this.name);
          },
          type: DefaultSkinsEnum,
          visible: true,
          displayName: "Default Skin",
          tooltip: false
        },
        _animationIndex: {
          get: function() {
            var animationName = this.animation;
            if (this.skeletonData && animationName) {
              var animsEnum = this.skeletonData.getAnimsEnum();
              if (animsEnum) {
                var animIndex = animsEnum[animationName];
                if (void 0 !== animIndex) return animIndex;
              }
            }
            return 0;
          },
          set: function(value) {
            if (0 === value) {
              this.animation = "";
              return;
            }
            var animsEnum;
            this.skeletonData && (animsEnum = this.skeletonData.getAnimsEnum());
            if (!animsEnum) return cc.errorID(7502, this.name);
            var animName = animsEnum[value];
            void 0 !== animName ? this.animation = animName : cc.errorID(7503, this.name);
          },
          type: DefaultAnimsEnum,
          visible: true,
          displayName: "Animation",
          tooltip: false
        },
        loop: {
          default: true,
          tooltip: false
        },
        premultipliedAlpha: {
          default: true,
          tooltip: false
        },
        timeScale: {
          default: 1,
          tooltip: false
        },
        debugSlots: {
          default: false,
          editorOnly: true,
          tooltip: false
        },
        debugBones: {
          default: false,
          editorOnly: true,
          tooltip: false
        }
      },
      ctor: function() {
        this._skeleton = null;
        this._rootBone = null;
        this._listener = null;
        this._boundingBox = cc.rect();
        this._material = new SpriteMaterial();
        this._renderDatas = [];
        this._debugNode = new Node();
        this._debugRenderer = this._debugNode.addComponent(Graphics);
      },
      setSkeletonData: function(skeletonData) {
        null != skeletonData.width && null != skeletonData.height && this.node.setContentSize(skeletonData.width, skeletonData.height);
        this._skeleton = new spine.Skeleton(skeletonData);
        this._rootBone = this._skeleton.getRootBone();
      },
      setAnimationStateData: function(stateData) {
        var state = new spine.AnimationState(stateData);
        if (this._listener) {
          this._state && this._listener && this._state.removeListener(this._listener);
          state.addListener(this._listener);
        }
        this._state = state;
      },
      __preload: function() {
        var Flags;
        false;
        this._updateSkeletonData();
      },
      onDestroy: function() {
        this._super();
        this._debugNode.destroy();
        this._debugRenderer.clear();
        this._renderDatas.length = 0;
      },
      updateWorldTransform: function() {
        this._skeleton && this._skeleton.updateWorldTransform();
      },
      setToSetupPose: function() {
        this._skeleton && this._skeleton.setToSetupPose();
      },
      setBonesToSetupPose: function() {
        this._skeleton && this._skeleton.setBonesToSetupPose();
      },
      setSlotsToSetupPose: function() {
        this._skeleton && this._skeleton.setSlotsToSetupPose();
      },
      findBone: function(boneName) {
        if (this._skeleton) return this._skeleton.findBone(boneName);
        return null;
      },
      findSlot: function(slotName) {
        if (this._skeleton) return this._skeleton.findSlot(slotName);
        return null;
      },
      setSkin: function(skinName) {
        if (this._skeleton) return this._skeleton.setSkin(skinName);
        return null;
      },
      getAttachment: function(slotName, attachmentName) {
        if (this._skeleton) return this._skeleton.getAttachment(slotName, attachmentName);
        return null;
      },
      setAttachment: function(slotName, attachmentName) {
        this._skeleton && this._skeleton.setAttachment(slotName, attachmentName);
      },
      getTextureAtlas: function(regionAttachment) {
        return regionAttachment.region;
      },
      setMix: function(fromAnimation, toAnimation, duration) {
        this._state && this._state.data.setMixWith(fromAnimation, toAnimation, duration);
      },
      setAnimationListener: function(target, callback) {
        this._skeleton && this._skeleton.setAnimationListener(target, callback);
      },
      setAnimation: function(trackIndex, name, loop) {
        if (this._skeleton) {
          var animation = this._skeleton.data.findAnimation(name);
          if (!animation) {
            cc.logID(7509, name);
            return null;
          }
          var res = this._state.setAnimationWith(trackIndex, animation, loop);
          false;
          return res;
        }
        return null;
      },
      addAnimation: function(trackIndex, name, loop, delay) {
        if (this._skeleton) {
          delay = delay || 0;
          var animation = this._skeleton.data.findAnimation(name);
          if (!animation) {
            cc.logID(7510, name);
            return null;
          }
          return this._state.addAnimationWith(trackIndex, animation, loop, delay);
        }
        return null;
      },
      findAnimation: function(name) {
        if (this._skeleton) return this._skeleton.data.findAnimation(name);
        return null;
      },
      getCurrent: function(trackIndex) {
        if (this._state) return this._state.getCurrent(trackIndex);
        return null;
      },
      clearTracks: function() {
        this._state && this._state.clearTracks();
      },
      clearTrack: function(trackIndex) {
        if (this._state) {
          this._state.clearTrack(trackIndex);
          false;
        }
      },
      setStartListener: function(listener) {
        this._ensureListener();
        this._listener.start = listener;
      },
      setInterruptListener: function(listener) {
        this._ensureListener();
        this._listener.interrupt = listener;
      },
      setEndListener: function(listener) {
        this._ensureListener();
        this._listener.end = listener;
      },
      setDisposeListener: function(listener) {
        this._ensureListener();
        this._listener.dispose = listener;
      },
      setCompleteListener: function(listener) {
        this._ensureListener();
        this._listener.complete = listener;
      },
      setEventListener: function(listener) {
        this._ensureListener();
        this._listener.event = listener;
      },
      setTrackStartListener: function(entry, listener) {
        TrackEntryListeners.getListeners(entry).start = listener;
      },
      setTrackInterruptListener: function(entry, listener) {
        TrackEntryListeners.getListeners(entry).interrupt = listener;
      },
      setTrackEndListener: function(entry, listener) {
        TrackEntryListeners.getListeners(entry).end = listener;
      },
      setTrackDisposeListener: function(entry, listener) {
        TrackEntryListeners.getListeners(entry).dispose = listener;
      },
      setTrackCompleteListener: function(entry, listener) {
        TrackEntryListeners.getListeners(entry).complete = function(trackEntry) {
          var loopCount = Math.floor(trackEntry.trackTime / trackEntry.animationEnd);
          listener(trackEntry, loopCount);
        };
      },
      setTrackEventListener: function(entry, listener) {
        TrackEntryListeners.getListeners(entry).event = listener;
      },
      getState: function() {
        return this._state;
      },
      _updateAnimEnum: false,
      _updateSkinEnum: false,
      _ensureListener: function() {
        if (!this._listener) {
          this._listener = new TrackEntryListeners();
          this._state.addListener(this._listener);
        }
      },
      _updateSkeletonData: function() {
        if (this.skeletonData) {
          var data = this.skeletonData.getRuntimeData();
          if (data) {
            try {
              this.setSkeletonData(data);
              this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data));
              this.defaultSkin && this._skeleton.setSkinByName(this.defaultSkin);
            } catch (e) {
              cc.warn(e);
            }
            this.animation = this.defaultAnimation;
          }
        }
      },
      _refreshInspector: function() {
        this._updateAnimEnum();
        this._updateSkinEnum();
        Editor.Utils.refreshSelectedInspector("node", this.node.uuid);
      }
    });
    module.exports = sp.Skeleton;
  }), {
    "../../cocos2d/core/CCNode": 30,
    "../../cocos2d/core/components/CCRenderComponent": 77,
    "../../cocos2d/core/graphics/graphics": 104,
    "../../cocos2d/core/renderer/render-engine": 197,
    "./lib/spine": 284,
    "./track-entry-listeners": 289
  } ],
  288: [ (function(require, module, exports) {
    var js = require("../../cocos2d/core/platform/js");
    var Skeleton = require("./skeleton");
    var spine = require("./lib/spine");
    var renderer = require("../../cocos2d/core/renderer");
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var vfmtPosUvColor = require("../../cocos2d/core/renderer/webgl/vertex-format").vfmtPosUvColor;
    var renderEngine = renderer.renderEngine;
    var gfx = renderEngine.gfx;
    var SpriteMaterial = renderEngine.SpriteMaterial;
    var _sharedMaterials = {};
    var _slotColor = cc.color(0, 0, 255, 255);
    var _boneColor = cc.color(255, 0, 0, 255);
    var _originColor = cc.color(0, 255, 0, 255);
    var _debugMaterial = new SpriteMaterial();
    _debugMaterial.useModel = true;
    _debugMaterial.useColor = false;
    _debugMaterial.useTexture = false;
    _debugMaterial.updateHash();
    function _getSlotMaterial(slot, tex, premultiAlpha) {
      var src = void 0, dst = void 0;
      switch (slot.data.blendMode) {
       case spine.BlendMode.Additive:
        src = premultiAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
        dst = cc.macro.ONE;
        break;

       case spine.BlendMode.Multiply:
        src = cc.macro.DST_COLOR;
        dst = cc.macro.ONE_MINUS_SRC_ALPHA;
        break;

       case spine.BlendMode.Screen:
        src = cc.macro.ONE;
        dst = cc.macro.ONE_MINUS_SRC_COLOR;
        break;

       case spine.BlendMode.Normal:
       default:
        src = premultiAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
        dst = cc.macro.ONE_MINUS_SRC_ALPHA;
      }
      var key = tex.url + src + dst;
      var material = _sharedMaterials[key];
      if (material) {
        if (material.texture !== tex) {
          material.texture = tex;
          material.updateHash();
        }
      } else {
        material = new SpriteMaterial();
        material.useModel = true;
        material.texture = tex;
        material.useColor = false;
        var pass = material._mainTech.passes[0];
        pass.setBlend(gfx.BLEND_FUNC_ADD, src, dst, gfx.BLEND_FUNC_ADD, src, dst);
        _sharedMaterials[key] = material;
        material.updateHash();
      }
      return material;
    }
    var spineAssembler = {
      useModel: true,
      _readAttachmentData: function(comp, attachment, slot, premultipliedAlpha, renderData, dataOffset) {
        var vertices = attachment.updateWorldVertices(slot, premultipliedAlpha);
        var vertexCount = vertices.length / 8;
        var graphics = comp._debugRenderer;
        renderData.dataLength += vertexCount;
        var data = renderData._data;
        var nodeColor = comp.node._color;
        var nodeR = nodeColor.r, nodeG = nodeColor.g, nodeB = nodeColor.b, nodeA = nodeColor.a;
        for (var i = 0, n = vertices.length; i < n; i += 8) {
          var r = vertices[i + 2] * nodeR, g = vertices[i + 3] * nodeG, b = vertices[i + 4] * nodeB, a = vertices[i + 5] * nodeA;
          var color = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
          var content = data[dataOffset];
          content.x = vertices[i];
          content.y = vertices[i + 1];
          content.color = color;
          content.u = vertices[i + 6];
          content.v = vertices[i + 7];
          dataOffset++;
        }
        if (comp.debugSlots && 4 === vertexCount) {
          var VERTEX = spine.RegionAttachment;
          graphics.strokeColor = _slotColor;
          graphics.lineWidth = 5;
          graphics.moveTo(vertices[VERTEX.X1], vertices[VERTEX.Y1]);
          graphics.lineTo(vertices[VERTEX.X2], vertices[VERTEX.Y2]);
          graphics.lineTo(vertices[VERTEX.X3], vertices[VERTEX.Y3]);
          graphics.lineTo(vertices[VERTEX.X4], vertices[VERTEX.Y4]);
          graphics.close();
          graphics.stroke();
        }
        return vertexCount;
      },
      genRenderDatas: function(comp, batchData) {
        var locSkeleton = comp._skeleton;
        var premultiAlpha = comp.premultipliedAlpha;
        var graphics = comp._debugRenderer;
        (comp.debugBones || comp.debugSlots) && graphics.clear();
        var attachment = void 0, slot = void 0;
        var dataId = 0, datas = comp._renderDatas, data = datas[dataId], newData = false;
        data || (data = datas[dataId] = comp.requestRenderData());
        data.dataLength = 0;
        var indices = void 0;
        var material = null, currMaterial = null;
        var vertexCount = 0, vertexOffset = 0;
        var indiceCount = 0, indiceOffset = 0;
        for (var i = 0, n = locSkeleton.drawOrder.length; i < n; i++) {
          slot = locSkeleton.drawOrder[i];
          if (!slot.attachment) continue;
          attachment = slot.attachment;
          vertexCount = 0;
          if (attachment instanceof spine.RegionAttachment) {
            vertexCount = 4;
            indiceCount = 6;
          } else {
            if (!(attachment instanceof spine.MeshAttachment)) continue;
            vertexCount = attachment.regionUVs.length / 2;
            indiceCount = attachment.triangles.length;
          }
          if (0 === vertexCount) continue;
          newData = false;
          material = _getSlotMaterial(slot, attachment.region.texture._texture, premultiAlpha);
          if (currMaterial !== material) {
            currMaterial && (newData = true);
            data.material = currMaterial = material;
          }
          if (newData) {
            data.vertexCount = vertexOffset;
            data.indiceCount = indiceOffset;
            dataId++;
            datas[dataId] || (data = datas[dataId] = comp.requestRenderData());
            data.dataLength = vertexCount;
            data.material = currMaterial;
            vertexOffset = 0;
            indiceOffset = 0;
          }
          if (attachment instanceof spine.RegionAttachment) {
            indices = data._indices;
            indices[indiceOffset] = vertexOffset;
            indices[indiceOffset + 1] = vertexOffset + 1;
            indices[indiceOffset + 2] = vertexOffset + 2;
            indices[indiceOffset + 3] = vertexOffset + 0;
            indices[indiceOffset + 4] = vertexOffset + 2;
            indices[indiceOffset + 5] = vertexOffset + 3;
          } else {
            var triangles = attachment.triangles;
            for (var t = 0; t < triangles.length; t++) indices[indiceOffset + t] = vertexOffset + triangles[t];
          }
          indiceOffset += indiceCount;
          vertexOffset += this._readAttachmentData(comp, attachment, slot, premultiAlpha, data, vertexOffset);
        }
        data.vertexCount = vertexOffset;
        data.indiceCount = indiceOffset;
        datas.length = dataId + 1;
        if (comp.debugBones) {
          var bone = void 0;
          graphics.lineWidth = 5;
          graphics.strokeColor = _boneColor;
          graphics.fillColor = _slotColor;
          for (var _i = 0, _n = locSkeleton.bones.length; _i < _n; _i++) {
            bone = locSkeleton.bones[_i];
            var x = bone.data.length * bone.a + bone.worldX;
            var y = bone.data.length * bone.c + bone.worldY;
            graphics.moveTo(bone.worldX, bone.worldY);
            graphics.lineTo(x, y);
            graphics.stroke();
            graphics.circle(bone.worldX, bone.worldY, 2 * Math.PI);
            graphics.fill();
            0 === _i && (graphics.fillColor = _originColor);
          }
        }
        if (comp.debugBones || comp.debugSlots) {
          var renderDatas = graphics._impl._renderDatas;
          for (var _i2 = 0; _i2 < renderDatas.length; _i2++) {
            renderDatas[_i2].material = _debugMaterial;
            datas.push(renderDatas[_i2]);
          }
        }
      },
      updateRenderData: function(comp, batchData) {
        var skeleton = comp._skeleton;
        var state = comp._state;
        if (skeleton) {
          var dt = cc.director.getDeltaTime();
          skeleton.update(dt);
          if (state) {
            dt *= comp.timeScale;
            state.update(dt);
            state.apply(skeleton);
          }
          skeleton.updateWorldTransform();
          this.genRenderDatas(comp, batchData);
        } else comp._renderDatas.length = 0;
      },
      fillBuffers: function(comp, renderer) {
        var renderDatas = comp._renderDatas;
        for (var index = 0, length = renderDatas.length; index < length; index++) {
          var data = renderDatas[index];
          if (data.material !== renderer.material) {
            renderer._flush();
            renderer.node = comp.node;
            renderer.material = data.material;
          }
          var vertexs = data._data;
          var indices = data._indices;
          var buffer = renderer.getBuffer("mesh", vfmtPosUvColor), vertexOffset = buffer.byteOffset >> 2, vbuf = buffer._vData, uintbuf = buffer._uintVData, vertexCount = data.vertexCount;
          var ibuf = buffer._iData, indiceOffset = buffer.indiceOffset, vertexId = buffer.vertexOffset;
          buffer.request(vertexCount, data.indiceCount);
          var vert = void 0;
          for (var i = 0, l = data.dataLength; i < l; i++) {
            vert = vertexs[i];
            vbuf[vertexOffset++] = vert.x;
            vbuf[vertexOffset++] = vert.y;
            vbuf[vertexOffset++] = vert.u;
            vbuf[vertexOffset++] = vert.v;
            uintbuf[vertexOffset++] = vert.color;
          }
          for (var _i3 = 0, _l = indices.length; _i3 < _l; _i3++) ibuf[indiceOffset++] = vertexId + indices[_i3];
        }
        comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      }
    };
    Skeleton._assembler = spineAssembler;
    module.exports = spineAssembler;
  }), {
    "../../cocos2d/core/platform/js": 175,
    "../../cocos2d/core/renderer": 196,
    "../../cocos2d/core/renderer/render-flow": 198,
    "../../cocos2d/core/renderer/webgl/vertex-format": 223,
    "./lib/spine": 284,
    "./skeleton": 287
  } ],
  289: [ (function(require, module, exports) {
    var TrackEntryListeners = function() {
      this.start = null;
      this.end = null;
      this.complete = null;
      this.event = null;
      this.interrupt = null;
      this.dispose = null;
    };
    TrackEntryListeners.getListeners = function(entry) {
      entry.listener || (entry.listener = new TrackEntryListeners());
      return entry.listener;
    };
    module.exports = TrackEntryListeners;
  }), {} ],
  290: [ (function(require, module, exports) {
    (function() {
      "use strict";
      Function.prototype._extend = function(parent) {
        this.prototype.parent = parent;
        for (var x in parent.prototype) this.prototype[x] || (this.prototype[x] = parent.prototype[x]);
      };
      Function.prototype._implement = function(parent) {
        return this._extend(parent);
      };
      var b2Profiler = (function() {
        "undefined" === typeof performance && (window["performance"] = {
          now: function() {
            return +new Date();
          }
        });
        function profileStruct(name, parent) {
          this.name = name;
          this.parent = parent;
          this.children = {};
          this.startTime = 0;
          this.elapsedTime = 0;
          this.totalTime = 0;
          this.running = false;
          this.childrenCount = 0;
        }
        profileStruct.prototype = {
          start: function() {
            this.startTime = performance.now();
            this.running = true;
          },
          stop: function(reset) {
            if (!this.running) return;
            this.running = false;
            this.elapsedTime += performance.now() - this.startTime;
            reset && this.start();
            for (var x in this.children) this.children[x].stop();
          },
          reset: function(dontRun) {
            if (!dontRun) {
              this.running = true;
              this.totalTime += this.elapsedTime;
              this.start();
            }
            this.elapsedTime = 0;
            for (var x in this.children) this.children[x].reset(true);
          }
        };
        var profiles = [];
        var root = new profileStruct("root");
        function create(name, parent) {
          if (!profiles) throw new Error("late profile creation not allowed");
          var s = new profileStruct(name, parent || "root");
          profiles.push(s);
          return s;
        }
        function destroy(profile) {
          profile.childrenCount--;
          delete profile.children[profile.name];
        }
        function recursiveParentCheck(node, profile) {
          if (node.name === profile.parent) return node;
          for (var x in node.children) {
            var n;
            if (n = recursiveParentCheck(node.children[x], profile)) return n;
          }
          return null;
        }
        function init() {
          while (profiles.length) {
            var p = profiles.pop();
            if (p.parentNode = recursiveParentCheck(root, p)) {
              p.parentNode.children[p.name] = p;
              p.parentNode.childrenCount++;
            } else profiles.unshift(p);
          }
          profiles = null;
        }
        function resetAll() {
          root.reset(true);
        }
        return {
          create: create,
          destroy: destroy,
          init: init,
          reset: resetAll,
          profileRoot: root
        };
      })();
      function b2Assert(A) {
        if (!A) {
          console.log("Assertion failed! Pls debug.");
          debugger;
        }
      }
      var b2_maxFloat = Number.MAX_VALUE;
      var b2_epsilon = 2.220446049250313e-16;
      var b2_pi = Math.PI;
      var b2_maxManifoldPoints = 2;
      var b2_maxPolygonVertices = 8;
      var b2_aabbExtension = .1;
      var b2_aabbMultiplier = 2;
      var b2_linearSlop = .005;
      var b2_angularSlop = 2 / 180 * b2_pi;
      var b2_polygonRadius = 2 * b2_linearSlop;
      var b2_maxSubSteps = 8;
      var b2_maxTOIContacts = 32;
      var b2_velocityThreshold = 1;
      var b2_maxLinearCorrection = .2;
      var b2_maxAngularCorrection = 8 / 180 * b2_pi;
      var b2_maxTranslation = 2;
      var b2_maxTranslationSquared = b2_maxTranslation * b2_maxTranslation;
      var b2_maxRotation = .5 * b2_pi;
      var b2_maxRotationSquared = b2_maxRotation * b2_maxRotation;
      var b2_baumgarte = .2;
      var b2_toiBaugarte = .75;
      var b2_timeToSleep = .5;
      var b2_linearSleepTolerance = .01;
      var b2_angularSleepTolerance = 2 / 180 * b2_pi;
      function b2Version(ma, mi, re) {
        this.major = ma;
        this.minor = mi;
        this.revision = re;
      }
      b2Version.prototype = {
        toString: function() {
          return this.major + "." + this.minor + "." + this.revision;
        }
      };
      var b2_version = new b2Version(2, 3, 1);
      function b2IsValid(x) {
        return isFinite(x) && !isNaN(x);
      }
      var sqrtf = Math.sqrt;
      var atan2f = Math.atan2;
      var sinf = Math.sin;
      var cosf = Math.cos;
      var floorf = Math.floor;
      var ceilf = Math.ceil;
      var b2Sqrt = sqrtf;
      var b2Atan2 = atan2f;
      function b2InvSqrt(x) {
        return 1 / sqrtf(x);
      }
      function b2Vec2(x, y) {
        if ("undefined" !== typeof x) {
          this.x = x;
          this.y = y;
        } else this.x = this.y = 0;
      }
      b2Vec2.prototype = {
        Clone: function() {
          return new b2Vec2(this.x, this.y);
        },
        SetZero: function() {
          this.x = 0;
          this.y = 0;
          return this;
        },
        Set: function(x_, y_) {
          this.x = x_;
          this.y = y_;
          return this;
        },
        Assign: function(l) {
          this.x = l.x;
          this.y = l.y;
          return this;
        },
        Negate: function() {
          var v = new b2Vec2();
          v.Set(-this.x, -this.y);
          return v;
        },
        get_i: function(i) {
          switch (i) {
           case 0:
            return this.x;

           case 1:
            return this.y;
          }
        },
        set_i: function(i, v) {
          switch (i) {
           case 0:
            return this.x = v;

           case 1:
            return this.y = v;
          }
        },
        Add: function(v) {
          this.x += v.x;
          this.y += v.y;
          return this;
        },
        Subtract: function(v) {
          this.x -= v.x;
          this.y -= v.y;
          return this;
        },
        Multiply: function(a) {
          this.x *= a;
          this.y *= a;
          return this;
        },
        Length: function() {
          return b2Sqrt(this.x * this.x + this.y * this.y);
        },
        LengthSquared: function() {
          return this.x * this.x + this.y * this.y;
        },
        Normalize: function() {
          var length = this.Length();
          if (length < b2_epsilon) return 0;
          var invLength = 1 / length;
          this.x *= invLength;
          this.y *= invLength;
          return length;
        },
        IsValid: function() {
          return b2IsValid(this.x) && b2IsValid(this.y);
        },
        Skew: function() {
          return new b2Vec2(-this.y, this.x);
        },
        _serialize: function(out) {
          var obj = out || [];
          obj[0] = this.x;
          obj[1] = this.y;
          return obj;
        },
        _deserialize: function(data) {
          this.x = data[0];
          this.y = data[1];
        }
      };
      b2Vec2.Add = function(a, b) {
        return new b2Vec2(a.x + b.x, a.y + b.y);
      };
      b2Vec2.Subtract = function(a, b) {
        return new b2Vec2(a.x - b.x, a.y - b.y);
      };
      b2Vec2.Equals = function(a, b) {
        return a.x == b.x && a.y == b.y;
      };
      b2Vec2.Multiply = function(s, a) {
        return new b2Vec2(s * a.x, s * a.y);
      };
      b2Vec2.Negate = function(a) {
        return new b2Vec2(-a.x, -a.y);
      };
      function b2Vec3(x, y, z) {
        if ("undefined" !== typeof x) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
      }
      b2Vec3.prototype = {
        Clone: function() {
          return new b2Vec3(this.x, this.y, this.z);
        },
        SetZero: function() {
          this.x = 0;
          this.y = 0;
          this.z = 0;
        },
        Set: function(x_, y_, z_) {
          this.x = x_;
          this.y = y_;
          this.z = z_;
        },
        Negate: function() {
          var v = new b2Vec3();
          v.Set(-this.x, -this.y, -this.z);
          return v;
        },
        Add: function(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
        },
        Subtract: function(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
        },
        Multiply: function(s) {
          this.x *= s;
          this.y *= s;
          this.z *= s;
        },
        Invert: function() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        },
        x: 0,
        y: 0,
        z: 0
      };
      b2Vec3.Multiply = function(s, a) {
        return new b2Vec3(s * a.x, s * a.y, s * a.z);
      };
      b2Vec3.Add = function(a, b) {
        return new b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
      };
      b2Vec3.Subtract = function(a, b) {
        return new b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
      };
      function b2Mat22(c1, c2) {
        this.ex = c1 ? c1.Clone() : new b2Vec2();
        this.ey = c2 ? c2.Clone() : new b2Vec2();
      }
      b2Mat22.prototype = {
        Set: function(c1, c2) {
          this.ex.Assign(c1);
          this.ey.Assign(c2);
        },
        Assign: function(mat) {
          this.ex.Assign(mat.ex);
          this.ey.Assign(mat.ey);
        },
        SetIdentity: function() {
          this.ex.x = 1;
          this.ey.x = 0;
          this.ex.y = 0;
          this.ey.y = 1;
        },
        SetZero: function() {
          this.ex.x = 0;
          this.ey.x = 0;
          this.ex.y = 0;
          this.ey.y = 0;
        },
        GetInverse: function() {
          var a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
          var B = new b2Mat22();
          var det = a * d - b * c;
          0 != det && (det = 1 / det);
          B.ex.x = det * d;
          B.ey.x = -det * b;
          B.ex.y = -det * c;
          B.ey.y = det * a;
          return B;
        },
        Solve: function(b) {
          var a11 = this.ex.x, a12 = this.ey.x, a21 = this.ex.y, a22 = this.ey.y;
          var det = a11 * a22 - a12 * a21;
          0 != det && (det = 1 / det);
          var x = new b2Vec2();
          x.x = det * (a22 * b.x - a12 * b.y);
          x.y = det * (a11 * b.y - a21 * b.x);
          return x;
        }
      };
      b2Mat22.Add = function(A, B) {
        return new b2Mat22(b2Vec2.Add(A.ex, B.ex), b2Vec2.Add(A.ey, B.ey));
      };
      function b2Mat33(c1, c2, c3) {
        this.ex = c1 ? c1.Clone() : new b2Vec3();
        this.ey = c2 ? c2.Clone() : new b2Vec3();
        this.ez = c3 ? c3.Clone() : new b2Vec3();
      }
      b2Mat33.prototype = {
        SetZero: function() {
          this.ex.SetZero();
          this.ey.SetZero();
          this.ez.SetZero();
        },
        Solve33: function(b) {
          var det = b2Dot_v3_v3(this.ex, b2Cross_v3_v3(this.ey, this.ez));
          0 != det && (det = 1 / det);
          var x = new b2Vec3();
          x.x = det * b2Dot_v3_v3(b, b2Cross_v3_v3(this.ey, this.ez));
          x.y = det * b2Dot_v3_v3(this.ex, b2Cross_v3_v3(b, this.ez));
          x.z = det * b2Dot_v3_v3(this.ex, b2Cross_v3_v3(this.ey, b));
          return x;
        },
        Solve22: function(b) {
          var a11 = this.ex.x, a12 = this.ey.x, a21 = this.ex.y, a22 = this.ey.y;
          var det = a11 * a22 - a12 * a21;
          0 != det && (det = 1 / det);
          var x = new b2Vec2();
          x.x = det * (a22 * b.x - a12 * b.y);
          x.y = det * (a11 * b.y - a21 * b.x);
          return x;
        },
        GetInverse22: function(M) {
          var a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
          var det = a * d - b * c;
          0 != det && (det = 1 / det);
          M.ex.x = det * d;
          M.ey.x = -det * b;
          M.ex.z = 0;
          M.ex.y = -det * c;
          M.ey.y = det * a;
          M.ey.z = 0;
          M.ez.x = 0;
          M.ez.y = 0;
          M.ez.z = 0;
        },
        GetSymInverse33: function(M) {
          var det = b2Dot_v3_v3(this.ex, b2Cross_v3_v3(this.ey, this.ez));
          0 != det && (det = 1 / det);
          var a11 = this.ex.x, a12 = this.ey.x, a13 = this.ez.x;
          var a22 = this.ey.y, a23 = this.ez.y;
          var a33 = this.ez.z;
          M.ex.x = det * (a22 * a33 - a23 * a23);
          M.ex.y = det * (a13 * a23 - a12 * a33);
          M.ex.z = det * (a12 * a23 - a13 * a22);
          M.ey.x = M.ex.y;
          M.ey.y = det * (a11 * a33 - a13 * a13);
          M.ey.z = det * (a13 * a12 - a11 * a23);
          M.ez.x = M.ex.z;
          M.ez.y = M.ey.z;
          M.ez.z = det * (a11 * a22 - a12 * a12);
        }
      };
      function b2Rot(angle, c) {
        if ("undefined" !== typeof c) {
          this.s = angle;
          this.c = c;
        } else "undefined" !== typeof angle && this.Set(angle);
      }
      b2Rot.prototype = {
        Clone: function() {
          return new b2Rot(this.s, this.c);
        },
        Assign: function(l) {
          this.s = l.s;
          this.c = l.c;
        },
        Set: function(x) {
          this.s = sinf(x);
          this.c = cosf(x);
        },
        SetIdentity: function() {
          this.s = 0;
          this.c = 1;
        },
        GetAngle: function() {
          return b2Atan2(this.s, this.c);
        },
        GetXAxis: function() {
          return new b2Vec2(this.c, this.s);
        },
        GetYAxis: function() {
          return new b2Vec2(-this.s, this.c);
        },
        s: 0,
        c: 1
      };
      function b2Transform(position, rotation) {
        this.p = new b2Vec2();
        this.q = new b2Rot();
        if (position) {
          this.p.Assign(position);
          this.q.Assign(rotation);
        }
      }
      b2Transform.prototype = {
        Clone: function() {
          var xf = new b2Transform(this.p, this.q);
          return xf;
        },
        Assign: function(xf) {
          this.p.Assign(xf.p);
          this.q.Assign(xf.q);
        },
        SetIdentity: function() {
          this.p.SetZero();
          this.q.SetIdentity();
        },
        Set: function(position, angle) {
          this.p.Assign(position);
          this.q.Set(angle);
        }
      };
      function b2Sweep() {
        this.localCenter = new b2Vec2();
        this.c0 = new b2Vec2();
        this.c = new b2Vec2();
      }
      b2Sweep.prototype = {
        Assign: function(sweep) {
          this.localCenter.Assign(sweep.localCenter);
          this.c0.Assign(sweep.c0);
          this.c.Assign(sweep.c);
          this.a = sweep.a;
          this.a0 = sweep.a0;
          this.alpha0 = sweep.alpha0;
        },
        Clone: function() {
          var sweep = new b2Sweep();
          sweep.localCenter.Assign(this.localCenter);
          sweep.c0.Assign(this.c0);
          sweep.c.Assign(this.c);
          sweep.a = this.a;
          sweep.a0 = this.a0;
          sweep.alpha0 = this.alpha0;
          return sweep;
        },
        GetTransform: function(xf, beta) {
          xf.p.x = (1 - beta) * this.c0.x + beta * this.c.x;
          xf.p.y = (1 - beta) * this.c0.y + beta * this.c.y;
          var angle = (1 - beta) * this.a0 + beta * this.a;
          xf.q.Set(angle);
          xf.p.x -= xf.q.c * this.localCenter.x - xf.q.s * this.localCenter.y;
          xf.p.y -= xf.q.s * this.localCenter.x + xf.q.c * this.localCenter.y;
        },
        Advance: function(alpha) {
          b2Assert(this.alpha0 < 1);
          var beta = (alpha - this.alpha0) / (1 - this.alpha0);
          this.c0.Add(b2Vec2.Multiply(beta, b2Vec2.Subtract(this.c, this.c0)));
          this.a0 += beta * (this.a - this.a0);
          this.alpha0 = alpha;
        },
        Normalize: function() {
          var twoPi = 2 * b2_pi;
          var d = twoPi * floorf(this.a0 / twoPi);
          this.a0 -= d;
          this.a -= d;
        },
        a0: 0,
        a: 0,
        alpha0: 0
      };
      function b2Dot_v2_v2(a, b) {
        return a.x * b.x + a.y * b.y;
      }
      function b2Cross_v2_v2(a, b) {
        return a.x * b.y - a.y * b.x;
      }
      function b2Cross_v2_f(a, s) {
        return new b2Vec2(s * a.y, -s * a.x);
      }
      function b2Cross_f_v2(s, a) {
        return new b2Vec2(-s * a.y, s * a.x);
      }
      function b2Mul_m22_v2(A, v) {
        return new b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
      }
      function b2MulT_m22_v2(A, v) {
        return new b2Vec2(b2Dot_v2_v2(v, A.ex), b2Dot_v2_v2(v, A.ey));
      }
      function b2Distance(a, b) {
        var c = b2Vec2.Subtract(a, b);
        return c.Length();
      }
      function b2DistanceSquared(a, b) {
        var c = b2Vec2.Subtract(a, b);
        return b2Dot_v2_v2(c, c);
      }
      function b2Dot_v3_v3(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
      }
      function b2Cross_v3_v3(a, b) {
        return new b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
      }
      function b2Mul_m22_m22(A, B) {
        return new b2Mat22(b2Mul_m22_v2(A, B.ex), b2Mul_m22_v2(A, B.ey));
      }
      function b2MulT_m22_m22(A, B) {
        var c1 = new b2Vec2(b2Dot_v2_v2(A.ex, B.ex), b2Dot_v2_v2(A.ey, B.ex));
        var c2 = new b2Vec2(b2Dot_v2_v2(A.ex, B.ey), b2Dot_v2_v2(A.ey, B.ey));
        return new b2Mat22(c1, c2);
      }
      function b2Mul_m33_v3(A, v) {
        return b2Vec3.Add(b2Vec3.Add(b2Vec3.Multiply(v.x, A.ex), b2Vec3.Multiply(v.y, A.ey)), b2Vec3.Multiply(v.z, A.ez));
      }
      function b2Mul22_m33_v2(A, v) {
        return new b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
      }
      function b2Mul_r_r(q, r) {
        var qr = new b2Rot();
        qr.s = q.s * r.c + q.c * r.s;
        qr.c = q.c * r.c - q.s * r.s;
        return qr;
      }
      function b2MulT_r_r(q, r) {
        var qr = new b2Rot();
        qr.s = q.c * r.s - q.s * r.c;
        qr.c = q.c * r.c + q.s * r.s;
        return qr;
      }
      function b2Mul_r_v2(q, v) {
        return new b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
      }
      function b2MulT_r_v2(q, v) {
        return new b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
      }
      function b2Mul_t_v2(T, v) {
        return new b2Vec2(T.q.c * v.x - T.q.s * v.y + T.p.x, T.q.s * v.x + T.q.c * v.y + T.p.y);
      }
      function b2MulT_t_v2(T, v) {
        var px = v.x - T.p.x;
        var py = v.y - T.p.y;
        var x = T.q.c * px + T.q.s * py;
        var y = -T.q.s * px + T.q.c * py;
        return new b2Vec2(x, y);
      }
      function b2Mul_t_t(A, B) {
        var C = new b2Transform();
        C.q = b2Mul_r_r(A.q, B.q);
        C.p = b2Vec2.Add(b2Mul_r_v2(A.q, B.p), A.p);
        return C;
      }
      function b2MulT_t_t(A, B) {
        var C = new b2Transform();
        C.q = b2MulT_r_r(A.q, B.q);
        var tvx = B.p.x - A.p.x;
        var tvy = B.p.y - A.p.y;
        C.p.x = A.q.c * tvx + A.q.s * tvy;
        C.p.y = -A.q.s * tvx + A.q.c * tvy;
        return C;
      }
      var b2Abs = Math.abs;
      function b2Abs_v2(a) {
        return new b2Vec2(b2Abs(a.x), b2Abs(a.y));
      }
      function b2Abs_m22(A) {
        return new b2Mat22(b2Abs_v2(A.ex), b2Abs_v2(A.ey));
      }
      var b2Min = Math.min;
      function b2Min_v2(a, b) {
        return new b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
      }
      var b2Max = Math.max;
      function b2Max_v2(a, b) {
        return new b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
      }
      function b2Clamp(a, low, high) {
        return b2Max(low, b2Min(a, high));
      }
      function b2Clamp_v2(a, low, high) {
        return b2Max_v2(low, b2Min_v2(a, high));
      }
      function b2NextPowerOfTwo(x) {
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        return x + 1;
      }
      function b2IsPowerOfTwo(x) {
        var result = x > 0 && 0 == (x & x - 1);
        return result;
      }
      var RAND_LIMIT = 32767;
      function b2RandomFloat(lo, hi) {
        var r = Math.random();
        r = "undefined" !== typeof lo ? (hi - lo) * r + lo : 2 * r - 1;
        return r;
      }
      function b2Color(r, g, b) {
        this.r = r || 0;
        this.g = g || 0;
        this.b = b || 0;
      }
      b2Color.prototype = {
        Set: function(r, g, b) {
          this.r = r;
          this.g = g;
          this.b = b;
        }
      };
      function b2Draw() {}
      b2Draw.prototype = {
        ClearDraw: function() {},
        SetFlags: function(flags) {
          this.m_drawFlags = flags;
        },
        GetFlags: function() {
          return this.m_drawFlags;
        },
        AppendFlags: function(flags) {
          this.m_drawFlags |= flags;
        },
        ClearFlags: function(flags) {
          this.m_drawFlags &= ~flags;
        },
        ToggleFlags: function(flags) {
          this.m_drawFlags ^= flags;
        },
        DrawPolygon: function(vertices, vertexCount, color) {},
        DrawSolidPolygon: function(vertices, vertexCount, color) {},
        DrawCircle: function(center, radius, color) {},
        DrawSolidCircle: function(center, radius, axis, color) {},
        DrawSegment: function(p1, p2, color) {},
        DrawTransform: function(xf) {},
        m_drawFlags: 0
      };
      b2Draw.e_shapeBit = 1;
      b2Draw.e_jointBit = 2;
      b2Draw.e_aabbBit = 4;
      b2Draw.e_centerOfMassBit = 8;
      b2Draw.e_contactPoints = 16;
      b2Draw.e_contactNormals = 32;
      b2Draw.e_contactImpulses = 64;
      b2Draw.e_frictionImpulses = 128;
      b2Draw.e_statistics = 256;
      b2Draw.e_profile = 512;
      b2Draw.e_pairBit = 1024;
      "undefined" === typeof performance && (window.performance = {
        now: function() {
          return +new Date();
        }
      });
      function b2Timer() {
        this.Reset();
      }
      b2Timer.prototype = {
        Reset: function() {
          this.m_start = performance.now();
        },
        GetMilliseconds: function() {
          return performance.now() - this.m_start;
        }
      };
      function b2MassData() {
        this.mass = 0;
        this.center = new b2Vec2();
        this.I = 0;
      }
      function b2Shape() {
        this.m_type = 0;
        this.m_radius = 0;
      }
      b2Shape.prototype = {
        Clone: function() {},
        GetType: function() {
          return this.m_type;
        },
        GetChildCount: function() {},
        TestPoint: function(xf, p) {},
        RayCast: function(output, input, transform, childIndex) {},
        ComputeAABB: function(aabb, xf, childIndex) {},
        ComputeMass: function(massData, density) {},
        _serialize: function(out) {
          var obj = out || {};
          obj["m_type"] = this.m_type;
          obj["m_radius"] = this.m_radius;
          return obj;
        },
        _deserialize: function(data) {
          this.m_radius = data["m_radius"];
        }
      };
      b2Shape.e_circle = 0;
      b2Shape.e_edge = 1;
      b2Shape.e_polygon = 2;
      b2Shape.e_chain = 3;
      b2Shape.e_typeCount = 4;
      function b2CircleShape() {
        this.parent.call(this);
        this.m_type = b2Shape.e_circle;
        this.m_radius = 0;
        this.m_p = new b2Vec2();
        Object.seal(this);
      }
      b2CircleShape.prototype = {
        Clone: function() {
          var shape = new b2CircleShape();
          shape.m_radius = this.m_radius;
          shape.m_p = this.m_p.Clone();
          return shape;
        },
        GetChildCount: function() {
          return 1;
        },
        TestPoint: function(transform, p) {
          var center = b2Vec2.Add(transform.p, b2Mul_r_v2(transform.q, this.m_p));
          var d = b2Vec2.Subtract(p, center);
          return b2Dot_v2_v2(d, d) <= this.m_radius * this.m_radius;
        },
        RayCast: function(output, input, transform, childIndex) {
          var position = b2Vec2.Add(transform.p, b2Mul_r_v2(transform.q, this.m_p));
          var s = b2Vec2.Subtract(input.p1, position);
          var b = b2Dot_v2_v2(s, s) - this.m_radius * this.m_radius;
          var r = b2Vec2.Subtract(input.p2, input.p1);
          var c = b2Dot_v2_v2(s, r);
          var rr = b2Dot_v2_v2(r, r);
          var sigma = c * c - rr * b;
          if (sigma < 0 || rr < b2_epsilon) return false;
          var a = -(c + b2Sqrt(sigma));
          if (0 <= a && a <= input.maxFraction * rr) {
            a /= rr;
            output.fraction = a;
            output.normal = b2Vec2.Add(s, b2Vec2.Multiply(a, r));
            output.normal.Normalize();
            return true;
          }
          return false;
        },
        ComputeAABB: function(aabb, transform, childIndex) {
          var px = transform.p.x + (transform.q.c * this.m_p.x - transform.q.s * this.m_p.y);
          var py = transform.p.y + (transform.q.s * this.m_p.x + transform.q.c * this.m_p.y);
          aabb.lowerBound.x = px - this.m_radius;
          aabb.lowerBound.y = py - this.m_radius;
          aabb.upperBound.x = px + this.m_radius;
          aabb.upperBound.y = py + this.m_radius;
        },
        ComputeMass: function(massData, density) {
          massData.mass = density * b2_pi * this.m_radius * this.m_radius;
          massData.center = this.m_p;
          massData.I = massData.mass * (.5 * this.m_radius * this.m_radius + b2Dot_v2_v2(this.m_p, this.m_p));
        },
        GetSupport: function(d) {
          return 0;
        },
        GetSupportVertex: function(d) {
          return this.m_p;
        },
        GetVertexCount: function() {
          return 1;
        },
        GetVertex: function(index) {
          b2Assert(0 == index);
          return this.m_p;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["m_p"] = this.m_p._serialize();
          return obj;
        },
        _deserialize: function(data) {
          this.parent.prototype._deserialize.call(this, data);
          this.m_p._deserialize(data["m_p"]);
        }
      };
      b2CircleShape._extend(b2Shape);
      function b2EdgeShape() {
        this.parent.call(this);
        this.m_type = b2Shape.e_edge;
        this.m_radius = b2_polygonRadius;
        this.m_vertex0 = new b2Vec2();
        this.m_vertex1 = new b2Vec2();
        this.m_vertex2 = new b2Vec2();
        this.m_vertex3 = new b2Vec2();
        this.m_hasVertex0 = false;
        this.m_hasVertex3 = false;
        Object.seal(this);
      }
      b2EdgeShape.prototype = {
        Set: function(v1, v2) {
          this.m_vertex1.Assign(v1);
          this.m_vertex2.Assign(v2);
          this.m_hasVertex0 = false;
          this.m_hasVertex3 = false;
        },
        Clone: function() {
          var shape = new b2EdgeShape();
          shape.m_vertex0 = this.m_vertex0.Clone();
          shape.m_vertex1 = this.m_vertex1.Clone();
          shape.m_vertex2 = this.m_vertex2.Clone();
          shape.m_vertex3 = this.m_vertex3.Clone();
          shape.m_hasVertex0 = this.m_hasVertex0;
          shape.m_hasVertex3 = this.m_hasVertex3;
          return shape;
        },
        GetChildCount: function() {
          return 1;
        },
        TestPoint: function(transform, p) {
          return false;
        },
        RayCast: function(output, input, xf, childIndex) {
          var p1 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p1, xf.p));
          var p2 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p2, xf.p));
          var d = b2Vec2.Subtract(p2, p1);
          var v1 = this.m_vertex1;
          var v2 = this.m_vertex2;
          var e = b2Vec2.Subtract(v2, v1);
          var normal = new b2Vec2(e.y, -e.x);
          normal.Normalize();
          var numerator = b2Dot_v2_v2(normal, b2Vec2.Subtract(v1, p1));
          var denominator = b2Dot_v2_v2(normal, d);
          if (0 == denominator) return false;
          var t = numerator / denominator;
          if (t < 0 || input.maxFraction < t) return false;
          var q = b2Vec2.Add(p1, b2Vec2.Multiply(t, d));
          var r = b2Vec2.Subtract(v2, v1);
          var rr = b2Dot_v2_v2(r, r);
          if (0 == rr) return false;
          var s = b2Dot_v2_v2(b2Vec2.Subtract(q, v1), r) / rr;
          if (s < 0 || 1 < s) return false;
          output.fraction = t;
          output.normal = numerator > 0 ? b2Mul_r_v2(xf.q, normal).Negate() : b2Mul_r_v2(xf.q, normal);
          return true;
        },
        ComputeAABB: function(aabb, xf, childIndex) {
          var v1x = xf.q.c * this.m_vertex1.x - xf.q.s * this.m_vertex1.y + xf.p.x;
          var v1y = xf.q.s * this.m_vertex1.x + xf.q.c * this.m_vertex1.y + xf.p.y;
          var v2x = xf.q.c * this.m_vertex2.x - xf.q.s * this.m_vertex2.y + xf.p.x;
          var v2y = xf.q.s * this.m_vertex2.x + xf.q.c * this.m_vertex2.y + xf.p.y;
          var lowerx = b2Min(v1x, v2x);
          var lowery = b2Min(v1y, v2y);
          var upperx = b2Max(v1x, v2x);
          var uppery = b2Max(v1y, v2y);
          aabb.lowerBound.x = lowerx - this.m_radius;
          aabb.lowerBound.y = lowery - this.m_radius;
          aabb.upperBound.x = upperx + this.m_radius;
          aabb.upperBound.y = uppery + this.m_radius;
        },
        ComputeMass: function(massData, density) {
          massData.mass = 0;
          massData.center = b2Vec2.Multiply(.5, b2Vec2.Add(this.m_vertex1, this.m_vertex2));
          massData.I = 0;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["m_vertex1"] = this.m_vertex1._serialize();
          obj["m_vertex2"] = this.m_vertex2._serialize();
          obj["m_hasVertex0"] = this.m_hasVertex0;
          this.m_hasVertex0 && (obj["m_vertex0"] = this.m_vertex0._serialize());
          obj["m_hasVertex3"] = this.m_hasVertex3;
          this.m_hasVertex3 && (obj["m_vertex3"] = this.m_vertex3._serialize());
          return obj;
        },
        _deserialize: function(data) {
          this.parent.prototype._deserialize.call(this, data);
          this.m_vertex1._deserialize(data["m_vertex1"]);
          this.m_vertex2._deserialize(data["m_vertex2"]);
          this.m_hasVertex0 = data["m_hasVertex0"];
          this.m_hasVertex0 && this.m_vertex0._deserialize(data["m_vertex0"]);
          this.m_hasVertex3 = data["m_hasVertex3"];
          this.m_hasVertex3 && this.m_vertex3._deserialize(data["m_vertex3"]);
        }
      };
      b2EdgeShape._extend(b2Shape);
      function b2ChainShape() {
        this.parent.call(this);
        this.m_type = b2Shape.e_chain;
        this.m_radius = b2_polygonRadius;
        this.m_prevVertex = new b2Vec2();
        this.m_nextVertex = new b2Vec2();
        this.m_hasPrevVertex = false;
        this.m_hasNextVertex = false;
        this.Clear();
        Object.seal(this);
      }
      b2ChainShape._tempEdge = new b2EdgeShape();
      b2ChainShape.prototype = {
        Clear: function() {
          this.m_vertices = null;
          this.m_count = 0;
        },
        CreateLoop: function(vertices, count) {
          b2Assert(null == this.m_vertices && 0 == this.m_count);
          b2Assert(count >= 3);
          for (var i = 1; i < count; ++i) b2Assert(b2DistanceSquared(vertices[i - 1], vertices[i]) > b2_linearSlop * b2_linearSlop);
          this.m_count = count + 1;
          this.m_vertices = new Array(this.m_count);
          for (var i = 0; i < count; ++i) this.m_vertices[i] = vertices[i].Clone();
          this.m_vertices[count] = this.m_vertices[0].Clone();
          this.m_prevVertex.Assign(this.m_vertices[this.m_count - 2]);
          this.m_nextVertex.Assign(this.m_vertices[1]);
          this.m_hasPrevVertex = true;
          this.m_hasNextVertex = true;
        },
        CreateChain: function(vertices, count) {
          b2Assert(null == this.m_vertices && 0 == this.m_count);
          b2Assert(count >= 2);
          for (var i = 1; i < count; ++i) {
            var v1 = vertices[i - 1];
            var v2 = vertices[i];
            b2Assert(b2DistanceSquared(v1, v2) > b2_linearSlop * b2_linearSlop);
          }
          this.m_count = count;
          this.m_vertices = new Array(count);
          for (var i = 0; i < count; ++i) this.m_vertices[i] = vertices[i].Clone();
          this.m_hasPrevVertex = false;
          this.m_hasNextVertex = false;
          this.m_prevVertex.SetZero();
          this.m_nextVertex.SetZero();
        },
        SetPrevVertex: function(prevVertex) {
          this.m_prevVertex.Assign(prevVertex);
          this.m_hasPrevVertex = true;
        },
        SetNextVertex: function(nextVertex) {
          this.m_nextVertex.Assign(nextVertex);
          this.m_hasNextVertex = true;
        },
        Clone: function() {
          var shape = new b2ChainShape();
          shape.m_count = this.m_count;
          shape.m_vertices = new Array(this.m_count);
          for (var i = 0; i < this.m_count; ++i) shape.m_vertices[i] = this.m_vertices[i].Clone();
          shape.m_prevVertex = this.m_prevVertex.Clone();
          shape.m_nextVertex = this.m_nextVertex.Clone();
          shape.m_hasPrevVertex = this.m_hasPrevVertex;
          shape.m_hasNextVertex = this.m_hasNextVertex;
          return shape;
        },
        GetChildCount: function() {
          return this.m_count - 1;
        },
        GetChildEdge: function(edge, index) {
          b2Assert(0 <= index && index < this.m_count - 1);
          edge.m_type = b2Shape.e_edge;
          edge.m_radius = this.m_radius;
          edge.m_vertex1 = this.m_vertices[index + 0];
          edge.m_vertex2 = this.m_vertices[index + 1];
          if (index > 0) {
            edge.m_vertex0 = this.m_vertices[index - 1];
            edge.m_hasVertex0 = true;
          } else {
            edge.m_vertex0 = this.m_prevVertex;
            edge.m_hasVertex0 = this.m_hasPrevVertex;
          }
          if (index < this.m_count - 2) {
            edge.m_vertex3 = this.m_vertices[index + 2];
            edge.m_hasVertex3 = true;
          } else {
            edge.m_vertex3 = this.m_nextVertex;
            edge.m_hasVertex3 = this.m_hasNextVertex;
          }
        },
        TestPoint: function(transform, p) {
          return false;
        },
        RayCast: function(output, input, xf, childIndex) {
          b2Assert(childIndex < this.m_count);
          var i1 = childIndex;
          var i2 = childIndex + 1;
          i2 == this.m_count && (i2 = 0);
          b2ChainShape._tempEdge.m_vertex1 = this.m_vertices[i1].Clone();
          b2ChainShape._tempEdge.m_vertex2 = this.m_vertices[i2].Clone();
          return b2ChainShape._tempEdge.RayCast(output, input, xf, 0);
        },
        ComputeAABB: function(aabb, xf, childIndex) {
          b2Assert(childIndex < this.m_count);
          var i1 = childIndex;
          var i2 = childIndex + 1;
          i2 == this.m_count && (i2 = 0);
          var v1x = xf.q.c * this.m_vertices[i1].x - xf.q.s * this.m_vertices[i1].y + xf.p.x;
          var v1y = xf.q.s * this.m_vertices[i1].x + xf.q.c * this.m_vertices[i1].y + xf.p.y;
          var v2x = xf.q.c * this.m_vertices[i2].x - xf.q.s * this.m_vertices[i2].y + xf.p.x;
          var v2y = xf.q.s * this.m_vertices[i2].x + xf.q.c * this.m_vertices[i2].y + xf.p.y;
          aabb.lowerBound.x = b2Min(v1x, v2x);
          aabb.lowerBound.y = b2Min(v1y, v2y);
          aabb.upperBound.x = b2Max(v1x, v2x);
          aabb.upperBound.y = b2Max(v1y, v2y);
        },
        ComputeMass: function(massData, density) {
          massData.mass = 0;
          massData.center.SetZero();
          massData.I = 0;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["m_count"] = this.m_count;
          obj["m_vertices"] = [];
          for (var i = 0; i < this.m_count; ++i) obj["m_vertices"].push(this.m_vertices[i]._serialize());
          obj["m_hasPrevVertex"] = this.m_hasPrevVertex;
          this.m_hasPrevVertex && (obj["m_prevVertex"] = this.m_prevVertex._serialize());
          obj["m_hasNextVertex"] = this.m_hasNextVertex;
          this.m_hasNextVertex && (obj["m_nextVertex"] = this.m_nextVertex._serialize());
          return obj;
        },
        _deserialize: function(data) {
          this.parent.prototype._deserialize.call(this, data);
          this.m_count = data["m_count"];
          this.m_vertices = [];
          for (var i = 0; i < this.m_count; ++i) {
            this.m_vertices[i] = new b2Vec2();
            this.m_vertices[i]._deserialize(data["m_vertices"][i]);
          }
          this.m_hasPrevVertex = data["m_hasPrevVertex"];
          this.m_hasPrevVertex && this.m_prevVertex._deserialize(data["m_prevVertex"]);
          this.m_hasNextVertex = data["m_hasNextVertex"];
          this.m_hasNextVertex && this.m_nextVertex._deserialize(data["m_nextVertex"]);
        }
      };
      b2ChainShape._extend(b2Shape);
      function b2PolygonShape() {
        this.parent.call(this);
        this.m_type = b2Shape.e_polygon;
        this.m_radius = b2_polygonRadius;
        this.m_count = 0;
        this.m_centroid = new b2Vec2();
        this.m_vertices = new Array(b2_maxPolygonVertices);
        this.m_normals = new Array(b2_maxPolygonVertices);
        Object.seal(this);
      }
      b2PolygonShape.prototype = {
        Clone: function() {
          var shape = new b2PolygonShape();
          shape.m_count = this.m_count;
          shape.m_centroid = this.m_centroid.Clone();
          for (var i = 0; i < this.m_count; ++i) {
            shape.m_vertices[i] = this.m_vertices[i].Clone();
            shape.m_normals[i] = this.m_normals[i].Clone();
          }
          return shape;
        },
        GetChildCount: function() {
          return 1;
        },
        Set: function(vertices, count) {
          b2Assert(3 <= count && count <= b2_maxPolygonVertices);
          if (count < 3) {
            this.SetAsBox(1, 1);
            return;
          }
          var n = b2Min(count, b2_maxPolygonVertices);
          var ps = new Array(b2_maxPolygonVertices);
          var tempCount = 0;
          for (var i = 0; i < n; ++i) {
            var v = vertices[i];
            var unique = true;
            for (var j = 0; j < tempCount; ++j) if (b2DistanceSquared(v, ps[j]) < .5 * b2_linearSlop) {
              unique = false;
              break;
            }
            unique && (ps[tempCount++] = v.Clone());
          }
          n = tempCount;
          if (n < 3) {
            b2Assert(false);
            this.SetAsBox(1, 1);
            return;
          }
          var i0 = 0;
          var x0 = ps[0].x;
          for (i = 1; i < n; ++i) {
            var x = ps[i].x;
            if (x > x0 || x == x0 && ps[i].y < ps[i0].y) {
              i0 = i;
              x0 = x;
            }
          }
          var hull = new Array(b2_maxPolygonVertices);
          var m = 0;
          var ih = i0;
          for (;;) {
            hull[m] = ih;
            var ie = 0;
            for (j = 1; j < n; ++j) {
              if (ie == ih) {
                ie = j;
                continue;
              }
              var r = b2Vec2.Subtract(ps[ie], ps[hull[m]]);
              var v = b2Vec2.Subtract(ps[j], ps[hull[m]]);
              var c = b2Cross_v2_v2(r, v);
              c < 0 && (ie = j);
              0 == c && v.LengthSquared() > r.LengthSquared() && (ie = j);
            }
            ++m;
            ih = ie;
            if (ie == i0) break;
          }
          if (m < 3) {
            b2Assert(false);
            this.SetAsBox(1, 1);
            return;
          }
          this.m_count = m;
          for (i = 0; i < m; ++i) this.m_vertices[i] = ps[hull[i]].Clone();
          for (i = 0; i < m; ++i) {
            var i1 = i;
            var i2 = i + 1 < m ? i + 1 : 0;
            var edge = b2Vec2.Subtract(this.m_vertices[i2], this.m_vertices[i1]);
            b2Assert(edge.LengthSquared() > b2_epsilon * b2_epsilon);
            this.m_normals[i] = b2Cross_v2_f(edge, 1).Clone();
            this.m_normals[i].Normalize();
          }
          this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, m);
        },
        SetAsBox: function(hx, hy, center, angle) {
          this.m_count = 4;
          this.m_vertices[0] = new b2Vec2(-hx, -hy);
          this.m_vertices[1] = new b2Vec2(hx, -hy);
          this.m_vertices[2] = new b2Vec2(hx, hy);
          this.m_vertices[3] = new b2Vec2(-hx, hy);
          this.m_normals[0] = new b2Vec2(0, -1);
          this.m_normals[1] = new b2Vec2(1, 0);
          this.m_normals[2] = new b2Vec2(0, 1);
          this.m_normals[3] = new b2Vec2(-1, 0);
          if (!center) return;
          this.m_centroid.Assign(center);
          var xf = new b2Transform();
          xf.p = center;
          xf.q.Set(angle);
          for (var i = 0; i < this.m_count; ++i) {
            this.m_vertices[i].Assign(b2Mul_t_v2(xf, this.m_vertices[i]));
            this.m_normals[i].Assign(b2Mul_r_v2(xf.q, this.m_normals[i]));
          }
        },
        TestPoint: function(xf, p) {
          var pLocal = b2MulT_r_v2(xf.q, b2Vec2.Subtract(p, xf.p));
          for (var i = 0; i < this.m_count; ++i) {
            var dot = b2Dot_v2_v2(this.m_normals[i], b2Vec2.Subtract(pLocal, this.m_vertices[i]));
            if (dot > 0) return false;
          }
          return true;
        },
        RayCast: function(output, input, xf, childIndex) {
          var p1 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p1, xf.p));
          var p2 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p2, xf.p));
          var d = b2Vec2.Subtract(p2, p1);
          var lower = 0, upper = input.maxFraction;
          var index = -1;
          for (var i = 0; i < this.m_count; ++i) {
            var numerator = b2Dot_v2_v2(this.m_normals[i], b2Vec2.Subtract(this.m_vertices[i], p1));
            var denominator = b2Dot_v2_v2(this.m_normals[i], d);
            if (0 == denominator) {
              if (numerator < 0) return false;
            } else if (denominator < 0 && numerator < lower * denominator) {
              lower = numerator / denominator;
              index = i;
            } else denominator > 0 && numerator < upper * denominator && (upper = numerator / denominator);
            if (upper < lower) return false;
          }
          b2Assert(0 <= lower && lower <= input.maxFraction);
          if (index >= 0) {
            output.fraction = lower;
            output.normal = b2Mul_r_v2(xf.q, this.m_normals[index]);
            return true;
          }
          return false;
        },
        ComputeAABB: function(aabb, xf, childIndex) {
          var lowerx = xf.q.c * this.m_vertices[0].x - xf.q.s * this.m_vertices[0].y + xf.p.x;
          var lowery = xf.q.s * this.m_vertices[0].x + xf.q.c * this.m_vertices[0].y + xf.p.y;
          var upperx = lowerx;
          var uppery = lowery;
          for (var i = 1; i < this.m_count; ++i) {
            var vx = xf.q.c * this.m_vertices[i].x - xf.q.s * this.m_vertices[i].y + xf.p.x;
            var vy = xf.q.s * this.m_vertices[i].x + xf.q.c * this.m_vertices[i].y + xf.p.y;
            lowerx = b2Min(lowerx, vx);
            lowery = b2Min(lowery, vy);
            upperx = b2Max(upperx, vx);
            uppery = b2Max(uppery, vy);
          }
          aabb.lowerBound.x = lowerx - this.m_radius;
          aabb.lowerBound.y = lowery - this.m_radius;
          aabb.upperBound.x = upperx + this.m_radius;
          aabb.upperBound.y = uppery + this.m_radius;
        },
        ComputeMass: function(massData, density) {
          b2Assert(this.m_count >= 3);
          var center = new b2Vec2(0, 0);
          var area = 0;
          var I = 0;
          var s = new b2Vec2(0, 0);
          for (var i = 0; i < this.m_count; ++i) s.Add(this.m_vertices[i]);
          s.Multiply(1 / this.m_count);
          var k_inv3 = 1 / 3;
          for (var i = 0; i < this.m_count; ++i) {
            var e1 = b2Vec2.Subtract(this.m_vertices[i], s);
            var e2 = i + 1 < this.m_count ? b2Vec2.Subtract(this.m_vertices[i + 1], s) : b2Vec2.Subtract(this.m_vertices[0], s);
            var D = b2Cross_v2_v2(e1, e2);
            var triangleArea = .5 * D;
            area += triangleArea;
            center.Add(b2Vec2.Multiply(triangleArea * k_inv3, b2Vec2.Add(e1, e2)));
            var ex1 = e1.x, ey1 = e1.y;
            var ex2 = e2.x, ey2 = e2.y;
            var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
            var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
            I += .25 * k_inv3 * D * (intx2 + inty2);
          }
          massData.mass = density * area;
          b2Assert(area > b2_epsilon);
          center.Multiply(1 / area);
          massData.center = b2Vec2.Add(center, s);
          massData.I = density * I;
          massData.I += massData.mass * (b2Dot_v2_v2(massData.center, massData.center) - b2Dot_v2_v2(center, center));
        },
        GetVertexCount: function() {
          return this.m_count;
        },
        GetVertex: function(index) {
          b2Assert(0 <= index && index < this.m_count);
          return this.m_vertices[index];
        },
        Validate: function() {
          for (var i = 0; i < this.m_count; ++i) {
            var i1 = i;
            var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
            var p = this.m_vertices[i1];
            var e = b2Vec2.Subtract(this.m_vertices[i2], p);
            for (var j = 0; j < this.m_count; ++j) {
              if (j == i1 || j == i2) continue;
              var v = b2Vec2.Subtract(this.m_vertices[j], p);
              var c = b2Cross_v2_v2(e, v);
              if (c < 0) return false;
            }
          }
          return true;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["m_count"] = this.m_count;
          obj["m_centroid"] = this.m_centroid._serialize();
          obj["m_vertices"] = [];
          obj["m_normals"] = [];
          for (var i = 0; i < this.m_count; ++i) {
            obj["m_vertices"].push(this.m_vertices[i]._serialize());
            obj["m_normals"].push(this.m_normals[i]._serialize());
          }
          return obj;
        },
        _deserialize: function(data) {
          this.parent.prototype._deserialize.call(this, data);
          this.m_count = data["m_count"];
          this.m_centroid._deserialize(data["m_centroid"]);
          this.m_vertices = [];
          this.m_normals = [];
          for (var i = 0; i < this.m_count; ++i) {
            this.m_vertices[i] = new b2Vec2();
            this.m_vertices[i]._deserialize(data["m_vertices"][i]);
            this.m_normals[i] = new b2Vec2();
            this.m_normals[i]._deserialize(data["m_normals"][i]);
          }
        }
      };
      b2PolygonShape.ComputeCentroid = function(vs, count) {
        b2Assert(count >= 3);
        var c = new b2Vec2();
        var area = 0;
        var pRef = new b2Vec2(0, 0);
        var inv3 = 1 / 3;
        for (var i = 0; i < count; ++i) {
          var p1 = pRef;
          var p2 = vs[i];
          var p3 = i + 1 < count ? vs[i + 1] : vs[0];
          var e1 = b2Vec2.Subtract(p2, p1);
          var e2 = b2Vec2.Subtract(p3, p1);
          var D = b2Cross_v2_v2(e1, e2);
          var triangleArea = .5 * D;
          area += triangleArea;
          c.Add(b2Vec2.Multiply(triangleArea, b2Vec2.Multiply(inv3, b2Vec2.Add(b2Vec2.Add(p1, p2), p3))));
        }
        b2Assert(area > b2_epsilon);
        c.Multiply(1 / area);
        return c;
      };
      b2PolygonShape._extend(b2Shape);
      function b2Pair() {
        this.proxyIdA = 0;
        this.proxyIdB = 0;
      }
      function b2PairLessThan(pair1, pair2) {
        if (pair1.proxyIdA == pair2.proxyIdA) return pair1.proxyIdB - pair2.proxyIdB;
        return pair1.proxyIdA - pair2.proxyIdA;
      }
      function b2BroadPhase() {
        this.m_tree = new b2DynamicTree();
        this.m_queryProxyId = 0;
        this.m_proxyCount = 0;
        this.m_pairCount = 0;
        this.m_pairBuffer = [];
        this.m_moveCount = 0;
        this.m_moveBuffer = [];
      }
      b2BroadPhase.prototype = {
        CreateProxy: function(aabb, userData) {
          var proxyId = this.m_tree.CreateProxy(aabb, userData);
          ++this.m_proxyCount;
          this.BufferMove(proxyId);
          return proxyId;
        },
        DestroyProxy: function(proxyId) {
          this.UnBufferMove(proxyId);
          --this.m_proxyCount;
          this.m_tree.DestroyProxy(proxyId);
        },
        MoveProxy: function(proxyId, aabb, displacement) {
          var buffer = this.m_tree.MoveProxy(proxyId, aabb, displacement);
          buffer && this.BufferMove(proxyId);
        },
        TouchProxy: function(proxyId) {
          this.BufferMove(proxyId);
        },
        GetFatAABB: function(proxyId) {
          return this.m_tree.GetFatAABB(proxyId);
        },
        GetUserData: function(proxyId) {
          return this.m_tree.GetUserData(proxyId);
        },
        TestOverlap: function(proxyIdA, proxyIdB) {
          var aabbA = this.m_tree.GetFatAABB(proxyIdA);
          var aabbB = this.m_tree.GetFatAABB(proxyIdB);
          return b2TestOverlap(aabbA, aabbB);
        },
        GetProxyCount: function() {
          return this.m_proxyCount;
        },
        UpdatePairs: function(callback) {
          this.m_pairCount = 0;
          this.m_pairBuffer.length = 0;
          for (var i = 0; i < this.m_moveCount; ++i) {
            this.m_queryProxyId = this.m_moveBuffer[i];
            if (this.m_queryProxyId == b2BroadPhase.e_nullProxy) continue;
            var fatAABB = this.m_tree.GetFatAABB(this.m_queryProxyId);
            this.m_tree.Query(this, fatAABB);
          }
          this.m_moveCount = 0;
          this.m_pairBuffer.sort(b2PairLessThan);
          var i = 0;
          while (i < this.m_pairCount) {
            var primaryPair = this.m_pairBuffer[i];
            var userDataA = this.m_tree.GetUserData(primaryPair.proxyIdA);
            var userDataB = this.m_tree.GetUserData(primaryPair.proxyIdB);
            callback.AddPair(userDataA, userDataB);
            ++i;
            while (i < this.m_pairCount) {
              var pair = this.m_pairBuffer[i];
              if (pair.proxyIdA != primaryPair.proxyIdA || pair.proxyIdB != primaryPair.proxyIdB) break;
              ++i;
            }
          }
        },
        Query: function(callback, aabb) {
          this.m_tree.Query(callback, aabb);
        },
        RayCast: function(callback, input) {
          this.m_tree.RayCast(callback, input);
        },
        GetTreeHeight: function() {
          return this.m_tree.GetHeight();
        },
        GetTreeBalance: function() {
          return this.m_tree.GetMaxBalance();
        },
        GetTreeQuality: function() {
          return this.m_tree.GetAreaRatio();
        },
        ShiftOrigin: function(newOrigin) {
          this.m_tree.ShiftOrigin(newOrigin);
        },
        BufferMove: function(proxyId) {
          this.m_moveBuffer[this.m_moveCount] = proxyId;
          ++this.m_moveCount;
        },
        UnBufferMove: function(proxyId) {
          for (var i = 0; i < this.m_moveCount; ++i) this.m_moveBuffer[i] == proxyId && (this.m_moveBuffer[i] = b2BroadPhase.e_nullProxy);
        },
        QueryCallback: function(proxyId) {
          if (proxyId == this.m_queryProxyId) return true;
          this.m_pairBuffer[this.m_pairCount] = new b2Pair();
          this.m_pairBuffer[this.m_pairCount].proxyIdA = b2Min(proxyId, this.m_queryProxyId);
          this.m_pairBuffer[this.m_pairCount].proxyIdB = b2Max(proxyId, this.m_queryProxyId);
          ++this.m_pairCount;
          return true;
        }
      };
      b2BroadPhase.e_nullProxy = -1;
      function b2DistanceProxy() {
        this.m_vertices = null;
        this.m_count = 0;
        this.m_radius = 0;
      }
      b2DistanceProxy.prototype = {
        Assign: function(l) {
          this.m_vertices = l.m_vertices;
          this.m_count = l.m_count;
          this.m_radius = l.m_radius;
        },
        Set: function(shape, index) {
          switch (shape.GetType()) {
           case b2Shape.e_circle:
            var circle = shape;
            this.m_vertices = [ circle.m_p ];
            this.m_count = 1;
            this.m_radius = circle.m_radius;
            break;

           case b2Shape.e_polygon:
            var polygon = shape;
            this.m_vertices = polygon.m_vertices;
            this.m_count = polygon.m_count;
            this.m_radius = polygon.m_radius;
            break;

           case b2Shape.e_chain:
            var chain = shape;
            b2Assert(0 <= index && index < chain.m_count);
            this.m_vertices = [ chain.m_vertices[index] ];
            index + 1 < chain.m_count ? this.m_vertices[1] = chain.m_vertices[index + 1] : this.m_vertices[1] = chain.m_vertices[0];
            this.m_count = 2;
            this.m_radius = chain.m_radius;
            break;

           case b2Shape.e_edge:
            var edge = shape;
            this.m_vertices = [ edge.m_vertex1, edge.m_vertex2 ];
            this.m_count = 2;
            this.m_radius = edge.m_radius;
            break;

           default:
            b2Assert(false);
          }
        },
        GetSupport: function(dx, dy) {
          var bestIndex = 0;
          var bestValue = this.m_vertices[0].x * dx + this.m_vertices[0].y * dy;
          for (var i = 1; i < this.m_count; ++i) {
            var value = this.m_vertices[i].x * dx + this.m_vertices[i].y * dy;
            if (value > bestValue) {
              bestIndex = i;
              bestValue = value;
            }
          }
          return bestIndex;
        },
        GetSupportVertex: function(dx, dy) {
          return this.m_vertices[this.GetSupport(dx, dy)];
        },
        GetVertexCount: function() {
          return this.m_count;
        },
        GetVertex: function(index) {
          b2Assert(0 <= index && index < this.m_count);
          return this.m_vertices[index];
        }
      };
      function b2SimplexCache() {
        this.metric = 0;
        this.count = 0;
        this.indexA = [ 0, 0, 0 ];
        this.indexB = [ 0, 0, 0 ];
      }
      function b2DistanceInput() {
        this.proxyA = new b2DistanceProxy();
        this.proxyB = new b2DistanceProxy();
        this.transformA = new b2Transform();
        this.transformB = new b2Transform();
        this.useRadii = false;
      }
      function b2DistanceOutput() {
        this.pointA = new b2Vec2();
        this.pointB = new b2Vec2();
        this.distance = 0;
        this.iterations = 0;
      }
      function b2SimplexVertex() {
        this.wA = new b2Vec2();
        this.wB = new b2Vec2();
        this.w = new b2Vec2();
        this.a = 0;
        this.indexA = 0;
        this.indexB = 0;
      }
      b2SimplexVertex.prototype = {
        Assign: function(l) {
          this.wA.x = l.wA.x;
          this.wA.y = l.wA.y;
          this.wB.x = l.wB.x;
          this.wB.y = l.wB.y;
          this.w.x = l.w.x;
          this.w.y = l.w.y;
          this.a = l.a;
          this.indexA = l.indexA;
          this.indexB = l.indexB;
        }
      };
      function b2Simplex() {
        this.m_v = [ new b2SimplexVertex(), new b2SimplexVertex(), new b2SimplexVertex() ];
        this.m_count = 0;
      }
      b2Simplex.prototype = {
        ReadCache: function(cache, proxyA, transformA, proxyB, transformB) {
          b2Assert(cache.count <= 3);
          this.m_count = cache.count;
          var vertices = this.m_v;
          for (var i = 0; i < this.m_count; ++i) {
            var v = vertices[i];
            v.indexA = cache.indexA[i];
            v.indexB = cache.indexB[i];
            var wALocal = proxyA.GetVertex(v.indexA);
            var wBLocal = proxyB.GetVertex(v.indexB);
            v.wA.x = transformA.q.c * wALocal.x - transformA.q.s * wALocal.y + transformA.p.x;
            v.wA.y = transformA.q.s * wALocal.x + transformA.q.c * wALocal.y + transformA.p.y;
            v.wB.x = transformB.q.c * wBLocal.x - transformB.q.s * wBLocal.y + transformB.p.x;
            v.wB.y = transformB.q.s * wBLocal.x + transformB.q.c * wBLocal.y + transformB.p.y;
            v.w.x = v.wB.x - v.wA.x;
            v.w.y = v.wB.y - v.wA.y;
            v.a = 0;
          }
          if (this.m_count > 1) {
            var metric1 = cache.metric;
            var metric2 = this.GetMetric();
            (metric2 < .5 * metric1 || 2 * metric1 < metric2 || metric2 < b2_epsilon) && (this.m_count = 0);
          }
          if (0 == this.m_count) {
            var v = vertices[0];
            v.indexA = 0;
            v.indexB = 0;
            var wALocal = proxyA.GetVertex(0);
            var wBLocal = proxyB.GetVertex(0);
            v.wA.x = transformA.q.c * wALocal.x - transformA.q.s * wALocal.y + transformA.p.x;
            v.wA.y = transformA.q.s * wALocal.x + transformA.q.c * wALocal.y + transformA.p.y;
            v.wB.x = transformB.q.c * wBLocal.x - transformB.q.s * wBLocal.y + transformB.p.x;
            v.wB.y = transformB.q.s * wBLocal.x + transformB.q.c * wBLocal.y + transformB.p.y;
            v.w.x = v.wB.x - v.wA.x;
            v.w.y = v.wB.y - v.wA.y;
            v.a = 1;
            this.m_count = 1;
          }
        },
        WriteCache: function(cache) {
          cache.metric = this.GetMetric();
          cache.count = this.m_count;
          var vertices = this.m_v;
          for (var i = 0; i < this.m_count; ++i) {
            cache.indexA[i] = vertices[i].indexA;
            cache.indexB[i] = vertices[i].indexB;
          }
        },
        GetSearchDirection: function(p) {
          switch (this.m_count) {
           case 1:
            p.x = -this.m_v[0].w.x;
            p.y = -this.m_v[0].w.y;
            break;

           case 2:
            var e12x = this.m_v[1].w.x - this.m_v[0].w.x;
            var e12y = this.m_v[1].w.y - this.m_v[0].w.y;
            var sgn = e12x * -this.m_v[0].w.y - e12y * -this.m_v[0].w.x;
            if (sgn > 0) {
              p.x = -1 * e12y;
              p.y = 1 * e12x;
            } else {
              p.x = 1 * e12y;
              p.y = -1 * e12x;
            }
            break;

           default:
            b2Assert(false);
            p.x = p.y = 0;
          }
        },
        GetClosestPoint: function(p) {
          switch (this.m_count) {
           case 1:
            p.x = this.m_v[0].w.x;
            p.y = this.m_v[0].w.y;
            break;

           case 2:
            p.x = this.m_v[0].a * this.m_v[0].w.x + this.m_v[1].a * this.m_v[1].w.x;
            p.y = this.m_v[0].a * this.m_v[0].w.y + this.m_v[1].a * this.m_v[1].w.y;
            break;

           case 3:
            p.x = p.y = 0;
            break;

           default:
            b2Assert(false);
            p.x = p.y = 0;
          }
        },
        GetWitnessPoints: function(pA, pB) {
          switch (this.m_count) {
           case 1:
            pA.x = this.m_v[0].wA.x;
            pA.y = this.m_v[0].wA.y;
            pB.x = this.m_v[0].wB.x;
            pB.y = this.m_v[0].wB.y;
            break;

           case 2:
            pA.x = this.m_v[0].a * this.m_v[0].wA.x + this.m_v[1].a * this.m_v[1].wA.x;
            pA.y = this.m_v[0].a * this.m_v[0].wA.y + this.m_v[1].a * this.m_v[1].wA.y;
            pB.x = this.m_v[0].a * this.m_v[0].wB.x + this.m_v[1].a * this.m_v[1].wB.x;
            pB.y = this.m_v[0].a * this.m_v[0].wB.y + this.m_v[1].a * this.m_v[1].wB.y;
            break;

           case 3:
            pA.x = this.m_v[0].a * this.m_v[0].wA.x + this.m_v[1].a * this.m_v[1].wA.x + this.m_v[2].a * this.m_v[2].wA.x;
            pA.y = this.m_v[0].a * this.m_v[0].wA.y + this.m_v[1].a * this.m_v[1].wA.y + this.m_v[2].a * this.m_v[2].wA.y;
            pB.x = pA.x;
            pB.y = pA.y;
            break;

           default:
            b2Assert(false);
          }
        },
        GetMetric: function() {
          switch (this.m_count) {
           case 1:
            return 0;

           case 2:
            return b2Distance(this.m_v[0].w, this.m_v[1].w);

           case 3:
            return (this.m_v[1].w.x - this.m_v[0].w.x) * (this.m_v[2].w.y - this.m_v[0].w.y) - (this.m_v[1].w.y - this.m_v[0].w.y) * (this.m_v[2].w.x - this.m_v[0].w.x);

           default:
            b2Assert(false);
            return 0;
          }
        },
        Solve2: function() {
          var w1 = this.m_v[0].w;
          var w2 = this.m_v[1].w;
          var e12x = w2.x - w1.x;
          var e12y = w2.y - w1.y;
          var d12_2 = -(w1.x * e12x + w1.y * e12y);
          if (d12_2 <= 0) {
            this.m_v[0].a = 1;
            this.m_count = 1;
            return;
          }
          var d12_1 = w2.x * e12x + w2.y * e12y;
          if (d12_1 <= 0) {
            this.m_v[1].a = 1;
            this.m_count = 1;
            this.m_v[0].Assign(this.m_v[1]);
            return;
          }
          var inv_d12 = 1 / (d12_1 + d12_2);
          this.m_v[0].a = d12_1 * inv_d12;
          this.m_v[1].a = d12_2 * inv_d12;
          this.m_count = 2;
        },
        Solve3: function() {
          var w1 = this.m_v[0].w;
          var w2 = this.m_v[1].w;
          var w3 = this.m_v[2].w;
          var e12x = w2.x - w1.x;
          var e12y = w2.y - w1.y;
          var w1e12 = w1.x * e12x + w1.y * e12y;
          var w2e12 = w2.x * e12x + w2.y * e12y;
          var d12_1 = w2e12;
          var d12_2 = -w1e12;
          var e13x = w3.x - w1.x;
          var e13y = w3.y - w1.y;
          var w1e13 = w1.x * e13x + w1.y * e13y;
          var w3e13 = w3.x * e13x + w3.y * e13y;
          var d13_1 = w3e13;
          var d13_2 = -w1e13;
          var e23x = w3.x - w2.x;
          var e23y = w3.y - w2.y;
          var w2e23 = w2.x * e23x + w2.y * e23y;
          var w3e23 = w3.x * e23x + w3.y * e23y;
          var d23_1 = w3e23;
          var d23_2 = -w2e23;
          var n123 = e12x * e13y - e12y * e13x;
          var d123_1 = n123 * (w2.x * w3.y - w2.y * w3.x);
          var d123_2 = n123 * (w3.x * w1.y - w3.y * w1.x);
          var d123_3 = n123 * (w1.x * w2.y - w1.y * w2.x);
          if (d12_2 <= 0 && d13_2 <= 0) {
            this.m_v[0].a = 1;
            this.m_count = 1;
            return;
          }
          if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
            var inv_d12 = 1 / (d12_1 + d12_2);
            this.m_v[0].a = d12_1 * inv_d12;
            this.m_v[1].a = d12_2 * inv_d12;
            this.m_count = 2;
            return;
          }
          if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
            var inv_d13 = 1 / (d13_1 + d13_2);
            this.m_v[0].a = d13_1 * inv_d13;
            this.m_v[2].a = d13_2 * inv_d13;
            this.m_count = 2;
            this.m_v[1].Assign(this.m_v[2]);
            return;
          }
          if (d12_1 <= 0 && d23_2 <= 0) {
            this.m_v[1].a = 1;
            this.m_count = 1;
            this.m_v[0].Assign(this.m_v[1]);
            return;
          }
          if (d13_1 <= 0 && d23_1 <= 0) {
            this.m_v[2].a = 1;
            this.m_count = 1;
            this.m_v[0].Assign(this.m_v[2]);
            return;
          }
          if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
            var inv_d23 = 1 / (d23_1 + d23_2);
            this.m_v[1].a = d23_1 * inv_d23;
            this.m_v[2].a = d23_2 * inv_d23;
            this.m_count = 2;
            this.m_v[0].Assign(this.m_v[2]);
            return;
          }
          var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
          this.m_v[0].a = d123_1 * inv_d123;
          this.m_v[1].a = d123_2 * inv_d123;
          this.m_v[2].a = d123_3 * inv_d123;
          this.m_count = 3;
        }
      };
      var _b2Distance_simplex = new b2Simplex();
      var _b2Distance_normal = new b2Vec2();
      var _b2Distance_p = new b2Vec2();
      function b2DistanceFunc(output, cache, input) {
        ++b2DistanceFunc.b2_gjkCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var transformA = input.transformA;
        var transformB = input.transformB;
        _b2Distance_simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
        var vertices = _b2Distance_simplex.m_v;
        var k_maxIters = 20;
        var saveA = [ 0, 0, 0 ], saveB = [ 0, 0, 0 ];
        var saveCount = 0;
        var distanceSqr1 = b2_maxFloat;
        var distanceSqr2 = distanceSqr1;
        var iter = 0;
        while (iter < k_maxIters) {
          saveCount = _b2Distance_simplex.m_count;
          for (var i = 0; i < saveCount; ++i) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
          }
          switch (_b2Distance_simplex.m_count) {
           case 1:
            break;

           case 2:
            _b2Distance_simplex.Solve2();
            break;

           case 3:
            _b2Distance_simplex.Solve3();
            break;

           default:
            b2Assert(false);
          }
          if (3 == _b2Distance_simplex.m_count) break;
          _b2Distance_simplex.GetClosestPoint(_b2Distance_p);
          distanceSqr2 = _b2Distance_p.LengthSquared();
          distanceSqr2 >= distanceSqr1;
          distanceSqr1 = distanceSqr2;
          _b2Distance_simplex.GetSearchDirection(_b2Distance_p);
          if (_b2Distance_p.LengthSquared() < b2_epsilon * b2_epsilon) break;
          var vertex = vertices[_b2Distance_simplex.m_count];
          vertex.indexA = proxyA.GetSupport(transformA.q.c * -_b2Distance_p.x + transformA.q.s * -_b2Distance_p.y, -transformA.q.s * -_b2Distance_p.x + transformA.q.c * -_b2Distance_p.y);
          var pva = proxyA.GetVertex(vertex.indexA);
          vertex.wA.x = transformA.q.c * pva.x - transformA.q.s * pva.y + transformA.p.x;
          vertex.wA.y = transformA.q.s * pva.x + transformA.q.c * pva.y + transformA.p.y;
          vertex.indexB = proxyB.GetSupport(transformB.q.c * _b2Distance_p.x + transformB.q.s * _b2Distance_p.y, -transformB.q.s * _b2Distance_p.x + transformB.q.c * _b2Distance_p.y);
          var pvb = proxyB.GetVertex(vertex.indexB);
          vertex.wB.x = transformB.q.c * pvb.x - transformB.q.s * pvb.y + transformB.p.x;
          vertex.wB.y = transformB.q.s * pvb.x + transformB.q.c * pvb.y + transformB.p.y;
          vertex.w.x = vertex.wB.x - vertex.wA.x;
          vertex.w.y = vertex.wB.y - vertex.wA.y;
          ++iter;
          ++b2DistanceFunc.b2_gjkIters;
          var duplicate = false;
          for (var i = 0; i < saveCount; ++i) if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
            duplicate = true;
            break;
          }
          if (duplicate) break;
          ++_b2Distance_simplex.m_count;
        }
        b2DistanceFunc.b2_gjkMaxIters = b2Max(b2DistanceFunc.b2_gjkMaxIters, iter);
        _b2Distance_simplex.GetWitnessPoints(output.pointA, output.pointB);
        output.distance = b2Distance(output.pointA, output.pointB);
        output.iterations = iter;
        _b2Distance_simplex.WriteCache(cache);
        if (input.useRadii) {
          var rA = proxyA.m_radius;
          var rB = proxyB.m_radius;
          if (output.distance > rA + rB && output.distance > b2_epsilon) {
            output.distance -= rA + rB;
            _b2Distance_normal.x = output.pointB.x - output.pointA.x;
            _b2Distance_normal.y = output.pointB.y - output.pointA.y;
            _b2Distance_normal.Normalize();
            output.pointA.x += rA * _b2Distance_normal.x;
            output.pointA.y += rA * _b2Distance_normal.y;
            output.pointB.x -= rB * _b2Distance_normal.x;
            output.pointB.y -= rB * _b2Distance_normal.y;
          } else {
            var px = .5 * (output.pointA.x + output.pointB.x);
            var py = .5 * (output.pointA.y + output.pointB.y);
            output.pointA.x = px;
            output.pointA.y = py;
            output.pointB.x = px;
            output.pointB.y = py;
            output.distance = 0;
          }
        }
      }
      b2DistanceFunc.b2_gjkCalls = 0;
      b2DistanceFunc.b2_gjkIters = 0;
      b2DistanceFunc.b2_gjkMaxIters = 0;
      var b2_nullFeature = 255;
      function b2ContactID() {}
      b2ContactID.prototype = {
        indexA: 0,
        indexB: 0,
        typeA: 0,
        typeB: 0,
        Reset: function() {
          this.indexA = this.indexB = this.typeA = this.typeB = 0;
        },
        Get: function() {
          return this.indexA | this.indexB << 8 | this.typeA << 16 | this.typeB << 24;
        },
        Assign: function(k) {
          this.indexA = k.indexA;
          this.indexB = k.indexB;
          this.typeA = k.typeA;
          this.typeB = k.typeB;
        }
      };
      b2ContactID.e_vertex = 0;
      b2ContactID.e_face = 1;
      function b2ManifoldPoint() {
        this.localPoint = new b2Vec2();
        this.normalImpulse = 0;
        this.tangentImpulse = 0;
        this.id = new b2ContactID();
      }
      b2ManifoldPoint.prototype = {
        Clone: function() {
          var point = new b2ManifoldPoint();
          point.localPoint.x = this.localPoint.x;
          point.localPoint.y = this.localPoint.y;
          point.normalImpulse = this.normalImpulse;
          point.tangentImpulse = this.tangentImpulse;
          point.id.Assign(this.id);
          return point;
        }
      };
      function b2Manifold() {
        this.points = new Array(b2_maxManifoldPoints);
        this.localNormal = new b2Vec2();
        this.localPoint = new b2Vec2();
        this.type = 0;
        this.pointCount = 0;
      }
      b2Manifold.prototype = {
        Clone: function() {
          var manifold = new b2Manifold();
          manifold.pointCount = this.pointCount;
          manifold.type = this.type;
          manifold.localPoint.x = this.localPoint.x;
          manifold.localPoint.y = this.localPoint.y;
          manifold.localNormal.x = this.localNormal.x;
          manifold.localNormal.y = this.localNormal.y;
          for (var i = 0; i < this.pointCount; ++i) manifold.points[i] = this.points[i].Clone();
          return manifold;
        },
        Assign: function(manifold) {
          this.pointCount = manifold.pointCount;
          this.type = manifold.type;
          this.localPoint.x = manifold.localPoint.x;
          this.localPoint.y = manifold.localPoint.y;
          this.localNormal.x = manifold.localNormal.x;
          this.localNormal.y = manifold.localNormal.y;
          for (var i = 0; i < this.pointCount; ++i) this.points[i] = manifold.points[i].Clone();
        }
      };
      b2Manifold.e_circles = 0;
      b2Manifold.e_faceA = 1;
      b2Manifold.e_faceB = 2;
      b2Manifold.b2_nullState = 0;
      b2Manifold.b2_addState = 1;
      b2Manifold.b2_persistState = 2;
      b2Manifold.b2_removeState = 3;
      function b2WorldManifold() {
        this.normal = new b2Vec2();
        this.points = new Array(b2_maxManifoldPoints);
        this.separations = new Array(b2_maxManifoldPoints);
      }
      b2WorldManifold.prototype = {
        Initialize: function(manifold, xfA, radiusA, xfB, radiusB) {
          if (0 == manifold.pointCount) return;
          switch (manifold.type) {
           case b2Manifold.e_circles:
            this.normal.x = 1;
            this.normal.y = 0;
            var pointAx = xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y + xfA.p.x;
            var pointAy = xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y + xfA.p.y;
            var pointBx = xfB.q.c * manifold.points[0].localPoint.x - xfB.q.s * manifold.points[0].localPoint.y + xfB.p.x;
            var pointBy = xfB.q.s * manifold.points[0].localPoint.x + xfB.q.c * manifold.points[0].localPoint.y + xfB.p.y;
            var cx = pointAx - pointBx;
            var cy = pointAy - pointBy;
            if (cx * cx + cy * cy > b2_epsilon * b2_epsilon) {
              this.normal.x = pointBx - pointAx;
              this.normal.y = pointBy - pointAy;
              this.normal.Normalize();
            }
            var cAx = pointAx + radiusA * this.normal.x;
            var cAy = pointAy + radiusA * this.normal.y;
            var cBx = pointBx - radiusB * this.normal.x;
            var cBy = pointBy - radiusB * this.normal.y;
            this.points[0] = new b2Vec2(.5 * (cAx + cBx), .5 * (cAy + cBy));
            this.separations[0] = (cBx - cAx) * this.normal.x + (cBy - cAy) * this.normal.y;
            break;

           case b2Manifold.e_faceA:
            this.normal.x = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;
            this.normal.y = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;
            var planePointx = xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y + xfA.p.x;
            var planePointy = xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y + xfA.p.y;
            for (var i = 0; i < manifold.pointCount; ++i) {
              var clipPointx = xfB.q.c * manifold.points[i].localPoint.x - xfB.q.s * manifold.points[i].localPoint.y + xfB.p.x;
              var clipPointy = xfB.q.s * manifold.points[i].localPoint.x + xfB.q.c * manifold.points[i].localPoint.y + xfB.p.y;
              var d = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y;
              var cAx = clipPointx + (radiusA - d) * this.normal.x;
              var cAy = clipPointy + (radiusA - d) * this.normal.y;
              var cBx = clipPointx - radiusB * this.normal.x;
              var cBy = clipPointy - radiusB * this.normal.y;
              this.points[i] = new b2Vec2(.5 * (cAx + cBx), .5 * (cAy + cBy));
              this.separations[i] = (cBx - cAx) * this.normal.x + (cBy - cAy) * this.normal.y;
            }
            break;

           case b2Manifold.e_faceB:
            this.normal.x = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;
            this.normal.y = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;
            var planePointx = xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y + xfB.p.x;
            var planePointy = xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y + xfB.p.y;
            for (var i = 0; i < manifold.pointCount; ++i) {
              var clipPointx = xfA.q.c * manifold.points[i].localPoint.x - xfA.q.s * manifold.points[i].localPoint.y + xfA.p.x;
              var clipPointy = xfA.q.s * manifold.points[i].localPoint.x + xfA.q.c * manifold.points[i].localPoint.y + xfA.p.y;
              var d = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y;
              var cBx = clipPointx + (radiusB - d) * this.normal.x;
              var cBy = clipPointy + (radiusB - d) * this.normal.y;
              var cAx = clipPointx - radiusA * this.normal.x;
              var cAy = clipPointy - radiusA * this.normal.y;
              this.points[i] = new b2Vec2(.5 * (cAx + cBx), .5 * (cAy + cBy));
              this.separations[i] = (cAx - cBx) * this.normal.x + (cAy - cBy) * this.normal.y;
            }
            this.normal.x = -this.normal.x;
            this.normal.y = -this.normal.y;
          }
        }
      };
      function b2GetPointStates(state1, state2, manifold1, manifold2) {
        for (var i = 0; i < b2_maxManifoldPoints; ++i) {
          state1[i] = b2Manifold.b2_nullState;
          state2[i] = b2Manifold.b2_nullState;
        }
        for (var i = 0; i < manifold1.pointCount; ++i) {
          var id = manifold1.points[i].id;
          state1[i] = b2Manifold.b2_removeState;
          for (var j = 0; j < manifold2.pointCount; ++j) if (manifold2.points[j].id.Get() == id.Get()) {
            state1[i] = b2Manifold.b2_persistState;
            break;
          }
        }
        for (var i = 0; i < manifold2.pointCount; ++i) {
          var id = manifold2.points[i].id;
          state2[i] = b2Manifold.b2_addState;
          for (var j = 0; j < manifold1.pointCount; ++j) if (manifold1.points[j].id.Get() == id.Get()) {
            state2[i] = b2Manifold.b2_persistState;
            break;
          }
        }
      }
      function b2ClipVertex() {
        this.v = new b2Vec2();
        this.id = new b2ContactID();
      }
      function b2RayCastInput() {
        this.p1 = new b2Vec2(), this.p2 = new b2Vec2();
        this.maxFraction = 0;
      }
      function b2RayCastOutput() {
        this.normal = new b2Vec2();
        this.fraction = 0;
      }
      function b2AABB() {
        this.lowerBound = new b2Vec2();
        this.upperBound = new b2Vec2();
      }
      b2AABB.prototype = {
        Assign: function(other) {
          this.lowerBound.x = other.lowerBound.x;
          this.lowerBound.y = other.lowerBound.y;
          this.upperBound.x = other.upperBound.x;
          this.upperBound.y = other.upperBound.y;
        },
        Clone: function() {
          var clone = new b2AABB();
          clone.lowerBound.x = this.lowerBound.x;
          clone.lowerBound.y = this.lowerBound.y;
          clone.upperBound.x = this.upperBound.x;
          clone.upperBound.y = this.upperBound.y;
          return clone;
        },
        IsValid: function() {
          return this.upperBound.x - this.lowerBound.x >= 0 && this.upperBound.y - this.lowerBound.y >= 0 && this.lowerBound.IsValid() && this.upperBound.IsValid();
        },
        GetCenter: function() {
          return new b2Vec2(.5 * (this.lowerBound.x + this.upperBound.x), .5 * (this.lowerBound.y + this.upperBound.y));
        },
        GetExtents: function() {
          return new b2Vec2(.5 * (this.upperBound.x - this.lowerBound.x), .5 * (this.upperBound.y - this.lowerBound.y));
        },
        GetPerimeter: function() {
          return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y));
        },
        Combine: function(aabb1, aabb2) {
          if (aabb2) {
            this.lowerBound.x = b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);
            this.lowerBound.y = b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);
            this.upperBound.x = b2Max(aabb1.upperBound.x, aabb2.upperBound.x);
            this.upperBound.y = b2Max(aabb1.upperBound.y, aabb2.upperBound.y);
          } else {
            this.lowerBound.x = b2Min(this.lowerBound.x, aabb1.lowerBound.x);
            this.lowerBound.y = b2Min(this.lowerBound.y, aabb1.lowerBound.y);
            this.upperBound.x = b2Max(this.upperBound.x, aabb1.upperBound.x);
            this.upperBound.y = b2Max(this.upperBound.y, aabb1.upperBound.y);
          }
        },
        Contains: function(aabb) {
          return this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
        },
        RayCast: function(output, input) {
          var tmin = -b2_maxFloat;
          var tmax = b2_maxFloat;
          var p = input.p1;
          var d = b2Vec2.Subtract(input.p2, input.p1);
          var absD = b2Abs_v2(d);
          var normal = new b2Vec2();
          for (var i = 0; i < 2; ++i) if (absD.get_i(i) < b2_epsilon) {
            if (p.get_i(i) < this.lowerBound.get_i(i) || this.upperBound.get_i(i) < p.get_i(i)) return false;
          } else {
            var inv_d = 1 / d.get_i(i);
            var t1 = (this.lowerBound.get_i(i) - p.get_i(i)) * inv_d;
            var t2 = (this.upperBound.get_i(i) - p.get_i(i)) * inv_d;
            var s = -1;
            if (t1 > t2) {
              var temp = t2;
              t2 = t1;
              t1 = temp;
              s = 1;
            }
            if (t1 > tmin) {
              normal.x = normal.y = 0;
              normal.set_i(i, s);
              tmin = t1;
            }
            tmax = b2Min(tmax, t2);
            if (tmin > tmax) return false;
          }
          if (tmin < 0 || input.maxFraction < tmin) return false;
          output.fraction = tmin;
          output.normal.x = normal.x;
          output.normal.y = normal.y;
          return true;
        }
      };
      function b2CollideCircles(manifold, circleA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        var pA = b2Mul_t_v2(xfA, circleA.m_p);
        var pB = b2Mul_t_v2(xfB, circleB.m_p);
        var dx = pB.x - pA.x;
        var dy = pB.y - pA.y;
        var distSqr = dx * dx + dy * dy;
        var rA = circleA.m_radius, rB = circleB.m_radius;
        var radius = rA + rB;
        if (distSqr > radius * radius) return;
        manifold.type = b2Manifold.e_circles;
        manifold.localPoint.x = circleA.m_p.x;
        manifold.localPoint.y = circleA.m_p.y;
        manifold.localNormal.x = manifold.localNormal.y = 0;
        manifold.pointCount = 1;
        manifold.points[0] = new b2ManifoldPoint();
        manifold.points[0].localPoint.x = circleB.m_p.x;
        manifold.points[0].localPoint.y = circleB.m_p.y;
        manifold.points[0].id.Reset();
      }
      function b2CollidePolygonAndCircle(manifold, polygonA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        var c = b2Mul_t_v2(xfB, circleB.m_p);
        var cLocal = b2MulT_t_v2(xfA, c);
        var normalIndex = 0;
        var separation = -b2_maxFloat;
        var radius = polygonA.m_radius + circleB.m_radius;
        var vertexCount = polygonA.m_count;
        var vertices = polygonA.m_vertices;
        var normals = polygonA.m_normals;
        for (var i = 0; i < vertexCount; ++i) {
          var s = normals[i].x * (cLocal.x - vertices[i].x) + normals[i].y * (cLocal.y - vertices[i].y);
          if (s > radius) return;
          if (s > separation) {
            separation = s;
            normalIndex = i;
          }
        }
        var vertIndex1 = normalIndex;
        var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
        var v1 = vertices[vertIndex1];
        var v2 = vertices[vertIndex2];
        if (separation < b2_epsilon) {
          manifold.pointCount = 1;
          manifold.type = b2Manifold.e_faceA;
          manifold.localNormal.x = normals[normalIndex].x;
          manifold.localNormal.y = normals[normalIndex].y;
          manifold.localPoint.x = .5 * (v1.x + v2.x);
          manifold.localPoint.y = .5 * (v1.y + v2.y);
          manifold.points[0] = new b2ManifoldPoint();
          manifold.points[0].localPoint.x = circleB.m_p.x;
          manifold.points[0].localPoint.y = circleB.m_p.y;
          manifold.points[0].id.Reset();
          return;
        }
        var u1 = (cLocal.x - v1.x) * (v2.x - v1.x) + (cLocal.y - v1.y) * (v2.y - v1.y);
        var u2 = (cLocal.x - v2.x) * (v1.x - v2.x) + (cLocal.y - v2.y) * (v1.y - v2.y);
        if (u1 <= 0) {
          if (b2DistanceSquared(cLocal, v1) > radius * radius) return;
          manifold.pointCount = 1;
          manifold.type = b2Manifold.e_faceA;
          manifold.localNormal.x = cLocal.x - v1.x;
          manifold.localNormal.y = cLocal.y - v1.y;
          manifold.localNormal.Normalize();
          manifold.localPoint.x = v1.x;
          manifold.localPoint.y = v1.y;
          manifold.points[0] = new b2ManifoldPoint();
          manifold.points[0].localPoint.x = circleB.m_p.x;
          manifold.points[0].localPoint.y = circleB.m_p.y;
          manifold.points[0].id.Reset();
        } else if (u2 <= 0) {
          if (b2DistanceSquared(cLocal, v2) > radius * radius) return;
          manifold.pointCount = 1;
          manifold.type = b2Manifold.e_faceA;
          manifold.localNormal.x = cLocal.x - v2.x;
          manifold.localNormal.y = cLocal.y - v2.y;
          manifold.localNormal.Normalize();
          manifold.localPoint.x = v2.x;
          manifold.localPoint.y = v2.y;
          manifold.points[0] = new b2ManifoldPoint();
          manifold.points[0].localPoint.x = circleB.m_p.x;
          manifold.points[0].localPoint.y = circleB.m_p.y;
          manifold.points[0].id.Reset();
        } else {
          var faceCenterx = .5 * (v1.x + v2.x);
          var faceCentery = .5 * (v1.y + v2.y);
          var separation = (cLocal.x - faceCenterx) * normals[vertIndex1].x + (cLocal.y - faceCentery) * normals[vertIndex1].y;
          if (separation > radius) return;
          manifold.pointCount = 1;
          manifold.type = b2Manifold.e_faceA;
          manifold.localNormal.x = normals[vertIndex1].x;
          manifold.localNormal.y = normals[vertIndex1].y;
          manifold.localPoint.x = faceCenterx;
          manifold.localPoint.y = faceCentery;
          manifold.points[0] = new b2ManifoldPoint();
          manifold.points[0].localPoint.x = circleB.m_p.x;
          manifold.points[0].localPoint.y = circleB.m_p.y;
          manifold.points[0].id.Reset();
        }
      }
      function b2FindMaxSeparation(edgeIndex, poly1, xf1, poly2, xf2) {
        var count1 = poly1.m_count;
        var count2 = poly2.m_count;
        var n1s = poly1.m_normals;
        var v1s = poly1.m_vertices;
        var v2s = poly2.m_vertices;
        var xf = b2MulT_t_t(xf2, xf1);
        var bestIndex = 0;
        var maxSeparation = -b2_maxFloat;
        for (var i = 0; i < count1; ++i) {
          var nx = xf.q.c * n1s[i].x - xf.q.s * n1s[i].y;
          var ny = xf.q.s * n1s[i].x + xf.q.c * n1s[i].y;
          var v1x = xf.q.c * v1s[i].x - xf.q.s * v1s[i].y + xf.p.x;
          var v1y = xf.q.s * v1s[i].x + xf.q.c * v1s[i].y + xf.p.y;
          var si = b2_maxFloat;
          for (var j = 0; j < count2; ++j) {
            var sij = nx * (v2s[j].x - v1x) + ny * (v2s[j].y - v1y);
            sij < si && (si = sij);
          }
          if (si > maxSeparation) {
            maxSeparation = si;
            bestIndex = i;
          }
        }
        edgeIndex[0] = bestIndex;
        return maxSeparation;
      }
      function b2FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
        var normals1 = poly1.m_normals;
        var count2 = poly2.m_count;
        var vertices2 = poly2.m_vertices;
        var normals2 = poly2.m_normals;
        b2Assert(0 <= edge1 && edge1 < poly1.m_count);
        var t1x = xf1.q.c * normals1[edge1].x - xf1.q.s * normals1[edge1].y;
        var t1y = xf1.q.s * normals1[edge1].x + xf1.q.c * normals1[edge1].y;
        var normal1x = xf2.q.c * t1x + xf2.q.s * t1y;
        var normal1y = -xf2.q.s * t1x + xf2.q.c * t1y;
        var index = 0;
        var minDot = b2_maxFloat;
        for (var i = 0; i < count2; ++i) {
          var dot = normal1x * normals2[i].x + normal1y * normals2[i].y;
          if (dot < minDot) {
            minDot = dot;
            index = i;
          }
        }
        var i1 = index;
        var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
        c[0].v.x = xf2.q.c * vertices2[i1].x - xf2.q.s * vertices2[i1].y + xf2.p.x;
        c[0].v.y = xf2.q.s * vertices2[i1].x + xf2.q.c * vertices2[i1].y + xf2.p.y;
        c[0].id.indexA = edge1;
        c[0].id.indexB = i1;
        c[0].id.typeA = b2ContactID.e_face;
        c[0].id.typeB = b2ContactID.e_vertex;
        c[1].v.x = xf2.q.c * vertices2[i2].x - xf2.q.s * vertices2[i2].y + xf2.p.x;
        c[1].v.y = xf2.q.s * vertices2[i2].x + xf2.q.c * vertices2[i2].y + xf2.p.y;
        c[1].id.indexA = edge1;
        c[1].id.indexB = i2;
        c[1].id.typeA = b2ContactID.e_face;
        c[1].id.typeB = b2ContactID.e_vertex;
      }
      function b2CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
        manifold.pointCount = 0;
        var totalRadius = polyA.m_radius + polyB.m_radius;
        var edgeA = [ 0 ];
        var separationA = b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);
        if (separationA > totalRadius) return;
        var edgeB = [ 0 ];
        var separationB = b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);
        if (separationB > totalRadius) return;
        var poly1;
        var poly2;
        var xf1, xf2;
        var edge1 = 0;
        var flip = 0;
        var k_tol = .1 * b2_linearSlop;
        if (separationB > separationA + k_tol) {
          poly1 = polyB;
          poly2 = polyA;
          xf1 = xfB;
          xf2 = xfA;
          edge1 = edgeB[0];
          manifold.type = b2Manifold.e_faceB;
          flip = 1;
        } else {
          poly1 = polyA;
          poly2 = polyB;
          xf1 = xfA;
          xf2 = xfB;
          edge1 = edgeA[0];
          manifold.type = b2Manifold.e_faceA;
          flip = 0;
        }
        b2FindIncidentEdge(b2CollidePolygons._local_incidentEdges, poly1, xf1, edge1, poly2, xf2);
        var count1 = poly1.m_count;
        var vertices1 = poly1.m_vertices;
        var iv1 = edge1;
        var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
        var v11 = vertices1[iv1];
        var v12 = vertices1[iv2];
        b2CollidePolygons._localTangent.x = v12.x - v11.x;
        b2CollidePolygons._localTangent.y = v12.y - v11.y;
        b2CollidePolygons._localTangent.Normalize();
        var localNormalx = 1 * b2CollidePolygons._localTangent.y;
        var localNormaly = -1 * b2CollidePolygons._localTangent.x;
        var planePointx = .5 * (v11.x + v12.x);
        var planePointy = .5 * (v11.y + v12.y);
        var tangentx = xf1.q.c * b2CollidePolygons._localTangent.x - xf1.q.s * b2CollidePolygons._localTangent.y;
        var tangenty = xf1.q.s * b2CollidePolygons._localTangent.x + xf1.q.c * b2CollidePolygons._localTangent.y;
        var normalx = 1 * tangenty;
        var normaly = -1 * tangentx;
        v11 = b2Mul_t_v2(xf1, v11);
        v12 = b2Mul_t_v2(xf1, v12);
        var frontOffset = normalx * v11.x + normaly * v11.y;
        var sideOffset1 = -(tangentx * v11.x + tangenty * v11.y) + totalRadius;
        var sideOffset2 = tangentx * v12.x + tangenty * v12.y + totalRadius;
        var clipPoints1 = new Array(2);
        var clipPoints2 = new Array(2);
        var np;
        np = b2ClipSegmentToLine(clipPoints1, b2CollidePolygons._local_incidentEdges, -tangentx, -tangenty, sideOffset1, iv1);
        if (np < 2) return;
        np = b2ClipSegmentToLine(clipPoints2, clipPoints1, tangentx, tangenty, sideOffset2, iv2);
        if (np < 2) return;
        manifold.localNormal.x = localNormalx;
        manifold.localNormal.y = localNormaly;
        manifold.localPoint.x = planePointx;
        manifold.localPoint.y = planePointy;
        var pointCount = 0;
        for (var i = 0; i < b2_maxManifoldPoints; ++i) {
          var separation = normalx * clipPoints2[i].v.x + normaly * clipPoints2[i].v.y - frontOffset;
          if (separation <= totalRadius) {
            var cp = manifold.points[pointCount] = new b2ManifoldPoint();
            cp.localPoint.Assign(b2MulT_t_v2(xf2, clipPoints2[i].v));
            cp.id.Assign(clipPoints2[i].id);
            if (flip) {
              var cf = new b2ContactID();
              cf.Assign(cp.id);
              cp.id.indexA = cf.indexB;
              cp.id.indexB = cf.indexA;
              cp.id.typeA = cf.typeB;
              cp.id.typeB = cf.typeA;
            }
            ++pointCount;
          }
        }
        manifold.pointCount = pointCount;
      }
      b2CollidePolygons._localTangent = new b2Vec2();
      b2CollidePolygons._local_incidentEdges = [ new b2ClipVertex(), new b2ClipVertex() ];
      function b2CollideEdgeAndCircle(manifold, edgeA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        var Q = b2MulT_t_v2(xfA, b2Mul_t_v2(xfB, circleB.m_p));
        var A = edgeA.m_vertex1, B = edgeA.m_vertex2;
        var ex = B.x - A.x;
        var ey = B.y - A.y;
        var u = ex * (B.x - Q.x) + ey * (B.y - Q.y);
        var v = ex * (Q.x - A.x) + ey * (Q.y - A.y);
        var radius = edgeA.m_radius + circleB.m_radius;
        var cf = new b2ContactID();
        cf.indexB = 0;
        cf.typeB = b2ContactID.e_vertex;
        if (v <= 0) {
          var P = A;
          var dx = Q.x - P.x;
          var dy = Q.y - P.y;
          var dd = dx * dx + dy * dy;
          if (dd > radius * radius) return;
          if (edgeA.m_hasVertex0) {
            var A1 = edgeA.m_vertex0;
            var B1 = A;
            var e1x = B1.x - A1.x;
            var e1y = B1.y - A1.y;
            var u1 = e1x * (B1.x - Q.x) + e1y * (B1.y - Q.y);
            if (u1 > 0) return;
          }
          cf.indexA = 0;
          cf.typeA = b2ContactID.e_vertex;
          manifold.pointCount = 1;
          manifold.type = b2Manifold.e_circles;
          manifold.localNormal.x = manifold.localNormal.y = 0;
          manifold.localPoint.x = P.x;
          manifold.localPoint.y = P.y;
          manifold.points[0] = new b2ManifoldPoint();
          manifold.points[0].id.Assign(cf);
          manifold.points[0].localPoint.x = circleB.m_p.x;
          manifold.points[0].localPoint.y = circleB.m_p.y;
          return;
        }
        if (u <= 0) {
          var P = B;
          var dx = Q.x - P.x;
          var dy = Q.y - P.y;
          var dd = dx * dx + dy * dy;
          if (dd > radius * radius) return;
          if (edgeA.m_hasVertex3) {
            var B2 = edgeA.m_vertex3;
            var A2 = B;
            var e2x = B2.x - A2.x;
            var e2y = B2.y - A2.y;
            var v2 = e2x * (Q.x - A2.x) + e2y * (Q.y - A2.y);
            if (v2 > 0) return;
          }
          cf.indexA = 1;
          cf.typeA = b2ContactID.e_vertex;
          manifold.pointCount = 1;
          manifold.type = b2Manifold.e_circles;
          manifold.localNormal.x = manifold.localNormal.y = 0;
          manifold.localPoint.x = P.x;
          manifold.localPoint.y = P.y;
          manifold.points[0] = new b2ManifoldPoint();
          manifold.points[0].id.Assign(cf);
          manifold.points[0].localPoint.x = circleB.m_p.x;
          manifold.points[0].localPoint.y = circleB.m_p.y;
          return;
        }
        var den = ex * ex + ey * ey;
        b2Assert(den > 0);
        var Px = 1 / den * (u * A.x + v * B.x);
        var Py = 1 / den * (u * A.y + v * B.y);
        var dx = Q.x - Px;
        var dy = Q.y - Py;
        var dd = dx * dx + dy * dy;
        if (dd > radius * radius) return;
        var nx = -ey;
        var ny = ex;
        if (nx * (Q.x - A.x) + ny * (Q.y - A.y) < 0) {
          nx = -nx;
          ny = -ny;
        }
        cf.indexA = 0;
        cf.typeA = b2ContactID.e_face;
        manifold.pointCount = 1;
        manifold.type = b2Manifold.e_faceA;
        manifold.localNormal.x = nx;
        manifold.localNormal.y = ny;
        manifold.localNormal.Normalize();
        manifold.localPoint.x = A.x;
        manifold.localPoint.y = A.y;
        manifold.points[0] = new b2ManifoldPoint();
        manifold.points[0].id.Assign(cf);
        manifold.points[0].localPoint.x = circleB.m_p.x;
        manifold.points[0].localPoint.y = circleB.m_p.y;
      }
      function b2EPAxis() {
        this.type = 0;
        this.index = 0;
        this.separation = 0;
      }
      b2EPAxis.e_unknown = 0;
      b2EPAxis.e_edgeA = 1;
      b2EPAxis.e_edgeB = 2;
      function b2TempPolygon() {
        this.vertices = new Array(b2_maxPolygonVertices);
        this.normals = new Array(b2_maxPolygonVertices);
        this.count = 0;
      }
      function b2ReferenceFace() {
        this.i1 = 0, this.i2 = 0;
        this.v1 = new b2Vec2(), this.v2 = new b2Vec2();
        this.normal = new b2Vec2();
        this.sideNormal1 = new b2Vec2();
        this.sideOffset1 = 0;
        this.sideNormal2 = new b2Vec2();
        this.sideOffset2 = 0;
      }
      function b2EPCollider() {
        this.m_polygonB = new b2TempPolygon();
        this.m_xf = new b2Transform();
        this.m_centroidB = new b2Vec2();
        this.m_v0 = new b2Vec2(), this.m_v1 = new b2Vec2(), this.m_v2 = new b2Vec2(), this.m_v3 = new b2Vec2();
        this.m_normal0 = new b2Vec2(), this.m_normal1 = new b2Vec2(), this.m_normal2 = new b2Vec2();
        this.m_normal = new b2Vec2();
        this.m_type1 = 0, this.m_type2 = 0;
        this.m_lowerLimit = new b2Vec2(), this.m_upperLimit = new b2Vec2();
        this.m_radius = 0;
        this.m_front = false;
      }
      b2EPCollider._temp_edge = new b2Vec2();
      b2EPCollider._temp_edge0 = new b2Vec2();
      b2EPCollider._temp_edge2 = new b2Vec2();
      b2EPCollider.prototype = {
        Collide: function(manifold, edgeA, xfA, polygonB, xfB) {
          this.m_xf.Assign(b2MulT_t_t(xfA, xfB));
          this.m_centroidB.x = this.m_xf.q.c * polygonB.m_centroid.x - this.m_xf.q.s * polygonB.m_centroid.y + this.m_xf.p.x;
          this.m_centroidB.y = this.m_xf.q.s * polygonB.m_centroid.x + this.m_xf.q.c * polygonB.m_centroid.y + this.m_xf.p.y;
          this.m_v0.x = edgeA.m_vertex0.x;
          this.m_v0.y = edgeA.m_vertex0.y;
          this.m_v1.x = edgeA.m_vertex1.x;
          this.m_v1.y = edgeA.m_vertex1.y;
          this.m_v2.x = edgeA.m_vertex2.x;
          this.m_v2.y = edgeA.m_vertex2.y;
          this.m_v3.x = edgeA.m_vertex3.x;
          this.m_v3.y = edgeA.m_vertex3.y;
          var hasVertex0 = edgeA.m_hasVertex0;
          var hasVertex3 = edgeA.m_hasVertex3;
          b2EPCollider._temp_edge.x = this.m_v2.x - this.m_v1.x;
          b2EPCollider._temp_edge.y = this.m_v2.y - this.m_v1.y;
          b2EPCollider._temp_edge.Normalize();
          this.m_normal1.x = b2EPCollider._temp_edge.y;
          this.m_normal1.y = -b2EPCollider._temp_edge.x;
          var offset1 = this.m_normal1.x * (this.m_centroidB.x - this.m_v1.x) + this.m_normal1.y * (this.m_centroidB.y - this.m_v1.y);
          var offset0 = 0, offset2 = 0;
          var convex1 = false, convex2 = false;
          if (hasVertex0) {
            b2EPCollider._temp_edge0.x = this.m_v1.x - this.m_v0.x;
            b2EPCollider._temp_edge0.y = this.m_v1.y - this.m_v0.y;
            b2EPCollider._temp_edge0.Normalize();
            this.m_normal0.x = b2EPCollider._temp_edge0.y;
            this.m_normal0.y = -b2EPCollider._temp_edge0.x;
            convex1 = b2EPCollider._temp_edge0.x * b2EPCollider._temp_edge.y - b2EPCollider._temp_edge0.y * b2EPCollider._temp_edge.x >= 0;
            offset0 = this.m_normal0.x * (this.m_centroidB.x - this.m_v0.x) + this.m_normal0.y * (this.m_centroidB.y - this.m_v0.y);
          }
          if (hasVertex3) {
            b2EPCollider._temp_edge2.x = this.m_v3.x - this.m_v2.x;
            b2EPCollider._temp_edge2.y = this.m_v3.y - this.m_v2.y;
            b2EPCollider._temp_edge2.Normalize();
            this.m_normal2.x = b2EPCollider._temp_edge2.y;
            this.m_normal2.y = -b2EPCollider._temp_edge2.x;
            convex2 = b2EPCollider._temp_edge.x * b2EPCollider._temp_edge2.y - b2EPCollider._temp_edge.y * b2EPCollider._temp_edge2.x > 0;
            offset2 = this.m_normal2.x * (this.m_centroidB.x - this.m_v2.x) + this.m_normal2.y * (this.m_centroidB.y - this.m_v2.y);
          }
          if (hasVertex0 && hasVertex3) if (convex1 && convex2) {
            this.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal0.x;
              this.m_lowerLimit.y = this.m_normal0.y;
              this.m_upperLimit.x = this.m_normal2.x;
              this.m_upperLimit.y = this.m_normal2.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal1.x;
              this.m_lowerLimit.y = -this.m_normal1.y;
              this.m_upperLimit.x = -this.m_normal1.x;
              this.m_upperLimit.y = -this.m_normal1.y;
            }
          } else if (convex1) {
            this.m_front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal0.x;
              this.m_lowerLimit.y = this.m_normal0.y;
              this.m_upperLimit.x = this.m_normal1.x;
              this.m_upperLimit.y = this.m_normal1.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal2.x;
              this.m_lowerLimit.y = -this.m_normal2.y;
              this.m_upperLimit.x = -this.m_normal1.x;
              this.m_upperLimit.y = -this.m_normal1.y;
            }
          } else if (convex2) {
            this.m_front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal1.x;
              this.m_lowerLimit.y = this.m_normal1.y;
              this.m_upperLimit.x = this.m_normal2.x;
              this.m_upperLimit.y = this.m_normal2.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal1.x;
              this.m_lowerLimit.y = -this.m_normal1.y;
              this.m_upperLimit.x = -this.m_normal0.x;
              this.m_upperLimit.y = -this.m_normal0.y;
            }
          } else {
            this.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal1.x;
              this.m_lowerLimit.y = this.m_normal1.y;
              this.m_upperLimit.x = this.m_normal1.x;
              this.m_upperLimit.y = this.m_normal1.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal2.x;
              this.m_lowerLimit.y = -this.m_normal2.y;
              this.m_upperLimit.x = -this.m_normal0.x;
              this.m_upperLimit.y = -this.m_normal0.y;
            }
          } else if (hasVertex0) if (convex1) {
            this.m_front = offset0 >= 0 || offset1 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal0.x;
              this.m_lowerLimit.y = this.m_normal0.y;
              this.m_upperLimit.x = -this.m_normal1.x;
              this.m_upperLimit.y = -this.m_normal1.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal1.x;
              this.m_lowerLimit.y = this.m_normal1.y;
              this.m_upperLimit.x = -this.m_normal1.x;
              this.m_upperLimit.y = -this.m_normal1.y;
            }
          } else {
            this.m_front = offset0 >= 0 && offset1 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal1.x;
              this.m_lowerLimit.y = this.m_normal1.y;
              this.m_upperLimit.x = -this.m_normal1.x;
              this.m_upperLimit.y = -this.m_normal1.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal1.x;
              this.m_lowerLimit.y = this.m_normal1.y;
              this.m_upperLimit.x = -this.m_normal0.x;
              this.m_upperLimit.y = -this.m_normal0.y;
            }
          } else if (hasVertex3) if (convex2) {
            this.m_front = offset1 >= 0 || offset2 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal1.x;
              this.m_lowerLimit.y = -this.m_normal1.y;
              this.m_upperLimit.x = this.m_normal2.x;
              this.m_upperLimit.y = this.m_normal2.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal1.x;
              this.m_lowerLimit.y = -this.m_normal1.y;
              this.m_upperLimit.x = this.m_normal1.x;
              this.m_upperLimit.y = this.m_normal1.y;
            }
          } else {
            this.m_front = offset1 >= 0 && offset2 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal1.x;
              this.m_lowerLimit.y = -this.m_normal1.y;
              this.m_upperLimit.x = this.m_normal1.x;
              this.m_upperLimit.y = this.m_normal1.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal2.x;
              this.m_lowerLimit.y = -this.m_normal2.y;
              this.m_upperLimit.x = this.m_normal1.x;
              this.m_upperLimit.y = this.m_normal1.y;
            }
          } else {
            this.m_front = offset1 >= 0;
            if (this.m_front) {
              this.m_normal.x = this.m_normal1.x;
              this.m_normal.y = this.m_normal1.y;
              this.m_lowerLimit.x = -this.m_normal1.x;
              this.m_lowerLimit.y = -this.m_normal1.y;
              this.m_upperLimit.x = -this.m_normal1.x;
              this.m_upperLimit.y = -this.m_normal1.y;
            } else {
              this.m_normal.x = -this.m_normal1.x;
              this.m_normal.y = -this.m_normal1.y;
              this.m_lowerLimit.x = this.m_normal1.x;
              this.m_lowerLimit.y = this.m_normal1.y;
              this.m_upperLimit.x = this.m_normal1.x;
              this.m_upperLimit.y = this.m_normal1.y;
            }
          }
          this.m_polygonB.count = polygonB.m_count;
          for (var i = 0; i < polygonB.m_count; ++i) {
            this.m_polygonB.vertices[i] = b2Mul_t_v2(this.m_xf, polygonB.m_vertices[i]);
            this.m_polygonB.normals[i] = b2Mul_r_v2(this.m_xf.q, polygonB.m_normals[i]);
          }
          this.m_radius = 2 * b2_polygonRadius;
          manifold.pointCount = 0;
          var edgeAxis = this.ComputeEdgeSeparation();
          if (edgeAxis.type == b2EPAxis.e_unknown) return;
          if (edgeAxis.separation > this.m_radius) return;
          var polygonAxis = this.ComputePolygonSeparation();
          if (polygonAxis.type != b2EPAxis.e_unknown && polygonAxis.separation > this.m_radius) return;
          var k_relativeTol = .98;
          var k_absoluteTol = .001;
          var primaryAxis = new b2EPAxis();
          primaryAxis = polygonAxis.type == b2EPAxis.e_unknown ? edgeAxis : polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol ? polygonAxis : edgeAxis;
          var ie = new Array(2);
          var rf = new b2ReferenceFace();
          if (primaryAxis.type == b2EPAxis.e_edgeA) {
            manifold.type = b2Manifold.e_faceA;
            var bestIndex = 0;
            var bestValue = this.m_normal.x * this.m_polygonB.normals[0].x + this.m_normal.y * this.m_polygonB.normals[0].y;
            for (var i = 1; i < this.m_polygonB.count; ++i) {
              var value = this.m_normal.x * this.m_polygonB.normals[i].x + this.m_normal.y * this.m_polygonB.normals[i].y;
              if (value < bestValue) {
                bestValue = value;
                bestIndex = i;
              }
            }
            var i1 = bestIndex;
            var i2 = i1 + 1 < this.m_polygonB.count ? i1 + 1 : 0;
            ie[0] = new b2ClipVertex();
            ie[0].v.x = this.m_polygonB.vertices[i1].x;
            ie[0].v.y = this.m_polygonB.vertices[i1].y;
            ie[0].id.indexA = 0;
            ie[0].id.indexB = i1;
            ie[0].id.typeA = b2ContactID.e_face;
            ie[0].id.typeB = b2ContactID.e_vertex;
            ie[1] = new b2ClipVertex();
            ie[1].v.x = this.m_polygonB.vertices[i2].x;
            ie[1].v.y = this.m_polygonB.vertices[i2].y;
            ie[1].id.indexA = 0;
            ie[1].id.indexB = i2;
            ie[1].id.typeA = b2ContactID.e_face;
            ie[1].id.typeB = b2ContactID.e_vertex;
            if (this.m_front) {
              rf.i1 = 0;
              rf.i2 = 1;
              rf.v1.x = this.m_v1.x;
              rf.v1.y = this.m_v1.y;
              rf.v2.x = this.m_v2.x;
              rf.v2.y = this.m_v2.y;
              rf.normal.x = this.m_normal1.x;
              rf.normal.y = this.m_normal1.y;
            } else {
              rf.i1 = 1;
              rf.i2 = 0;
              rf.v1.x = this.m_v2.x;
              rf.v1.y = this.m_v2.y;
              rf.v2.x = this.m_v1.x;
              rf.v2.y = this.m_v1.y;
              rf.normal.x = -this.m_normal1.x;
              rf.normal.y = -this.m_normal1.y;
            }
          } else {
            manifold.type = b2Manifold.e_faceB;
            ie[0] = new b2ClipVertex();
            ie[0].v = this.m_v1;
            ie[0].id.indexA = 0;
            ie[0].id.indexB = primaryAxis.index;
            ie[0].id.typeA = b2ContactID.e_vertex;
            ie[0].id.typeB = b2ContactID.e_face;
            ie[1] = new b2ClipVertex();
            ie[1].v = this.m_v2;
            ie[1].id.indexA = 0;
            ie[1].id.indexB = primaryAxis.index;
            ie[1].id.typeA = b2ContactID.e_vertex;
            ie[1].id.typeB = b2ContactID.e_face;
            rf.i1 = primaryAxis.index;
            rf.i2 = rf.i1 + 1 < this.m_polygonB.count ? rf.i1 + 1 : 0;
            rf.v1.x = this.m_polygonB.vertices[rf.i1].x;
            rf.v1.y = this.m_polygonB.vertices[rf.i1].y;
            rf.v2.x = this.m_polygonB.vertices[rf.i2].x;
            rf.v2.y = this.m_polygonB.vertices[rf.i2].y;
            rf.normal.x = this.m_polygonB.normals[rf.i1].x;
            rf.normal.y = this.m_polygonB.normals[rf.i1].y;
          }
          rf.sideNormal1.x = rf.normal.y;
          rf.sideNormal1.y = -rf.normal.x;
          rf.sideNormal2.x = -rf.sideNormal1.x;
          rf.sideNormal2.y = -rf.sideNormal1.y;
          rf.sideOffset1 = rf.sideNormal1.x * rf.v1.x + rf.sideNormal1.y * rf.v1.y;
          rf.sideOffset2 = rf.sideNormal2.x * rf.v2.x + rf.sideNormal2.y * rf.v2.y;
          var clipPoints1 = new Array(2);
          var clipPoints2 = new Array(2);
          var np;
          np = b2ClipSegmentToLine(clipPoints1, ie, rf.sideNormal1.x, rf.sideNormal1.y, rf.sideOffset1, rf.i1);
          if (np < b2_maxManifoldPoints) return;
          np = b2ClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2.x, rf.sideNormal2.y, rf.sideOffset2, rf.i2);
          if (np < b2_maxManifoldPoints) return;
          if (primaryAxis.type == b2EPAxis.e_edgeA) {
            manifold.localNormal.x = rf.normal.x;
            manifold.localNormal.y = rf.normal.y;
            manifold.localPoint.x = rf.v1.x;
            manifold.localPoint.y = rf.v1.y;
          } else {
            manifold.localNormal.x = polygonB.m_normals[rf.i1].x;
            manifold.localNormal.y = polygonB.m_normals[rf.i1].y;
            manifold.localPoint.x = polygonB.m_vertices[rf.i1].x;
            manifold.localPoint.y = polygonB.m_vertices[rf.i1].y;
          }
          var pointCount = 0;
          for (var i = 0; i < b2_maxManifoldPoints; ++i) {
            var separation = rf.normal.x * (clipPoints2[i].v.x - rf.v1.x) + rf.normal.y * (clipPoints2[i].v.y - rf.v1.y);
            if (separation <= this.m_radius) {
              var cp = manifold.points[pointCount] = new b2ManifoldPoint();
              if (primaryAxis.type == b2EPAxis.e_edgeA) {
                cp.localPoint.Assign(b2MulT_t_v2(this.m_xf, clipPoints2[i].v));
                cp.id.Assign(clipPoints2[i].id);
              } else {
                cp.localPoint.x = clipPoints2[i].v.x;
                cp.localPoint.y = clipPoints2[i].v.y;
                cp.id.typeA = clipPoints2[i].id.typeB;
                cp.id.typeB = clipPoints2[i].id.typeA;
                cp.id.indexA = clipPoints2[i].id.indexB;
                cp.id.indexB = clipPoints2[i].id.indexA;
              }
              ++pointCount;
            }
          }
          manifold.pointCount = pointCount;
        },
        ComputeEdgeSeparation: function() {
          var axis = new b2EPAxis();
          axis.type = b2EPAxis.e_edgeA;
          axis.index = this.m_front ? 0 : 1;
          axis.separation = Number.MAX_VALUE;
          for (var i = 0; i < this.m_polygonB.count; ++i) {
            var s = this.m_normal.x * (this.m_polygonB.vertices[i].x - this.m_v1.x) + this.m_normal.y * (this.m_polygonB.vertices[i].y - this.m_v1.y);
            s < axis.separation && (axis.separation = s);
          }
          return axis;
        },
        ComputePolygonSeparation: function() {
          var axis = new b2EPAxis();
          axis.type = b2EPAxis.e_unknown;
          axis.index = -1;
          axis.separation = -Number.MAX_VALUE;
          var perpx = -this.m_normal.y;
          var perpy = this.m_normal.x;
          for (var i = 0; i < this.m_polygonB.count; ++i) {
            var nx = -this.m_polygonB.normals[i].x;
            var ny = -this.m_polygonB.normals[i].y;
            var s1 = nx * (this.m_polygonB.vertices[i].x - this.m_v1.x) + ny * (this.m_polygonB.vertices[i].y - this.m_v1.y);
            var s2 = nx * (this.m_polygonB.vertices[i].x - this.m_v2.x) + ny * (this.m_polygonB.vertices[i].y - this.m_v2.y);
            var s = b2Min(s1, s2);
            if (s > this.m_radius) {
              axis.type = b2EPAxis.e_edgeB;
              axis.index = i;
              axis.separation = s;
              return axis;
            }
            if (nx * perpx + ny * perpy >= 0) {
              if ((nx - this.m_upperLimit.x) * this.m_normal.x + (ny - this.m_upperLimit.y) * this.m_normal.y < -b2_angularSlop) continue;
            } else if ((nx - this.m_lowerLimit.x) * this.m_normal.x + (ny - this.m_lowerLimit.y) * this.m_normal.y < -b2_angularSlop) continue;
            if (s > axis.separation) {
              axis.type = b2EPAxis.e_edgeB;
              axis.index = i;
              axis.separation = s;
            }
          }
          return axis;
        }
      };
      b2EPCollider.e_isolated = 0;
      b2EPCollider.e_concave = 1;
      b2EPCollider.e_convex = 2;
      function b2CollideEdgeAndPolygon(manifold, edgeA, xfA, polygonB, xfB) {
        b2CollideEdgeAndPolygon.collider.Collide(manifold, edgeA, xfA, polygonB, xfB);
      }
      b2CollideEdgeAndPolygon.collider = new b2EPCollider();
      function b2ClipSegmentToLine(vOut, vIn, normalx, normaly, offset, vertexIndexA) {
        var numOut = 0;
        var distance0 = normalx * vIn[0].v.x + normaly * vIn[0].v.y - offset;
        var distance1 = normalx * vIn[1].v.x + normaly * vIn[1].v.y - offset;
        distance0 <= 0 && (vOut[numOut++] = vIn[0]);
        distance1 <= 0 && (vOut[numOut++] = vIn[1]);
        if (distance0 * distance1 < 0) {
          var interp = distance0 / (distance0 - distance1);
          vOut[numOut] = new b2ClipVertex();
          vOut[numOut].v.x = vIn[0].v.x + interp * (vIn[1].v.x - vIn[0].v.x);
          vOut[numOut].v.y = vIn[0].v.y + interp * (vIn[1].v.y - vIn[0].v.y);
          vOut[numOut].id.indexA = vertexIndexA;
          vOut[numOut].id.indexB = vIn[0].id.indexB;
          vOut[numOut].id.typeA = b2ContactID.e_vertex;
          vOut[numOut].id.typeB = b2ContactID.e_face;
          ++numOut;
        }
        return numOut;
      }
      function b2TestShapeOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB) {
        b2TestShapeOverlap.input.proxyA.Set(shapeA, indexA);
        b2TestShapeOverlap.input.proxyB.Set(shapeB, indexB);
        b2TestShapeOverlap.input.transformA = xfA;
        b2TestShapeOverlap.input.transformB = xfB;
        b2TestShapeOverlap.input.useRadii = true;
        b2TestShapeOverlap.cache.count = 0;
        b2DistanceFunc(b2TestShapeOverlap.output, b2TestShapeOverlap.cache, b2TestShapeOverlap.input);
        return b2TestShapeOverlap.output.distance < 10 * b2_epsilon;
      }
      b2TestShapeOverlap.input = new b2DistanceInput();
      b2TestShapeOverlap.cache = new b2SimplexCache();
      b2TestShapeOverlap.output = new b2DistanceOutput();
      function b2TestOverlap(a, b) {
        return !(b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0 || a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0);
      }
      var b2_nullNode = -1;
      function b2TreeNode() {
        this.aabb = new b2AABB();
        this.userData = null;
        this.parent = 0;
        this.child1 = this.child2 = this.height = 0;
      }
      b2TreeNode.prototype = {
        IsLeaf: function() {
          return this.child1 == b2_nullNode;
        }
      };
      function b2DynamicTree() {
        this.m_root = b2_nullNode;
        this.m_nodeCapacity = 16;
        this.m_nodeCount = 0;
        this.m_nodes = new Array(this.m_nodeCapacity);
        for (var i = 0; i < this.m_nodeCapacity - 1; ++i) {
          this.m_nodes[i] = new b2TreeNode();
          this.m_nodes[i].parent = i + 1;
          this.m_nodes[i].height = -1;
        }
        this.m_nodes[this.m_nodeCapacity - 1] = new b2TreeNode();
        this.m_nodes[this.m_nodeCapacity - 1].parent = b2_nullNode;
        this.m_nodes[this.m_nodeCapacity - 1].height = -1;
        this.m_freeList = 0;
        this.m_path = 0;
        this.m_insertionCount = 0;
      }
      b2DynamicTree.aabbExtensionFattener = new b2Vec2(b2_aabbExtension, b2_aabbExtension);
      b2DynamicTree.prototype = {
        CreateProxy: function(aabb, userData) {
          var proxyId = this.AllocateNode();
          this.m_nodes[proxyId].aabb.lowerBound.Assign(b2Vec2.Subtract(aabb.lowerBound, b2DynamicTree.aabbExtensionFattener));
          this.m_nodes[proxyId].aabb.upperBound.Assign(b2Vec2.Add(aabb.upperBound, b2DynamicTree.aabbExtensionFattener));
          this.m_nodes[proxyId].userData = userData;
          this.m_nodes[proxyId].height = 0;
          this.InsertLeaf(proxyId);
          return proxyId;
        },
        DestroyProxy: function(proxyId) {
          b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
          b2Assert(this.m_nodes[proxyId].IsLeaf());
          this.RemoveLeaf(proxyId);
          this.FreeNode(proxyId);
        },
        MoveProxy: function(proxyId, aabb, displacement) {
          b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
          b2Assert(this.m_nodes[proxyId].IsLeaf());
          if (this.m_nodes[proxyId].aabb.Contains(aabb)) return false;
          this.RemoveLeaf(proxyId);
          this.m_nodes[proxyId].aabb.Assign(aabb);
          this.m_nodes[proxyId].aabb.lowerBound.Subtract(b2DynamicTree.aabbExtensionFattener);
          this.m_nodes[proxyId].aabb.upperBound.Add(b2DynamicTree.aabbExtensionFattener);
          var d = b2Vec2.Multiply(b2_aabbMultiplier, displacement);
          d.x < 0 ? this.m_nodes[proxyId].aabb.lowerBound.x += d.x : this.m_nodes[proxyId].aabb.upperBound.x += d.x;
          d.y < 0 ? this.m_nodes[proxyId].aabb.lowerBound.y += d.y : this.m_nodes[proxyId].aabb.upperBound.y += d.y;
          this.InsertLeaf(proxyId);
          return true;
        },
        GetUserData: function(proxyId) {
          b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
          return this.m_nodes[proxyId].userData;
        },
        GetFatAABB: function(proxyId) {
          b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
          return this.m_nodes[proxyId].aabb;
        },
        Query: function(callback, aabb) {
          var stack = [];
          stack.push(this.m_root);
          while (stack.length > 0) {
            var nodeId = stack.pop();
            if (nodeId == b2_nullNode) continue;
            var node = this.m_nodes[nodeId];
            if (b2TestOverlap(node.aabb, aabb)) if (node.IsLeaf()) {
              var proceed = callback.QueryCallback(nodeId);
              if (false == proceed) return;
            } else {
              stack.push(node.child1);
              stack.push(node.child2);
            }
          }
        },
        RayCast: function(callback, input) {
          var p1 = input.p1;
          var p2 = input.p2;
          var r = b2Vec2.Subtract(p2, p1);
          b2Assert(r.LengthSquared() > 0);
          r.Normalize();
          var v = b2Cross_f_v2(1, r);
          var abs_v = b2Abs_v2(v);
          var maxFraction = input.maxFraction;
          var segmentAABB = new b2AABB();
          var t = b2Vec2.Add(p1, b2Vec2.Multiply(maxFraction, b2Vec2.Subtract(p2, p1)));
          segmentAABB.lowerBound.Assign(b2Min_v2(p1, t));
          segmentAABB.upperBound.Assign(b2Max_v2(p1, t));
          var stack = [];
          stack.push(this.m_root);
          while (stack.length > 0) {
            var nodeId = stack.pop();
            if (nodeId == b2_nullNode) continue;
            var node = this.m_nodes[nodeId];
            if (false == b2TestOverlap(node.aabb, segmentAABB)) continue;
            var c = node.aabb.GetCenter();
            var h = node.aabb.GetExtents();
            var separation = b2Abs(b2Dot_v2_v2(v, b2Vec2.Subtract(p1, c))) - b2Dot_v2_v2(abs_v, h);
            if (separation > 0) continue;
            if (node.IsLeaf()) {
              var subInput = new b2RayCastInput();
              subInput.p1.Assign(input.p1);
              subInput.p2.Assign(input.p2);
              subInput.maxFraction = maxFraction;
              var value = callback.RayCastCallback(subInput, nodeId);
              if (0 == value) return;
              if (value > 0) {
                maxFraction = value;
                var t = b2Vec2.Add(p1, b2Vec2.Multiply(maxFraction, b2Vec2.Subtract(p2, p1)));
                segmentAABB.lowerBound.Assign(b2Min_v2(p1, t));
                segmentAABB.upperBound.Assign(b2Max_v2(p1, t));
              }
            } else {
              stack.push(node.child1);
              stack.push(node.child2);
            }
          }
        },
        Validate: function() {
          this.ValidateStructure(this.m_root);
          this.ValidateMetrics(this.m_root);
          var freeCount = 0;
          var freeIndex = this.m_freeList;
          while (freeIndex != b2_nullNode) {
            b2Assert(0 <= freeIndex && freeIndex < this.m_nodeCapacity);
            freeIndex = this.m_nodes[freeIndex].parent;
            ++freeCount;
          }
          b2Assert(this.GetHeight() == this.ComputeHeight());
          b2Assert(this.m_nodeCount + freeCount == this.m_nodeCapacity);
        },
        GetHeight: function() {
          if (this.m_root == b2_nullNode) return 0;
          return this.m_nodes[this.m_root].height;
        },
        GetMaxBalance: function() {
          var maxBalance = 0;
          for (var i = 0; i < this.m_nodeCapacity; ++i) {
            var node = this.m_nodes[i];
            if (node.height <= 1) continue;
            b2Assert(false == node.IsLeaf());
            var child1 = node.child1;
            var child2 = node.child2;
            var balance = b2Abs(this.m_nodes[child2].height - this.m_nodes[child1].height);
            maxBalance = b2Max(maxBalance, balance);
          }
          return maxBalance;
        },
        GetAreaRatio: function() {
          if (this.m_root == b2_nullNode) return 0;
          var root = this.m_nodes[this.m_root];
          var rootArea = root.aabb.GetPerimeter();
          var totalArea = 0;
          for (var i = 0; i < this.m_nodeCapacity; ++i) {
            var node = this.m_nodes[i];
            if (node.height < 0) continue;
            totalArea += node.aabb.GetPerimeter();
          }
          return totalArea / rootArea;
        },
        RebuildBottomUp: function() {
          var nodes = new Array(this.m_nodeCount);
          var count = 0;
          for (var i = 0; i < this.m_nodeCapacity; ++i) {
            if (this.m_nodes[i].height < 0) continue;
            if (this.m_nodes[i].IsLeaf()) {
              this.m_nodes[i].parent = b2_nullNode;
              nodes[count] = i;
              ++count;
            } else this.FreeNode(i);
          }
          while (count > 1) {
            var minCost = b2_maxFloat;
            var iMin = -1, jMin = -1;
            for (i = 0; i < count; ++i) {
              var aabbi = this.m_nodes[nodes[i]].aabb;
              for (var j = i + 1; j < count; ++j) {
                var aabbj = this.m_nodes[nodes[j]].aabb;
                var b = new b2AABB();
                b.Combine(aabbi, aabbj);
                var cost = b.GetPerimeter();
                if (cost < minCost) {
                  iMin = i;
                  jMin = j;
                  minCost = cost;
                }
              }
            }
            var index1 = nodes[iMin];
            var index2 = nodes[jMin];
            var child1 = this.m_nodes[index1];
            var child2 = this.m_nodes[index2];
            var parentIndex = this.AllocateNode();
            var parent = this.m_nodes[parentIndex];
            parent.child1 = index1;
            parent.child2 = index2;
            parent.height = 1 + b2Max(child1.height, child2.height);
            parent.aabb.Combine(child1.aabb, child2.aabb);
            parent.parent = b2_nullNode;
            child1.parent = parentIndex;
            child2.parent = parentIndex;
            nodes[jMin] = nodes[count - 1];
            nodes[iMin] = parentIndex;
            --count;
          }
          this.m_root = nodes[0];
          this.Validate();
        },
        ShiftOrigin: function(newOrigin) {
          for (var i = 0; i < this.m_nodeCapacity; ++i) {
            this.m_nodes[i].aabb.lowerBound.Subtract(newOrigin);
            this.m_nodes[i].aabb.upperBound.Subtract(newOrigin);
          }
        },
        AllocateNode: function() {
          if (this.m_freeList == b2_nullNode) {
            b2Assert(this.m_nodeCount == this.m_nodeCapacity);
            var oldNodes = this.m_nodes;
            this.m_nodeCapacity *= 2;
            this.m_nodes = oldNodes.concat(new Array(this.m_nodeCapacity - this.m_nodeCount));
            for (var i = this.m_nodeCount; i < this.m_nodeCapacity - 1; ++i) {
              this.m_nodes[i] = new b2TreeNode();
              this.m_nodes[i].parent = i + 1;
              this.m_nodes[i].height = -1;
            }
            this.m_nodes[this.m_nodeCapacity - 1] = new b2TreeNode();
            this.m_nodes[this.m_nodeCapacity - 1].parent = b2_nullNode;
            this.m_nodes[this.m_nodeCapacity - 1].height = -1;
            this.m_freeList = this.m_nodeCount;
          }
          var nodeId = this.m_freeList;
          this.m_freeList = this.m_nodes[nodeId].parent;
          this.m_nodes[nodeId].parent = b2_nullNode;
          this.m_nodes[nodeId].child1 = b2_nullNode;
          this.m_nodes[nodeId].child2 = b2_nullNode;
          this.m_nodes[nodeId].height = 0;
          this.m_nodes[nodeId].userData = null;
          ++this.m_nodeCount;
          return nodeId;
        },
        FreeNode: function(nodeId) {
          b2Assert(0 <= nodeId && nodeId < this.m_nodeCapacity);
          b2Assert(0 < this.m_nodeCount);
          this.m_nodes[nodeId].parent = this.m_freeList;
          this.m_nodes[nodeId].height = -1;
          this.m_freeList = nodeId;
          --this.m_nodeCount;
        },
        InsertLeaf: function(leaf) {
          ++this.m_insertionCount;
          if (this.m_root == b2_nullNode) {
            this.m_root = leaf;
            this.m_nodes[this.m_root].parent = b2_nullNode;
            return;
          }
          var leafAABB = this.m_nodes[leaf].aabb;
          var index = this.m_root;
          while (false == this.m_nodes[index].IsLeaf()) {
            var child1 = this.m_nodes[index].child1;
            var child2 = this.m_nodes[index].child2;
            var area = this.m_nodes[index].aabb.GetPerimeter();
            var combinedAABB = new b2AABB();
            combinedAABB.Combine(this.m_nodes[index].aabb, leafAABB);
            var combinedArea = combinedAABB.GetPerimeter();
            var cost = 2 * combinedArea;
            var inheritanceCost = 2 * (combinedArea - area);
            var cost1;
            var aabb;
            if (this.m_nodes[child1].IsLeaf()) {
              aabb = new b2AABB();
              aabb.Combine(leafAABB, this.m_nodes[child1].aabb);
              cost1 = aabb.GetPerimeter() + inheritanceCost;
            } else {
              aabb = new b2AABB();
              aabb.Combine(leafAABB, this.m_nodes[child1].aabb);
              var oldArea = this.m_nodes[child1].aabb.GetPerimeter();
              var newArea = aabb.GetPerimeter();
              cost1 = newArea - oldArea + inheritanceCost;
            }
            var cost2;
            if (this.m_nodes[child2].IsLeaf()) {
              aabb = new b2AABB();
              aabb.Combine(leafAABB, this.m_nodes[child2].aabb);
              cost2 = aabb.GetPerimeter() + inheritanceCost;
            } else {
              aabb = new b2AABB();
              aabb.Combine(leafAABB, this.m_nodes[child2].aabb);
              var oldArea = this.m_nodes[child2].aabb.GetPerimeter();
              var newArea = aabb.GetPerimeter();
              cost2 = newArea - oldArea + inheritanceCost;
            }
            if (cost < cost1 && cost < cost2) break;
            index = cost1 < cost2 ? child1 : child2;
          }
          var sibling = index;
          var oldParent = this.m_nodes[sibling].parent;
          var newParent = this.AllocateNode();
          this.m_nodes[newParent].parent = oldParent;
          this.m_nodes[newParent].userData = null;
          this.m_nodes[newParent].aabb.Combine(leafAABB, this.m_nodes[sibling].aabb);
          this.m_nodes[newParent].height = this.m_nodes[sibling].height + 1;
          if (oldParent != b2_nullNode) {
            this.m_nodes[oldParent].child1 == sibling ? this.m_nodes[oldParent].child1 = newParent : this.m_nodes[oldParent].child2 = newParent;
            this.m_nodes[newParent].child1 = sibling;
            this.m_nodes[newParent].child2 = leaf;
            this.m_nodes[sibling].parent = newParent;
            this.m_nodes[leaf].parent = newParent;
          } else {
            this.m_nodes[newParent].child1 = sibling;
            this.m_nodes[newParent].child2 = leaf;
            this.m_nodes[sibling].parent = newParent;
            this.m_nodes[leaf].parent = newParent;
            this.m_root = newParent;
          }
          index = this.m_nodes[leaf].parent;
          while (index != b2_nullNode) {
            index = this.Balance(index);
            var child1 = this.m_nodes[index].child1;
            var child2 = this.m_nodes[index].child2;
            b2Assert(child1 != b2_nullNode);
            b2Assert(child2 != b2_nullNode);
            this.m_nodes[index].height = 1 + b2Max(this.m_nodes[child1].height, this.m_nodes[child2].height);
            this.m_nodes[index].aabb.Combine(this.m_nodes[child1].aabb, this.m_nodes[child2].aabb);
            index = this.m_nodes[index].parent;
          }
        },
        RemoveLeaf: function(leaf) {
          if (leaf == this.m_root) {
            this.m_root = b2_nullNode;
            return;
          }
          var parent = this.m_nodes[leaf].parent;
          var grandParent = this.m_nodes[parent].parent;
          var sibling;
          sibling = this.m_nodes[parent].child1 == leaf ? this.m_nodes[parent].child2 : this.m_nodes[parent].child1;
          if (grandParent != b2_nullNode) {
            this.m_nodes[grandParent].child1 == parent ? this.m_nodes[grandParent].child1 = sibling : this.m_nodes[grandParent].child2 = sibling;
            this.m_nodes[sibling].parent = grandParent;
            this.FreeNode(parent);
            var index = grandParent;
            while (index != b2_nullNode) {
              index = this.Balance(index);
              var child1 = this.m_nodes[index].child1;
              var child2 = this.m_nodes[index].child2;
              this.m_nodes[index].aabb.Combine(this.m_nodes[child1].aabb, this.m_nodes[child2].aabb);
              this.m_nodes[index].height = 1 + b2Max(this.m_nodes[child1].height, this.m_nodes[child2].height);
              index = this.m_nodes[index].parent;
            }
          } else {
            this.m_root = sibling;
            this.m_nodes[sibling].parent = b2_nullNode;
            this.FreeNode(parent);
          }
        },
        Balance: function(iA) {
          b2Assert(iA != b2_nullNode);
          var A = this.m_nodes[iA];
          if (A.IsLeaf() || A.height < 2) return iA;
          var iB = A.child1;
          var iC = A.child2;
          b2Assert(0 <= iB && iB < this.m_nodeCapacity);
          b2Assert(0 <= iC && iC < this.m_nodeCapacity);
          var B = this.m_nodes[iB];
          var C = this.m_nodes[iC];
          var balance = C.height - B.height;
          if (balance > 1) {
            var iF = C.child1;
            var iG = C.child2;
            var F = this.m_nodes[iF];
            var G = this.m_nodes[iG];
            b2Assert(0 <= iF && iF < this.m_nodeCapacity);
            b2Assert(0 <= iG && iG < this.m_nodeCapacity);
            C.child1 = iA;
            C.parent = A.parent;
            A.parent = iC;
            if (C.parent != b2_nullNode) if (this.m_nodes[C.parent].child1 == iA) this.m_nodes[C.parent].child1 = iC; else {
              b2Assert(this.m_nodes[C.parent].child2 == iA);
              this.m_nodes[C.parent].child2 = iC;
            } else this.m_root = iC;
            if (F.height > G.height) {
              C.child2 = iF;
              A.child2 = iG;
              G.parent = iA;
              A.aabb.Combine(B.aabb, G.aabb);
              C.aabb.Combine(A.aabb, F.aabb);
              A.height = 1 + b2Max(B.height, G.height);
              C.height = 1 + b2Max(A.height, F.height);
            } else {
              C.child2 = iG;
              A.child2 = iF;
              F.parent = iA;
              A.aabb.Combine(B.aabb, F.aabb);
              C.aabb.Combine(A.aabb, G.aabb);
              A.height = 1 + b2Max(B.height, F.height);
              C.height = 1 + b2Max(A.height, G.height);
            }
            return iC;
          }
          if (balance < -1) {
            var iD = B.child1;
            var iE = B.child2;
            var D = this.m_nodes[iD];
            var E = this.m_nodes[iE];
            b2Assert(0 <= iD && iD < this.m_nodeCapacity);
            b2Assert(0 <= iE && iE < this.m_nodeCapacity);
            B.child1 = iA;
            B.parent = A.parent;
            A.parent = iB;
            if (B.parent != b2_nullNode) if (this.m_nodes[B.parent].child1 == iA) this.m_nodes[B.parent].child1 = iB; else {
              b2Assert(this.m_nodes[B.parent].child2 == iA);
              this.m_nodes[B.parent].child2 = iB;
            } else this.m_root = iB;
            if (D.height > E.height) {
              B.child2 = iD;
              A.child1 = iE;
              E.parent = iA;
              A.aabb.Combine(C.aabb, E.aabb);
              B.aabb.Combine(A.aabb, D.aabb);
              A.height = 1 + b2Max(C.height, E.height);
              B.height = 1 + b2Max(A.height, D.height);
            } else {
              B.child2 = iE;
              A.child1 = iD;
              D.parent = iA;
              A.aabb.Combine(C.aabb, D.aabb);
              B.aabb.Combine(A.aabb, E.aabb);
              A.height = 1 + b2Max(C.height, D.height);
              B.height = 1 + b2Max(A.height, E.height);
            }
            return iB;
          }
          return iA;
        },
        ComputeHeight: function(nodeId) {
          "undefined" === typeof nodeId && (nodeId = this.m_root);
          b2Assert(0 <= nodeId && nodeId < this.m_nodeCapacity);
          var node = this.m_nodes[nodeId];
          if (node.IsLeaf()) return 0;
          var height1 = this.ComputeHeight(node.child1);
          var height2 = this.ComputeHeight(node.child2);
          return 1 + b2Max(height1, height2);
        },
        ValidateStructure: function(index) {
          if (index == b2_nullNode) return;
          index == this.m_root && b2Assert(this.m_nodes[index].parent == b2_nullNode);
          var node = this.m_nodes[index];
          var child1 = node.child1;
          var child2 = node.child2;
          if (node.IsLeaf()) {
            b2Assert(child1 == b2_nullNode);
            b2Assert(child2 == b2_nullNode);
            b2Assert(0 == node.height);
            return;
          }
          b2Assert(0 <= child1 && child1 < this.m_nodeCapacity);
          b2Assert(0 <= child2 && child2 < this.m_nodeCapacity);
          b2Assert(this.m_nodes[child1].parent == index);
          b2Assert(this.m_nodes[child2].parent == index);
          this.ValidateStructure(child1);
          this.ValidateStructure(child2);
        },
        ValidateMetrics: function(index) {
          if (index == b2_nullNode) return;
          var node = this.m_nodes[index];
          var child1 = node.child1;
          var child2 = node.child2;
          if (node.IsLeaf()) {
            b2Assert(child1 == b2_nullNode);
            b2Assert(child2 == b2_nullNode);
            b2Assert(0 == node.height);
            return;
          }
          b2Assert(0 <= child1 && child1 < this.m_nodeCapacity);
          b2Assert(0 <= child2 && child2 < this.m_nodeCapacity);
          var height1 = this.m_nodes[child1].height;
          var height2 = this.m_nodes[child2].height;
          var height;
          height = 1 + b2Max(height1, height2);
          b2Assert(node.height == height);
          var aabb = new b2AABB();
          aabb.Combine(this.m_nodes[child1].aabb, this.m_nodes[child2].aabb);
          b2Assert(b2Vec2.Equals(aabb.lowerBound, node.aabb.lowerBound));
          b2Assert(b2Vec2.Equals(aabb.upperBound, node.aabb.upperBound));
          this.ValidateMetrics(child1);
          this.ValidateMetrics(child2);
        }
      };
      function b2TOIInput() {
        this.proxyA = new b2DistanceProxy();
        this.proxyB = new b2DistanceProxy();
        this.sweepA = new b2Sweep();
        this.sweepB = new b2Sweep();
        this.tMax = 0;
      }
      function b2TOIOutput() {
        this.state = 0;
        this.t = 0;
      }
      b2TOIOutput.e_unknown = 0;
      b2TOIOutput.e_failed = 1;
      b2TOIOutput.e_overlapped = 2;
      b2TOIOutput.e_touching = 3;
      b2TOIOutput.e_separated = 4;
      function b2SeparationFunction() {
        this.m_proxyA = null;
        this.m_proxyB = null;
        this.m_sweepA = null;
        this.m_sweepB = null;
        this.m_type = 0;
        this.m_localPoint = new b2Vec2();
        this.m_axis = new b2Vec2();
      }
      var _local_xfA = new b2Transform();
      var _local_xfB = new b2Transform();
      b2SeparationFunction.prototype = {
        Initialize: function(cache, proxyA, sweepA, proxyB, sweepB, t1) {
          this.m_proxyA = proxyA;
          this.m_proxyB = proxyB;
          var count = cache.count;
          b2Assert(0 < count && count < 3);
          this.m_sweepA = sweepA;
          this.m_sweepB = sweepB;
          this.m_sweepA.GetTransform(_local_xfA, t1);
          this.m_sweepB.GetTransform(_local_xfB, t1);
          if (1 == count) {
            this.m_type = b2SeparationFunction.e_points;
            var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
            var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
            this.m_axis.x = pointBx - pointAx;
            this.m_axis.y = pointBy - pointAy;
            var s = this.m_axis.Normalize();
            return s;
          }
          if (cache.indexA[0] == cache.indexA[1]) {
            this.m_type = b2SeparationFunction.e_faceB;
            var localPointB1 = proxyB.GetVertex(cache.indexB[0]);
            var localPointB2 = proxyB.GetVertex(cache.indexB[1]);
            this.m_axis.x = 1 * (localPointB2.y - localPointB1.y);
            this.m_axis.y = -1 * (localPointB2.x - localPointB1.x);
            this.m_axis.Normalize();
            var normalx = _local_xfB.q.c * this.m_axis.x - _local_xfB.q.s * this.m_axis.y;
            var normaly = _local_xfB.q.s * this.m_axis.x + _local_xfB.q.c * this.m_axis.y;
            this.m_localPoint.x = .5 * (localPointB1.x + localPointB2.x);
            this.m_localPoint.y = .5 * (localPointB1.y + localPointB2.y);
            var pointBx = _local_xfB.q.c * this.m_localPoint.x - _local_xfB.q.s * this.m_localPoint.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * this.m_localPoint.x + _local_xfB.q.c * this.m_localPoint.y + _local_xfB.p.y;
            var localPointA = proxyA.GetVertex(cache.indexA[0]);
            var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
            var s = (pointAx - pointBx) * normalx + (pointAy - pointBy) * normaly;
            if (s < 0) {
              this.m_axis.x = -this.m_axis.x;
              this.m_axis.y = -this.m_axis.y;
              s = -s;
            }
            return s;
          }
          this.m_type = b2SeparationFunction.e_faceA;
          var localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
          var localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
          this.m_axis.x = 1 * (localPointA2.y - localPointA1.y);
          this.m_axis.y = -1 * (localPointA2.x - localPointA1.x);
          this.m_axis.Normalize();
          var normalx = _local_xfA.q.c * this.m_axis.x - _local_xfA.q.s * this.m_axis.y;
          var normaly = _local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
          this.m_localPoint.x = .5 * (localPointA1.x + localPointA2.x);
          this.m_localPoint.y = .5 * (localPointA1.y + localPointA2.y);
          var pointAx = _local_xfA.q.c * this.m_localPoint.x - _local_xfA.q.s * this.m_localPoint.y + _local_xfA.p.x;
          var pointAy = _local_xfA.q.s * this.m_localPoint.x + _local_xfA.q.c * this.m_localPoint.y + _local_xfA.p.y;
          var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
          var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
          var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
          var s = (pointBx - pointAx) * normalx + (pointBy - pointAy) * normaly;
          if (s < 0) {
            this.m_axis.x = -this.m_axis.x;
            this.m_axis.y = -this.m_axis.y;
            s = -s;
          }
          return s;
        },
        FindMinSeparation: function(indices, t) {
          this.m_sweepA.GetTransform(_local_xfA, t);
          this.m_sweepB.GetTransform(_local_xfB, t);
          switch (this.m_type) {
           case b2SeparationFunction.e_points:
            var axisAx = _local_xfA.q.c * this.m_axis.x + _local_xfA.q.s * this.m_axis.y;
            var axisAy = -_local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
            var axisBx = _local_xfB.q.c * -this.m_axis.x + _local_xfB.q.s * -this.m_axis.y;
            var axisBy = -_local_xfB.q.s * -this.m_axis.x + _local_xfB.q.c * -this.m_axis.y;
            indices[0] = this.m_proxyA.GetSupport(axisAx, axisAy);
            indices[1] = this.m_proxyB.GetSupport(axisBx, axisBy);
            var localPointA = this.m_proxyA.GetVertex(indices[0]);
            var localPointB = this.m_proxyB.GetVertex(indices[1]);
            var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
            var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
            return (pointBx - pointAx) * this.m_axis.x + (pointBy - pointAy) * this.m_axis.y;

           case b2SeparationFunction.e_faceA:
            var normalx = _local_xfA.q.c * this.m_axis.x - _local_xfA.q.s * this.m_axis.y;
            var normaly = _local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
            var pointAx = _local_xfA.q.c * this.m_localPoint.x - _local_xfA.q.s * this.m_localPoint.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * this.m_localPoint.x + _local_xfA.q.c * this.m_localPoint.y + _local_xfA.p.y;
            var axisBx = _local_xfB.q.c * -normalx + _local_xfB.q.s * -normaly;
            var axisBy = -_local_xfB.q.s * -normalx + _local_xfB.q.c * -normaly;
            indices[0] = -1;
            indices[1] = this.m_proxyB.GetSupport(axisBx, axisBy);
            var localPointB = this.m_proxyB.GetVertex(indices[1]);
            var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
            return (pointBx - pointAx) * normalx + (pointBy - pointAy) * normaly;

           case b2SeparationFunction.e_faceB:
            var normalx = _local_xfB.q.c * this.m_axis.x - _local_xfB.q.s * this.m_axis.y;
            var normaly = _local_xfB.q.s * this.m_axis.x + _local_xfB.q.c * this.m_axis.y;
            var pointBx = _local_xfB.q.c * this.m_localPoint.x - _local_xfB.q.s * this.m_localPoint.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * this.m_localPoint.x + _local_xfB.q.c * this.m_localPoint.y + _local_xfB.p.y;
            var axisAx = _local_xfA.q.c * -normalx + _local_xfA.q.s * -normaly;
            var axisBy = -_local_xfA.q.s * -normalx + _local_xfA.q.c * -normaly;
            indices[1] = -1;
            indices[0] = this.m_proxyA.GetSupport(axisAx, axisBy);
            var localPointA = this.m_proxyA.GetVertex(indices[0]);
            var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
            return (pointAx - pointBx) * normalx + (pointAy - pointBy) * normaly;

           default:
            b2Assert(false);
            indices[0] = -1;
            indices[1] = -1;
            return 0;
          }
        },
        Evaluate: function(indexA, indexB, t) {
          this.m_sweepA.GetTransform(_local_xfA, t);
          this.m_sweepB.GetTransform(_local_xfB, t);
          switch (this.m_type) {
           case b2SeparationFunction.e_points:
            var localPointA = this.m_proxyA.GetVertex(indexA);
            var localPointB = this.m_proxyB.GetVertex(indexB);
            var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
            var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
            var separation = (pointBx - pointAx) * this.m_axis.x + (pointBy - pointAy) * this.m_axis.y;
            return separation;

           case b2SeparationFunction.e_faceA:
            var normalx = _local_xfA.q.c * this.m_axis.x - _local_xfA.q.s * this.m_axis.y;
            var normaly = _local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
            var pointAx = _local_xfA.q.c * this.m_localPoint.x - _local_xfA.q.s * this.m_localPoint.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * this.m_localPoint.x + _local_xfA.q.c * this.m_localPoint.y + _local_xfA.p.y;
            var localPointB = this.m_proxyB.GetVertex(indexB);
            var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
            var separation = (pointBx - pointAx) * normalx + (pointBy - pointAy) * normaly;
            return separation;

           case b2SeparationFunction.e_faceB:
            var normalx = _local_xfB.q.c * this.m_axis.x - _local_xfB.q.s * this.m_axis.y;
            var normaly = _local_xfB.q.s * this.m_axis.x + _local_xfB.q.c * this.m_axis.y;
            var pointBx = _local_xfB.q.c * this.m_localPoint.x - _local_xfB.q.s * this.m_localPoint.y + _local_xfB.p.x;
            var pointBy = _local_xfB.q.s * this.m_localPoint.x + _local_xfB.q.c * this.m_localPoint.y + _local_xfB.p.y;
            var localPointA = this.m_proxyA.GetVertex(indexA);
            var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
            var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
            var separation = (pointAx - pointBx) * normalx + (pointAy - pointBy) * normaly;
            return separation;

           default:
            b2Assert(false);
            return 0;
          }
        }
      };
      b2SeparationFunction.e_points = 0;
      b2SeparationFunction.e_faceA = 1;
      b2SeparationFunction.e_faceB = 2;
      var profile_toi = b2Profiler.create("toi", "solveTOI");
      function b2TimeOfImpact(output, input) {
        profile_toi.start();
        ++b2TimeOfImpact.b2_toiCalls;
        output.state = b2TOIOutput.e_unknown;
        output.t = input.tMax;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        b2TimeOfImpact._temp_sweepA.Assign(input.sweepA);
        b2TimeOfImpact._temp_sweepB.Assign(input.sweepB);
        b2TimeOfImpact._temp_sweepA.Normalize();
        b2TimeOfImpact._temp_sweepB.Normalize();
        var tMax = input.tMax;
        var totalRadius = proxyA.m_radius + proxyB.m_radius;
        var target = b2Max(b2_linearSlop, totalRadius - 3 * b2_linearSlop);
        var tolerance = .25 * b2_linearSlop;
        b2Assert(target > tolerance);
        var t1 = 0;
        var k_maxIterations = 20;
        var iter = 0;
        var cache = new b2SimplexCache();
        cache.count = 0;
        var distanceInput = new b2DistanceInput();
        distanceInput.proxyA.Assign(input.proxyA);
        distanceInput.proxyB.Assign(input.proxyB);
        distanceInput.useRadii = false;
        for (;;) {
          b2TimeOfImpact._temp_sweepA.GetTransform(distanceInput.transformA, t1);
          b2TimeOfImpact._temp_sweepB.GetTransform(distanceInput.transformB, t1);
          var distanceOutput = new b2DistanceOutput();
          b2DistanceFunc(distanceOutput, cache, distanceInput);
          if (distanceOutput.distance <= 0) {
            output.state = b2TOIOutput.e_overlapped;
            output.t = 0;
            break;
          }
          if (distanceOutput.distance < target + tolerance) {
            output.state = b2TOIOutput.e_touching;
            output.t = t1;
            break;
          }
          var fcn = new b2SeparationFunction();
          fcn.Initialize(cache, proxyA, b2TimeOfImpact._temp_sweepA, proxyB, b2TimeOfImpact._temp_sweepB, t1);
          var done = false;
          var t2 = tMax;
          var pushBackIter = 0;
          for (;;) {
            var indices = [];
            var s2 = fcn.FindMinSeparation(indices, t2);
            if (s2 > target + tolerance) {
              output.state = b2TOIOutput.e_separated;
              output.t = tMax;
              done = true;
              break;
            }
            if (s2 > target - tolerance) {
              t1 = t2;
              break;
            }
            var s1 = fcn.Evaluate(indices[0], indices[1], t1);
            if (s1 < target - tolerance) {
              output.state = b2TOIOutput.e_failed;
              output.t = t1;
              done = true;
              break;
            }
            if (s1 <= target + tolerance) {
              output.state = b2TOIOutput.e_touching;
              output.t = t1;
              done = true;
              break;
            }
            var rootIterCount = 0;
            var a1 = t1, a2 = t2;
            for (;;) {
              var t;
              t = 1 & rootIterCount ? a1 + (target - s1) * (a2 - a1) / (s2 - s1) : .5 * (a1 + a2);
              ++rootIterCount;
              ++b2TimeOfImpact.b2_toiRootIters;
              var s = fcn.Evaluate(indices[0], indices[1], t);
              if (b2Abs(s - target) < tolerance) {
                t2 = t;
                break;
              }
              if (s > target) {
                a1 = t;
                s1 = s;
              } else {
                a2 = t;
                s2 = s;
              }
              if (50 == rootIterCount) break;
            }
            b2TimeOfImpact.b2_toiMaxRootIters = b2Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
            ++pushBackIter;
            if (pushBackIter == b2_maxPolygonVertices) break;
          }
          ++iter;
          ++b2TimeOfImpact.b2_toiIters;
          if (done) break;
          if (iter == k_maxIterations) {
            output.state = b2TOIOutput.e_failed;
            output.t = t1;
            break;
          }
        }
        b2TimeOfImpact.b2_toiMaxIters = b2Max(b2TimeOfImpact.b2_toiMaxIters, iter);
        profile_toi.stop();
        b2TimeOfImpact.b2_toiMaxTime = b2Max(b2TimeOfImpact.b2_toiMaxTime, profile_toi.elapsedTime);
        b2TimeOfImpact.b2_toiTime += profile_toi.elapsedTime;
      }
      b2TimeOfImpact._temp_sweepA = new b2Sweep();
      b2TimeOfImpact._temp_sweepB = new b2Sweep();
      b2TimeOfImpact.b2_toiTime = 0;
      b2TimeOfImpact.b2_toiMaxTime = 0;
      b2TimeOfImpact.b2_toiCalls = 0;
      b2TimeOfImpact.b2_toiIters = 0;
      b2TimeOfImpact.b2_toiMaxIters = 0;
      b2TimeOfImpact.b2_toiRootIters = 0;
      b2TimeOfImpact.b2_toiMaxRootIters = 0;
      function b2BodyDef() {
        this.type = b2Body.b2_staticBody;
        this.position = new b2Vec2(0, 0);
        this.angle = 0;
        this.linearVelocity = new b2Vec2(0, 0);
        this.angularVelocity = 0;
        this.linearDamping = 0;
        this.angularDamping = 0;
        this.allowSleep = true;
        this.awake = true;
        this.fixedRotation = false;
        this.bullet = false;
        this.active = true;
        this.userData = null;
        this.gravityScale = 1;
        Object.seal(this);
      }
      b2BodyDef.prototype = {
        _deserialize: function(data) {
          this.type = data["type"];
          this.position._deserialize(data["position"]);
          this.angle = data["angle"];
          this.linearVelocity._deserialize(data["linearVelocity"]);
          this.angularVelocity = data["angularVelocity"];
          this.linearDamping = data["linearDamping"];
          this.angularDamping = data["angularDamping"];
          this.allowSleep = data["allowSleep"];
          this.awake = data["awake"];
          this.fixedRotation = data["fixedRotation"];
          this.bullet = data["bullet"];
          this.active = data["active"];
          this.gravityScale = data["gravityScale"];
        }
      };
      function b2Body(bd, world) {
        b2Assert(bd.position.IsValid());
        b2Assert(bd.linearVelocity.IsValid());
        b2Assert(b2IsValid(bd.angle));
        b2Assert(b2IsValid(bd.angularVelocity));
        b2Assert(b2IsValid(bd.angularDamping) && bd.angularDamping >= 0);
        b2Assert(b2IsValid(bd.linearDamping) && bd.linearDamping >= 0);
        this.m_islandIndex = 0;
        this.m_flags = 0;
        bd.bullet && (this.m_flags |= b2Body.e_bulletFlag);
        bd.fixedRotation && (this.m_flags |= b2Body.e_fixedRotationFlag);
        bd.allowSleep && (this.m_flags |= b2Body.e_autoSleepFlag);
        bd.awake && (this.m_flags |= b2Body.e_awakeFlag);
        bd.active && (this.m_flags |= b2Body.e_activeFlag);
        this.m_world = world;
        this.m_xf = new b2Transform();
        this.m_xf.p.Assign(bd.position);
        this.m_xf.q.Set(bd.angle);
        this.m_sweep = new b2Sweep();
        this.m_sweep.localCenter.SetZero();
        this.m_sweep.c0.Assign(this.m_xf.p);
        this.m_sweep.c.Assign(this.m_xf.p);
        this.m_sweep.a0 = bd.angle;
        this.m_sweep.a = bd.angle;
        this.m_sweep.alpha0 = 0;
        this.m_jointList = null;
        this.m_contactList = null;
        this.m_prev = null;
        this.m_next = null;
        this.m_linearVelocity = bd.linearVelocity.Clone();
        this.m_angularVelocity = bd.angularVelocity;
        this.m_linearDamping = bd.linearDamping;
        this.m_angularDamping = bd.angularDamping;
        this.m_gravityScale = bd.gravityScale;
        this.m_force = new b2Vec2();
        this.m_torque = 0;
        this.m_sleepTime = 0;
        this.m_type = bd.type;
        if (this.m_type == b2Body.b2_dynamicBody) {
          this.m_mass = 1;
          this.m_invMass = 1;
        } else {
          this.m_mass = 0;
          this.m_invMass = 0;
        }
        this.m_I = 0;
        this.m_invI = 0;
        this.m_userData = bd.userData;
        this.m_fixtureList = null;
        this.m_fixtureCount = 0;
      }
      b2Body.b2_staticBody = 0;
      b2Body.b2_kinematicBody = 1;
      b2Body.b2_dynamicBody = 2;
      b2Body.e_islandFlag = 1;
      b2Body.e_awakeFlag = 2;
      b2Body.e_autoSleepFlag = 4;
      b2Body.e_bulletFlag = 8;
      b2Body.e_fixedRotationFlag = 16;
      b2Body.e_activeFlag = 32;
      b2Body.e_toiFlag = 64;
      b2Body.m_local_oldCenter = new b2Vec2();
      b2Body.m_local_xf1 = new b2Transform();
      b2Body.prototype = {
        CreateFixture: function(def, density) {
          if ("undefined" !== typeof density) {
            var ndef = new b2FixtureDef();
            ndef.shape = def;
            ndef.density = density;
            return this.CreateFixture(ndef);
          }
          b2Assert(false == this.m_world.IsLocked());
          if (true == this.m_world.IsLocked()) return null;
          var fixture = new b2Fixture();
          fixture.Create(this, def);
          if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.CreateProxies(broadPhase, this.m_xf);
          }
          fixture.m_next = this.m_fixtureList;
          this.m_fixtureList = fixture;
          ++this.m_fixtureCount;
          fixture.m_body = this;
          fixture.m_density > 0 && this.ResetMassData();
          this.m_world.m_flags |= b2World.e_newFixture;
          return fixture;
        },
        DestroyFixture: function(fixture) {
          b2Assert(false == this.m_world.IsLocked());
          if (true == this.m_world.IsLocked()) return;
          b2Assert(fixture.m_body == this);
          b2Assert(this.m_fixtureCount > 0);
          var node = this.m_fixtureList;
          var found = false;
          while (null != node) {
            if (node == fixture) {
              this.m_fixtureList = node = fixture.m_next;
              found = true;
              break;
            }
            node = node.m_next;
          }
          b2Assert(found);
          var edge = this.m_contactList;
          while (edge) {
            var c = edge.contact;
            edge = edge.next;
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            fixture != fixtureA && fixture != fixtureB || this.m_world.m_contactManager.Destroy(c);
          }
          if (this.m_flags & b2Body.e_activeFlag) {
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            fixture.DestroyProxies(broadPhase);
          }
          fixture.Destroy();
          fixture.m_body = null;
          fixture.m_next = null;
          --this.m_fixtureCount;
          this.ResetMassData();
        },
        SetTransform: function(position, angle) {
          b2Assert(false == this.m_world.IsLocked());
          if (true == this.m_world.IsLocked()) return;
          this.m_xf.q.Set(angle);
          this.m_xf.p.Assign(position);
          this.m_sweep.c.Assign(b2Mul_t_v2(this.m_xf, this.m_sweep.localCenter));
          this.m_sweep.a = angle;
          this.m_sweep.c0.Assign(this.m_sweep.c);
          this.m_sweep.a0 = angle;
          var broadPhase = this.m_world.m_contactManager.m_broadPhase;
          for (var f = this.m_fixtureList; f; f = f.m_next) f.Synchronize(broadPhase, this.m_xf, this.m_xf);
        },
        GetTransform: function() {
          return this.m_xf;
        },
        GetPosition: function() {
          return this.m_xf.p;
        },
        GetAngle: function() {
          return this.m_sweep.a;
        },
        GetWorldCenter: function() {
          return this.m_sweep.c;
        },
        GetLocalCenter: function() {
          return this.m_sweep.localCenter;
        },
        SetLinearVelocity: function(v) {
          if (this.m_type == b2Body.b2_staticBody) return;
          b2Dot_v2_v2(v, v) > 0 && this.SetAwake(true);
          this.m_linearVelocity = v;
        },
        GetLinearVelocity: function() {
          return this.m_linearVelocity;
        },
        SetAngularVelocity: function(w) {
          if (this.m_type == b2Body.b2_staticBody) return;
          w * w > 0 && this.SetAwake(true);
          this.m_angularVelocity = w;
        },
        GetAngularVelocity: function() {
          return this.m_angularVelocity;
        },
        ApplyForce: function(force, point, wake) {
          if (this.m_type != b2Body.b2_dynamicBody) return;
          wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
          if (this.m_flags & b2Body.e_awakeFlag) {
            this.m_force.Add(force);
            this.m_torque += b2Cross_v2_v2(b2Vec2.Subtract(point, this.m_sweep.c), force);
          }
        },
        ApplyForceToCenter: function(force, wake) {
          if (this.m_type != b2Body.b2_dynamicBody) return;
          wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
          this.m_flags & b2Body.e_awakeFlag && this.m_force.Add(force);
        },
        ApplyTorque: function(torque, wake) {
          if (this.m_type != b2Body.b2_dynamicBody) return;
          wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
          this.m_flags & b2Body.e_awakeFlag && (this.m_torque += torque);
        },
        ApplyLinearImpulse: function(impulse, point, wake) {
          if (this.m_type != b2Body.b2_dynamicBody) return;
          wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
          if (this.m_flags & b2Body.e_awakeFlag) {
            this.m_linearVelocity.Add(b2Vec2.Multiply(this.m_invMass, impulse));
            this.m_angularVelocity += this.m_invI * b2Cross_v2_v2(b2Vec2.Subtract(point, this.m_sweep.c), impulse);
          }
        },
        ApplyAngularImpulse: function(impulse, wake) {
          if (this.m_type != b2Body.b2_dynamicBody) return;
          wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
          this.m_flags & b2Body.e_awakeFlag && (this.m_angularVelocity += this.m_invI * impulse);
        },
        GetMass: function() {
          return this.m_mass;
        },
        GetInertia: function() {
          return this.m_I + this.m_mass * b2Dot_v2_v2(this.m_sweep.localCenter, this.m_sweep.localCenter);
        },
        GetMassData: function(data) {
          data.mass = this.m_mass;
          data.I = this.m_I + this.m_mass * b2Dot_v2_v2(this.m_sweep.localCenter, this.m_sweep.localCenter);
          data.center = this.m_sweep.localCenter;
        },
        SetMassData: function(massData) {
          b2Assert(false == this.m_world.IsLocked());
          if (true == this.m_world.IsLocked()) return;
          if (this.m_type != b2Body.b2_dynamicBody) return;
          this.m_invMass = 0;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_mass = massData.mass;
          this.m_mass <= 0 && (this.m_mass = 1);
          this.m_invMass = 1 / this.m_mass;
          if (massData.I > 0 && 0 == (this.m_flags & b2Body.e_fixedRotationFlag)) {
            this.m_I = massData.I - this.m_mass * b2Dot_v2_v2(massData.center, massData.center);
            b2Assert(this.m_I > 0);
            this.m_invI = 1 / this.m_I;
          }
          b2Body.m_local_oldCenter.Assign(this.m_sweep.c);
          this.m_sweep.localCenter.Assign(massData.center);
          this.m_sweep.c0.Assign(b2Mul_t_v2(this.m_xf, this.m_sweep.localCenter));
          this.m_sweep.c.Assign(this.m_sweep.c0);
          this.m_linearVelocity.Add(b2Cross_f_v2(this.m_angularVelocity, b2Vec2.Subtract(this.m_sweep.c, b2Body.m_local_oldCenter)));
        },
        ResetMassData: function() {
          this.m_mass = 0;
          this.m_invMass = 0;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_sweep.localCenter.SetZero();
          if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
            this.m_sweep.c0.Assign(this.m_xf.p);
            this.m_sweep.c.Assign(this.m_xf.p);
            this.m_sweep.a0 = this.m_sweep.a;
            return;
          }
          b2Assert(this.m_type == b2Body.b2_dynamicBody);
          var localCenter = new b2Vec2(0, 0);
          for (var f = this.m_fixtureList; f; f = f.m_next) {
            if (0 == f.m_density) continue;
            var massData = new b2MassData();
            f.GetMassData(massData);
            this.m_mass += massData.mass;
            localCenter.Add(b2Vec2.Multiply(massData.mass, massData.center));
            this.m_I += massData.I;
          }
          if (this.m_mass > 0) {
            this.m_invMass = 1 / this.m_mass;
            localCenter.Multiply(this.m_invMass);
          } else {
            this.m_mass = 1;
            this.m_invMass = 1;
          }
          if (this.m_I > 0 && 0 == (this.m_flags & b2Body.e_fixedRotationFlag)) {
            this.m_I -= this.m_mass * b2Dot_v2_v2(localCenter, localCenter);
            b2Assert(this.m_I > 0);
            this.m_invI = 1 / this.m_I;
          } else {
            this.m_I = 0;
            this.m_invI = 0;
          }
          b2Body.m_local_oldCenter.Assign(this.m_sweep.c);
          this.m_sweep.localCenter.Assign(localCenter);
          this.m_sweep.c0.Assign(b2Mul_t_v2(this.m_xf, this.m_sweep.localCenter));
          this.m_sweep.c.Assign(this.m_sweep.c0);
          this.m_linearVelocity.Add(b2Cross_f_v2(this.m_angularVelocity, b2Vec2.Subtract(this.m_sweep.c, b2Body.m_local_oldCenter)));
        },
        GetWorldPoint: function(localPoint) {
          return b2Mul_t_v2(this.m_xf, localPoint);
        },
        GetWorldVector: function(localVector) {
          return b2Mul_r_v2(this.m_xf.q, localVector);
        },
        GetLocalPoint: function(worldPoint) {
          return b2MulT_t_v2(this.m_xf, worldPoint);
        },
        GetLocalVector: function(worldVector) {
          return b2MulT_r_v2(this.m_xf.q, worldVector);
        },
        GetLinearVelocityFromWorldPoint: function(worldPoint) {
          return b2Vec2.Add(this.m_linearVelocity, b2Cross_f_v2(this.m_angularVelocity, b2Vec2.Subtract(worldPoint, this.m_sweep.c)));
        },
        GetLinearVelocityFromLocalPoint: function(localPoint) {
          return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint));
        },
        GetLinearDamping: function() {
          return this.m_linearDamping;
        },
        SetLinearDamping: function(linearDamping) {
          this.m_linearDamping = linearDamping;
        },
        GetAngularDamping: function() {
          return this.m_angularDamping;
        },
        SetAngularDamping: function(angularDamping) {
          this.m_angularDamping = angularDamping;
        },
        GetGravityScale: function() {
          return this.m_gravityScale;
        },
        SetGravityScale: function(scale) {
          this.m_gravityScale = scale;
        },
        SetType: function(type) {
          b2Assert(false == this.m_world.IsLocked());
          if (true == this.m_world.IsLocked()) return;
          if (this.m_type == type) return;
          this.m_type = type;
          this.ResetMassData();
          if (this.m_type == b2Body.b2_staticBody) {
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0;
            this.m_sweep.a0 = this.m_sweep.a;
            this.m_sweep.c0.Assign(this.m_sweep.c);
            this.SynchronizeFixtures();
          }
          this.SetAwake(true);
          this.m_force.SetZero();
          this.m_torque = 0;
          var ce = this.m_contactList;
          while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
          }
          this.m_contactList = null;
          var broadPhase = this.m_world.m_contactManager.m_broadPhase;
          for (var f = this.m_fixtureList; f; f = f.m_next) {
            var proxyCount = f.m_proxyCount;
            for (var i = 0; i < proxyCount; ++i) broadPhase.TouchProxy(f.m_proxies[i].proxyId);
          }
        },
        GetType: function() {
          return this.m_type;
        },
        SetBullet: function(flag) {
          flag ? this.m_flags |= b2Body.e_bulletFlag : this.m_flags &= ~b2Body.e_bulletFlag;
        },
        IsBullet: function() {
          return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
        },
        SetSleepingAllowed: function(flag) {
          if (flag) this.m_flags |= b2Body.e_autoSleepFlag; else {
            this.m_flags &= ~b2Body.e_autoSleepFlag;
            this.SetAwake(true);
          }
        },
        IsSleepingAllowed: function() {
          return (this.m_flags & b2Body.e_autoSleepFlag) == b2Body.e_autoSleepFlag;
        },
        SetAwake: function(flag) {
          if (flag) {
            if (0 == (this.m_flags & b2Body.e_awakeFlag)) {
              this.m_flags |= b2Body.e_awakeFlag;
              this.m_sleepTime = 0;
            }
          } else {
            this.m_flags &= ~b2Body.e_awakeFlag;
            this.m_sleepTime = 0;
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0;
            this.m_force.SetZero();
            this.m_torque = 0;
          }
        },
        IsAwake: function() {
          return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
        },
        SetActive: function(flag) {
          b2Assert(false == this.m_world.IsLocked());
          if (flag == this.IsActive()) return;
          if (flag) {
            this.m_flags |= b2Body.e_activeFlag;
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (var f = this.m_fixtureList; f; f = f.m_next) f.CreateProxies(broadPhase, this.m_xf);
          } else {
            this.m_flags &= ~b2Body.e_activeFlag;
            var broadPhase = this.m_world.m_contactManager.m_broadPhase;
            for (var f = this.m_fixtureList; f; f = f.m_next) f.DestroyProxies(broadPhase);
            var ce = this.m_contactList;
            while (ce) {
              var ce0 = ce;
              ce = ce.next;
              this.m_world.m_contactManager.Destroy(ce0.contact);
            }
            this.m_contactList = null;
          }
        },
        IsActive: function() {
          return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
        },
        SetFixedRotation: function(flag) {
          var status = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
          if (status == flag) return;
          flag ? this.m_flags |= b2Body.e_fixedRotationFlag : this.m_flags &= ~b2Body.e_fixedRotationFlag;
          this.m_angularVelocity = 0;
          this.ResetMassData();
        },
        IsFixedRotation: function() {
          return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
        },
        GetFixtureList: function() {
          return this.m_fixtureList;
        },
        GetJointList: function() {
          return this.m_jointList;
        },
        GetContactList: function() {
          return this.m_contactList;
        },
        GetNext: function() {
          return this.m_next;
        },
        GetUserData: function() {
          return this.m_userData;
        },
        SetUserData: function(data) {
          this.m_userData = data;
        },
        GetWorld: function() {
          return this.m_world;
        },
        SynchronizeFixtures: function() {
          b2Body.m_local_xf1.q.Set(this.m_sweep.a0);
          b2Body.m_local_xf1.p.Assign(b2Vec2.Subtract(this.m_sweep.c0, b2Mul_r_v2(b2Body.m_local_xf1.q, this.m_sweep.localCenter)));
          var broadPhase = this.m_world.m_contactManager.m_broadPhase;
          for (var f = this.m_fixtureList; f; f = f.m_next) f.Synchronize(broadPhase, b2Body.m_local_xf1, this.m_xf);
        },
        SynchronizeTransform: function() {
          this.m_xf.q.Set(this.m_sweep.a);
          this.m_xf.p.Assign(b2Vec2.Subtract(this.m_sweep.c, b2Mul_r_v2(this.m_xf.q, this.m_sweep.localCenter)));
        },
        ShouldCollide: function(other) {
          if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) return false;
          for (var jn = this.m_jointList; jn; jn = jn.next) if (jn.other == other && false == jn.joint.m_collideConnected) return false;
          return true;
        },
        Advance: function(alpha) {
          this.m_sweep.Advance(alpha);
          this.m_sweep.c.Assign(this.m_sweep.c0);
          this.m_sweep.a = this.m_sweep.a0;
          this.m_xf.q.Set(this.m_sweep.a);
          this.m_xf.p.Assign(b2Vec2.Subtract(this.m_sweep.c, b2Mul_r_v2(this.m_xf.q, this.m_sweep.localCenter)));
        },
        _serialize: function(out) {
          var obj = out || {};
          obj["fixtures"] = null;
          obj["type"] = this.m_type;
          obj["position"] = this.GetPosition()._serialize();
          obj["angle"] = this.GetAngle();
          obj["linearVelocity"] = this.GetLinearVelocity()._serialize();
          obj["angularVelocity"] = this.GetAngularVelocity();
          obj["linearDamping"] = this.GetLinearDamping();
          obj["angularDamping"] = this.GetAngularDamping();
          obj["allowSleep"] = this.IsSleepingAllowed();
          obj["awake"] = this.IsAwake();
          obj["fixedRotation"] = this.IsFixedRotation();
          obj["bullet"] = this.IsBullet();
          obj["active"] = this.IsActive();
          obj["gravityScale"] = this.GetGravityScale();
          return obj;
        }
      };
      function b2Filter() {
        this.categoryBits = 1;
        this.maskBits = 65535;
        this.groupIndex = 0;
      }
      b2Filter.prototype = {
        Clone: function() {
          var filter = new b2Filter();
          filter.categoryBits = this.categoryBits;
          filter.maskBits = this.maskBits;
          filter.groupIndex = this.groupIndex;
          return filter;
        },
        Assign: function(filter) {
          this.categoryBits = filter.categoryBits;
          this.maskBits = filter.maskBits;
          this.groupIndex = filter.groupIndex;
        },
        _serialize: function(out) {
          var obj = out || {};
          obj["categoryBits"] = this.categoryBits;
          obj["maskBits"] = this.maskBits;
          obj["groupIndex"] = this.groupIndex;
          return obj;
        },
        _deserialize: function(data) {
          this.categoryBits = data["categoryBits"];
          this.maskBits = data["maskBits"];
          this.groupIndex = data["groupIndex"];
        }
      };
      function b2FixtureDef() {
        this.shape = null;
        this.userData = null;
        this.friction = .2;
        this.restitution = 0;
        this.density = 0;
        this.isSensor = false;
        this.filter = new b2Filter();
        Object.seal(this);
      }
      b2FixtureDef.prototype = {
        _deserialize: function(data) {
          this.friction = data["friction"];
          this.restitution = data["restitution"];
          this.density = data["density"];
          this.isSensor = data["isSensor"];
          this.filter._deserialize(data["filter"]);
        }
      };
      function b2FixtureProxy() {
        this.aabb = new b2AABB();
        this.fixture = null;
        this.childIndex = 0;
        this.proxyId = 0;
      }
      function b2Fixture() {
        this.m_userData = null;
        this.m_body = null;
        this.m_next = null;
        this.m_proxies = null;
        this.m_proxyCount = 0;
        this.m_shape = null;
        this.m_density = 0;
        this.m_filter = new b2Filter();
        this.m_isSensor = false;
        this.m_friction = 0;
        this.m_restitution = 0;
      }
      b2Fixture.prototype = {
        GetType: function() {
          return this.m_shape.GetType();
        },
        GetShape: function() {
          return this.m_shape;
        },
        SetSensor: function(sensor) {
          if (sensor != this.m_isSensor) {
            this.m_body.SetAwake(true);
            this.m_isSensor = sensor;
          }
        },
        IsSensor: function() {
          return this.m_isSensor;
        },
        SetFilterData: function(filter) {
          this.m_filter = filter;
          this.Refilter();
        },
        GetFilterData: function() {
          return this.m_filter;
        },
        Refilter: function() {
          if (null == this.m_body) return;
          var edge = this.m_body.GetContactList();
          while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            fixtureA != this && fixtureB != this || contact.FlagForFiltering();
            edge = edge.next;
          }
          var world = this.m_body.GetWorld();
          if (null == world) return;
          var broadPhase = world.m_contactManager.m_broadPhase;
          for (var i = 0; i < this.m_proxyCount; ++i) broadPhase.TouchProxy(this.m_proxies[i].proxyId);
        },
        GetBody: function() {
          return this.m_body;
        },
        GetNext: function() {
          return this.m_next;
        },
        GetUserData: function() {
          return this.m_userData;
        },
        SetUserData: function(data) {
          this.m_userData = data;
        },
        TestPoint: function(p) {
          return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
        },
        RayCast: function(output, input, childIndex) {
          return this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);
        },
        GetMassData: function(massData) {
          this.m_shape.ComputeMass(massData, this.m_density);
        },
        SetDensity: function(density) {
          b2Assert(b2IsValid(density) && density >= 0);
          this.m_density = density;
        },
        GetDensity: function() {
          return this.m_density;
        },
        GetFriction: function() {
          return this.m_friction;
        },
        SetFriction: function(friction) {
          this.m_friction = friction;
        },
        GetRestitution: function() {
          return this.m_restitution;
        },
        SetRestitution: function(restitution) {
          this.m_restitution = restitution;
        },
        GetAABB: function(childIndex) {
          b2Assert(0 <= childIndex && childIndex < this.m_proxyCount);
          return this.m_proxies[childIndex].aabb;
        },
        Create: function(body, def) {
          this.m_userData = def.userData;
          this.m_friction = def.friction;
          this.m_restitution = def.restitution;
          this.m_body = body;
          this.m_next = null;
          this.m_filter.Assign(def.filter);
          this.m_isSensor = def.isSensor;
          this.m_shape = def.shape.Clone();
          var childCount = this.m_shape.GetChildCount();
          this.m_proxies = new Array(childCount);
          for (var i = 0; i < childCount; ++i) {
            this.m_proxies[i] = new b2FixtureProxy();
            this.m_proxies[i].fixture = null;
            this.m_proxies[i].proxyId = b2BroadPhase.e_nullProxy;
          }
          this.m_proxyCount = 0;
          this.m_density = def.density;
        },
        Destroy: function() {
          b2Assert(0 == this.m_proxyCount);
          this.m_proxies = null;
          this.m_shape = null;
        },
        CreateProxies: function(broadPhase, xf) {
          b2Assert(0 == this.m_proxyCount);
          this.m_proxyCount = this.m_shape.GetChildCount();
          for (var i = 0; i < this.m_proxyCount; ++i) {
            var proxy = this.m_proxies[i];
            this.m_shape.ComputeAABB(proxy.aabb, xf, i);
            proxy.proxyId = broadPhase.CreateProxy(proxy.aabb, proxy);
            proxy.fixture = this;
            proxy.childIndex = i;
          }
        },
        DestroyProxies: function(broadPhase) {
          for (var i = 0; i < this.m_proxyCount; ++i) {
            var proxy = this.m_proxies[i];
            broadPhase.DestroyProxy(proxy.proxyId);
            proxy.proxyId = b2BroadPhase.e_nullProxy;
          }
          this.m_proxyCount = 0;
        },
        Synchronize: function(broadPhase, transform1, transform2) {
          if (0 == this.m_proxyCount) return;
          for (var i = 0; i < this.m_proxyCount; ++i) {
            var proxy = this.m_proxies[i];
            var aabb1 = new b2AABB(), aabb2 = new b2AABB();
            this.m_shape.ComputeAABB(aabb1, transform1, proxy.childIndex);
            this.m_shape.ComputeAABB(aabb2, transform2, proxy.childIndex);
            proxy.aabb.Combine(aabb1, aabb2);
            var displacement = b2Vec2.Subtract(transform2.p, transform1.p);
            broadPhase.MoveProxy(proxy.proxyId, proxy.aabb, displacement);
          }
        },
        _serialize: function(out) {
          var obj = out || {};
          obj["shape"] = null;
          obj["friction"] = this.m_friction;
          obj["restitution"] = this.m_restitution;
          obj["density"] = this.m_density;
          obj["isSensor"] = this.m_isSensor;
          obj["filter"] = this.m_filter._serialize();
          return obj;
        }
      };
      function b2DestructionListener() {}
      b2DestructionListener.prototype = {
        SayGoodbyeJoint: function(joint) {},
        SayGoodbyeFixture: function(fixture) {}
      };
      function b2ContactFilter() {}
      b2ContactFilter.prototype = {
        ShouldCollide: function(fixtureA, fixtureB) {
          var filterA = fixtureA.GetFilterData();
          var filterB = fixtureB.GetFilterData();
          if (filterA.groupIndex == filterB.groupIndex && 0 != filterA.groupIndex) return filterA.groupIndex > 0;
          var collide = 0 != (filterA.maskBits & filterB.categoryBits) && 0 != (filterA.categoryBits & filterB.maskBits);
          return collide;
        }
      };
      function b2ContactImpulse() {
        this.normalImpulses = new Array(b2_maxManifoldPoints);
        this.tangentImpulses = new Array(b2_maxManifoldPoints);
        this.count = 0;
      }
      function b2ContactListener() {}
      b2ContactListener.prototype = {
        BeginContact: function(contact) {},
        EndContact: function(contact) {},
        PreSolve: function(contact, oldManifold) {},
        PostSolve: function(contact, impulse) {}
      };
      function b2QueryCallback() {}
      b2QueryCallback.prototype = {
        ReportFixture: function(fixture) {
          return false;
        }
      };
      function b2RayCastCallback() {}
      b2RayCastCallback.prototype = {
        ReportFixture: function(fixture, point, normal, fraction) {}
      };
      function b2TimeStep() {
        this.dt = 0;
        this.inv_dt = 0;
        this.dtRatio = 0;
        this.velocityIterations = 0;
        this.positionIterations = 0;
        this.warmStarting = false;
      }
      function b2Position() {
        this.c = new b2Vec2();
        this.a = 0;
      }
      function b2Velocity() {
        this.v = new b2Vec2();
        this.w = 0;
      }
      function b2SolverData() {
        this.step = new b2TimeStep();
        this.positions = null;
        this.velocities = null;
      }
      var profile_world_step = b2Profiler.create("step");
      var profile_world_collide = b2Profiler.create("collide", "step");
      var profile_world_solve = b2Profiler.create("solve", "step");
      var profile_world_solveTOI = b2Profiler.create("solveTOI", "step");
      var profile_world_broadphase = b2Profiler.create("broadphase", "step");
      function b2World(gravity) {
        this.m_contactManager = new b2ContactManager();
        this.m_destructionListener = null;
        this.g_debugDraw = null;
        this.m_bodyList = null;
        this.m_jointList = null;
        this.m_bodyCount = 0;
        this.m_jointCount = 0;
        this.m_warmStarting = true;
        this.m_continuousPhysics = true;
        this.m_subStepping = false;
        this.m_stepComplete = true;
        this.m_allowSleep = true;
        this.m_gravity = gravity;
        this.m_flags = b2World.e_clearForces;
        this.m_inv_dt0 = 0;
        this.p_step = new b2TimeStep();
        this.p_island = new b2Island();
      }
      function b2WorldQueryWrapper() {
        this.broadPhase = null;
        this.callback = null;
      }
      b2WorldQueryWrapper.prototype = {
        QueryCallback: function(proxyId) {
          var proxy = this.broadPhase.GetUserData(proxyId);
          return this.callback.ReportFixture(proxy.fixture);
        }
      };
      function b2WorldRayCastWrapper() {
        this.broadPhase = null;
        this.callback = null;
      }
      b2WorldRayCastWrapper.prototype = {
        RayCastCallback: function(input, proxyId) {
          var userData = this.broadPhase.GetUserData(proxyId);
          var proxy = userData;
          var fixture = proxy.fixture;
          var index = proxy.childIndex;
          var output = new b2RayCastOutput();
          var hit = fixture.RayCast(output, input, index);
          if (hit) {
            var fraction = output.fraction;
            var point = b2Vec2.Add(b2Vec2.Multiply(1 - fraction, input.p1), b2Vec2.Multiply(fraction, input.p2));
            return this.callback.ReportFixture(fixture, point, output.normal, fraction);
          }
          return input.maxFraction;
        }
      };
      b2World.m_local_sweep_backupA = new b2Sweep();
      b2World.m_local_sweep_backupB = new b2Sweep();
      b2World.m_local_sweep_backupC = new b2Sweep();
      b2World.prototype = {
        Destroy: function() {
          var b = this.m_bodyList;
          while (b) {
            var bNext = b.m_next;
            var f = b.m_fixtureList;
            while (f) {
              var fNext = f.m_next;
              f.m_proxyCount = 0;
              f.Destroy();
              f = fNext;
            }
            b = bNext;
          }
        },
        SetDestructionListener: function(listener) {
          this.m_destructionListener = listener;
        },
        SetContactFilter: function(filter) {
          this.m_contactManager.m_contactFilter = filter;
        },
        SetContactListener: function(listener) {
          this.m_contactManager.m_contactListener = listener;
        },
        SetDebugDraw: function(debugDraw) {
          this.g_debugDraw = debugDraw;
        },
        CreateBody: function(def) {
          b2Assert(false == this.IsLocked());
          if (this.IsLocked()) return null;
          var b = new b2Body(def, this);
          b.m_prev = null;
          b.m_next = this.m_bodyList;
          this.m_bodyList && (this.m_bodyList.m_prev = b);
          this.m_bodyList = b;
          ++this.m_bodyCount;
          return b;
        },
        DestroyBody: function(b) {
          b2Assert(this.m_bodyCount > 0);
          b2Assert(false == this.IsLocked());
          if (this.IsLocked()) return;
          var je = b.m_jointList;
          while (je) {
            var je0 = je;
            je = je.next;
            this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(je0.joint);
            this.DestroyJoint(je0.joint);
            b.m_jointList = je;
          }
          b.m_jointList = null;
          var ce = b.m_contactList;
          while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_contactManager.Destroy(ce0.contact);
          }
          b.m_contactList = null;
          var f = b.m_fixtureList;
          while (f) {
            var f0 = f;
            f = f.m_next;
            this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(f0);
            f0.DestroyProxies(this.m_contactManager.m_broadPhase);
            f0.Destroy();
            b.m_fixtureList = f;
            b.m_fixtureCount -= 1;
          }
          b.m_fixtureList = null;
          b.m_fixtureCount = 0;
          b.m_prev && (b.m_prev.m_next = b.m_next);
          b.m_next && (b.m_next.m_prev = b.m_prev);
          b == this.m_bodyList && (this.m_bodyList = b.m_next);
          b.m_destroyed = true;
          --this.m_bodyCount;
        },
        CreateJoint: function(def) {
          b2Assert(false == this.IsLocked());
          if (this.IsLocked()) return null;
          var j = b2Joint.Create(def);
          j.m_prev = null;
          j.m_next = this.m_jointList;
          this.m_jointList && (this.m_jointList.m_prev = j);
          this.m_jointList = j;
          ++this.m_jointCount;
          j.m_edgeA.joint = j;
          j.m_edgeA.other = j.m_bodyB;
          j.m_edgeA.prev = null;
          j.m_edgeA.next = j.m_bodyA.m_jointList;
          j.m_bodyA.m_jointList && (j.m_bodyA.m_jointList.prev = j.m_edgeA);
          j.m_bodyA.m_jointList = j.m_edgeA;
          j.m_edgeB.joint = j;
          j.m_edgeB.other = j.m_bodyA;
          j.m_edgeB.prev = null;
          j.m_edgeB.next = j.m_bodyB.m_jointList;
          j.m_bodyB.m_jointList && (j.m_bodyB.m_jointList.prev = j.m_edgeB);
          j.m_bodyB.m_jointList = j.m_edgeB;
          var bodyA = def.bodyA;
          var bodyB = def.bodyB;
          if (false == def.collideConnected) {
            var edge = bodyB.GetContactList();
            while (edge) {
              edge.other == bodyA && edge.contact.FlagForFiltering();
              edge = edge.next;
            }
          }
          return j;
        },
        DestroyJoint: function(j) {
          b2Assert(false == this.IsLocked());
          if (this.IsLocked()) return;
          var collideConnected = j.m_collideConnected;
          j.m_prev && (j.m_prev.m_next = j.m_next);
          j.m_next && (j.m_next.m_prev = j.m_prev);
          j == this.m_jointList && (this.m_jointList = j.m_next);
          var bodyA = j.m_bodyA;
          var bodyB = j.m_bodyB;
          bodyA.SetAwake(true);
          bodyB.SetAwake(true);
          j.m_edgeA.prev && (j.m_edgeA.prev.next = j.m_edgeA.next);
          j.m_edgeA.next && (j.m_edgeA.next.prev = j.m_edgeA.prev);
          j.m_edgeA == bodyA.m_jointList && (bodyA.m_jointList = j.m_edgeA.next);
          j.m_edgeA.prev = null;
          j.m_edgeA.next = null;
          j.m_edgeB.prev && (j.m_edgeB.prev.next = j.m_edgeB.next);
          j.m_edgeB.next && (j.m_edgeB.next.prev = j.m_edgeB.prev);
          j.m_edgeB == bodyB.m_jointList && (bodyB.m_jointList = j.m_edgeB.next);
          j.m_edgeB.prev = null;
          j.m_edgeB.next = null;
          b2Joint.Destroy(j);
          b2Assert(this.m_jointCount > 0);
          --this.m_jointCount;
          if (false == collideConnected) {
            var edge = bodyB.GetContactList();
            while (edge) {
              edge.other == bodyA && edge.contact.FlagForFiltering();
              edge = edge.next;
            }
          }
        },
        Step: function(dt, velocityIterations, positionIterations) {
          profile_world_step.start();
          if (this.m_flags & b2World.e_newFixture) {
            this.m_contactManager.FindNewContacts();
            this.m_flags &= ~b2World.e_newFixture;
          }
          this.m_flags |= b2World.e_locked;
          this.p_step.dt = dt;
          this.p_step.velocityIterations = velocityIterations;
          this.p_step.positionIterations = positionIterations;
          this.p_step.inv_dt = dt > 0 ? 1 / dt : 0;
          this.p_step.dtRatio = this.m_inv_dt0 * dt;
          this.p_step.warmStarting = this.m_warmStarting;
          profile_world_collide.start();
          this.m_contactManager.Collide();
          profile_world_collide.stop();
          if (this.m_stepComplete && this.p_step.dt > 0) {
            profile_world_solve.start();
            this.Solve(this.p_step);
            profile_world_solve.stop();
          }
          if (this.m_continuousPhysics && this.p_step.dt > 0) {
            profile_world_solveTOI.start();
            this.SolveTOI(this.p_step);
            profile_world_solveTOI.stop();
          }
          this.p_step.dt > 0 && (this.m_inv_dt0 = this.p_step.inv_dt);
          this.m_flags & b2World.e_clearForces && this.ClearForces();
          this.m_flags &= ~b2World.e_locked;
          profile_world_step.stop();
        },
        ClearForces: function() {
          for (var body = this.m_bodyList; body; body = body.GetNext()) {
            body.m_force.x = body.m_force.y = 0;
            body.m_torque = 0;
          }
        },
        DrawDebugData: function() {
          if (null == this.g_debugDraw) return;
          this.g_debugDraw.ClearDraw();
          var flags = this.g_debugDraw.GetFlags();
          if (flags & b2Draw.e_shapeBit) for (var b = this.m_bodyList; b; b = b.GetNext()) {
            var xf = b.GetTransform();
            for (var f = b.GetFixtureList(); f; f = f.GetNext()) false == b.IsActive() ? this.DrawShape(f, xf, new b2Color(.5, .5, .3)) : b.GetType() == b2Body.b2_staticBody ? this.DrawShape(f, xf, new b2Color(.5, .9, .5)) : b.GetType() == b2Body.b2_kinematicBody ? this.DrawShape(f, xf, new b2Color(.5, .5, .9)) : false == b.IsAwake() ? this.DrawShape(f, xf, new b2Color(.6, .6, .6)) : this.DrawShape(f, xf, new b2Color(.9, .7, .7));
          }
          if (flags & b2Draw.e_jointBit) for (var j = this.m_jointList; j; j = j.GetNext()) this.DrawJoint(j);
          if (flags & b2Draw.e_pairBit) {
            var color = new b2Color(.3, .9, .9);
            for (var c = this.m_contactManager.m_contactList; c; c = c.GetNext()) {
              var fixtureA = c.GetFixtureA();
              var fixtureB = c.GetFixtureB();
              var cA = fixtureA.GetAABB(c.GetChildIndexA()).GetCenter();
              var cB = fixtureB.GetAABB(c.GetChildIndexB()).GetCenter();
              this.g_debugDraw.DrawSegment(cA, cB, color);
            }
          }
          if (flags & b2Draw.e_aabbBit) {
            var color = new b2Color(.9, .3, .9);
            var color2 = new b2Color(.3, .3, .9);
            var bp = this.m_contactManager.m_broadPhase;
            for (var b = this.m_bodyList; b; b = b.GetNext()) {
              if (false == b.IsActive()) continue;
              for (var f = b.GetFixtureList(); f; f = f.GetNext()) for (var i = 0; i < f.m_proxyCount; ++i) {
                var proxy = f.m_proxies[i];
                var aabb = bp.GetFatAABB(proxy.proxyId);
                var vs = [];
                vs[0] = new b2Vec2(aabb.lowerBound.x, aabb.lowerBound.y);
                vs[1] = new b2Vec2(aabb.upperBound.x, aabb.lowerBound.y);
                vs[2] = new b2Vec2(aabb.upperBound.x, aabb.upperBound.y);
                vs[3] = new b2Vec2(aabb.lowerBound.x, aabb.upperBound.y);
                this.g_debugDraw.DrawPolygon(vs, 4, color);
                var realAABB = new b2AABB();
                f.GetShape().ComputeAABB(realAABB, b.GetTransform(), 0);
                var vs = [];
                vs[0] = new b2Vec2(realAABB.lowerBound.x, realAABB.lowerBound.y);
                vs[1] = new b2Vec2(realAABB.upperBound.x, realAABB.lowerBound.y);
                vs[2] = new b2Vec2(realAABB.upperBound.x, realAABB.upperBound.y);
                vs[3] = new b2Vec2(realAABB.lowerBound.x, realAABB.upperBound.y);
                this.g_debugDraw.DrawPolygon(vs, 4, color2);
              }
            }
          }
          if (flags & b2Draw.e_centerOfMassBit) for (var b = this.m_bodyList; b; b = b.GetNext()) {
            var xf = b.GetTransform().Clone();
            xf.p = b.GetWorldCenter();
            this.g_debugDraw.DrawTransform(xf);
          }
        },
        QueryAABB: function(callback, aabb) {
          var wrapper = new b2WorldQueryWrapper();
          wrapper.broadPhase = this.m_contactManager.m_broadPhase;
          wrapper.callback = callback;
          this.m_contactManager.m_broadPhase.Query(wrapper, aabb);
        },
        RayCast: function(callback, point1, point2) {
          var wrapper = new b2WorldRayCastWrapper();
          wrapper.broadPhase = this.m_contactManager.m_broadPhase;
          wrapper.callback = callback;
          var input = new b2RayCastInput();
          input.maxFraction = 1;
          input.p1 = point1;
          input.p2 = point2;
          this.m_contactManager.m_broadPhase.RayCast(wrapper, input);
        },
        GetBodyList: function() {
          return this.m_bodyList;
        },
        GetJointList: function() {
          return this.m_jointList;
        },
        GetContactList: function() {
          return this.m_contactManager.m_contactList;
        },
        SetAllowSleeping: function(flag) {
          if (flag == this.m_allowSleep) return;
          this.m_allowSleep = flag;
          if (false == this.m_allowSleep) for (var b = this.m_bodyList; b; b = b.m_next) b.SetAwake(true);
        },
        GetAllowSleeping: function() {
          return this.m_allowSleep;
        },
        SetWarmStarting: function(flag) {
          this.m_warmStarting = flag;
        },
        GetWarmStarting: function() {
          return this.m_warmStarting;
        },
        SetContinuousPhysics: function(flag) {
          this.m_continuousPhysics = flag;
        },
        GetContinuousPhysics: function() {
          return this.m_continuousPhysics;
        },
        SetSubStepping: function(flag) {
          this.m_subStepping = flag;
        },
        GetSubStepping: function() {
          return this.m_subStepping;
        },
        GetProxyCount: function() {
          return this.m_contactManager.m_broadPhase.GetProxyCount();
        },
        GetBodyCount: function() {
          return this.m_bodyCount;
        },
        GetJointCount: function() {
          return this.m_jointCount;
        },
        GetContactCount: function() {
          return this.m_contactManager.m_contactCount;
        },
        GetTreeHeight: function() {
          return this.m_contactManager.m_broadPhase.GetTreeHeight();
        },
        GetTreeBalance: function() {
          return this.m_contactManager.m_broadPhase.GetTreeBalance();
        },
        GetTreeQuality: function() {
          return this.m_contactManager.m_broadPhase.GetTreeQuality();
        },
        SetGravity: function(gravity) {
          this.m_gravity = gravity;
        },
        GetGravity: function() {
          return this.m_gravity;
        },
        IsLocked: function() {
          return (this.m_flags & b2World.e_locked) == b2World.e_locked;
        },
        SetAutoClearForces: function(flag) {
          flag ? this.m_flags |= b2World.e_clearForces : this.m_flags &= ~b2World.e_clearForces;
        },
        GetAutoClearForces: function() {
          return (this.m_flags & b2World.e_clearForces) == b2World.e_clearForces;
        },
        ShiftOrigin: function(newOrigin) {
          b2Assert(0 == (this.m_flags & b2World.e_locked));
          if ((this.m_flags & b2World.e_locked) == b2World.e_locked) return;
          for (var b = this.m_bodyList; b; b = b.m_next) {
            b.m_xf.p.Subtract(newOrigin);
            b.m_sweep.c0.Subtract(newOrigin);
            b.m_sweep.c.Subtract(newOrigin);
          }
          for (var j = this.m_jointList; j; j = j.m_next) j.ShiftOrigin(newOrigin);
          this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);
        },
        GetContactManager: function() {
          return this.m_contactManager;
        },
        Solve: function(step) {
          this.p_island.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, this.m_contactManager.m_contactListener);
          for (var b = this.m_bodyList; b; b = b.m_next) b.m_flags &= ~b2Body.e_islandFlag;
          for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) c.m_flags &= ~b2Contact.e_islandFlag;
          for (var j = this.m_jointList; j; j = j.m_next) j.m_islandFlag = false;
          var stackSize = this.m_bodyCount;
          var stack = new Array(stackSize);
          for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
            if (seed.m_flags & b2Body.e_islandFlag) continue;
            if (false == seed.IsAwake() || false == seed.IsActive()) continue;
            if (seed.GetType() == b2Body.b2_staticBody) continue;
            this.p_island.Clear();
            var stackCount = 0;
            stack[stackCount++] = seed;
            seed.m_flags |= b2Body.e_islandFlag;
            while (stackCount > 0) {
              var b = stack[--stackCount];
              b2Assert(true == b.IsActive());
              this.p_island.AddBody(b);
              b.SetAwake(true);
              if (b.GetType() == b2Body.b2_staticBody) continue;
              for (var ce = b.m_contactList; ce; ce = ce.next) {
                var contact = ce.contact;
                if (contact.m_flags & b2Contact.e_islandFlag) continue;
                if (false == contact.IsEnabled() || false == contact.IsTouching()) continue;
                var sensorA = contact.m_fixtureA.m_isSensor;
                var sensorB = contact.m_fixtureB.m_isSensor;
                if (sensorA || sensorB) continue;
                this.p_island.AddContact(contact);
                contact.m_flags |= b2Contact.e_islandFlag;
                var other = ce.other;
                if (other.m_flags & b2Body.e_islandFlag) continue;
                b2Assert(stackCount < stackSize);
                stack[stackCount++] = other;
                other.m_flags |= b2Body.e_islandFlag;
              }
              for (var je = b.m_jointList; je; je = je.next) {
                if (true == je.joint.m_islandFlag) continue;
                var other = je.other;
                if (false == other.IsActive()) continue;
                this.p_island.AddJoint(je.joint);
                je.joint.m_islandFlag = true;
                if (other.m_flags & b2Body.e_islandFlag) continue;
                b2Assert(stackCount < stackSize);
                stack[stackCount++] = other;
                other.m_flags |= b2Body.e_islandFlag;
              }
            }
            this.p_island.Solve(step, this.m_gravity, this.m_allowSleep);
            for (var i = 0; i < this.p_island.m_bodyCount; ++i) {
              var b = this.p_island.m_bodies[i];
              b.GetType() == b2Body.b2_staticBody && (b.m_flags &= ~b2Body.e_islandFlag);
            }
          }
          profile_world_broadphase.start();
          for (var b = this.m_bodyList; b; b = b.GetNext()) {
            if (0 == (b.m_flags & b2Body.e_islandFlag)) continue;
            if (b.GetType() == b2Body.b2_staticBody) continue;
            b.SynchronizeFixtures();
          }
          this.m_contactManager.FindNewContacts();
          profile_world_broadphase.stop();
        },
        SolveTOI: function(step) {
          this.p_island.Initialize(2 * b2_maxTOIContacts, b2_maxTOIContacts, 0, this.m_contactManager.m_contactListener);
          if (this.m_stepComplete) {
            for (var b = this.m_bodyList; b; b = b.m_next) {
              b.m_flags &= ~b2Body.e_islandFlag;
              b.m_sweep.alpha0 = 0;
            }
            for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {
              c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
              c.m_toiCount = 0;
              c.m_toi = 1;
            }
          }
          for (;;) {
            var minContact = null;
            var minAlpha = 1;
            for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {
              if (false == c.IsEnabled()) continue;
              if (c.m_toiCount > b2_maxSubSteps) continue;
              var alpha = 1;
              if (c.m_flags & b2Contact.e_toiFlag) alpha = c.m_toi; else {
                var fA = c.GetFixtureA();
                var fB = c.GetFixtureB();
                if (fA.IsSensor() || fB.IsSensor()) continue;
                var bA = fA.GetBody();
                var bB = fB.GetBody();
                var typeA = bA.m_type;
                var typeB = bB.m_type;
                b2Assert(typeA == b2Body.b2_dynamicBody || typeB == b2Body.b2_dynamicBody);
                var activeA = bA.IsAwake() && typeA != b2Body.b2_staticBody;
                var activeB = bB.IsAwake() && typeB != b2Body.b2_staticBody;
                if (false == activeA && false == activeB) continue;
                var collideA = bA.IsBullet() || typeA != b2Body.b2_dynamicBody;
                var collideB = bB.IsBullet() || typeB != b2Body.b2_dynamicBody;
                if (false == collideA && false == collideB) continue;
                var alpha0 = bA.m_sweep.alpha0;
                if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                  alpha0 = bB.m_sweep.alpha0;
                  bA.m_sweep.Advance(alpha0);
                } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                  alpha0 = bA.m_sweep.alpha0;
                  bB.m_sweep.Advance(alpha0);
                }
                b2Assert(alpha0 < 1);
                var indexA = c.GetChildIndexA();
                var indexB = c.GetChildIndexB();
                var input = new b2TOIInput();
                input.proxyA.Set(fA.GetShape(), indexA);
                input.proxyB.Set(fB.GetShape(), indexB);
                input.sweepA.Assign(bA.m_sweep);
                input.sweepB.Assign(bB.m_sweep);
                input.tMax = 1;
                var output = new b2TOIOutput();
                b2TimeOfImpact(output, input);
                var beta = output.t;
                alpha = output.state == b2TOIOutput.e_touching ? b2Min(alpha0 + (1 - alpha0) * beta, 1) : 1;
                c.m_toi = alpha;
                c.m_flags |= b2Contact.e_toiFlag;
              }
              if (alpha < minAlpha) {
                minContact = c;
                minAlpha = alpha;
              }
            }
            if (null == minContact || 1 - 10 * b2_epsilon < minAlpha) {
              this.m_stepComplete = true;
              break;
            }
            var fA = minContact.GetFixtureA();
            var fB = minContact.GetFixtureB();
            var bA = fA.GetBody();
            var bB = fB.GetBody();
            b2World.m_local_sweep_backupA.Assign(bA.m_sweep);
            b2World.m_local_sweep_backupB.Assign(bB.m_sweep);
            bA.Advance(minAlpha);
            bB.Advance(minAlpha);
            minContact.Update(this.m_contactManager.m_contactListener);
            minContact.m_flags &= ~b2Contact.e_toiFlag;
            ++minContact.m_toiCount;
            if (false == minContact.IsEnabled() || false == minContact.IsTouching()) {
              minContact.SetEnabled(false);
              bA.m_sweep.Assign(b2World.m_local_sweep_backupA);
              bB.m_sweep.Assign(b2World.m_local_sweep_backupB);
              bA.SynchronizeTransform();
              bB.SynchronizeTransform();
              continue;
            }
            bA.SetAwake(true);
            bB.SetAwake(true);
            this.p_island.Clear();
            this.p_island.AddBody(bA);
            this.p_island.AddBody(bB);
            this.p_island.AddContact(minContact);
            bA.m_flags |= b2Body.e_islandFlag;
            bB.m_flags |= b2Body.e_islandFlag;
            minContact.m_flags |= b2Contact.e_islandFlag;
            var bodies = [ bA, bB ];
            for (var i = 0; i < 2; ++i) {
              var body = bodies[i];
              if (body.m_type == b2Body.b2_dynamicBody) for (var ce = body.m_contactList; ce; ce = ce.next) {
                if (this.p_island.m_bodyCount == this.p_island.m_bodyCapacity) break;
                if (this.p_island.m_contactCount == this.p_island.m_contactCapacity) break;
                var contact = ce.contact;
                if (contact.m_flags & b2Contact.e_islandFlag) continue;
                var other = ce.other;
                if (other.m_type == b2Body.b2_dynamicBody && false == body.IsBullet() && false == other.IsBullet()) continue;
                var sensorA = contact.m_fixtureA.m_isSensor;
                var sensorB = contact.m_fixtureB.m_isSensor;
                if (sensorA || sensorB) continue;
                b2World.m_local_sweep_backupC.Assign(other.m_sweep);
                0 == (other.m_flags & b2Body.e_islandFlag) && other.Advance(minAlpha);
                contact.Update(this.m_contactManager.m_contactListener);
                if (false == contact.IsEnabled()) {
                  other.m_sweep.Assign(b2World.m_local_sweep_backupC);
                  other.SynchronizeTransform();
                  continue;
                }
                if (false == contact.IsTouching()) {
                  other.m_sweep.Assign(b2World.m_local_sweep_backupC);
                  other.SynchronizeTransform();
                  continue;
                }
                contact.m_flags |= b2Contact.e_islandFlag;
                this.p_island.AddContact(contact);
                if (other.m_flags & b2Body.e_islandFlag) continue;
                other.m_flags |= b2Body.e_islandFlag;
                other.m_type != b2Body.b2_staticBody && other.SetAwake(true);
                this.p_island.AddBody(other);
              }
            }
            var subStep = new b2TimeStep();
            subStep.dt = (1 - minAlpha) * step.dt;
            subStep.inv_dt = 1 / subStep.dt;
            subStep.dtRatio = 1;
            subStep.positionIterations = 20;
            subStep.velocityIterations = step.velocityIterations;
            subStep.warmStarting = false;
            this.p_island.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);
            for (var i = 0; i < this.p_island.m_bodyCount; ++i) {
              var body = this.p_island.m_bodies[i];
              body.m_flags &= ~b2Body.e_islandFlag;
              if (body.m_type != b2Body.b2_dynamicBody) continue;
              body.SynchronizeFixtures();
              for (var ce = body.m_contactList; ce; ce = ce.next) ce.contact.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
            }
            this.m_contactManager.FindNewContacts();
            if (this.m_subStepping) {
              this.m_stepComplete = false;
              break;
            }
          }
        },
        DrawJoint: function(joint) {
          var bodyA = joint.GetBodyA();
          var bodyB = joint.GetBodyB();
          var xf1 = bodyA.GetTransform();
          var xf2 = bodyB.GetTransform();
          var x1 = xf1.p;
          var x2 = xf2.p;
          var p1 = joint.GetAnchorA();
          var p2 = joint.GetAnchorB();
          var color = new b2Color(.5, .8, .8);
          switch (joint.GetType()) {
           case b2Joint.e_distanceJoint:
            this.g_debugDraw.DrawSegment(p1, p2, color);
            break;

           case b2Joint.e_pulleyJoint:
            var pulley = joint;
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.g_debugDraw.DrawSegment(s1, p1, color);
            this.g_debugDraw.DrawSegment(s2, p2, color);
            this.g_debugDraw.DrawSegment(s1, s2, color);
            break;

           case b2Joint.e_mouseJoint:
            break;

           case b2Joint.e_motorJoint:
            this.g_debugDraw.DrawPoint(joint.GetLinearOffset(), 5, color);

           default:
            this.g_debugDraw.DrawSegment(x1, p1, color);
            this.g_debugDraw.DrawSegment(p1, p2, color);
            this.g_debugDraw.DrawSegment(x2, p2, color);
          }
        },
        DrawShape: function(fixture, xf, color) {
          switch (fixture.GetType()) {
           case b2Shape.e_circle:
            var circle = fixture.GetShape();
            var center = b2Mul_t_v2(xf, circle.m_p);
            var radius = circle.m_radius;
            var axis = b2Mul_r_v2(xf.q, new b2Vec2(1, 0));
            this.g_debugDraw.DrawSolidCircle(center, radius, axis, color);
            break;

           case b2Shape.e_edge:
            var edge = fixture.GetShape();
            var v1 = b2Mul_t_v2(xf, edge.m_vertex1);
            var v2 = b2Mul_t_v2(xf, edge.m_vertex2);
            this.g_debugDraw.DrawSegment(v1, v2, color);
            break;

           case b2Shape.e_chain:
            var chain = fixture.GetShape();
            var count = chain.m_count;
            var vertices = chain.m_vertices;
            var v1 = b2Mul_t_v2(xf, vertices[0]);
            for (var i = 1; i < count; ++i) {
              var v2 = b2Mul_t_v2(xf, vertices[i]);
              this.g_debugDraw.DrawSegment(v1, v2, color);
              v1 = v2;
            }
            break;

           case b2Shape.e_polygon:
            var poly = fixture.GetShape();
            var vertexCount = poly.m_count;
            b2Assert(vertexCount <= b2_maxPolygonVertices);
            var vertices = new Array(b2_maxPolygonVertices);
            for (var i = 0; i < vertexCount; ++i) vertices[i] = b2Mul_t_v2(xf, poly.m_vertices[i]);
            this.g_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
          }
        }
      };
      b2World.e_newFixture = 1;
      b2World.e_locked = 2;
      b2World.e_clearForces = 4;
      function b2MixFriction(friction1, friction2) {
        return b2Sqrt(friction1 * friction2);
      }
      function b2MixRestitution(restitution1, restitution2) {
        return restitution1 > restitution2 ? restitution1 : restitution2;
      }
      function b2ContactRegister() {
        this.fcn = null;
        this.primary = false;
      }
      function b2ContactEdge() {
        this.other = null;
        this.contact = null;
        this.prev = null;
        this.next = null;
      }
      b2ContactEdge.prototype = {
        Clear: function() {
          this.other = this.prev = this.next = null;
        }
      };
      function b2Contact() {
        this.m_nodeA = new b2ContactEdge();
        this.m_nodeB = new b2ContactEdge();
        this.m_manifold = new b2Manifold();
      }
      b2Contact.m_local_tempManifold = new b2Manifold();
      b2Contact.prototype = {
        Create: function(fA, indexA, fB, indexB) {
          this.m_toi = 0;
          this.m_flags = b2Contact.e_enabledFlag;
          this.m_fixtureA = fA || null;
          this.m_fixtureB = fB || null;
          this.m_indexA = indexA || 0;
          this.m_indexB = indexB || 0;
          this.m_manifold.pointCount = 0;
          this.m_prev = null;
          this.m_next = null;
          this.m_nodeA.contact = null;
          this.m_nodeA.prev = null;
          this.m_nodeA.next = null;
          this.m_nodeA.other = null;
          this.m_nodeB.contact = null;
          this.m_nodeB.prev = null;
          this.m_nodeB.next = null;
          this.m_nodeB.other = null;
          this.m_toiCount = 0;
          if (fA) {
            this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
            this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
          } else {
            this.m_friction = 0;
            this.m_restitution = 0;
          }
          this.m_tangentSpeed = 0;
        },
        GetManifold: function() {
          return this.m_manifold;
        },
        GetWorldManifold: function(worldManifold) {
          var bodyA = this.m_fixtureA.GetBody();
          var bodyB = this.m_fixtureB.GetBody();
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
        },
        IsTouching: function() {
          return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
        },
        SetEnabled: function(flag) {
          flag ? this.m_flags |= b2Contact.e_enabledFlag : this.m_flags &= ~b2Contact.e_enabledFlag;
        },
        IsEnabled: function() {
          return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
        },
        GetNext: function() {
          return this.m_next;
        },
        GetFixtureA: function() {
          return this.m_fixtureA;
        },
        GetChildIndexA: function() {
          return this.m_indexA;
        },
        GetFixtureB: function() {
          return this.m_fixtureB;
        },
        GetChildIndexB: function() {
          return this.m_indexB;
        },
        SetFriction: function(friction) {
          this.m_friction = friction;
        },
        GetFriction: function() {
          return this.m_friction;
        },
        ResetFriction: function() {
          this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
        },
        SetRestitution: function(restitution) {
          this.m_restitution = restitution;
        },
        GetRestitution: function() {
          return this.m_restitution;
        },
        ResetRestitution: function() {
          this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
        },
        SetTangentSpeed: function(speed) {
          this.m_tangentSpeed = speed;
        },
        GetTangentSpeed: function() {
          return this.m_tangentSpeed;
        },
        Evaluate: function(manifold, xfA, xfB) {},
        FlagForFiltering: function() {
          this.m_flags |= b2Contact.e_filterFlag;
        },
        m_oldManifold: null,
        Update: function(listener) {
          b2Contact.m_local_tempManifold.Assign(this.m_manifold);
          this.m_flags |= b2Contact.e_enabledFlag;
          var touching = false;
          var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
          var sensorA = this.m_fixtureA.IsSensor();
          var sensorB = this.m_fixtureB.IsSensor();
          var sensor = sensorA || sensorB;
          var bodyA = this.m_fixtureA.GetBody();
          var bodyB = this.m_fixtureB.GetBody();
          var xfA = bodyA.GetTransform();
          var xfB = bodyB.GetTransform();
          if (sensor) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            touching = b2TestShapeOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
            this.m_manifold.pointCount = 0;
          } else {
            this.Evaluate(this.m_manifold, xfA, xfB);
            touching = this.m_manifold.pointCount > 0;
            for (var i = 0; i < this.m_manifold.pointCount; ++i) {
              var mp2 = this.m_manifold.points[i];
              mp2.normalImpulse = 0;
              mp2.tangentImpulse = 0;
              var id2 = mp2.id;
              for (var j = 0; j < b2Contact.m_local_tempManifold.pointCount; ++j) {
                var mp1 = b2Contact.m_local_tempManifold.points[j];
                if (mp1.id.Get() == id2.Get()) {
                  mp2.normalImpulse = mp1.normalImpulse;
                  mp2.tangentImpulse = mp1.tangentImpulse;
                  break;
                }
              }
            }
            if (touching != wasTouching) {
              bodyA.SetAwake(true);
              bodyB.SetAwake(true);
            }
          }
          touching ? this.m_flags |= b2Contact.e_touchingFlag : this.m_flags &= ~b2Contact.e_touchingFlag;
          false == wasTouching && true == touching && listener && listener.BeginContact(this);
          true == wasTouching && false == touching && listener && listener.EndContact(this);
          false == sensor && touching && listener && listener.PreSolve(this, b2Contact.m_local_tempManifold);
        }
      };
      b2Contact.e_islandFlag = 1;
      b2Contact.e_touchingFlag = 2;
      b2Contact.e_enabledFlag = 4;
      b2Contact.e_filterFlag = 8;
      b2Contact.e_bulletHitFlag = 16;
      b2Contact.e_toiFlag = 32;
      function b2CircleContact() {
        this.parent.call(this);
      }
      b2CircleContact.prototype = {
        Evaluate: function(manifold, xfA, xfB) {
          b2CollideCircles(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
        },
        Create: function(fixtureA, unused1, fixtureB, unused2) {
          this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
          b2Assert(this.m_fixtureA.GetType() == b2Shape.e_circle);
          b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
        }
      };
      b2CircleContact._extend(b2Contact);
      var _local_temp_edgeShape = new b2EdgeShape();
      function b2ChainAndCircleContact() {
        this.parent.call(this);
      }
      b2ChainAndCircleContact.prototype = {
        Evaluate: function(manifold, xfA, xfB) {
          var chain = this.m_fixtureA.GetShape();
          chain.GetChildEdge(_local_temp_edgeShape, this.m_indexA);
          b2CollideEdgeAndCircle(manifold, _local_temp_edgeShape, xfA, this.m_fixtureB.GetShape(), xfB);
        },
        Create: function(fixtureA, indexA, fixtureB, indexB) {
          this.parent.prototype.Create.call(this, fixtureA, indexA, fixtureB, indexB);
          b2Assert(this.m_fixtureA.GetType() == b2Shape.e_chain);
          b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
        }
      };
      b2ChainAndCircleContact._extend(b2Contact);
      function b2ChainAndPolygonContact() {
        this.parent.call(this);
      }
      b2ChainAndPolygonContact.prototype = {
        Evaluate: function(manifold, xfA, xfB) {
          var chain = this.m_fixtureA.GetShape();
          chain.GetChildEdge(_local_temp_edgeShape, this.m_indexA);
          b2CollideEdgeAndPolygon(manifold, _local_temp_edgeShape, xfA, this.m_fixtureB.GetShape(), xfB);
        },
        Create: function(fixtureA, indexA, fixtureB, indexB) {
          this.parent.prototype.Create.call(this, fixtureA, indexA, fixtureB, indexB);
          b2Assert(this.m_fixtureA.GetType() == b2Shape.e_chain);
          b2Assert(this.m_fixtureB.GetType() == b2Shape.e_polygon);
        }
      };
      b2ChainAndPolygonContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
        return new b2ChainAndPolygonContact(fixtureA, indexA, fixtureB, indexB);
      };
      b2ChainAndPolygonContact._extend(b2Contact);
      function b2EdgeAndCircleContact() {
        this.parent.call(this);
      }
      b2EdgeAndCircleContact.prototype = {
        Evaluate: function(manifold, xfA, xfB) {
          b2CollideEdgeAndCircle(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
        },
        Create: function(fixtureA, indexA, fixtureB, indexB) {
          this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
          b2Assert(this.m_fixtureA.GetType() == b2Shape.e_edge);
          b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
        }
      };
      b2EdgeAndCircleContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
        return new b2EdgeAndCircleContact(fixtureA, fixtureB);
      };
      b2EdgeAndCircleContact._extend(b2Contact);
      function b2EdgeAndPolygonContact() {
        this.parent.call(this);
      }
      b2EdgeAndPolygonContact.prototype = {
        Evaluate: function(manifold, xfA, xfB) {
          b2CollideEdgeAndPolygon(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
        },
        Create: function(fixtureA, indexA, fixtureB, indexB) {
          this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
          b2Assert(this.m_fixtureA.GetType() == b2Shape.e_edge);
          b2Assert(this.m_fixtureB.GetType() == b2Shape.e_polygon);
        }
      };
      b2EdgeAndPolygonContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
        return new b2EdgeAndPolygonContact(fixtureA, fixtureB);
      };
      b2EdgeAndPolygonContact._extend(b2Contact);
      function b2PolygonAndCircleContact() {
        this.parent.call(this);
      }
      b2PolygonAndCircleContact.prototype = {
        Evaluate: function(manifold, xfA, xfB) {
          b2CollidePolygonAndCircle(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
        },
        Create: function(fixtureA, indexA, fixtureB, indexB) {
          this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
          b2Assert(this.m_fixtureA.GetType() == b2Shape.e_polygon);
          b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
        }
      };
      b2PolygonAndCircleContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
        return new b2PolygonAndCircleContact(fixtureA, fixtureB);
      };
      b2PolygonAndCircleContact._extend(b2Contact);
      function b2PolygonContact() {
        this.parent.call(this);
      }
      b2PolygonContact.prototype = {
        Evaluate: function(manifold, xfA, xfB) {
          b2CollidePolygons(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
        },
        Create: function(fixtureA, indexA, fixtureB, indexB) {
          this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
          b2Assert(this.m_fixtureA.GetType() == b2Shape.e_polygon);
          b2Assert(this.m_fixtureB.GetType() == b2Shape.e_polygon);
        }
      };
      b2PolygonContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
        return new b2PolygonContact(fixtureA, fixtureB);
      };
      b2PolygonContact._extend(b2Contact);
      b2Contact.AddType = function(fcn, type1, type2) {
        b2Assert(0 <= type1 && type1 < b2Shape.e_typeCount);
        b2Assert(0 <= type2 && type2 < b2Shape.e_typeCount);
        b2Contact.s_registers[type1] || (b2Contact.s_registers[type1] = []);
        b2Contact.s_registers[type1][type2] = new b2ContactRegister();
        b2Contact.s_registers[type1][type2].fcn = fcn;
        b2Contact.s_registers[type1][type2].primary = true;
        if (type1 != type2) {
          b2Contact.s_registers[type2] || (b2Contact.s_registers[type2] = []);
          b2Contact.s_registers[type2][type1] = new b2ContactRegister();
          b2Contact.s_registers[type2][type1].fcn = fcn;
          b2Contact.s_registers[type2][type1].primary = false;
        }
        fcn.garbage = [];
        fcn.alloc = 2;
      };
      b2Contact.InitializeRegisters = function() {
        b2Contact.AddType(b2CircleContact, b2Shape.e_circle, b2Shape.e_circle);
        b2Contact.AddType(b2PolygonAndCircleContact, b2Shape.e_polygon, b2Shape.e_circle);
        b2Contact.AddType(b2PolygonContact, b2Shape.e_polygon, b2Shape.e_polygon);
        b2Contact.AddType(b2EdgeAndCircleContact, b2Shape.e_edge, b2Shape.e_circle);
        b2Contact.AddType(b2EdgeAndPolygonContact, b2Shape.e_edge, b2Shape.e_polygon);
        b2Contact.AddType(b2ChainAndCircleContact, b2Shape.e_chain, b2Shape.e_circle);
        b2Contact.AddType(b2ChainAndPolygonContact, b2Shape.e_chain, b2Shape.e_polygon);
      };
      b2Contact.RetrieveGarbage = function(fcn) {
        var contact;
        if (contact = fcn.garbage.pop()) return contact;
        for (var i = 0; i < fcn.alloc - 1; ++i) fcn.garbage.push(new fcn());
        fcn.alloc += 32;
        return new fcn();
      };
      b2Contact.Create = function(fixtureA, indexA, fixtureB, indexB) {
        if (false == b2Contact.s_initialized) {
          b2Contact.InitializeRegisters();
          b2Contact.s_initialized = true;
        }
        var type1 = fixtureA.GetType();
        var type2 = fixtureB.GetType();
        b2Assert(0 <= type1 && type1 < b2Shape.e_typeCount);
        b2Assert(0 <= type2 && type2 < b2Shape.e_typeCount);
        var fcn = b2Contact.s_registers[type1] && b2Contact.s_registers[type1][type2] ? b2Contact.s_registers[type1][type2].fcn : null;
        if (fcn) {
          var contact = b2Contact.RetrieveGarbage(fcn);
          b2Contact.s_registers[type1][type2].primary ? contact.Create(fixtureA, indexA, fixtureB, indexB) : contact.Create(fixtureB, indexB, fixtureA, indexA);
          return contact;
        }
        return null;
      };
      b2Contact.Destroy = function(contact) {
        b2Assert(true == b2Contact.s_initialized);
        var fixtureA = contact.m_fixtureA;
        var fixtureB = contact.m_fixtureB;
        if (contact.m_manifold.pointCount > 0 && false == fixtureA.IsSensor() && false == fixtureB.IsSensor()) {
          fixtureA.GetBody().SetAwake(true);
          fixtureB.GetBody().SetAwake(true);
        }
        var typeA = fixtureA.GetType();
        var typeB = fixtureB.GetType();
        b2Assert(0 <= typeA && typeB < b2Shape.e_typeCount);
        b2Assert(0 <= typeA && typeB < b2Shape.e_typeCount);
        contact.m_nodeA.Clear();
        contact.m_nodeB.Clear();
        b2Contact.s_registers[typeA][typeB].fcn.garbage.push(contact);
      };
      b2Contact.s_registers = [];
      b2Contact.s_initialized = false;
      var b2_defaultFilter = new b2ContactFilter();
      var b2_defaultListener = new b2ContactListener();
      function b2ContactManager() {
        this.m_broadPhase = new b2BroadPhase();
        this.m_contactList = null;
        this.m_contactCount = 0;
        this.m_contactFilter = b2_defaultFilter;
        this.m_contactListener = b2_defaultListener;
      }
      b2ContactManager.prototype = {
        AddPair: function(proxyUserDataA, proxyUserDataB) {
          var proxyA = proxyUserDataA;
          var proxyB = proxyUserDataB;
          var fixtureA = proxyA.fixture;
          var fixtureB = proxyB.fixture;
          var indexA = proxyA.childIndex;
          var indexB = proxyB.childIndex;
          var bodyA = fixtureA.GetBody();
          var bodyB = fixtureB.GetBody();
          if (bodyA == bodyB) return;
          var edge = bodyB.GetContactList();
          while (edge) {
            if (edge.other == bodyA) {
              var fA = edge.contact.GetFixtureA();
              var fB = edge.contact.GetFixtureB();
              var iA = edge.contact.GetChildIndexA();
              var iB = edge.contact.GetChildIndexB();
              if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) return;
              if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) return;
            }
            edge = edge.next;
          }
          if (false == bodyB.ShouldCollide(bodyA)) return;
          if (this.m_contactFilter && false == this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) return;
          var c = b2Contact.Create(fixtureA, indexA, fixtureB, indexB);
          if (null == c) return;
          fixtureA = c.GetFixtureA();
          fixtureB = c.GetFixtureB();
          indexA = c.GetChildIndexA();
          indexB = c.GetChildIndexB();
          bodyA = fixtureA.GetBody();
          bodyB = fixtureB.GetBody();
          c.m_prev = null;
          c.m_next = this.m_contactList;
          null != this.m_contactList && (this.m_contactList.m_prev = c);
          this.m_contactList = c;
          c.m_nodeA.contact = c;
          c.m_nodeA.other = bodyB;
          c.m_nodeA.prev = null;
          c.m_nodeA.next = bodyA.m_contactList;
          null != bodyA.m_contactList && (bodyA.m_contactList.prev = c.m_nodeA);
          bodyA.m_contactList = c.m_nodeA;
          c.m_nodeB.contact = c;
          c.m_nodeB.other = bodyA;
          c.m_nodeB.prev = null;
          c.m_nodeB.next = bodyB.m_contactList;
          null != bodyB.m_contactList && (bodyB.m_contactList.prev = c.m_nodeB);
          bodyB.m_contactList = c.m_nodeB;
          if (false == fixtureA.IsSensor() && false == fixtureB.IsSensor()) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
          }
          ++this.m_contactCount;
        },
        FindNewContacts: function() {
          this.m_broadPhase.UpdatePairs(this);
        },
        Destroy: function(c) {
          var fixtureA = c.GetFixtureA();
          var fixtureB = c.GetFixtureB();
          var bodyA = fixtureA.GetBody();
          var bodyB = fixtureB.GetBody();
          this.m_contactListener && c.IsTouching() && this.m_contactListener.EndContact(c);
          c.m_prev && (c.m_prev.m_next = c.m_next);
          c.m_next && (c.m_next.m_prev = c.m_prev);
          c == this.m_contactList && (this.m_contactList = c.m_next);
          c.m_nodeA.prev && (c.m_nodeA.prev.next = c.m_nodeA.next);
          c.m_nodeA.next && (c.m_nodeA.next.prev = c.m_nodeA.prev);
          c.m_nodeA == bodyA.m_contactList && (bodyA.m_contactList = c.m_nodeA.next);
          c.m_nodeB.prev && (c.m_nodeB.prev.next = c.m_nodeB.next);
          c.m_nodeB.next && (c.m_nodeB.next.prev = c.m_nodeB.prev);
          c.m_nodeB == bodyB.m_contactList && (bodyB.m_contactList = c.m_nodeB.next);
          b2Contact.Destroy(c);
          --this.m_contactCount;
        },
        Collide: function() {
          var c = this.m_contactList;
          while (c) {
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            var indexA = c.GetChildIndexA();
            var indexB = c.GetChildIndexB();
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            if (c.m_flags & b2Contact.e_filterFlag) {
              if (false == bodyB.ShouldCollide(bodyA)) {
                var cNuke = c;
                c = cNuke.GetNext();
                this.Destroy(cNuke);
                continue;
              }
              if (this.m_contactFilter && false == this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {
                var cNuke = c;
                c = cNuke.GetNext();
                this.Destroy(cNuke);
                continue;
              }
              c.m_flags &= ~b2Contact.e_filterFlag;
            }
            var activeA = bodyA.IsAwake() && bodyA.m_type != b2Body.b2_staticBody;
            var activeB = bodyB.IsAwake() && bodyB.m_type != b2Body.b2_staticBody;
            if (false == activeA && false == activeB) {
              c = c.GetNext();
              continue;
            }
            var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
            var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
            var overlap = this.m_broadPhase.TestOverlap(proxyIdA, proxyIdB);
            if (false == overlap) {
              var cNuke = c;
              c = cNuke.GetNext();
              this.Destroy(cNuke);
              continue;
            }
            c.Update(this.m_contactListener);
            c = c.GetNext();
          }
        }
      };
      function b2VelocityConstraintPoint() {
        this.rA = new b2Vec2();
        this.rB = new b2Vec2();
        this.normalImpulse = 0;
        this.tangentImpulse = 0;
        this.normalMass = 0;
        this.tangentMass = 0;
        this.velocityBias = 0;
      }
      function b2ContactPositionConstraint() {
        this.localPoints = new Array(b2_maxManifoldPoints);
        this.localNormal = new b2Vec2();
        this.localPoint = new b2Vec2();
        this.indexA = 0;
        this.indexB = 0;
        this.invMassA = 0, this.invMassB = 0;
        this.localCenterA = new b2Vec2(), this.localCenterB = new b2Vec2();
        this.invIA = 0, this.invIB = 0;
        this.type = 0;
        this.radiusA = 0, this.radiusB = 0;
        this.pointCount = 0;
      }
      function b2ContactVelocityConstraint() {
        this.points = new Array(b2_maxManifoldPoints);
        for (var i = 0; i < this.points.length; ++i) this.points[i] = new b2VelocityConstraintPoint();
        this.normal = new b2Vec2();
        this.normalMass = new b2Mat22();
        this.K = new b2Mat22();
        this.indexA = 0;
        this.indexB = 0;
        this.invMassA = 0, this.invMassB = 0;
        this.invIA = 0, this.invIB = 0;
        this.friction = 0;
        this.restitution = 0;
        this.tangentSpeed = 0;
        this.pointCount = 0;
        this.contactIndex = 0;
      }
      function b2PositionSolverManifold() {
        this.normal = new b2Vec2();
        this.point = new b2Vec2();
        this.separation = 0;
      }
      b2PositionSolverManifold.prototype = {
        Initialize: function(pc, xfA, xfB, index) {
          b2Assert(pc.pointCount > 0);
          switch (pc.type) {
           case b2Manifold.e_circles:
            var pointAx = xfA.q.c * pc.localPoint.x - xfA.q.s * pc.localPoint.y + xfA.p.x;
            var pointAy = xfA.q.s * pc.localPoint.x + xfA.q.c * pc.localPoint.y + xfA.p.y;
            var pointBx = xfB.q.c * pc.localPoints[0].x - xfB.q.s * pc.localPoints[0].y + xfB.p.x;
            var pointBy = xfB.q.s * pc.localPoints[0].x + xfB.q.c * pc.localPoints[0].y + xfB.p.y;
            this.point.x = .5 * (pointAx + pointBx);
            this.point.y = .5 * (pointAy + pointBy);
            this.normal.x = pointBx - pointAx;
            this.normal.y = pointBy - pointAy;
            var tempnx = this.normal.x;
            var tempny = this.normal.y;
            this.normal.Normalize();
            this.separation = tempnx * this.normal.x + tempny * this.normal.y - pc.radiusA - pc.radiusB;
            break;

           case b2Manifold.e_faceA:
            this.normal.x = xfA.q.c * pc.localNormal.x - xfA.q.s * pc.localNormal.y;
            this.normal.y = xfA.q.s * pc.localNormal.x + xfA.q.c * pc.localNormal.y;
            var planePointx = xfA.q.c * pc.localPoint.x - xfA.q.s * pc.localPoint.y + xfA.p.x;
            var planePointy = xfA.q.s * pc.localPoint.x + xfA.q.c * pc.localPoint.y + xfA.p.y;
            var clipPointx = xfB.q.c * pc.localPoints[index].x - xfB.q.s * pc.localPoints[index].y + xfB.p.x;
            var clipPointy = xfB.q.s * pc.localPoints[index].x + xfB.q.c * pc.localPoints[index].y + xfB.p.y;
            this.separation = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y - pc.radiusA - pc.radiusB;
            this.point.x = clipPointx;
            this.point.y = clipPointy;
            break;

           case b2Manifold.e_faceB:
            this.normal.x = xfB.q.c * pc.localNormal.x - xfB.q.s * pc.localNormal.y;
            this.normal.y = xfB.q.s * pc.localNormal.x + xfB.q.c * pc.localNormal.y;
            var planePointx = xfB.q.c * pc.localPoint.x - xfB.q.s * pc.localPoint.y + xfB.p.x;
            var planePointy = xfB.q.s * pc.localPoint.x + xfB.q.c * pc.localPoint.y + xfB.p.y;
            var clipPointx = xfA.q.c * pc.localPoints[index].x - xfA.q.s * pc.localPoints[index].y + xfA.p.x;
            var clipPointy = xfA.q.s * pc.localPoints[index].x + xfA.q.c * pc.localPoints[index].y + xfA.p.y;
            this.separation = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y - pc.radiusA - pc.radiusB;
            this.point.x = clipPointx;
            this.point.y = clipPointy;
            this.normal.x = -this.normal.x;
            this.normal.y = -this.normal.y;
          }
        }
      };
      function b2ContactSolverDef() {
        this.step = new b2TimeStep();
        this.contacts = null;
        this.count = 0;
        this.positions = null;
        this.velocities = null;
      }
      function b2ContactSolver() {
        this.m_positionConstraints = [];
        this.m_velocityConstraints = [];
      }
      b2ContactSolver.cs_xfA = new b2Transform();
      b2ContactSolver.cs_xfB = new b2Transform();
      b2ContactSolver.temp_solver_manifold = new b2PositionSolverManifold();
      b2ContactSolver.prototype = {
        Init: function(def) {
          this.m_step = def.step;
          this.m_count = def.count;
          this.m_positionConstraints.length = this.m_count;
          this.m_velocityConstraints.length = this.m_count;
          this.m_positions = def.positions;
          this.m_velocities = def.velocities;
          this.m_contacts = def.contacts;
          for (var i = 0; i < this.m_count; ++i) {
            var contact = this.m_contacts[i];
            var fixtureA = contact.m_fixtureA;
            var fixtureB = contact.m_fixtureB;
            var shapeA = fixtureA.GetShape();
            var shapeB = fixtureB.GetShape();
            var radiusA = shapeA.m_radius;
            var radiusB = shapeB.m_radius;
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            var manifold = contact.GetManifold();
            var pointCount = manifold.pointCount;
            b2Assert(pointCount > 0);
            var vc = this.m_velocityConstraints[i] || new b2ContactVelocityConstraint();
            vc.friction = contact.m_friction;
            vc.restitution = contact.m_restitution;
            vc.tangentSpeed = contact.m_tangentSpeed;
            vc.indexA = bodyA.m_islandIndex;
            vc.indexB = bodyB.m_islandIndex;
            vc.invMassA = bodyA.m_invMass;
            vc.invMassB = bodyB.m_invMass;
            vc.invIA = bodyA.m_invI;
            vc.invIB = bodyB.m_invI;
            vc.contactIndex = i;
            vc.pointCount = pointCount;
            vc.K.SetZero();
            vc.normalMass.SetZero();
            this.m_velocityConstraints[i] = vc;
            var pc = this.m_positionConstraints[i] || new b2ContactPositionConstraint();
            pc.indexA = bodyA.m_islandIndex;
            pc.indexB = bodyB.m_islandIndex;
            pc.invMassA = bodyA.m_invMass;
            pc.invMassB = bodyB.m_invMass;
            pc.localCenterA.x = bodyA.m_sweep.localCenter.x;
            pc.localCenterA.y = bodyA.m_sweep.localCenter.y;
            pc.localCenterB.x = bodyB.m_sweep.localCenter.x;
            pc.localCenterB.y = bodyB.m_sweep.localCenter.y;
            pc.invIA = bodyA.m_invI;
            pc.invIB = bodyB.m_invI;
            pc.localNormal.x = manifold.localNormal.x;
            pc.localNormal.y = manifold.localNormal.y;
            pc.localPoint.x = manifold.localPoint.x;
            pc.localPoint.y = manifold.localPoint.y;
            pc.pointCount = pointCount;
            pc.radiusA = radiusA;
            pc.radiusB = radiusB;
            pc.type = manifold.type;
            this.m_positionConstraints[i] = pc;
            for (var j = 0; j < pointCount; ++j) {
              var cp = manifold.points[j];
              var vcp = vc.points[j];
              if (this.m_step.warmStarting) {
                vcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;
                vcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;
              } else {
                vcp.normalImpulse = 0;
                vcp.tangentImpulse = 0;
              }
              vcp.rA.SetZero();
              vcp.rB.SetZero();
              vcp.normalMass = 0;
              vcp.tangentMass = 0;
              vcp.velocityBias = 0;
              pc.localPoints[j] = cp.localPoint;
            }
          }
        },
        InitializeVelocityConstraints: function() {
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var pc = this.m_positionConstraints[i];
            var radiusA = pc.radiusA;
            var radiusB = pc.radiusB;
            var manifold = this.m_contacts[vc.contactIndex].GetManifold();
            var indexA = vc.indexA;
            var indexB = vc.indexB;
            var mA = vc.invMassA;
            var mB = vc.invMassB;
            var iA = vc.invIA;
            var iB = vc.invIB;
            var localCenterA = pc.localCenterA;
            var localCenterB = pc.localCenterB;
            var cA = this.m_positions[indexA].c;
            var aA = this.m_positions[indexA].a;
            var vA = this.m_velocities[indexA].v;
            var wA = this.m_velocities[indexA].w;
            var cB = this.m_positions[indexB].c;
            var aB = this.m_positions[indexB].a;
            var vB = this.m_velocities[indexB].v;
            var wB = this.m_velocities[indexB].w;
            b2Assert(manifold.pointCount > 0);
            b2ContactSolver.cs_xfA.q.Set(aA);
            b2ContactSolver.cs_xfB.q.Set(aB);
            b2ContactSolver.cs_xfA.p.x = cA.x - (b2ContactSolver.cs_xfA.q.c * localCenterA.x - b2ContactSolver.cs_xfA.q.s * localCenterA.y);
            b2ContactSolver.cs_xfA.p.y = cA.y - (b2ContactSolver.cs_xfA.q.s * localCenterA.x + b2ContactSolver.cs_xfA.q.c * localCenterA.y);
            b2ContactSolver.cs_xfB.p.x = cB.x - (b2ContactSolver.cs_xfB.q.c * localCenterB.x - b2ContactSolver.cs_xfB.q.s * localCenterB.y);
            b2ContactSolver.cs_xfB.p.y = cB.y - (b2ContactSolver.cs_xfB.q.s * localCenterB.x + b2ContactSolver.cs_xfB.q.c * localCenterB.y);
            var worldManifold = new b2WorldManifold();
            worldManifold.Initialize(manifold, b2ContactSolver.cs_xfA, radiusA, b2ContactSolver.cs_xfB, radiusB);
            vc.normal.x = worldManifold.normal.x;
            vc.normal.y = worldManifold.normal.y;
            var pointCount = vc.pointCount;
            for (var j = 0; j < pointCount; ++j) {
              var vcp = vc.points[j];
              vcp.rA.x = worldManifold.points[j].x - cA.x;
              vcp.rA.y = worldManifold.points[j].y - cA.y;
              vcp.rB.x = worldManifold.points[j].x - cB.x;
              vcp.rB.y = worldManifold.points[j].y - cB.y;
              var rnA = vcp.rA.x * vc.normal.y - vcp.rA.y * vc.normal.x;
              var rnB = vcp.rB.x * vc.normal.y - vcp.rB.y * vc.normal.x;
              var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
              vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;
              var tangentx = 1 * vc.normal.y;
              var tangenty = -1 * vc.normal.x;
              var rtA = vcp.rA.x * tangenty - vcp.rA.y * tangentx;
              var rtB = vcp.rB.x * tangenty - vcp.rB.y * tangentx;
              var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
              vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;
              vcp.velocityBias = 0;
              var vRel = vc.normal.x * (vB.x + -wB * vcp.rB.y - vA.x - -wA * vcp.rA.y) + vc.normal.y * (vB.y + wB * vcp.rB.x - vA.y - wA * vcp.rA.x);
              vRel < -b2_velocityThreshold && (vcp.velocityBias = -vc.restitution * vRel);
            }
            if (2 == vc.pointCount) {
              var vcp1 = vc.points[0];
              var vcp2 = vc.points[1];
              var rn1A = vcp1.rA.x * vc.normal.y - vcp1.rA.y * vc.normal.x;
              var rn1B = vcp1.rB.x * vc.normal.y - vcp1.rB.y * vc.normal.x;
              var rn2A = vcp2.rA.x * vc.normal.y - vcp2.rA.y * vc.normal.x;
              var rn2B = vcp2.rB.x * vc.normal.y - vcp2.rB.y * vc.normal.x;
              var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
              var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
              var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
              var k_maxConditionNumber = 1e3;
              if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                vc.K.ex.x = k11;
                vc.K.ex.y = k12;
                vc.K.ey.x = k12;
                vc.K.ey.y = k22;
                vc.normalMass.Assign(vc.K.GetInverse());
              } else vc.pointCount = 1;
            }
          }
        },
        WarmStart: function() {
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var indexA = vc.indexA;
            var indexB = vc.indexB;
            var mA = vc.invMassA;
            var iA = vc.invIA;
            var mB = vc.invMassB;
            var iB = vc.invIB;
            var pointCount = vc.pointCount;
            var vA = this.m_velocities[indexA].v;
            var wA = this.m_velocities[indexA].w;
            var vB = this.m_velocities[indexB].v;
            var wB = this.m_velocities[indexB].w;
            var normal = vc.normal;
            var tangentx = 1 * normal.y;
            var tangenty = -1 * normal.x;
            for (var j = 0; j < pointCount; ++j) {
              var vcp = vc.points[j];
              var Px = vcp.normalImpulse * normal.x + vcp.tangentImpulse * tangentx;
              var Py = vcp.normalImpulse * normal.y + vcp.tangentImpulse * tangenty;
              wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
              vA.x -= mA * Px;
              vA.y -= mA * Py;
              wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
              vB.x += mB * Px;
              vB.y += mB * Py;
            }
            this.m_velocities[indexA].w = wA;
            this.m_velocities[indexB].w = wB;
          }
        },
        SolveVelocityConstraints: function() {
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var indexA = vc.indexA;
            var indexB = vc.indexB;
            var mA = vc.invMassA;
            var iA = vc.invIA;
            var mB = vc.invMassB;
            var iB = vc.invIB;
            var pointCount = vc.pointCount;
            var vA = this.m_velocities[indexA].v;
            var wA = this.m_velocities[indexA].w;
            var vB = this.m_velocities[indexB].v;
            var wB = this.m_velocities[indexB].w;
            var normal = vc.normal;
            var tangentx = 1 * normal.y;
            var tangenty = -1 * normal.x;
            var friction = vc.friction;
            b2Assert(1 == pointCount || 2 == pointCount);
            for (var j = 0; j < pointCount; ++j) {
              var vcp = vc.points[j];
              var dvx = vB.x + -wB * vcp.rB.y - vA.x - -wA * vcp.rA.y;
              var dvy = vB.y + wB * vcp.rB.x - vA.y - wA * vcp.rA.x;
              var vt = dvx * tangentx + dvy * tangenty - vc.tangentSpeed;
              var lambda = vcp.tangentMass * -vt;
              var maxFriction = friction * vcp.normalImpulse;
              var newImpulse = b2Clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
              lambda = newImpulse - vcp.tangentImpulse;
              vcp.tangentImpulse = newImpulse;
              var Px = lambda * tangentx;
              var Py = lambda * tangenty;
              vA.x -= mA * Px;
              vA.y -= mA * Py;
              wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
              vB.x += mB * Px;
              vB.y += mB * Py;
              wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
            }
            if (1 == vc.pointCount) {
              vcp = vc.points[0];
              dvx = vB.x + -wB * vcp.rB.y - vA.x - -wA * vcp.rA.y;
              dvy = vB.y + wB * vcp.rB.x - vA.y - wA * vcp.rA.x;
              var vn = dvx * normal.x + dvy * normal.y;
              var lambda = -vcp.normalMass * (vn - vcp.velocityBias);
              var newImpulse = b2Max(vcp.normalImpulse + lambda, 0);
              lambda = newImpulse - vcp.normalImpulse;
              vcp.normalImpulse = newImpulse;
              Px = lambda * normal.x;
              Py = lambda * normal.y;
              vA.x -= mA * Px;
              vA.y -= mA * Py;
              wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
              vB.x += mB * Px;
              vB.y += mB * Py;
              wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
            } else {
              var cp1 = vc.points[0];
              var cp2 = vc.points[1];
              var ax = cp1.normalImpulse;
              var ay = cp2.normalImpulse;
              b2Assert(ax >= 0 && ay >= 0);
              var dv1x = vB.x + -wB * cp1.rB.y - vA.x - -wA * cp1.rA.y;
              var dv1y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
              var dv2x = vB.x + -wB * cp2.rB.y - vA.x - -wA * cp2.rA.y;
              var dv2y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
              var vn1 = dv1x * normal.x + dv1y * normal.y;
              var vn2 = dv2x * normal.x + dv2y * normal.y;
              var bx = vn1 - cp1.velocityBias;
              var by = vn2 - cp2.velocityBias;
              bx -= vc.K.ex.x * ax + vc.K.ey.x * ay;
              by -= vc.K.ex.y * ax + vc.K.ey.y * ay;
              for (;;) {
                var xx = -(vc.normalMass.ex.x * bx + vc.normalMass.ey.x * by);
                var xy = -(vc.normalMass.ex.y * bx + vc.normalMass.ey.y * by);
                if (xx >= 0 && xy >= 0) {
                  var dx = xx - ax;
                  var dy = xy - ay;
                  var P1x = dx * normal.x;
                  var P1y = dx * normal.y;
                  var P2x = dy * normal.x;
                  var P2y = dy * normal.y;
                  vA.x -= mA * (P1x + P2x);
                  vA.y -= mA * (P1y + P2y);
                  wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                  vB.x += mB * (P1x + P2x);
                  vB.y += mB * (P1y + P2y);
                  wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                  cp1.normalImpulse = xx;
                  cp2.normalImpulse = xy;
                  break;
                }
                xx = -cp1.normalMass * bx;
                xy = 0;
                vn1 = 0;
                vn2 = vc.K.ex.y * xx + by;
                if (xx >= 0 && vn2 >= 0) {
                  dx = xx - ax;
                  dy = xy - ay;
                  P1x = dx * normal.x;
                  P1y = dx * normal.y;
                  P2x = dy * normal.x;
                  P2y = dy * normal.y;
                  vA.x -= mA * (P1x + P2x);
                  vA.y -= mA * (P1y + P2y);
                  wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                  vB.x += mB * (P1x + P2x);
                  vB.y += mB * (P1y + P2y);
                  wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                  cp1.normalImpulse = xx;
                  cp2.normalImpulse = xy;
                  break;
                }
                xx = 0;
                xy = -cp2.normalMass * by;
                vn1 = vc.K.ey.x * xy + bx;
                vn2 = 0;
                if (xy >= 0 && vn1 >= 0) {
                  dx = xx - ax;
                  dy = xy - ay;
                  P1x = dx * normal.x;
                  P1y = dx * normal.y;
                  P2x = dy * normal.x;
                  P2y = dy * normal.y;
                  vA.x -= mA * (P1x + P2x);
                  vA.y -= mA * (P1y + P2y);
                  wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                  vB.x += mB * (P1x + P2x);
                  vB.y += mB * (P1y + P2y);
                  wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                  cp1.normalImpulse = xx;
                  cp2.normalImpulse = xy;
                  break;
                }
                xx = 0;
                xy = 0;
                vn1 = bx;
                vn2 = by;
                if (vn1 >= 0 && vn2 >= 0) {
                  dx = xx - ax;
                  dy = xy - ay;
                  P1x = dx * normal.x;
                  P1y = dx * normal.y;
                  P2x = dy * normal.x;
                  P2y = dy * normal.y;
                  vA.x -= mA * (P1x + P2x);
                  vA.y -= mA * (P1y + P2y);
                  wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                  vB.x += mB * (P1x + P2x);
                  vB.y += mB * (P1y + P2y);
                  wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                  cp1.normalImpulse = xx;
                  cp2.normalImpulse = xy;
                  break;
                }
                break;
              }
            }
            this.m_velocities[indexA].w = wA;
            this.m_velocities[indexB].w = wB;
          }
        },
        StoreImpulses: function() {
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var manifold = this.m_contacts[vc.contactIndex].GetManifold();
            for (var j = 0; j < vc.pointCount; ++j) {
              manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
              manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
            }
          }
        },
        SolvePositionConstraints: function() {
          var minSeparation = 0;
          for (var i = 0; i < this.m_count; ++i) {
            var pc = this.m_positionConstraints[i];
            var indexA = pc.indexA;
            var indexB = pc.indexB;
            var localCenterA = pc.localCenterA;
            var mA = pc.invMassA;
            var iA = pc.invIA;
            var localCenterB = pc.localCenterB;
            var mB = pc.invMassB;
            var iB = pc.invIB;
            var pointCount = pc.pointCount;
            var cA = this.m_positions[indexA].c;
            var aA = this.m_positions[indexA].a;
            var cB = this.m_positions[indexB].c;
            var aB = this.m_positions[indexB].a;
            for (var j = 0; j < pointCount; ++j) {
              b2ContactSolver.cs_xfA.q.Set(aA);
              b2ContactSolver.cs_xfB.q.Set(aB);
              b2ContactSolver.cs_xfA.p.x = cA.x - (b2ContactSolver.cs_xfA.q.c * localCenterA.x - b2ContactSolver.cs_xfA.q.s * localCenterA.y);
              b2ContactSolver.cs_xfA.p.y = cA.y - (b2ContactSolver.cs_xfA.q.s * localCenterA.x + b2ContactSolver.cs_xfA.q.c * localCenterA.y);
              b2ContactSolver.cs_xfB.p.x = cB.x - (b2ContactSolver.cs_xfB.q.c * localCenterB.x - b2ContactSolver.cs_xfB.q.s * localCenterB.y);
              b2ContactSolver.cs_xfB.p.y = cB.y - (b2ContactSolver.cs_xfB.q.s * localCenterB.x + b2ContactSolver.cs_xfB.q.c * localCenterB.y);
              b2ContactSolver.temp_solver_manifold.Initialize(pc, b2ContactSolver.cs_xfA, b2ContactSolver.cs_xfB, j);
              var normal = b2ContactSolver.temp_solver_manifold.normal;
              var point = b2ContactSolver.temp_solver_manifold.point;
              var separation = b2ContactSolver.temp_solver_manifold.separation;
              var rAx = point.x - cA.x;
              var rAy = point.y - cA.y;
              var rBx = point.x - cB.x;
              var rBy = point.y - cB.y;
              minSeparation = b2Min(minSeparation, separation);
              var C = b2Clamp(b2_baumgarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0);
              var rnA = rAx * normal.y - rAy * normal.x;
              var rnB = rBx * normal.y - rBy * normal.x;
              var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
              var impulse = K > 0 ? -C / K : 0;
              var Px = impulse * normal.x;
              var Py = impulse * normal.y;
              cA.x -= mA * Px;
              cA.y -= mA * Py;
              aA -= iA * (rAx * Py - rAy * Px);
              cB.x += mB * Px;
              cB.y += mB * Py;
              aB += iB * (rBx * Py - rBy * Px);
            }
            this.m_positions[indexA].a = aA;
            this.m_positions[indexB].a = aB;
          }
          return minSeparation >= -3 * b2_linearSlop;
        },
        SolveTOIPositionConstraints: function(toiIndexA, toiIndexB) {
          var minSeparation = 0;
          for (var i = 0; i < this.m_count; ++i) {
            var pc = this.m_positionConstraints[i];
            var indexA = pc.indexA;
            var indexB = pc.indexB;
            var localCenterA = pc.localCenterA;
            var localCenterB = pc.localCenterB;
            var pointCount = pc.pointCount;
            var mA = 0;
            var iA = 0;
            if (indexA == toiIndexA || indexA == toiIndexB) {
              mA = pc.invMassA;
              iA = pc.invIA;
            }
            var mB = 0;
            var iB = 0;
            if (indexB == toiIndexA || indexB == toiIndexB) {
              mB = pc.invMassB;
              iB = pc.invIB;
            }
            var cA = this.m_positions[indexA].c;
            var aA = this.m_positions[indexA].a;
            var cB = this.m_positions[indexB].c;
            var aB = this.m_positions[indexB].a;
            for (var j = 0; j < pointCount; ++j) {
              b2ContactSolver.cs_xfA.q.Set(aA);
              b2ContactSolver.cs_xfB.q.Set(aB);
              b2ContactSolver.cs_xfA.p.Assign(b2Vec2.Subtract(cA, b2Mul_r_v2(b2ContactSolver.cs_xfA.q, localCenterA)));
              b2ContactSolver.cs_xfB.p.Assign(b2Vec2.Subtract(cB, b2Mul_r_v2(b2ContactSolver.cs_xfB.q, localCenterB)));
              b2ContactSolver.temp_solver_manifold.Initialize(pc, b2ContactSolver.cs_xfA, b2ContactSolver.cs_xfB, j);
              var normal = b2ContactSolver.temp_solver_manifold.normal;
              var point = b2ContactSolver.temp_solver_manifold.point;
              var separation = b2ContactSolver.temp_solver_manifold.separation;
              var rA = b2Vec2.Subtract(point, cA);
              var rB = b2Vec2.Subtract(point, cB);
              minSeparation = b2Min(minSeparation, separation);
              var C = b2Clamp(b2_toiBaugarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0);
              var rnA = b2Cross_v2_v2(rA, normal);
              var rnB = b2Cross_v2_v2(rB, normal);
              var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
              var impulse = K > 0 ? -C / K : 0;
              var P = b2Vec2.Multiply(impulse, normal);
              cA.Subtract(b2Vec2.Multiply(mA, P));
              aA -= iA * b2Cross_v2_v2(rA, P);
              cB.Add(b2Vec2.Multiply(mB, P));
              aB += iB * b2Cross_v2_v2(rB, P);
            }
            this.m_positions[indexA].a = aA;
            this.m_positions[indexB].a = aB;
          }
          return minSeparation >= -1.5 * b2_linearSlop;
        }
      };
      function b2Island() {
        this.m_bodies = [];
        this.m_contacts = [];
        this.m_joints = [];
        this.m_velocities = [];
        this.m_positions = [];
      }
      var profile_solve_init = b2Profiler.create("solve initialization", "solve");
      var profile_solve_init_warmStarting = b2Profiler.create("warm starting", "solve initialization");
      var profile_solve_velocity = b2Profiler.create("solve velocities", "solve");
      var profile_solve_position = b2Profiler.create("solve positions", "solve");
      b2Island._solverData = new b2SolverData();
      b2Island._solverDef = new b2ContactSolverDef();
      b2Island._solver = new b2ContactSolver();
      b2Island.prototype = {
        Clear: function() {
          this.m_bodyCount = 0;
          this.m_contactCount = 0;
          this.m_jointCount = 0;
        },
        Initialize: function(bodyCapacity, contactCapacity, jointCapacity, listener) {
          this.m_listener = listener;
          this.m_bodyCapacity = bodyCapacity;
          this.m_contactCapacity = contactCapacity;
          this.m_jointCapacity = jointCapacity;
          this.m_bodyCount = 0;
          this.m_contactCount = 0;
          this.m_jointCount = 0;
          this.m_bodies.length = bodyCapacity;
          this.m_contacts.length = contactCapacity;
          this.m_joints.length = jointCapacity;
          this.m_velocities.length = bodyCapacity;
          this.m_positions.length = bodyCapacity;
        },
        Solve: function(step, gravity, allowSleep) {
          profile_solve_init.start();
          var h = step.dt;
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            this.m_positions[i].c.Assign(b.m_sweep.c);
            var a = b.m_sweep.a;
            this.m_velocities[i].v.Assign(b.m_linearVelocity);
            var w = b.m_angularVelocity;
            b.m_sweep.c0.Assign(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            if (b.m_type == b2Body.b2_dynamicBody) {
              this.m_velocities[i].v.x += h * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);
              this.m_velocities[i].v.y += h * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);
              w += h * b.m_invI * b.m_torque;
              this.m_velocities[i].v.x *= 1 / (1 + h * b.m_linearDamping);
              this.m_velocities[i].v.y *= 1 / (1 + h * b.m_linearDamping);
              w *= 1 / (1 + h * b.m_angularDamping);
            }
            this.m_positions[i].a = a;
            this.m_velocities[i].w = w;
          }
          b2Island._solverData.step = step;
          b2Island._solverData.positions = this.m_positions;
          b2Island._solverData.velocities = this.m_velocities;
          b2Island._solverDef.step = step;
          b2Island._solverDef.contacts = this.m_contacts;
          b2Island._solverDef.count = this.m_contactCount;
          b2Island._solverDef.positions = this.m_positions;
          b2Island._solverDef.velocities = this.m_velocities;
          b2Island._solverDef.allocator = this.m_allocator;
          b2Island._solver.Init(b2Island._solverDef);
          b2Island._solver.InitializeVelocityConstraints();
          if (step.warmStarting) {
            profile_solve_init_warmStarting.start();
            b2Island._solver.WarmStart();
            profile_solve_init_warmStarting.stop();
          }
          for (var i = 0; i < this.m_jointCount; ++i) this.m_joints[i].InitVelocityConstraints(b2Island._solverData);
          profile_solve_init.stop();
          profile_solve_velocity.start();
          for (var i = 0; i < step.velocityIterations; ++i) {
            for (var j = 0; j < this.m_jointCount; ++j) this.m_joints[j].SolveVelocityConstraints(b2Island._solverData);
            b2Island._solver.SolveVelocityConstraints();
          }
          b2Island._solver.StoreImpulses();
          profile_solve_velocity.stop();
          profile_solve_position.start();
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var c = this.m_positions[i].c;
            var a = this.m_positions[i].a;
            var v = this.m_velocities[i].v;
            var w = this.m_velocities[i].w;
            var translationx = h * v.x;
            var translationy = h * v.y;
            var translationl = translationx * translationx + translationy * translationy;
            if (translationl > b2_maxTranslationSquared) {
              var ratio = b2_maxTranslation / b2Sqrt(translationl);
              v.x *= ratio;
              v.y *= ratio;
            }
            var rotation = h * w;
            if (rotation * rotation > b2_maxRotationSquared) {
              var ratio = b2_maxRotation / b2Abs(rotation);
              w *= ratio;
            }
            c.x += h * v.x;
            c.y += h * v.y;
            a += h * w;
            this.m_positions[i].a = a;
            this.m_velocities[i].w = w;
          }
          var positionSolved = false;
          for (var i = 0; i < step.positionIterations; ++i) {
            var contactsOkay = b2Island._solver.SolvePositionConstraints();
            var jointsOkay = true;
            for (var j = 0; j < this.m_jointCount; ++j) {
              var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Island._solverData);
              jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
              positionSolved = true;
              break;
            }
          }
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var body = this.m_bodies[i];
            body.m_sweep.c.Assign(this.m_positions[i].c);
            body.m_sweep.a = this.m_positions[i].a;
            body.m_linearVelocity.Assign(this.m_velocities[i].v);
            body.m_angularVelocity = this.m_velocities[i].w;
            body.SynchronizeTransform();
          }
          profile_solve_position.stop();
          this.Report(b2Island._solver.m_velocityConstraints);
          if (allowSleep) {
            var minSleepTime = b2_maxFloat;
            var linTolSqr = b2_linearSleepTolerance * b2_linearSleepTolerance;
            var angTolSqr = b2_angularSleepTolerance * b2_angularSleepTolerance;
            for (var i = 0; i < this.m_bodyCount; ++i) {
              var b = this.m_bodies[i];
              if (b.GetType() == b2Body.b2_staticBody) continue;
              if (0 == (b.m_flags & b2Body.e_autoSleepFlag) || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Dot_v2_v2(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                b.m_sleepTime = 0;
                minSleepTime = 0;
              } else {
                b.m_sleepTime += h;
                minSleepTime = b2Min(minSleepTime, b.m_sleepTime);
              }
            }
            if (minSleepTime >= b2_timeToSleep && positionSolved) for (var i = 0; i < this.m_bodyCount; ++i) {
              var b = this.m_bodies[i];
              b.SetAwake(false);
            }
          }
        },
        SolveTOI: function(subStep, toiIndexA, toiIndexB) {
          b2Assert(toiIndexA < this.m_bodyCount);
          b2Assert(toiIndexB < this.m_bodyCount);
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            this.m_positions[i].c.Assign(b.m_sweep.c);
            this.m_positions[i].a = b.m_sweep.a;
            this.m_velocities[i].v.Assign(b.m_linearVelocity);
            this.m_velocities[i].w = b.m_angularVelocity;
          }
          b2Island._solverDef.contacts = this.m_contacts;
          b2Island._solverDef.count = this.m_contactCount;
          b2Island._solverDef.step = subStep;
          b2Island._solverDef.positions = this.m_positions;
          b2Island._solverDef.velocities = this.m_velocities;
          b2Island._solver.Init(b2Island._solverDef);
          for (var i = 0; i < subStep.positionIterations; ++i) {
            var contactsOkay = b2Island._solver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);
            if (contactsOkay) break;
          }
          this.m_bodies[toiIndexA].m_sweep.c0.Assign(this.m_positions[toiIndexA].c);
          this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;
          this.m_bodies[toiIndexB].m_sweep.c0.Assign(this.m_positions[toiIndexB].c);
          this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;
          b2Island._solver.InitializeVelocityConstraints();
          for (var i = 0; i < subStep.velocityIterations; ++i) b2Island._solver.SolveVelocityConstraints();
          var h = subStep.dt;
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var c = this.m_positions[i].c;
            var a = this.m_positions[i].a;
            var v = this.m_velocities[i].v;
            var w = this.m_velocities[i].w;
            var translation = b2Vec2.Multiply(h, v);
            if (b2Dot_v2_v2(translation, translation) > b2_maxTranslationSquared) {
              var ratio = b2_maxTranslation / translation.Length();
              v.Multiply(ratio);
            }
            var rotation = h * w;
            if (rotation * rotation > b2_maxRotationSquared) {
              var ratio = b2_maxRotation / b2Abs(rotation);
              w *= ratio;
            }
            c.Add(b2Vec2.Multiply(h, v));
            a += h * w;
            this.m_positions[i].a = a;
            this.m_velocities[i].w = w;
            var body = this.m_bodies[i];
            body.m_sweep.c.Assign(c);
            body.m_sweep.a = a;
            body.m_linearVelocity.Assign(v);
            body.m_angularVelocity = w;
            body.SynchronizeTransform();
          }
          this.Report(b2Island._solver.m_velocityConstraints);
        },
        AddBody: function(body) {
          b2Assert(this.m_bodyCount < this.m_bodyCapacity);
          body.m_islandIndex = this.m_bodyCount;
          this.m_bodies[this.m_bodyCount] = body;
          if (!this.m_positions[this.m_bodyCount]) {
            this.m_positions[this.m_bodyCount] = new b2Position();
            this.m_velocities[this.m_bodyCount] = new b2Velocity();
          }
          ++this.m_bodyCount;
        },
        AddContact: function(contact) {
          b2Assert(this.m_contactCount < this.m_contactCapacity);
          this.m_contacts[this.m_contactCount++] = contact;
        },
        AddJoint: function(joint) {
          b2Assert(this.m_jointCount < this.m_jointCapacity);
          this.m_joints[this.m_jointCount++] = joint;
        },
        Report: function(constraints) {
          if (null == this.m_listener) return;
          for (var i = 0; i < this.m_contactCount; ++i) {
            var c = this.m_contacts[i];
            var vc = constraints[i];
            var impulse = new b2ContactImpulse();
            impulse.count = vc.pointCount;
            for (var j = 0; j < vc.pointCount; ++j) {
              impulse.normalImpulses[j] = vc.points[j].normalImpulse;
              impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
            }
            this.m_listener.PostSolve(c, impulse);
          }
        }
      };
      function b2Jacobian() {
        this.linear = new b2Vec2();
        this.angularA = 0;
        this.angularB = 0;
      }
      function b2JointEdge() {
        this.other = null;
        this.joint = null;
        this.prev = null;
        this.next = null;
      }
      function b2JointDef() {
        this.type = b2Joint.e_unknownJoint;
        this.userData = null;
        this.bodyA = null;
        this.bodyB = null;
        this.collideConnected = false;
      }
      b2JointDef.prototype = {
        _deserialize: function(data, bodies, joints) {
          this.bodyA = bodies[data["bodyA"]];
          this.bodyB = bodies[data["bodyB"]];
          this.collideConnected = data["collideConnected"];
        }
      };
      function b2Joint(def) {
        b2Assert(def.bodyA != def.bodyB);
        this.m_type = def.type;
        this.m_prev = null;
        this.m_next = null;
        this.m_bodyA = def.bodyA;
        this.m_bodyB = def.bodyB;
        this.m_index = 0;
        this.m_collideConnected = def.collideConnected;
        this.m_islandFlag = false;
        this.m_userData = def.userData;
        this.m_edgeA = new b2JointEdge();
        this.m_edgeA.joint = null;
        this.m_edgeA.other = null;
        this.m_edgeA.prev = null;
        this.m_edgeA.next = null;
        this.m_edgeB = new b2JointEdge();
        this.m_edgeB.joint = null;
        this.m_edgeB.other = null;
        this.m_edgeB.prev = null;
        this.m_edgeB.next = null;
      }
      b2Joint.prototype = {
        GetType: function() {
          return this.m_type;
        },
        GetBodyA: function() {
          return this.m_bodyA;
        },
        GetBodyB: function() {
          return this.m_bodyB;
        },
        GetAnchorA: function() {},
        GetAnchorB: function() {},
        GetReactionForce: function(inv_dt) {},
        GetReactionTorque: function(inv_dt) {},
        GetNext: function() {
          return this.m_next;
        },
        GetUserData: function() {
          return this.m_userData;
        },
        SetUserData: function(data) {
          this.m_userData = data;
        },
        IsActive: function() {
          return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
        },
        GetCollideConnected: function() {
          return this.m_collideConnected;
        },
        ShiftOrigin: function(newOrigin) {},
        InitVelocityConstraints: function(data) {},
        SolveVelocityConstraints: function(data) {},
        SolvePositionConstraints: function(data) {},
        _serialize: function(out) {
          var obj = out || {};
          obj["bodyA"] = null;
          obj["bodyB"] = null;
          obj["type"] = this.m_type;
          obj["collideConnected"] = this.m_collideConnected;
          return obj;
        }
      };
      b2Joint.e_inactiveLimit = 0;
      b2Joint.e_atLowerLimit = 1;
      b2Joint.e_atUpperLimit = 2;
      b2Joint.e_equalLimits = 3;
      b2Joint.e_unknownJoint = 0;
      b2Joint.e_revoluteJoint = 1;
      b2Joint.e_prismaticJoint = 2;
      b2Joint.e_distanceJoint = 3;
      b2Joint.e_pulleyJoint = 4;
      b2Joint.e_mouseJoint = 5;
      b2Joint.e_gearJoint = 6;
      b2Joint.e_wheelJoint = 7;
      b2Joint.e_weldJoint = 8;
      b2Joint.e_frictionJoint = 9;
      b2Joint.e_ropeJoint = 10;
      b2Joint.e_motorJoint = 11;
      b2Joint.Create = function(def) {
        var joint = null;
        switch (def.type) {
         case b2Joint.e_distanceJoint:
          joint = new b2DistanceJoint(def);
          break;

         case b2Joint.e_mouseJoint:
          joint = new b2MouseJoint(def);
          break;

         case b2Joint.e_prismaticJoint:
          joint = new b2PrismaticJoint(def);
          break;

         case b2Joint.e_revoluteJoint:
          joint = new b2RevoluteJoint(def);
          break;

         case b2Joint.e_pulleyJoint:
          joint = new b2PulleyJoint(def);
          break;

         case b2Joint.e_gearJoint:
          joint = new b2GearJoint(def);
          break;

         case b2Joint.e_wheelJoint:
          joint = new b2WheelJoint(def);
          break;

         case b2Joint.e_weldJoint:
          joint = new b2WeldJoint(def);
          break;

         case b2Joint.e_frictionJoint:
          joint = new b2FrictionJoint(def);
          break;

         case b2Joint.e_ropeJoint:
          joint = new b2RopeJoint(def);
          break;

         case b2Joint.e_motorJoint:
          joint = new b2MotorJoint(def);
          break;

         default:
          b2Assert(false);
        }
        return joint;
      };
      b2Joint.Destroy = function(joint) {};
      function b2RevoluteJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_revoluteJoint;
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.referenceAngle = 0;
        this.lowerAngle = 0;
        this.upperAngle = 0;
        this.maxMotorTorque = 0;
        this.motorSpeed = 0;
        this.enableLimit = false;
        this.enableMotor = false;
        Object.seal(this);
      }
      b2RevoluteJointDef.prototype = {
        Initialize: function(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
          this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.referenceAngle = data["referenceAngle"];
          this.lowerAngle = data["lowerAngle"];
          this.upperAngle = data["upperAngle"];
          this.maxMotorTorque = data["maxMotorTorque"];
          this.motorSpeed = data["motorSpeed"];
          this.enableLimit = data["enableLimit"];
          this.enableMotor = data["enableMotor"];
        }
      };
      b2RevoluteJointDef._extend(b2JointDef);
      function b2RevoluteJoint(def) {
        this.parent.call(this, def);
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse = new b2Vec3();
        this.m_motorImpulse = 0;
        this.m_lowerAngle = def.lowerAngle;
        this.m_upperAngle = def.upperAngle;
        this.m_maxMotorTorque = def.maxMotorTorque;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_rA = new b2Vec2();
        this.m_rB = new b2Vec2();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_mass = new b2Mat33();
        this.m_motorMass = 0;
      }
      b2RevoluteJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetLocalAnchorA: function() {
          return this.m_localAnchorA;
        },
        GetLocalAnchorB: function() {
          return this.m_localAnchorB;
        },
        GetReferenceAngle: function() {
          return this.m_referenceAngle;
        },
        GetJointAngle: function() {
          var bA = this.m_bodyA;
          var bB = this.m_bodyB;
          return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
        },
        GetJointSpeed: function() {
          var bA = this.m_bodyA;
          var bB = this.m_bodyB;
          return bB.m_angularVelocity - bA.m_angularVelocity;
        },
        IsLimitEnabled: function() {
          return this.m_enableLimit;
        },
        EnableLimit: function(flag) {
          if (flag != this.m_enableLimit) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_enableLimit = flag;
            this.m_impulse.z = 0;
          }
        },
        GetLowerLimit: function() {
          return this.m_lowerAngle;
        },
        GetUpperLimit: function() {
          return this.m_upperAngle;
        },
        SetLimits: function(lower, upper) {
          b2Assert(lower <= upper);
          if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_impulse.z = 0;
            this.m_lowerAngle = lower;
            this.m_upperAngle = upper;
          }
        },
        IsMotorEnabled: function() {
          return this.m_enableMotor;
        },
        EnableMotor: function(flag) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_enableMotor = flag;
        },
        SetMotorSpeed: function(speed) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_motorSpeed = speed;
        },
        GetMotorSpeed: function() {
          return this.m_motorSpeed;
        },
        SetMaxMotorTorque: function(torque) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_maxMotorTorque = torque;
        },
        GetMaxMotorTorque: function() {
          return this.m_maxMotorTorque;
        },
        GetReactionForce: function(inv_dt) {
          var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
          return b2Vec2.Multiply(inv_dt, P);
        },
        GetReactionTorque: function(inv_dt) {
          return inv_dt * this.m_impulse.z;
        },
        GetMotorTorque: function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
          this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          this.m_rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          this.m_rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var fixedRotation = iA + iB == 0;
          this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
          this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
          this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
          this.m_mass.ex.y = this.m_mass.ey.x;
          this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
          this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
          this.m_mass.ex.z = this.m_mass.ez.x;
          this.m_mass.ey.z = this.m_mass.ez.y;
          this.m_mass.ez.z = iA + iB;
          this.m_motorMass = iA + iB;
          this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
          (false == this.m_enableMotor || fixedRotation) && (this.m_motorImpulse = 0);
          if (this.m_enableLimit && false == fixedRotation) {
            var jointAngle = aB - aA - this.m_referenceAngle;
            if (b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2_angularSlop) this.m_limitState = b2Joint.e_equalLimits; else if (jointAngle <= this.m_lowerAngle) {
              this.m_limitState != b2Joint.e_atLowerLimit && (this.m_impulse.z = 0);
              this.m_limitState = b2Joint.e_atLowerLimit;
            } else if (jointAngle >= this.m_upperAngle) {
              this.m_limitState != b2Joint.e_atUpperLimit && (this.m_impulse.z = 0);
              this.m_limitState = b2Joint.e_atUpperLimit;
            } else {
              this.m_limitState = b2Joint.e_inactiveLimit;
              this.m_impulse.z = 0;
            }
          } else this.m_limitState = b2Joint.e_inactiveLimit;
          if (data.step.warmStarting) {
            this.m_impulse.Multiply(data.step.dtRatio);
            this.m_motorImpulse *= data.step.dtRatio;
            var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);
          } else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0;
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var fixedRotation = iA + iB == 0;
          if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits && false == fixedRotation) {
            var Cdot = wB - wA - this.m_motorSpeed;
            var impulse = -this.m_motorMass * Cdot;
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = data.step.dt * this.m_maxMotorTorque;
            this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            wA -= iA * impulse;
            wB += iB * impulse;
          }
          if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit && false == fixedRotation) {
            var Cdot1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
            var Cdot2 = wB - wA;
            var Cdot = new b2Vec3(Cdot1.x, Cdot1.y, Cdot2);
            var impulse = this.m_mass.Solve33(Cdot).Negate();
            if (this.m_limitState == b2Joint.e_equalLimits) this.m_impulse.Add(impulse); else if (this.m_limitState == b2Joint.e_atLowerLimit) {
              var newImpulse = this.m_impulse.z + impulse.z;
              if (newImpulse < 0) {
                var rhs = b2Vec2.Add(Cdot1.Negate(), b2Vec2.Multiply(this.m_impulse.z, new b2Vec2(this.m_mass.ez.x, this.m_mass.ez.y)));
                var reduced = this.m_mass.Solve22(rhs);
                impulse.x = reduced.x;
                impulse.y = reduced.y;
                impulse.z = -this.m_impulse.z;
                this.m_impulse.x += reduced.x;
                this.m_impulse.y += reduced.y;
                this.m_impulse.z = 0;
              } else this.m_impulse.Add(impulse);
            } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
              var newImpulse = this.m_impulse.z + impulse.z;
              if (newImpulse > 0) {
                var rhs = b2Vec2.Add(Cdot1.Negate(), b2Vec2.Multiply(this.m_impulse.z, new b2Vec2(this.m_mass.ez.x, this.m_mass.ez.y)));
                var reduced = this.m_mass.Solve22(rhs);
                impulse.x = reduced.x;
                impulse.y = reduced.y;
                impulse.z = -this.m_impulse.z;
                this.m_impulse.x += reduced.x;
                this.m_impulse.y += reduced.y;
                this.m_impulse.z = 0;
              } else this.m_impulse.Add(impulse);
            }
            var P = new b2Vec2(impulse.x, impulse.y);
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + impulse.z);
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * (b2Cross_v2_v2(this.m_rB, P) + impulse.z);
          } else {
            var Cdot = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
            var impulse = this.m_mass.Solve22(Cdot.Negate());
            this.m_impulse.x += impulse.x;
            this.m_impulse.y += impulse.y;
            vA.Subtract(b2Vec2.Multiply(mA, impulse));
            wA -= iA * b2Cross_v2_v2(this.m_rA, impulse);
            vB.Add(b2Vec2.Multiply(mB, impulse));
            wB += iB * b2Cross_v2_v2(this.m_rB, impulse);
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var angularError = 0;
          var positionError = 0;
          var fixedRotation = this.m_invIA + this.m_invIB == 0;
          if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit && false == fixedRotation) {
            var angle = aB - aA - this.m_referenceAngle;
            var limitImpulse = 0;
            if (this.m_limitState == b2Joint.e_equalLimits) {
              var C = b2Clamp(angle - this.m_lowerAngle, -b2_maxAngularCorrection, b2_maxAngularCorrection);
              limitImpulse = -this.m_motorMass * C;
              angularError = b2Abs(C);
            } else if (this.m_limitState == b2Joint.e_atLowerLimit) {
              var C = angle - this.m_lowerAngle;
              angularError = -C;
              C = b2Clamp(C + b2_angularSlop, -b2_maxAngularCorrection, 0);
              limitImpulse = -this.m_motorMass * C;
            } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
              var C = angle - this.m_upperAngle;
              angularError = C;
              C = b2Clamp(C - b2_angularSlop, 0, b2_maxAngularCorrection);
              limitImpulse = -this.m_motorMass * C;
            }
            aA -= this.m_invIA * limitImpulse;
            aB += this.m_invIB * limitImpulse;
          }
          qA.Set(aA);
          qB.Set(aB);
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var C = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
          positionError = C.Length();
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = new b2Mat22();
          K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
          K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
          var impulse = K.Solve(C).Negate();
          cA.Subtract(b2Vec2.Multiply(mA, impulse));
          aA -= iA * b2Cross_v2_v2(rA, impulse);
          cB.Add(b2Vec2.Multiply(mB, impulse));
          aB += iB * b2Cross_v2_v2(rB, impulse);
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["referenceAngle"] = this.m_referenceAngle;
          obj["lowerAngle"] = this.m_lowerAngle;
          obj["upperAngle"] = this.m_upperAngle;
          obj["maxMotorTorque"] = this.m_maxMotorTorque;
          obj["motorSpeed"] = this.m_motorSpeed;
          obj["enableLimit"] = this.m_enableLimit;
          obj["enableMotor"] = this.m_enableMotor;
          return obj;
        }
      };
      b2RevoluteJoint._extend(b2Joint);
      function b2MouseJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_mouseJoint;
        this.target = new b2Vec2(0, 0);
        this.maxForce = 0;
        this.frequencyHz = 5;
        this.dampingRatio = .7;
        Object.seal(this);
      }
      b2MouseJointDef._extend(b2JointDef);
      function b2MouseJoint(def) {
        this.parent.call(this, def);
        b2Assert(def.target.IsValid());
        b2Assert(b2IsValid(def.maxForce) && def.maxForce >= 0);
        b2Assert(b2IsValid(def.frequencyHz) && def.frequencyHz >= 0);
        b2Assert(b2IsValid(def.dampingRatio) && def.dampingRatio >= 0);
        this.m_targetA = def.target.Clone();
        this.m_localAnchorB = b2MulT_t_v2(this.m_bodyB.GetTransform(), this.m_targetA);
        this.m_maxForce = def.maxForce;
        this.m_impulse = new b2Vec2();
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_beta = 0;
        this.m_gamma = 0;
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_rB = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassB = 0;
        this.m_invIB = 0;
        this.m_mass = new b2Mat22();
        this.m_C = new b2Vec2();
      }
      b2MouseJoint.prototype = {
        GetAnchorA: function() {
          return this.m_targetA;
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          return b2Vec2.Multiply(inv_dt, this.m_impulse);
        },
        GetReactionTorque: function(inv_dt) {
          return 0 * inv_dt;
        },
        SetTarget: function(target) {
          false == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(true);
          this.m_targetA.Assign(target);
        },
        GetTarget: function() {
          return this.m_targetA;
        },
        SetMaxForce: function(force) {
          this.m_maxForce = force;
        },
        GetMaxForce: function() {
          return this.m_maxForce;
        },
        SetFrequency: function(hz) {
          this.m_frequencyHz = hz;
        },
        GetFrequency: function() {
          return this.m_frequencyHz;
        },
        SetDampingRatio: function(ratio) {
          this.m_dampingRatio = ratio;
        },
        GetDampingRatio: function() {
          return this.m_dampingRatio;
        },
        ShiftOrigin: function(newOrigin) {
          this.m_targetA.Subtract(newOrigin);
        },
        InitVelocityConstraints: function(data) {
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIB = this.m_bodyB.m_invI;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qB = new b2Rot(aB);
          var mass = this.m_bodyB.GetMass();
          var omega = 2 * b2_pi * this.m_frequencyHz;
          var d = 2 * mass * this.m_dampingRatio * omega;
          var k = mass * (omega * omega);
          var h = data.step.dt;
          b2Assert(d + h * k > b2_epsilon);
          this.m_gamma = h * (d + h * k);
          0 != this.m_gamma && (this.m_gamma = 1 / this.m_gamma);
          this.m_beta = h * k * this.m_gamma;
          this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
          var K = new b2Mat22();
          K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
          K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
          this.m_mass.Assign(K.GetInverse());
          this.m_C.Assign(b2Vec2.Subtract(b2Vec2.Add(cB, this.m_rB), this.m_targetA));
          this.m_C.Multiply(this.m_beta);
          wB *= .98;
          if (data.step.warmStarting) {
            this.m_impulse.Multiply(data.step.dtRatio);
            vB.Add(b2Vec2.Multiply(this.m_invMassB, this.m_impulse));
            wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, this.m_impulse);
          } else this.m_impulse.SetZero();
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var Cdot = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
          var impulse = b2Mul_m22_v2(this.m_mass, b2Vec2.Add(b2Vec2.Add(Cdot, this.m_C), b2Vec2.Multiply(this.m_gamma, this.m_impulse)).Negate());
          var oldImpulse = this.m_impulse.Clone();
          this.m_impulse.Add(impulse);
          var maxImpulse = data.step.dt * this.m_maxForce;
          this.m_impulse.LengthSquared() > maxImpulse * maxImpulse && this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
          impulse.Assign(b2Vec2.Subtract(this.m_impulse, oldImpulse));
          vB.Add(b2Vec2.Multiply(this.m_invMassB, impulse));
          wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, impulse);
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          return true;
        }
      };
      b2MouseJoint._extend(b2Joint);
      function b2DistanceJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_distanceJoint;
        this.localAnchorA = new b2Vec2(0, 0);
        this.localAnchorB = new b2Vec2(0, 0);
        this.length = 1;
        this.frequencyHz = 0;
        this.dampingRatio = 0;
        Object.seal(this);
      }
      b2DistanceJointDef.prototype = {
        Initialize: function(b1, b2, anchor1, anchor2) {
          this.bodyA = b1;
          this.bodyB = b2;
          this.localAnchorA = this.bodyA.GetLocalPoint(anchor1);
          this.localAnchorB = this.bodyB.GetLocalPoint(anchor2);
          var d = b2Vec2.Subtract(anchor2, anchor1);
          this.length = d.Length();
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.length = data["length"];
          this.frequencyHz = data["frequencyHz"];
          this.dampingRatio = data["dampingRatio"];
        }
      };
      b2DistanceJointDef._extend(b2JointDef);
      function b2DistanceJoint(def) {
        this.parent.call(this, def);
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_length = def.length;
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_impulse = 0;
        this.m_gamma = 0;
        this.m_bias = 0;
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_u = new b2Vec2();
        this.m_rA = new b2Vec2();
        this.m_rB = new b2Vec2();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_mass = 0;
      }
      b2DistanceJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          var F = b2Vec2.Multiply(inv_dt * this.m_impulse, this.m_u);
          return F;
        },
        GetReactionTorque: function(inv_dt) {
          return 0;
        },
        GetLocalAnchorA: function() {
          return this.m_localAnchorA;
        },
        GetLocalAnchorB: function() {
          return this.m_localAnchorB;
        },
        SetLength: function(length) {
          this.m_length = length;
        },
        GetLength: function() {
          return this.m_length;
        },
        SetFrequency: function(hz) {
          this.m_frequencyHz = hz;
        },
        GetFrequency: function() {
          return this.m_frequencyHz;
        },
        SetDampingRatio: function(ratio) {
          this.m_dampingRatio = ratio;
        },
        GetDampingRatio: function() {
          return this.m_dampingRatio;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          this.m_rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          this.m_rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          this.m_u = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, this.m_rB), cA), this.m_rA);
          var length = this.m_u.Length();
          length > b2_linearSlop ? this.m_u.Multiply(1 / length) : this.m_u.Set(0, 0);
          var crAu = b2Cross_v2_v2(this.m_rA, this.m_u);
          var crBu = b2Cross_v2_v2(this.m_rB, this.m_u);
          var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
          this.m_mass = 0 != invMass ? 1 / invMass : 0;
          if (this.m_frequencyHz > 0) {
            var C = length - this.m_length;
            var omega = 2 * b2_pi * this.m_frequencyHz;
            var d = 2 * this.m_mass * this.m_dampingRatio * omega;
            var k = this.m_mass * omega * omega;
            var h = data.step.dt;
            this.m_gamma = h * (d + h * k);
            this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
            this.m_bias = C * h * k * this.m_gamma;
            invMass += this.m_gamma;
            this.m_mass = 0 != invMass ? 1 / invMass : 0;
          } else {
            this.m_gamma = 0;
            this.m_bias = 0;
          }
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            var P = b2Vec2.Multiply(this.m_impulse, this.m_u);
            vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
            wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
            vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
            wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var vpA = b2Vec2.Add(vA, b2Cross_f_v2(wA, this.m_rA));
          var vpB = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
          var Cdot = b2Dot_v2_v2(this.m_u, b2Vec2.Subtract(vpB, vpA));
          var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
          this.m_impulse += impulse;
          var P = b2Vec2.Multiply(impulse, this.m_u);
          vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
          wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
          vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
          wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          if (this.m_frequencyHz > 0) return true;
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var u = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
          var length = u.Normalize();
          var C = length - this.m_length;
          C = b2Clamp(C, -b2_maxLinearCorrection, b2_maxLinearCorrection);
          var impulse = -this.m_mass * C;
          var P = b2Vec2.Multiply(impulse, u);
          cA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
          aA -= this.m_invIA * b2Cross_v2_v2(rA, P);
          cB.Add(b2Vec2.Multiply(this.m_invMassB, P));
          aB += this.m_invIB * b2Cross_v2_v2(rB, P);
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          return b2Abs(C) < b2_linearSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["length"] = this.m_length;
          obj["frequencyHz"] = this.m_frequencyHz;
          obj["dampingRatio"] = this.m_dampingRatio;
          return obj;
        }
      };
      b2DistanceJoint._extend(b2Joint);
      function b2PrismaticJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_prismaticJoint;
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2(1, 0);
        this.referenceAngle = 0;
        this.enableLimit = false;
        this.lowerTranslation = 0;
        this.upperTranslation = 0;
        this.enableMotor = false;
        this.maxMotorForce = 0;
        this.motorSpeed = 0;
        Object.seal(this);
      }
      b2PrismaticJointDef.prototype = {
        Initialize: function(bA, bB, anchor, axis) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
          this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
          this.localAxisA = this.bodyA.GetLocalVector(axis);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.localAxisA._deserialize(data["localAxisA"]);
          this.referenceAngle = data["referenceAngle"];
          this.enableLimit = data["enableLimit"];
          this.lowerTranslation = data["lowerTranslation"];
          this.upperTranslation = data["upperTranslation"];
          this.enableMotor = data["enableMotor"];
          this.maxMotorForce = data["maxMotorForce"];
          this.motorSpeed = data["motorSpeed"];
        }
      };
      b2PrismaticJointDef._extend(b2JointDef);
      function b2PrismaticJoint(def) {
        this.parent.call(this, def);
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_localXAxisA = def.localAxisA.Clone();
        this.m_localXAxisA.Normalize();
        this.m_localYAxisA = b2Cross_f_v2(1, this.m_localXAxisA);
        this.m_referenceAngle = def.referenceAngle;
        this.m_impulse = new b2Vec3();
        this.m_motorMass = 0;
        this.m_motorImpulse = 0;
        this.m_lowerTranslation = def.lowerTranslation;
        this.m_upperTranslation = def.upperTranslation;
        this.m_maxMotorForce = def.maxMotorForce;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableLimit = def.enableLimit;
        this.m_enableMotor = def.enableMotor;
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_axis = new b2Vec2();
        this.m_perp = new b2Vec2();
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_s1 = 0, this.m_s2 = 0;
        this.m_a1 = 0, this.m_a2 = 0;
        this.m_K = new b2Mat33();
        this.m_motorMass = 0;
      }
      b2PrismaticJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          return b2Vec2.Multiply(inv_dt, b2Vec2.Add(b2Vec2.Multiply(this.m_impulse.x, this.m_perp), b2Vec2.Multiply(this.m_motorImpulse + this.m_impulse.z, this.m_axis)));
        },
        GetReactionTorque: function(inv_dt) {
          return inv_dt * this.m_impulse.y;
        },
        GetLocalAnchorA: function() {
          return this.m_localAnchorA;
        },
        GetLocalAnchorB: function() {
          return this.m_localAnchorB;
        },
        GetLocalAxisA: function() {
          return this.m_localXAxisA;
        },
        GetReferenceAngle: function() {
          return this.m_referenceAngle;
        },
        GetJointTranslation: function() {
          var pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
          var pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
          var d = b2Vec2.Subtract(pB, pA);
          var axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA);
          var translation = b2Dot_v2_v2(d, axis);
          return translation;
        },
        GetJointSpeed: function() {
          var bA = this.m_bodyA;
          var bB = this.m_bodyB;
          var rA = b2Mul_r_v2(bA.m_xf.q, b2Vec2.Subtract(this.m_localAnchorA, bA.m_sweep.localCenter));
          var rB = b2Mul_r_v2(bB.m_xf.q, b2Vec2.Subtract(this.m_localAnchorB, bB.m_sweep.localCenter));
          var p1 = b2Vec2.Add(bA.m_sweep.c, rA);
          var p2 = b2Vec2.Add(bB.m_sweep.c, rB);
          var d = b2Vec2.Subtract(p2, p1);
          var axis = b2Mul_r_v2(bA.m_xf.q, this.m_localXAxisA);
          var vA = bA.m_linearVelocity;
          var vB = bB.m_linearVelocity;
          var wA = bA.m_angularVelocity;
          var wB = bB.m_angularVelocity;
          var speed = b2Dot_v2_v2(d, b2Cross_f_v2(wA, axis)) + b2Dot_v2_v2(axis, b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, rB)), vA), b2Cross_f_v2(wA, rA)));
          return speed;
        },
        IsLimitEnabled: function() {
          return this.m_enableLimit;
        },
        EnableLimit: function(flag) {
          if (flag != this.m_enableLimit) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_enableLimit = flag;
            this.m_impulse.z = 0;
          }
        },
        GetLowerLimit: function() {
          return this.m_lowerTranslation;
        },
        GetUpperLimit: function() {
          return this.m_upperTranslation;
        },
        SetLimits: function(lower, upper) {
          b2Assert(lower <= upper);
          if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_lowerTranslation = lower;
            this.m_upperTranslation = upper;
            this.m_impulse.z = 0;
          }
        },
        IsMotorEnabled: function() {
          return this.m_enableMotor;
        },
        EnableMotor: function(flag) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_enableMotor = flag;
        },
        SetMotorSpeed: function(speed) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_motorSpeed = speed;
        },
        GetMotorSpeed: function() {
          return this.m_motorSpeed;
        },
        SetMaxMotorForce: function(force) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_maxMotorForce = force;
        },
        GetMaxMotorForce: function() {
          return this.m_maxMotorForce;
        },
        GetMotorForce: function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
          this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var d = b2Vec2.Add(b2Vec2.Subtract(cB, cA), b2Vec2.Subtract(rB, rA));
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          this.m_axis = b2Mul_r_v2(qA, this.m_localXAxisA);
          this.m_a1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_axis);
          this.m_a2 = b2Cross_v2_v2(rB, this.m_axis);
          this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
          this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
          this.m_perp = b2Mul_r_v2(qA, this.m_localYAxisA);
          this.m_s1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_perp);
          this.m_s2 = b2Cross_v2_v2(rB, this.m_perp);
          var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
          var k12 = iA * this.m_s1 + iB * this.m_s2;
          var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
          var k22 = iA + iB;
          0 == k22 && (k22 = 1);
          var k23 = iA * this.m_a1 + iB * this.m_a2;
          var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
          this.m_K.ex.Set(k11, k12, k13);
          this.m_K.ey.Set(k12, k22, k23);
          this.m_K.ez.Set(k13, k23, k33);
          if (this.m_enableLimit) {
            var jointTranslation = b2Dot_v2_v2(this.m_axis, d);
            if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) this.m_limitState = b2Joint.e_equalLimits; else if (jointTranslation <= this.m_lowerTranslation) {
              if (this.m_limitState != b2Joint.e_atLowerLimit) {
                this.m_limitState = b2Joint.e_atLowerLimit;
                this.m_impulse.z = 0;
              }
            } else if (jointTranslation >= this.m_upperTranslation) {
              if (this.m_limitState != b2Joint.e_atUpperLimit) {
                this.m_limitState = b2Joint.e_atUpperLimit;
                this.m_impulse.z = 0;
              }
            } else {
              this.m_limitState = b2Joint.e_inactiveLimit;
              this.m_impulse.z = 0;
            }
          } else {
            this.m_limitState = b2Joint.e_inactiveLimit;
            this.m_impulse.z = 0;
          }
          false == this.m_enableMotor && (this.m_motorImpulse = 0);
          if (data.step.warmStarting) {
            this.m_impulse.Multiply(data.step.dtRatio);
            this.m_motorImpulse *= data.step.dtRatio;
            var P = b2Vec2.Add(b2Vec2.Multiply(this.m_impulse.x, this.m_perp), b2Vec2.Multiply(this.m_motorImpulse + this.m_impulse.z, this.m_axis));
            var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
            var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * LA;
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * LB;
          } else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0;
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
            var Cdot = b2Dot_v2_v2(this.m_axis, b2Vec2.Subtract(vB, vA)) + this.m_a2 * wB - this.m_a1 * wA;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = data.step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            var P = b2Vec2.Multiply(impulse, this.m_axis);
            var LA = impulse * this.m_a1;
            var LB = impulse * this.m_a2;
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * LA;
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * LB;
          }
          var Cdot1 = new b2Vec2();
          Cdot1.x = b2Dot_v2_v2(this.m_perp, b2Vec2.Subtract(vB, vA)) + this.m_s2 * wB - this.m_s1 * wA;
          Cdot1.y = wB - wA;
          if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
            var Cdot2;
            Cdot2 = b2Dot_v2_v2(this.m_axis, b2Vec2.Subtract(vB, vA)) + this.m_a2 * wB - this.m_a1 * wA;
            var Cdot = new b2Vec3(Cdot1.x, Cdot1.y, Cdot2);
            var f1 = this.m_impulse.Clone();
            var df = this.m_K.Solve33(Cdot.Negate());
            this.m_impulse.Add(df);
            this.m_limitState == b2Joint.e_atLowerLimit ? this.m_impulse.z = b2Max(this.m_impulse.z, 0) : this.m_limitState == b2Joint.e_atUpperLimit && (this.m_impulse.z = b2Min(this.m_impulse.z, 0));
            var b = b2Vec2.Subtract(Cdot1.Negate(), b2Vec2.Multiply(this.m_impulse.z - f1.z, new b2Vec2(this.m_K.ez.x, this.m_K.ez.y)));
            var f2r = b2Vec2.Add(this.m_K.Solve22(b), new b2Vec2(f1.x, f1.y));
            this.m_impulse.x = f2r.x;
            this.m_impulse.y = f2r.y;
            df = b2Vec3.Subtract(this.m_impulse, f1);
            var P = b2Vec2.Add(b2Vec2.Multiply(df.x, this.m_perp), b2Vec2.Multiply(df.z, this.m_axis));
            var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;
            var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * LA;
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * LB;
          } else {
            var df = this.m_K.Solve22(Cdot1.Negate());
            this.m_impulse.x += df.x;
            this.m_impulse.y += df.y;
            var P = b2Vec2.Multiply(df.x, this.m_perp);
            var LA = df.x * this.m_s1 + df.y;
            var LB = df.x * this.m_s2 + df.y;
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * LA;
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * LB;
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var d = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
          var axis = b2Mul_r_v2(qA, this.m_localXAxisA);
          var a1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), axis);
          var a2 = b2Cross_v2_v2(rB, axis);
          var perp = b2Mul_r_v2(qA, this.m_localYAxisA);
          var s1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), perp);
          var s2 = b2Cross_v2_v2(rB, perp);
          var impulse = new b2Vec3();
          var C1 = new b2Vec2();
          C1.x = b2Dot_v2_v2(perp, d);
          C1.y = aB - aA - this.m_referenceAngle;
          var linearError = b2Abs(C1.x);
          var angularError = b2Abs(C1.y);
          var active = false;
          var C2 = 0;
          if (this.m_enableLimit) {
            var translation = b2Dot_v2_v2(axis, d);
            if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) {
              C2 = b2Clamp(translation, -b2_maxLinearCorrection, b2_maxLinearCorrection);
              linearError = b2Max(linearError, b2Abs(translation));
              active = true;
            } else if (translation <= this.m_lowerTranslation) {
              C2 = b2Clamp(translation - this.m_lowerTranslation + b2_linearSlop, -b2_maxLinearCorrection, 0);
              linearError = b2Max(linearError, this.m_lowerTranslation - translation);
              active = true;
            } else if (translation >= this.m_upperTranslation) {
              C2 = b2Clamp(translation - this.m_upperTranslation - b2_linearSlop, 0, b2_maxLinearCorrection);
              linearError = b2Max(linearError, translation - this.m_upperTranslation);
              active = true;
            }
          }
          if (active) {
            var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
            var k12 = iA * s1 + iB * s2;
            var k13 = iA * s1 * a1 + iB * s2 * a2;
            var k22 = iA + iB;
            0 == k22 && (k22 = 1);
            var k23 = iA * a1 + iB * a2;
            var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
            var K = new b2Mat33();
            K.ex.Set(k11, k12, k13);
            K.ey.Set(k12, k22, k23);
            K.ez.Set(k13, k23, k33);
            var C = new b2Vec3();
            C.x = C1.x;
            C.y = C1.y;
            C.z = C2;
            impulse = K.Solve33(C.Negate());
          } else {
            var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
            var k12 = iA * s1 + iB * s2;
            var k22 = iA + iB;
            0 == k22 && (k22 = 1);
            var K = new b2Mat22();
            K.ex.Set(k11, k12);
            K.ey.Set(k12, k22);
            var impulse1 = K.Solve(C1.Negate());
            impulse.x = impulse1.x;
            impulse.y = impulse1.y;
            impulse.z = 0;
          }
          var P = b2Vec2.Add(b2Vec2.Multiply(impulse.x, perp), b2Vec2.Multiply(impulse.z, axis));
          var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
          var LB = impulse.x * s2 + impulse.y + impulse.z * a2;
          cA.Subtract(b2Vec2.Multiply(mA, P));
          aA -= iA * LA;
          cB.Add(b2Vec2.Multiply(mB, P));
          aB += iB * LB;
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          return linearError <= b2_linearSlop && angularError <= b2_angularSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["localAxisA"] = this.m_localXAxisA._serialize();
          obj["referenceAngle"] = this.m_referenceAngle;
          obj["enableLimit"] = this.m_enableLimit;
          obj["lowerTranslation"] = this.m_lowerTranslation;
          obj["upperTranslation"] = this.m_upperTranslation;
          obj["enableMotor"] = this.m_enableMotor;
          obj["maxMotorForce"] = this.m_maxMotorForce;
          obj["motorSpeed"] = this.m_motorSpeed;
          return obj;
        }
      };
      b2PrismaticJoint._extend(b2Joint);
      function b2FrictionJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_frictionJoint;
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.maxForce = 0;
        this.maxTorque = 0;
        Object.seal(this);
      }
      b2FrictionJointDef.prototype = {
        Initialize: function(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchor));
          this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchor));
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.maxForce = data["maxForce"];
          this.maxTorque = data["maxTorque"];
        }
      };
      b2FrictionJointDef._extend(b2JointDef);
      function b2FrictionJoint(def) {
        this.parent.call(this, def);
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_linearImpulse = new b2Vec2();
        this.m_angularImpulse = 0;
        this.m_maxForce = def.maxForce;
        this.m_maxTorque = def.maxTorque;
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_rA = new b2Vec2();
        this.m_rB = new b2Vec2();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_linearMass = new b2Mat22();
        this.m_angularMass = 0;
      }
      b2FrictionJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          return b2Vec2.Multiply(inv_dt, this.m_linearImpulse);
        },
        GetReactionTorque: function(inv_dt) {
          return inv_dt * this.m_angularImpulse;
        },
        GetLocalAnchorA: function() {
          return this.m_localAnchorA;
        },
        GetLocalAnchorB: function() {
          return this.m_localAnchorB;
        },
        SetMaxForce: function(force) {
          b2Assert(b2IsValid(force) && force >= 0);
          this.m_maxForce = force;
        },
        GetMaxForce: function() {
          return this.m_maxForce;
        },
        SetMaxTorque: function(torque) {
          b2Assert(b2IsValid(torque) && torque >= 0);
          this.m_maxTorque = torque;
        },
        GetMaxTorque: function() {
          return this.m_maxTorque;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          this.m_rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          this.m_rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = new b2Mat22();
          K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
          K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
          this.m_linearMass = K.GetInverse();
          this.m_angularMass = iA + iB;
          this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass);
          if (data.step.warmStarting) {
            this.m_linearImpulse.Multiply(data.step.dtRatio);
            this.m_angularImpulse *= data.step.dtRatio;
            var P = new b2Vec2(this.m_linearImpulse.x, this.m_linearImpulse.y);
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_angularImpulse);
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_angularImpulse);
          } else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0;
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var h = data.step.dt;
          var Cdot = wB - wA;
          var impulse = -this.m_angularMass * Cdot;
          var oldImpulse = this.m_angularImpulse;
          var maxImpulse = h * this.m_maxTorque;
          this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
          impulse = this.m_angularImpulse - oldImpulse;
          wA -= iA * impulse;
          wB += iB * impulse;
          var Cdot = b2Vec2.Add(vB, b2Vec2.Subtract(b2Cross_f_v2(wB, this.m_rB), b2Vec2.Subtract(vA, b2Cross_f_v2(wA, this.m_rA))));
          var impulse = b2Mul_m22_v2(this.m_linearMass, Cdot).Negate();
          var oldImpulse = this.m_linearImpulse.Clone();
          this.m_linearImpulse.Add(impulse);
          var maxImpulse = h * this.m_maxForce;
          if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
          }
          impulse = b2Vec2.Subtract(this.m_linearImpulse, oldImpulse);
          vA.Subtract(b2Vec2.Multiply(mA, impulse));
          wA -= iA * b2Cross_v2_v2(this.m_rA, impulse);
          vB.Add(b2Vec2.Multiply(mB, impulse));
          wB += iB * b2Cross_v2_v2(this.m_rB, impulse);
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          return true;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["maxForce"] = this.m_maxForce;
          obj["maxTorque"] = this.m_maxTorque;
          return obj;
        }
      };
      b2FrictionJoint._extend(b2Joint);
      function b2WeldJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_weldJoint;
        this.localAnchorA = new b2Vec2(0, 0);
        this.localAnchorB = new b2Vec2(0, 0);
        this.referenceAngle = 0;
        this.frequencyHz = 0;
        this.dampingRatio = 0;
        Object.seal(this);
      }
      b2WeldJointDef.prototype = {
        Initialize: function(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchor));
          this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchor));
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.referenceAngle = data["referenceAngle"];
          this.frequencyHz = data["frequencyHz"];
          this.dampingRatio = data["dampingRatio"];
        }
      };
      b2WeldJointDef._extend(b2JointDef);
      function b2WeldJoint(def) {
        this.parent.call(this, def);
        this.m_bias = 0;
        this.m_gamma = 0;
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_rA = new b2Vec2();
        this.m_rB = new b2Vec2();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_mass = new b2Mat33();
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_referenceAngle = def.referenceAngle;
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_impulse = new b2Vec3();
      }
      b2WeldJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
          return b2Vec2.Multiply(inv_dt, P);
        },
        GetReactionTorque: function(inv_dt) {
          return inv_dt * this.m_impulse.z;
        },
        GetLocalAnchorA: function() {
          return this.m_localAnchorA;
        },
        GetLocalAnchorB: function() {
          return this.m_localAnchorB;
        },
        GetReferenceAngle: function() {
          return this.m_referenceAngle;
        },
        SetFrequency: function(hz) {
          this.m_frequencyHz = hz;
        },
        GetFrequency: function() {
          return this.m_frequencyHz;
        },
        SetDampingRatio: function(ratio) {
          this.m_dampingRatio = ratio;
        },
        GetDampingRatio: function() {
          return this.m_dampingRatio;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          this.m_rA.Assign(b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA)));
          this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = new b2Mat33();
          K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
          K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
          K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
          K.ex.y = K.ey.x;
          K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
          K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
          K.ex.z = K.ez.x;
          K.ey.z = K.ez.y;
          K.ez.z = iA + iB;
          if (this.m_frequencyHz > 0) {
            K.GetInverse22(this.m_mass);
            var invM = iA + iB;
            var m = invM > 0 ? 1 / invM : 0;
            var C = aB - aA - this.m_referenceAngle;
            var omega = 2 * b2_pi * this.m_frequencyHz;
            var d = 2 * m * this.m_dampingRatio * omega;
            var k = m * omega * omega;
            var h = data.step.dt;
            this.m_gamma = h * (d + h * k);
            this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
            this.m_bias = C * h * k * this.m_gamma;
            invM += this.m_gamma;
            this.m_mass.ez.z = 0 != invM ? 1 / invM : 0;
          } else if (0 == K.ez.z) {
            K.GetInverse22(this.m_mass);
            this.m_gamma = 0;
            this.m_bias = 0;
          } else {
            K.GetSymInverse33(this.m_mass);
            this.m_gamma = 0;
            this.m_bias = 0;
          }
          if (data.step.warmStarting) {
            this.m_impulse.Multiply(data.step.dtRatio);
            var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_impulse.z);
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_impulse.z);
          } else this.m_impulse.SetZero();
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          if (this.m_frequencyHz > 0) {
            var Cdot2 = wB - wA;
            var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
            this.m_impulse.z += impulse2;
            wA -= iA * impulse2;
            wB += iB * impulse2;
            var Cdot1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
            var impulse1 = b2Mul22_m33_v2(this.m_mass, Cdot1).Negate();
            this.m_impulse.x += impulse1.x;
            this.m_impulse.y += impulse1.y;
            var P = impulse1.Clone();
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * b2Cross_v2_v2(this.m_rA, P);
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * b2Cross_v2_v2(this.m_rB, P);
          } else {
            var Cdot1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
            var Cdot2 = wB - wA;
            var Cdot = new b2Vec3(Cdot1.x, Cdot1.y, Cdot2);
            var impulse = b2Mul_m33_v3(this.m_mass, Cdot).Negate();
            this.m_impulse.Add(impulse);
            var P = new b2Vec2(impulse.x, impulse.y);
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + impulse.z);
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * (b2Cross_v2_v2(this.m_rB, P) + impulse.z);
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var positionError, angularError;
          var K = new b2Mat33();
          K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
          K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
          K.ez.x = -rA.y * iA - rB.y * iB;
          K.ex.y = K.ey.x;
          K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
          K.ez.y = rA.x * iA + rB.x * iB;
          K.ex.z = K.ez.x;
          K.ey.z = K.ez.y;
          K.ez.z = iA + iB;
          if (this.m_frequencyHz > 0) {
            var C1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
            positionError = C1.Length();
            angularError = 0;
            var P = K.Solve22(C1).Negate();
            cA.Subtract(b2Vec2.Multiply(mA, P));
            aA -= iA * b2Cross_v2_v2(rA, P);
            cB.Add(b2Vec2.Multiply(mB, P));
            aB += iB * b2Cross_v2_v2(rB, P);
          } else {
            var C1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
            var C2 = aB - aA - this.m_referenceAngle;
            positionError = C1.Length();
            angularError = b2Abs(C2);
            var C = new b2Vec3(C1.x, C1.y, C2);
            var impulse;
            if (K.ez.z > 0) impulse = K.Solve33(C).Invert(); else {
              var impulse2 = K.Solve22(C1).Invert();
              impulse = new b2Vec3(impulse2.x, impulse2.y, 0);
            }
            var P = new b2Vec2(impulse.x, impulse.y);
            cA.Subtract(b2Vec2.Multiply(mA, P));
            aA -= iA * (b2Cross_v2_v2(rA, P) + impulse.z);
            cB.Add(b2Vec2.Multiply(mB, P));
            aB += iB * (b2Cross_v2_v2(rB, P) + impulse.z);
          }
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["referenceAngle"] = this.m_referenceAngle;
          obj["frequencyHz"] = this.m_frequencyHz;
          obj["dampingRatio"] = this.m_dampingRatio;
          return obj;
        }
      };
      b2WeldJoint._extend(b2Joint);
      function b2WheelJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_wheelJoint;
        this.localAnchorA = new b2Vec2();
        this.localAnchorB = new b2Vec2();
        this.localAxisA = new b2Vec2(1, 0);
        this.enableMotor = false;
        this.maxMotorTorque = 0;
        this.motorSpeed = 0;
        this.frequencyHz = 2;
        this.dampingRatio = .7;
        Object.seal(this);
      }
      b2WheelJointDef.prototype = {
        Initialize: function(bA, bB, anchor, axis) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchor));
          this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchor));
          this.localAxisA.Assign(this.bodyA.GetLocalVector(axis));
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.localAxisA._deserialize(data["localAxisA"]);
          this.enableMotor = data["enableMotor"];
          this.maxMotorTorque = data["maxMotorTorque"];
          this.motorSpeed = data["motorSpeed"];
          this.frequencyHz = data["frequencyHz"];
          this.dampingRatio = data["dampingRatio"];
        }
      };
      b2WheelJointDef._extend(b2JointDef);
      function b2WheelJoint(def) {
        this.parent.call(this, def);
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_localXAxisA = def.localAxisA.Clone();
        this.m_localYAxisA = b2Cross_f_v2(1, this.m_localXAxisA);
        this.m_mass = 0;
        this.m_impulse = 0;
        this.m_motorMass = 0;
        this.m_motorImpulse = 0;
        this.m_springMass = 0;
        this.m_springImpulse = 0;
        this.m_maxMotorTorque = def.maxMotorTorque;
        this.m_motorSpeed = def.motorSpeed;
        this.m_enableMotor = def.enableMotor;
        this.m_frequencyHz = def.frequencyHz;
        this.m_dampingRatio = def.dampingRatio;
        this.m_bias = 0;
        this.m_gamma = 0;
        this.m_ax = new b2Vec2();
        this.m_ay = new b2Vec2();
        this.m_sAx = this.m_sBx = 0;
        this.m_sAy = this.m_sBy = 0;
      }
      b2WheelJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          return b2Vec2.Multiply(inv_dt, b2Vec2.Add(b2Vec2.Multiply(this.m_impulse, this.m_ay), b2Vec2.Multiply(this.m_springImpulse, this.m_ax)));
        },
        GetReactionTorque: function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        },
        GetLocalAnchorA: function() {
          return this.m_localAnchorA;
        },
        GetLocalAnchorB: function() {
          return this.m_localAnchorB;
        },
        GetLocalAxisA: function() {
          return this.m_localXAxisA;
        },
        GetJointTranslation: function() {
          var bA = this.m_bodyA;
          var bB = this.m_bodyB;
          var pA = bA.GetWorldPoint(this.m_localAnchorA);
          var pB = bB.GetWorldPoint(this.m_localAnchorB);
          var d = b2Vec2.Subtract(pB, pA);
          var axis = bA.GetWorldVector(this.m_localXAxisA);
          var translation = b2Dot_v2_v2(d, axis);
          return translation;
        },
        GetJointSpeed: function() {
          var wA = this.m_bodyA.m_angularVelocity;
          var wB = this.m_bodyB.m_angularVelocity;
          return wB - wA;
        },
        IsMotorEnabled: function() {
          return this.m_enableMotor;
        },
        EnableMotor: function(flag) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_enableMotor = flag;
        },
        SetMotorSpeed: function(speed) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_motorSpeed = speed;
        },
        GetMotorSpeed: function() {
          return this.m_motorSpeed;
        },
        SetMaxMotorTorque: function(torque) {
          this.m_bodyA.SetAwake(true);
          this.m_bodyB.SetAwake(true);
          this.m_maxMotorTorque = torque;
        },
        GetMaxMotorTorque: function() {
          return this.m_maxMotorTorque;
        },
        GetMotorTorque: function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        },
        SetSpringFrequencyHz: function(hz) {
          this.m_frequencyHz = hz;
        },
        GetSpringFrequencyHz: function() {
          return this.m_frequencyHz;
        },
        SetSpringDampingRatio: function(ratio) {
          this.m_dampingRatio = ratio;
        },
        GetSpringDampingRatio: function() {
          return this.m_dampingRatio;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var d = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
          this.m_ay.Assign(b2Mul_r_v2(qA, this.m_localYAxisA));
          this.m_sAy = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_ay);
          this.m_sBy = b2Cross_v2_v2(rB, this.m_ay);
          this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;
          this.m_mass > 0 && (this.m_mass = 1 / this.m_mass);
          this.m_springMass = 0;
          this.m_bias = 0;
          this.m_gamma = 0;
          if (this.m_frequencyHz > 0) {
            this.m_ax.Assign(b2Mul_r_v2(qA, this.m_localXAxisA));
            this.m_sAx = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_ax);
            this.m_sBx = b2Cross_v2_v2(rB, this.m_ax);
            var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;
            if (invMass > 0) {
              this.m_springMass = 1 / invMass;
              var C = b2Dot_v2_v2(d, this.m_ax);
              var omega = 2 * b2_pi * this.m_frequencyHz;
              var d = 2 * this.m_springMass * this.m_dampingRatio * omega;
              var k = this.m_springMass * omega * omega;
              var h = data.step.dt;
              this.m_gamma = h * (d + h * k);
              this.m_gamma > 0 && (this.m_gamma = 1 / this.m_gamma);
              this.m_bias = C * h * k * this.m_gamma;
              this.m_springMass = invMass + this.m_gamma;
              this.m_springMass > 0 && (this.m_springMass = 1 / this.m_springMass);
            }
          } else this.m_springImpulse = 0;
          if (this.m_enableMotor) {
            this.m_motorMass = iA + iB;
            this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
          } else {
            this.m_motorMass = 0;
            this.m_motorImpulse = 0;
          }
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            this.m_springImpulse *= data.step.dtRatio;
            this.m_motorImpulse *= data.step.dtRatio;
            var P = b2Vec2.Add(b2Vec2.Multiply(this.m_impulse, this.m_ay), b2Vec2.Multiply(this.m_springImpulse, this.m_ax));
            var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
            var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
            vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
            wA -= this.m_invIA * LA;
            vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
            wB += this.m_invIB * LB;
          } else {
            this.m_impulse = 0;
            this.m_springImpulse = 0;
            this.m_motorImpulse = 0;
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var Cdot = b2Dot_v2_v2(this.m_ax, b2Vec2.Subtract(vB, vA)) + this.m_sBx * wB - this.m_sAx * wA;
          var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
          this.m_springImpulse += impulse;
          var P = b2Vec2.Multiply(impulse, this.m_ax);
          var LA = impulse * this.m_sAx;
          var LB = impulse * this.m_sBx;
          vA.Subtract(b2Vec2.Multiply(mA, P));
          wA -= iA * LA;
          vB.Add(b2Vec2.Multiply(mB, P));
          wB += iB * LB;
          var Cdot = wB - wA - this.m_motorSpeed;
          var impulse = -this.m_motorMass * Cdot;
          var oldImpulse = this.m_motorImpulse;
          var maxImpulse = data.step.dt * this.m_maxMotorTorque;
          this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
          impulse = this.m_motorImpulse - oldImpulse;
          wA -= iA * impulse;
          wB += iB * impulse;
          var Cdot = b2Dot_v2_v2(this.m_ay, b2Vec2.Subtract(vB, vA)) + this.m_sBy * wB - this.m_sAy * wA;
          var impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          var P = b2Vec2.Multiply(impulse, this.m_ay);
          var LA = impulse * this.m_sAy;
          var LB = impulse * this.m_sBy;
          vA.Subtract(b2Vec2.Multiply(mA, P));
          wA -= iA * LA;
          vB.Add(b2Vec2.Multiply(mB, P));
          wB += iB * LB;
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var d = b2Vec2.Add(b2Vec2.Subtract(cB, cA), b2Vec2.Subtract(rB, rA));
          var ay = b2Mul_r_v2(qA, this.m_localYAxisA);
          var sAy = b2Cross_v2_v2(b2Vec2.Add(d, rA), ay);
          var sBy = b2Cross_v2_v2(rB, ay);
          var C = b2Dot_v2_v2(d, ay);
          var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
          var impulse;
          impulse = 0 != k ? -C / k : 0;
          var P = b2Vec2.Multiply(impulse, ay);
          var LA = impulse * sAy;
          var LB = impulse * sBy;
          cA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
          aA -= this.m_invIA * LA;
          cB.Add(b2Vec2.Multiply(this.m_invMassB, P));
          aB += this.m_invIB * LB;
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          return b2Abs(C) <= b2_linearSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["localAxisA"] = this.m_localAxisA._serialize();
          obj["enableMotor"] = this.m_enableMotor;
          obj["maxMotorTorque"] = this.m_maxMotorTorque;
          obj["motorSpeed"] = this.m_motorSpeed;
          obj["frequencyHz"] = this.m_frequencyHz;
          obj["dampingRatio"] = this.m_dampingRatio;
          return obj;
        }
      };
      b2WheelJoint._extend(b2Joint);
      function b2GearJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_gearJoint;
        this.joint1 = null;
        this.joint2 = null;
        this.ratio = 1;
        Object.seal(this);
      }
      b2GearJointDef.prototype = {
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.joint1 = data["joint1"];
          this.joint2 = data["joint2"];
          this.ratio = data["ratio"];
        }
      };
      b2GearJointDef._extend(b2JointDef);
      function b2GearJoint(def) {
        this.parent.call(this, def);
        this.m_joint1 = def.joint1;
        this.m_joint2 = def.joint2;
        this.m_typeA = this.m_joint1.GetType();
        this.m_typeB = this.m_joint2.GetType();
        b2Assert(this.m_typeA == b2Joint.e_revoluteJoint || this.m_typeA == b2Joint.e_prismaticJoint);
        b2Assert(this.m_typeB == b2Joint.e_revoluteJoint || this.m_typeB == b2Joint.e_prismaticJoint);
        var coordinateA, coordinateB;
        this.m_bodyC = this.m_joint1.GetBodyA();
        this.m_bodyA = this.m_joint1.GetBodyB();
        var xfA = this.m_bodyA.m_xf;
        var aA = this.m_bodyA.m_sweep.a;
        var xfC = this.m_bodyC.m_xf;
        var aC = this.m_bodyC.m_sweep.a;
        this.m_localAnchorA = new b2Vec2();
        this.m_localAnchorB = new b2Vec2();
        this.m_localAnchorC = new b2Vec2();
        this.m_localAnchorD = new b2Vec2();
        this.m_localAxisC = new b2Vec2();
        this.m_localAxisD = new b2Vec2();
        if (this.m_typeA == b2Joint.e_revoluteJoint) {
          var revolute = def.joint1;
          this.m_localAnchorC.Assign(revolute.m_localAnchorA);
          this.m_localAnchorA.Assign(revolute.m_localAnchorB);
          this.m_referenceAngleA = revolute.m_referenceAngle;
          this.m_localAxisC.SetZero();
          coordinateA = aA - aC - this.m_referenceAngleA;
        } else {
          var prismatic = def.joint1;
          this.m_localAnchorC.Assign(prismatic.m_localAnchorA);
          this.m_localAnchorA.Assign(prismatic.m_localAnchorB);
          this.m_referenceAngleA = prismatic.m_referenceAngle;
          this.m_localAxisC.Assign(prismatic.m_localXAxisA);
          var pC = this.m_localAnchorC;
          var pA = b2MulT_r_v2(xfC.q, b2Vec2.Add(b2Mul_r_v2(xfA.q, this.m_localAnchorA), b2Vec2.Subtract(xfA.p, xfC.p)));
          coordinateA = b2Dot_v2_v2(b2Vec2.Subtract(pA, pC), this.m_localAxisC);
        }
        this.m_bodyD = this.m_joint2.GetBodyA();
        this.m_bodyB = this.m_joint2.GetBodyB();
        var xfB = this.m_bodyB.m_xf;
        var aB = this.m_bodyB.m_sweep.a;
        var xfD = this.m_bodyD.m_xf;
        var aD = this.m_bodyD.m_sweep.a;
        if (this.m_typeB == b2Joint.e_revoluteJoint) {
          var revolute = def.joint2;
          this.m_localAnchorD.Assign(revolute.m_localAnchorA);
          this.m_localAnchorB.Assign(revolute.m_localAnchorB);
          this.m_referenceAngleB = revolute.m_referenceAngle;
          this.m_localAxisD.SetZero();
          coordinateB = aB - aD - this.m_referenceAngleB;
        } else {
          var prismatic = def.joint2;
          this.m_localAnchorD.Assign(prismatic.m_localAnchorA);
          this.m_localAnchorB.Assign(prismatic.m_localAnchorB);
          this.m_referenceAngleB = prismatic.m_referenceAngle;
          this.m_localAxisD.Assign(prismatic.m_localXAxisA);
          var pD = this.m_localAnchorD;
          var pB = b2MulT_r_v2(xfD.q, b2Vec2.Add(b2Mul_r_v2(xfB.q, this.m_localAnchorB), b2Vec2.Subtract(xfB.p, xfD.p)));
          coordinateB = b2Dot_v2_v2(b2Vec2.Subtract(pB, pD), this.m_localAxisD);
        }
        this.m_ratio = def.ratio;
        this.m_constant = coordinateA + this.m_ratio * coordinateB;
        this.m_impulse = 0;
        this.m_indexA = this.m_indexB = this.m_indexC = this.m_indexD = 0;
        this.m_lcA = new b2Vec2();
        this.m_lcB = new b2Vec2();
        this.m_lcC = new b2Vec2();
        this.m_lcD = new b2Vec2();
        this.m_mA = this.m_mB = this.m_mC = this.m_mD = 0;
        this.m_iA = this.m_iB = this.m_iC = this.m_iD = 0;
        this.m_JvAC = new b2Vec2(), this.m_JvBD = new b2Vec2();
        this.m_JwA = this.m_JwB = this.m_JwC = this.m_JwD = 0;
        this.m_mass = 0;
      }
      b2GearJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          var P = b2Vec2.Multiply(this.m_impulse, this.m_JvAC);
          return b2Vec2.Multiply(inv_dt, P);
        },
        GetReactionTorque: function(inv_dt) {
          var L = this.m_impulse * this.m_JwA;
          return inv_dt * L;
        },
        GetJoint1: function() {
          return this.m_joint1;
        },
        GetJoint2: function() {
          return this.m_joint2;
        },
        SetRatio: function(ratio) {
          b2Assert(b2IsValid(ratio));
          this.m_ratio = ratio;
        },
        GetRatio: function() {
          return this.m_ratio;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_indexC = this.m_bodyC.m_islandIndex;
          this.m_indexD = this.m_bodyD.m_islandIndex;
          this.m_lcA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_lcB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_lcC.Assign(this.m_bodyC.m_sweep.localCenter);
          this.m_lcD.Assign(this.m_bodyD.m_sweep.localCenter);
          this.m_mA = this.m_bodyA.m_invMass;
          this.m_mB = this.m_bodyB.m_invMass;
          this.m_mC = this.m_bodyC.m_invMass;
          this.m_mD = this.m_bodyD.m_invMass;
          this.m_iA = this.m_bodyA.m_invI;
          this.m_iB = this.m_bodyB.m_invI;
          this.m_iC = this.m_bodyC.m_invI;
          this.m_iD = this.m_bodyD.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var aC = data.positions[this.m_indexC].a;
          var vC = data.velocities[this.m_indexC].v.Clone();
          var wC = data.velocities[this.m_indexC].w;
          var aD = data.positions[this.m_indexD].a;
          var vD = data.velocities[this.m_indexD].v.Clone();
          var wD = data.velocities[this.m_indexD].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB), qC = new b2Rot(aC), qD = new b2Rot(aD);
          this.m_mass = 0;
          if (this.m_typeA == b2Joint.e_revoluteJoint) {
            this.m_JvAC.SetZero();
            this.m_JwA = 1;
            this.m_JwC = 1;
            this.m_mass += this.m_iA + this.m_iC;
          } else {
            var u = b2Mul_r_v2(qC, this.m_localAxisC);
            var rC = b2Mul_r_v2(qC, b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC));
            var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_lcA));
            this.m_JvAC.Assign(u);
            this.m_JwC = b2Cross_v2_v2(rC, u);
            this.m_JwA = b2Cross_v2_v2(rA, u);
            this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
          }
          if (this.m_typeB == b2Joint.e_revoluteJoint) {
            this.m_JvBD.SetZero();
            this.m_JwB = this.m_ratio;
            this.m_JwD = this.m_ratio;
            this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
          } else {
            var u = b2Mul_r_v2(qD, this.m_localAxisD);
            var rD = b2Mul_r_v2(qD, b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD));
            var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_lcB));
            this.m_JvBD.Assign(b2Vec2.Multiply(this.m_ratio, u));
            this.m_JwD = this.m_ratio * b2Cross_v2_v2(rD, u);
            this.m_JwB = this.m_ratio * b2Cross_v2_v2(rB, u);
            this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
          }
          this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
          if (data.step.warmStarting) {
            vA.Add(b2Vec2.Multiply(this.m_mA * this.m_impulse, this.m_JvAC));
            wA += this.m_iA * this.m_impulse * this.m_JwA;
            vB.Add(b2Vec2.Multiply(this.m_mB * this.m_impulse, this.m_JvBD));
            wB += this.m_iB * this.m_impulse * this.m_JwB;
            vC.Subtract(b2Vec2.Multiply(this.m_mC * this.m_impulse, this.m_JvAC));
            wC -= this.m_iC * this.m_impulse * this.m_JwC;
            vD.Subtract(b2Vec2.Multiply(this.m_mD * this.m_impulse, this.m_JvBD));
            wD -= this.m_iD * this.m_impulse * this.m_JwD;
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
          data.velocities[this.m_indexC].v.Assign(vC);
          data.velocities[this.m_indexC].w = wC;
          data.velocities[this.m_indexD].v.Assign(vD);
          data.velocities[this.m_indexD].w = wD;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var vC = data.velocities[this.m_indexC].v.Clone();
          var wC = data.velocities[this.m_indexC].w;
          var vD = data.velocities[this.m_indexD].v.Clone();
          var wD = data.velocities[this.m_indexD].w;
          var Cdot = b2Dot_v2_v2(this.m_JvAC, b2Vec2.Subtract(vA, vC)) + b2Dot_v2_v2(this.m_JvBD, b2Vec2.Subtract(vB, vD));
          Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);
          var impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          vA.Add(b2Vec2.Multiply(this.m_mA * impulse, this.m_JvAC));
          wA += this.m_iA * impulse * this.m_JwA;
          vB.Add(b2Vec2.Multiply(this.m_mB * impulse, this.m_JvBD));
          wB += this.m_iB * impulse * this.m_JwB;
          vC.Subtract(b2Vec2.Multiply(this.m_mC * impulse, this.m_JvAC));
          wC -= this.m_iC * impulse * this.m_JwC;
          vD.Subtract(b2Vec2.Multiply(this.m_mD * impulse, this.m_JvBD));
          wD -= this.m_iD * impulse * this.m_JwD;
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
          data.velocities[this.m_indexC].v.Assign(vC);
          data.velocities[this.m_indexC].w = wC;
          data.velocities[this.m_indexD].v.Assign(vD);
          data.velocities[this.m_indexD].w = wD;
        },
        SolvePositionConstraints: function(data) {
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var cC = data.positions[this.m_indexC].c.Clone();
          var aC = data.positions[this.m_indexC].a;
          var cD = data.positions[this.m_indexD].c.Clone();
          var aD = data.positions[this.m_indexD].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB), qC = new b2Rot(aC), qD = new b2Rot(aD);
          var linearError = 0;
          var coordinateA, coordinateB;
          var JvAC = new b2Vec2(), JvBD = new b2Vec2();
          var JwA, JwB, JwC, JwD;
          var mass = 0;
          if (this.m_typeA == b2Joint.e_revoluteJoint) {
            JvAC.SetZero();
            JwA = 1;
            JwC = 1;
            mass += this.m_iA + this.m_iC;
            coordinateA = aA - aC - this.m_referenceAngleA;
          } else {
            var u = b2Mul_r_v2(qC, this.m_localAxisC);
            var rC = b2Mul_r_v2(qC, b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC));
            var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_lcA));
            JvAC.Assign(u);
            JwC = b2Cross_v2_v2(rC, u);
            JwA = b2Cross_v2_v2(rA, u);
            mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
            var pC = b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC);
            var pA = b2MulT_r_v2(qC, b2Vec2.Add(rA, b2Vec2.Subtract(cA, cC)));
            coordinateA = b2Dot_v2_v2(b2Vec2.Subtract(pA, pC), this.m_localAxisC);
          }
          if (this.m_typeB == b2Joint.e_revoluteJoint) {
            JvBD.SetZero();
            JwB = this.m_ratio;
            JwD = this.m_ratio;
            mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
            coordinateB = aB - aD - this.m_referenceAngleB;
          } else {
            var u = b2Mul_r_v2(qD, this.m_localAxisD);
            var rD = b2Mul_r_v2(qD, b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD));
            var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_lcB));
            JvBD.Assign(b2Vec2.Multiply(this.m_ratio, u));
            JwD = this.m_ratio * b2Cross_v2_v2(rD, u);
            JwB = this.m_ratio * b2Cross_v2_v2(rB, u);
            mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
            var pD = b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD);
            var pB = b2MulT_r_v2(qD, b2Vec2.Add(rB, b2Vec2.Subtract(cB, cD)));
            coordinateB = b2Dot_v2_v2(b2Vec2.Subtract(pB, pD), this.m_localAxisD);
          }
          var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;
          var impulse = 0;
          mass > 0 && (impulse = -C / mass);
          cA.Add(b2Vec2.Multiply(this.m_mA, b2Vec2.Multiply(impulse, JvAC)));
          aA += this.m_iA * impulse * JwA;
          cB.Add(b2Vec2.Multiply(this.m_mB, b2Vec2.Multiply(impulse, JvBD)));
          aB += this.m_iB * impulse * JwB;
          cC.Subtract(b2Vec2.Multiply(this.m_mC, b2Vec2.Multiply(impulse, JvAC)));
          aC -= this.m_iC * impulse * JwC;
          cD.Subtract(b2Vec2.Multiply(this.m_mD, b2Vec2.Multiply(impulse, JvBD)));
          aD -= this.m_iD * impulse * JwD;
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          data.positions[this.m_indexC].c.Assign(cC);
          data.positions[this.m_indexC].a = aC;
          data.positions[this.m_indexD].c.Assign(cD);
          data.positions[this.m_indexD].a = aD;
          return linearError < b2_linearSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["joint1"] = this.m_joint1.__temp_joint_id;
          obj["joint2"] = this.m_joint2.__temp_joint_id;
          obj["ratio"] = this.m_ratio;
          return obj;
        }
      };
      b2GearJoint._extend(b2Joint);
      function b2MotorJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_motorJoint;
        this.linearOffset = new b2Vec2();
        this.angularOffset = 0;
        this.maxForce = 1;
        this.maxTorque = 1;
        this.correctionFactor = .3;
        Object.seal(this);
      }
      b2MotorJointDef.prototype = {
        Initialize: function(bA, bB) {
          this.bodyA = bA;
          this.bodyB = bB;
          var xB = this.bodyB.GetPosition();
          this.linearOffset.Assign(this.bodyA.GetLocalPoint(xB));
          var angleA = this.bodyA.GetAngle();
          var angleB = this.bodyB.GetAngle();
          this.angularOffset = angleB - angleA;
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.linearOffset._deserialize(data["linearOffset"]);
          this.angularOffset = data["angularOffset"];
          this.maxForce = data["maxForce"];
          this.maxTorque = data["maxTorque"];
          this.correctionFactor = data["correctionFactor"];
        }
      };
      b2MotorJointDef._extend(b2JointDef);
      function b2MotorJoint(def) {
        this.parent.call(this, def);
        this.m_linearOffset = def.linearOffset.Clone();
        this.m_angularOffset = def.angularOffset;
        this.m_linearImpulse = new b2Vec2();
        this.m_angularImpulse = 0;
        this.m_maxForce = def.maxForce;
        this.m_maxTorque = def.maxTorque;
        this.m_correctionFactor = def.correctionFactor;
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_rA = new b2Vec2();
        this.m_rB = new b2Vec2();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_linearError = new b2Vec2();
        this.m_angularError = 0;
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_linearMass = new b2Mat22();
        this.m_angularMass = 0;
      }
      b2MotorJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetPosition();
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetPosition();
        },
        GetReactionForce: function(inv_dt) {
          return b2Vec2.Multiply(inv_dt, this.m_linearImpulse);
        },
        GetReactionTorque: function(inv_dt) {
          return inv_dt * this.m_angularImpulse;
        },
        SetLinearOffset: function(linearOffset) {
          if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_linearOffset.Assign(linearOffset);
          }
        },
        GetLinearOffset: function() {
          return this.m_linearOffset;
        },
        SetAngularOffset: function(angularOffset) {
          if (angularOffset != this.m_angularOffset) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_angularOffset = angularOffset;
          }
        },
        GetAngularOffset: function() {
          return this.m_angularOffset;
        },
        SetMaxForce: function(force) {
          b2Assert(b2IsValid(force) && force >= 0);
          this.m_maxForce = force;
        },
        GetMaxForce: function() {
          return this.m_maxForce;
        },
        SetMaxTorque: function(torque) {
          b2Assert(b2IsValid(torque) && torque >= 0);
          this.m_maxTorque = torque;
        },
        GetMaxTorque: function() {
          return this.m_maxTorque;
        },
        SetCorrectionFactor: function(factor) {
          b2Assert(b2IsValid(factor) && 0 <= factor && factor <= 1);
          this.m_correctionFactor = factor;
        },
        GetCorrectionFactor: function() {
          return this.m_correctionFactor;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          this.m_rA.Assign(b2Mul_r_v2(qA, this.m_localCenterA.Negate()));
          this.m_rB.Assign(b2Mul_r_v2(qB, this.m_localCenterB.Negate()));
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = new b2Mat22();
          K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
          K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
          this.m_linearMass.Assign(K.GetInverse());
          this.m_angularMass = iA + iB;
          this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass);
          this.m_linearError.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x - (qA.c * this.m_linearOffset.x - qA.s * this.m_linearOffset.y);
          this.m_linearError.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y - (qA.s * this.m_linearOffset.x + qA.c * this.m_linearOffset.y);
          this.m_angularError = aB - aA - this.m_angularOffset;
          if (data.step.warmStarting) {
            this.m_linearImpulse.Multiply(data.step.dtRatio);
            this.m_angularImpulse *= data.step.dtRatio;
            var P = new b2Vec2(this.m_linearImpulse.x, this.m_linearImpulse.y);
            vA.Subtract(b2Vec2.Multiply(mA, P));
            wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_angularImpulse);
            vB.Add(b2Vec2.Multiply(mB, P));
            wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_angularImpulse);
          } else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0;
          }
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var h = data.step.dt;
          var inv_h = data.step.inv_dt;
          var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
          var impulse = -this.m_angularMass * Cdot;
          var oldImpulse = this.m_angularImpulse;
          var maxImpulse = h * this.m_maxTorque;
          this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
          impulse = this.m_angularImpulse - oldImpulse;
          wA -= iA * impulse;
          wB += iB * impulse;
          var Cdot = new b2Vec2(vB.x + -wB * this.m_rB.x - vA.x - -wA * this.m_rA.x + inv_h * this.m_correctionFactor * this.m_linearError.x, vB.y + wB * this.m_rB.y - vA.y - wA * this.m_rA.y + inv_h * this.m_correctionFactor * this.m_linearError.y);
          var impulse = b2Mul_m22_v2(this.m_linearMass, Cdot).Negate();
          var oldImpulse = this.m_linearImpulse.Clone();
          this.m_linearImpulse.Add(impulse);
          var maxImpulse = h * this.m_maxForce;
          if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.Multiply(maxImpulse);
          }
          impulse.Assign(b2Vec2.Subtract(this.m_linearImpulse, oldImpulse));
          vA.Subtract(b2Vec2.Multiply(mA, impulse));
          wA -= iA * b2Cross_v2_v2(this.m_rA, impulse);
          vB.Add(b2Vec2.Multiply(mB, impulse));
          wB += iB * b2Cross_v2_v2(this.m_rB, impulse);
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          return true;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["linearOffset"] = this.m_linearOffset._serialize();
          obj["angularOffset"] = this.m_angularOffset;
          obj["maxForce"] = this.m_maxForce;
          obj["maxTorque"] = this.m_maxTorque;
          obj["correctionFactor"] = this.m_correctionFactor;
          return obj;
        }
      };
      b2MotorJoint._extend(b2Joint);
      var b2_minPulleyLength = 2;
      function b2PulleyJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_pulleyJoint;
        this.groundAnchorA = new b2Vec2(-1, 1);
        this.groundAnchorB = new b2Vec2(1, 1);
        this.localAnchorA = new b2Vec2(-1, 0);
        this.localAnchorB = new b2Vec2(1, 0);
        this.lengthA = 0;
        this.lengthB = 0;
        this.ratio = 1;
        this.collideConnected = true;
        Object.seal(this);
      }
      b2PulleyJointDef.prototype = {
        Initialize: function(bA, bB, groundA, groundB, anchorA, anchorB, r) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.groundAnchorA.Assign(groundA);
          this.groundAnchorB.Assign(groundB);
          this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchorA));
          this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchorB));
          var dA = b2Vec2.Subtract(anchorA, groundA);
          this.lengthA = dA.Length();
          var dB = b2Vec2.Subtract(anchorB, groundB);
          this.lengthB = dB.Length();
          this.ratio = r;
          b2Assert(this.ratio > b2_epsilon);
        },
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.groundAnchorA._deserialize(data["groundAnchorA"]);
          this.groundAnchorB._deserialize(data["groundAnchorB"]);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.lengthA = data["lengthA"];
          this.lengthB = data["lengthB"];
          this.ratio = data["ratio"];
        }
      };
      b2PulleyJointDef._extend(b2JointDef);
      function b2PulleyJoint(def) {
        this.parent.call(this, def);
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_uA = new b2Vec2();
        this.m_uB = new b2Vec2();
        this.m_rA = new b2Vec2();
        this.m_rB = new b2Vec2();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
        this.m_mass = 0;
        this.m_groundAnchorA = def.groundAnchorA.Clone();
        this.m_groundAnchorB = def.groundAnchorB.Clone();
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_lengthA = def.lengthA;
        this.m_lengthB = def.lengthB;
        b2Assert(0 != def.ratio);
        this.m_ratio = def.ratio;
        this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
        this.m_impulse = 0;
      }
      b2PulleyJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          var P = b2Vec2.Multiply(this.m_impulse, this.m_uB);
          return b2Vec2.Multiply(inv_dt, P);
        },
        GetReactionTorque: function(inv_dt) {
          return 0;
        },
        GetGroundAnchorA: function() {
          return this.m_groundAnchorA;
        },
        GetGroundAnchorB: function() {
          return this.m_groundAnchorB;
        },
        GetLengthA: function() {
          return this.m_lengthA;
        },
        GetLengthB: function() {
          return this.m_lengthB;
        },
        GetRatio: function() {
          return this.m_ratio;
        },
        GetCurrentLengthA: function() {
          var p = this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
          var s = this.m_groundAnchorA;
          var d = b2Vec2.Subtract(p, s);
          return d.Length();
        },
        GetCurrentLengthB: function() {
          var p = this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
          var s = this.m_groundAnchorB;
          var d = b2Vec2.Subtract(p, s);
          return d.Length();
        },
        ShiftOrigin: function(newOrigin) {
          this.m_groundAnchorA.Subtract(newOrigin);
          this.m_groundAnchorB.Subtract(newOrigin);
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          this.m_rA.Assign(b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA)));
          this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
          this.m_uA.Assign(b2Vec2.Add(cA, b2Vec2.Subtract(this.m_rA, this.m_groundAnchorA)));
          this.m_uB.Assign(b2Vec2.Add(cB, b2Vec2.Subtract(this.m_rB, this.m_groundAnchorB)));
          var lengthA = this.m_uA.Length();
          var lengthB = this.m_uB.Length();
          lengthA > 10 * b2_linearSlop ? this.m_uA.Multiply(1 / lengthA) : this.m_uA.SetZero();
          lengthB > 10 * b2_linearSlop ? this.m_uB.Multiply(1 / lengthB) : this.m_uB.SetZero();
          var ruA = b2Cross_v2_v2(this.m_rA, this.m_uA);
          var ruB = b2Cross_v2_v2(this.m_rB, this.m_uB);
          var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
          var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
          this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
          this.m_mass > 0 && (this.m_mass = 1 / this.m_mass);
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            var PA = b2Vec2.Multiply(-this.m_impulse, this.m_uA);
            var PB = b2Vec2.Multiply(-this.m_ratio * this.m_impulse, this.m_uB);
            vA.Add(b2Vec2.Multiply(this.m_invMassA, PA));
            wA += this.m_invIA * b2Cross_v2_v2(this.m_rA, PA);
            vB.Add(b2Vec2.Multiply(this.m_invMassB, PB));
            wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, PB);
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var vpA = b2Vec2.Add(vA, b2Cross_f_v2(wA, this.m_rA));
          var vpB = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
          var Cdot = -b2Dot_v2_v2(this.m_uA, vpA) - this.m_ratio * b2Dot_v2_v2(this.m_uB, vpB);
          var impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          var PA = b2Vec2.Multiply(-impulse, this.m_uA);
          var PB = b2Vec2.Multiply(-this.m_ratio, b2Vec2.Multiply(impulse, this.m_uB));
          vA.Add(b2Vec2.Multiply(this.m_invMassA, PA));
          wA += this.m_invIA * b2Cross_v2_v2(this.m_rA, PA);
          vB.Add(b2Vec2.Multiply(this.m_invMassB, PB));
          wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, PB);
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var uA = b2Vec2.Add(cA, b2Vec2.Subtract(rA, this.m_groundAnchorA));
          var uB = b2Vec2.Add(cB, b2Vec2.Subtract(rB, this.m_groundAnchorB));
          var lengthA = uA.Length();
          var lengthB = uB.Length();
          lengthA > 10 * b2_linearSlop ? uA.Multiply(1 / lengthA) : uA.SetZero();
          lengthB > 10 * b2_linearSlop ? uB.Multiply(1 / lengthB) : uB.SetZero();
          var ruA = b2Cross_v2_v2(rA, uA);
          var ruB = b2Cross_v2_v2(rB, uB);
          var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
          var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
          var mass = mA + this.m_ratio * this.m_ratio * mB;
          mass > 0 && (mass = 1 / mass);
          var C = this.m_constant - lengthA - this.m_ratio * lengthB;
          var linearError = b2Abs(C);
          var impulse = -mass * C;
          var PA = b2Vec2.Multiply(-impulse, uA);
          var PB = b2Vec2.Multiply(-this.m_ratio, b2Vec2.Multiply(impulse, uB));
          cA.Add(b2Vec2.Multiply(this.m_invMassA, PA));
          aA += this.m_invIA * b2Cross_v2_v2(rA, PA);
          cB.Add(b2Vec2.Multiply(this.m_invMassB, PB));
          aB += this.m_invIB * b2Cross_v2_v2(rB, PB);
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          return linearError < b2_linearSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["groundAnchorA"] = this.m_groundAnchorA._serialize();
          obj["groundAnchorB"] = this.m_groundAnchorB._serialize();
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["lengthA"] = this.m_lengthA;
          obj["lengthB"] = this.m_lengthB;
          obj["ratio"] = this.m_ratio;
          return obj;
        }
      };
      b2PulleyJoint._extend(b2Joint);
      function b2RopeJointDef() {
        this.parent.call(this);
        this.type = b2Joint.e_ropeJoint;
        this.localAnchorA = new b2Vec2(-1, 0);
        this.localAnchorB = new b2Vec2(1, 0);
        this.maxLength = 0;
        Object.seal(this);
      }
      b2RopeJointDef.prototype = {
        _deserialize: function(data, bodies, joints) {
          this.parent.prototype._deserialize.call(this, data, bodies, joints);
          this.localAnchorA._deserialize(data["localAnchorA"]);
          this.localAnchorB._deserialize(data["localAnchorB"]);
          this.maxLength = data["maxLength"];
        }
      };
      b2RopeJointDef._extend(b2JointDef);
      function b2RopeJoint(def) {
        this.parent.call(this, def);
        this.m_localAnchorA = def.localAnchorA.Clone();
        this.m_localAnchorB = def.localAnchorB.Clone();
        this.m_maxLength = def.maxLength;
        this.m_mass = 0;
        this.m_impulse = 0;
        this.m_state = b2Joint.e_inactiveLimit;
        this.m_length = 0;
        this.m_indexA = 0;
        this.m_indexB = 0;
        this.m_u = new b2Vec2();
        this.m_rA = new b2Vec2();
        this.m_rB = new b2Vec2();
        this.m_localCenterA = new b2Vec2();
        this.m_localCenterB = new b2Vec2();
        this.m_invMassA = 0;
        this.m_invMassB = 0;
        this.m_invIA = 0;
        this.m_invIB = 0;
      }
      b2RopeJoint.prototype = {
        GetAnchorA: function() {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
        },
        GetAnchorB: function() {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
        },
        GetReactionForce: function(inv_dt) {
          var F = b2Vec2.Multiply(inv_dt * this.m_impulse, this.m_u);
          return F;
        },
        GetReactionTorque: function(inv_dt) {
          return 0;
        },
        GetLocalAnchorA: function() {
          return this.m_localAnchorA;
        },
        GetLocalAnchorB: function() {
          return this.m_localAnchorB;
        },
        SetMaxLength: function(length) {
          this.m_maxLength = length;
        },
        GetMaxLength: function() {
          return this.m_maxLength;
        },
        GetLimitState: function() {
          return this.m_state;
        },
        InitVelocityConstraints: function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          this.m_rA.Assign(b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA)));
          this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
          this.m_u.Assign(b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, this.m_rB), cA), this.m_rA));
          this.m_length = this.m_u.Length();
          var C = this.m_length - this.m_maxLength;
          this.m_state = C > 0 ? b2Joint.e_atUpperLimit : b2Joint.e_inactiveLimit;
          if (!(this.m_length > b2_linearSlop)) {
            this.m_u.SetZero();
            this.m_mass = 0;
            this.m_impulse = 0;
            return;
          }
          this.m_u.Multiply(1 / this.m_length);
          var crA = b2Cross_v2_v2(this.m_rA, this.m_u);
          var crB = b2Cross_v2_v2(this.m_rB, this.m_u);
          var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;
          this.m_mass = 0 != invMass ? 1 / invMass : 0;
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            var P = b2Vec2.Multiply(this.m_impulse, this.m_u);
            vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
            wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
            vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
            wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolveVelocityConstraints: function(data) {
          var vA = data.velocities[this.m_indexA].v.Clone();
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v.Clone();
          var wB = data.velocities[this.m_indexB].w;
          var vpA = b2Vec2.Add(vA, b2Cross_f_v2(wA, this.m_rA));
          var vpB = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
          var C = this.m_length - this.m_maxLength;
          var Cdot = b2Dot_v2_v2(this.m_u, b2Vec2.Subtract(vpB, vpA));
          C < 0 && (Cdot += data.step.inv_dt * C);
          var impulse = -this.m_mass * Cdot;
          var oldImpulse = this.m_impulse;
          this.m_impulse = b2Min(0, this.m_impulse + impulse);
          impulse = this.m_impulse - oldImpulse;
          var P = b2Vec2.Multiply(impulse, this.m_u);
          vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
          wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
          vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
          wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
          data.velocities[this.m_indexA].v.Assign(vA);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].v.Assign(vB);
          data.velocities[this.m_indexB].w = wB;
        },
        SolvePositionConstraints: function(data) {
          var cA = data.positions[this.m_indexA].c.Clone();
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c.Clone();
          var aB = data.positions[this.m_indexB].a;
          var qA = new b2Rot(aA), qB = new b2Rot(aB);
          var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
          var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
          var u = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
          var length = u.Normalize();
          var C = length - this.m_maxLength;
          C = b2Clamp(C, 0, b2_maxLinearCorrection);
          var impulse = -this.m_mass * C;
          var P = b2Vec2.Multiply(impulse, u);
          cA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
          aA -= this.m_invIA * b2Cross_v2_v2(rA, P);
          cB.Add(b2Vec2.Multiply(this.m_invMassB, P));
          aB += this.m_invIB * b2Cross_v2_v2(rB, P);
          data.positions[this.m_indexA].c.Assign(cA);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].c.Assign(cB);
          data.positions[this.m_indexB].a = aB;
          return length - this.m_maxLength < b2_linearSlop;
        },
        _serialize: function(out) {
          var obj = out || {};
          this.parent.prototype._serialize.call(this, obj);
          obj["localAnchorA"] = this.m_localAnchorA._serialize();
          obj["localAnchorB"] = this.m_localAnchorB._serialize();
          obj["maxLength"] = this.m_maxLength;
          return obj;
        }
      };
      b2RopeJoint._extend(b2Joint);
      var expf = Math.exp;
      function b2RopeDef() {
        this.vertices = null;
        this.count = 0;
        this.masses = null;
        this.gravity = new b2Vec2();
        this.damping = .1;
        this.k2 = .9;
        this.k3 = .1;
      }
      function b2Rope() {
        this.m_count = 0;
        this.m_ps = null;
        this.m_p0s = null;
        this.m_vs = null;
        this.m_ims = null;
        this.m_Ls = null;
        this.m_as = null;
        this.m_damping = 0;
        this.m_gravity = new b2Vec2();
        this.m_k2 = 1;
        this.m_k3 = .1;
      }
      b2Rope.prototype = {
        Initialize: function(def) {
          b2Assert(def.count >= 3);
          this.m_count = def.count;
          this.m_ps = new Array(this.m_count);
          this.m_p0s = new Array(this.m_count);
          this.m_vs = new Array(this.m_count);
          this.m_ims = new Array(this.m_count);
          for (var i = 0; i < this.m_count; ++i) {
            this.m_ps[i] = def.vertices[i].Clone();
            this.m_p0s[i] = def.vertices[i].Clone();
            this.m_vs[i] = new b2Vec2();
            var m = def.masses[i];
            this.m_ims[i] = m > 0 ? 1 / m : 0;
          }
          var count2 = this.m_count - 1;
          var count3 = this.m_count - 2;
          this.m_Ls = new Array(count2);
          this.m_as = new Array(count3);
          for (var i = 0; i < count2; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            this.m_Ls[i] = b2Distance(p1, p2);
          }
          for (var i = 0; i < count3; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            var p3 = this.m_ps[i + 2];
            var d1 = b2Vec2.Subtract(p2, p1);
            var d2 = b2Vec2.Subtract(p3, p2);
            var a = b2Cross_v2_v2(d1, d2);
            var b = b2Dot_v2_v2(d1, d2);
            this.m_as[i] = b2Atan2(a, b);
          }
          this.m_gravity = def.gravity.Clone();
          this.m_damping = def.damping;
          this.m_k2 = def.k2;
          this.m_k3 = def.k3;
        },
        Step: function(h, iterations) {
          if (0 == h) return;
          var d = expf(-h * this.m_damping);
          for (var i = 0; i < this.m_count; ++i) {
            this.m_p0s[i].Assign(this.m_ps[i]);
            this.m_ims[i] > 0 && this.m_vs[i].Add(b2Vec2.Multiply(h, this.m_gravity));
            this.m_vs[i].Multiply(d);
            this.m_ps[i].Add(b2Vec2.Multiply(h, this.m_vs[i]));
          }
          for (var i = 0; i < iterations; ++i) {
            this.SolveC2();
            this.SolveC3();
            this.SolveC2();
          }
          var inv_h = 1 / h;
          for (var i = 0; i < this.m_count; ++i) this.m_vs[i] = b2Vec2.Multiply(inv_h, b2Vec2.Subtract(this.m_ps[i], this.m_p0s[i]));
        },
        GetVertexCount: function() {
          return this.m_count;
        },
        GetVertices: function() {
          return this.m_ps;
        },
        Draw: function(draw) {
          var c = new b2Color(.4, .5, .7);
          for (var i = 0; i < this.m_count - 1; ++i) draw.DrawSegment(this.m_ps[i], this.m_ps[i + 1], c);
        },
        SetAngle: function(angle) {
          var count3 = this.m_count - 2;
          for (var i = 0; i < count3; ++i) this.m_as[i] = angle;
        },
        SolveC2: function() {
          var count2 = this.m_count - 1;
          for (var i = 0; i < count2; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            var d = b2Vec2.Subtract(p2, p1);
            var L = d.Normalize();
            var im1 = this.m_ims[i];
            var im2 = this.m_ims[i + 1];
            if (im1 + im2 == 0) continue;
            var s1 = im1 / (im1 + im2);
            var s2 = im2 / (im1 + im2);
            p1.Subtract(b2Vec2.Multiply(this.m_k2 * s1 * (this.m_Ls[i] - L), d));
            p2.Add(b2Vec2.Multiply(this.m_k2 * s2 * (this.m_Ls[i] - L), d));
          }
        },
        SolveC3: function() {
          var count3 = this.m_count - 2;
          for (var i = 0; i < count3; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            var p3 = this.m_ps[i + 2];
            var m1 = this.m_ims[i];
            var m2 = this.m_ims[i + 1];
            var m3 = this.m_ims[i + 2];
            var d1 = b2Vec2.Subtract(p2, p1);
            var d2 = b2Vec2.Subtract(p3, p2);
            var L1sqr = d1.LengthSquared();
            var L2sqr = d2.LengthSquared();
            if (L1sqr * L2sqr == 0) continue;
            var a = b2Cross_v2_v2(d1, d2);
            var b = b2Dot_v2_v2(d1, d2);
            var angle = b2Atan2(a, b);
            var Jd1 = b2Vec2.Multiply(-1 / L1sqr, d1.Skew());
            var Jd2 = b2Vec2.Multiply(1 / L2sqr, d2.Skew());
            var J1 = b2Vec2.Negate(Jd1);
            var J2 = b2Vec2.Subtract(Jd1, Jd2);
            var J3 = Jd2;
            var mass = m1 * b2Dot_v2_v2(J1, J1) + m2 * b2Dot_v2_v2(J2, J2) + m3 * b2Dot_v2_v2(J3, J3);
            if (0 == mass) continue;
            mass = 1 / mass;
            var C = angle - this.m_as[i];
            while (C > b2_pi) {
              angle -= 2 * b2_pi;
              C = angle - this.m_as[i];
            }
            while (C < -b2_pi) {
              angle += 2 * b2_pi;
              C = angle - this.m_as[i];
            }
            var impulse = -this.m_k3 * mass * C;
            p1.Add(b2Vec2.Multiply(m1 * impulse, J1));
            p2.Add(b2Vec2.Multiply(m2 * impulse, J2));
            p3.Add(b2Vec2.Multiply(m3 * impulse, J3));
          }
        }
      };
      var b2JsonSerializer = {
        serialize: function(world) {
          var shapes = [];
          var i;
          var serialized;
          var b;
          var f;
          var shape;
          for (b = world.GetBodyList(); b; b = b.GetNext()) for (f = b.GetFixtureList(); f; f = f.GetNext()) {
            shape = f.GetShape();
            f.__temp_shape_id = shapes.length;
            shapes.push(shape._serialize());
          }
          var fixtures = [];
          for (b = world.GetBodyList(); b; b = b.GetNext()) {
            b.__temp_fixture_ids = [];
            for (f = b.GetFixtureList(); f; f = f.GetNext()) {
              serialized = f._serialize();
              serialized["shape"] = f.__temp_shape_id;
              delete f.__temp_shape_id;
              b.__temp_fixture_ids.push(fixtures.length);
              fixtures.push(serialized);
            }
          }
          var bodies = [];
          for (b = world.GetBodyList(); b; b = b.GetNext()) {
            serialized = b._serialize();
            serialized.fixtures = [];
            for (i = 0; i < b.__temp_fixture_ids.length; ++i) serialized.fixtures.push(b.__temp_fixture_ids[i]);
            delete b.__temp_fixture_ids;
            b.__temp_body_id = bodies.length;
            bodies.push(serialized);
          }
          var joints = [];
          var j;
          for (j = world.GetJointList(), i = 0; j; j = j.GetNext(), ++i) j.__temp_joint_id = i;
          for (j = world.GetJointList(); j; j = j.GetNext()) {
            if (j.GetType() === b2Joint.e_mouseJoint) continue;
            serialized = j._serialize();
            serialized["bodyA"] = j.GetBodyA().__temp_body_id;
            serialized["bodyB"] = j.GetBodyB().__temp_body_id;
            joints.push(serialized);
          }
          for (j = world.GetJointList(); j; j = j.GetNext()) delete j.__temp_joint_id;
          for (b = world.GetBodyList(); b; b = b.GetNext()) delete b.__temp_body_id;
          return {
            shapes: shapes,
            fixtures: fixtures,
            bodies: bodies,
            joints: joints
          };
        },
        deserialize: function(serialized, world, clear) {
          var deserialized = JSON.parse(serialized);
          if (clear) {
            for (var b = world.GetBodyList(); b; ) {
              var next = b.GetNext();
              world.DestroyBody(b);
              b = next;
            }
            for (var j = world.GetJointList(); j; ) {
              var next = j.GetNext();
              world.DestroyJoint(j);
              j = next;
            }
          }
          var shapes = [];
          for (var i = 0; i < deserialized.shapes.length; ++i) {
            var shapeData = deserialized.shapes[i];
            var shape;
            switch (shapeData.m_type) {
             case b2Shape.e_circle:
              shape = new b2CircleShape();
              break;

             case b2Shape.e_edge:
              shape = new b2EdgeShape();
              break;

             case b2Shape.e_chain:
              shape = new b2ChainShape();
              break;

             case b2Shape.e_polygon:
              shape = new b2PolygonShape();
            }
            shape._deserialize(shapeData);
            shapes.push(shape);
          }
          var fixtures = [];
          for (i = 0; i < deserialized.fixtures.length; ++i) {
            var fixtureData = deserialized.fixtures[i];
            var fixture = new b2FixtureDef();
            fixture._deserialize(fixtureData);
            fixture.shape = shapes[fixtureData["shape"]];
            fixtures.push(fixture);
          }
          var bodies = [];
          for (i = 0; i < deserialized.bodies.length; ++i) {
            var bodyData = deserialized.bodies[i];
            var def = new b2BodyDef();
            def._deserialize(bodyData);
            var body = world.CreateBody(def);
            for (var x = 0; x < bodyData.fixtures.length; ++x) body.CreateFixture(fixtures[bodyData.fixtures[x]]);
            bodies.push(body);
          }
          var joints = [];
          var gears = [];
          for (i = 0; i < deserialized.joints.length; ++i) {
            var jointData = deserialized.joints[i];
            var jointDef;
            switch (jointData.type) {
             case b2Joint.e_revoluteJoint:
              jointDef = new b2RevoluteJointDef();
              break;

             case b2Joint.e_prismaticJoint:
              jointDef = new b2PrismaticJointDef();
              break;

             case b2Joint.e_distanceJoint:
              jointDef = new b2DistanceJointDef();
              break;

             case b2Joint.e_pulleyJoint:
              jointDef = new b2PulleyJointDef();
              break;

             case b2Joint.e_gearJoint:
              jointDef = new b2GearJointDef();
              break;

             case b2Joint.e_wheelJoint:
              jointDef = new b2WheelJointDef();
              break;

             case b2Joint.e_weldJoint:
              jointDef = new b2WeldJointDef();
              break;

             case b2Joint.e_frictionJoint:
              jointDef = new b2FrictionJointDef();
              break;

             case b2Joint.e_ropeJoint:
              jointDef = new b2RopeJointDef();
              break;

             case b2Joint.e_motorJoint:
              jointDef = new b2MotorJointDef();
              break;

             default:
              throw new Error("unknown joint");
            }
            jointDef._deserialize(jointData, bodies);
            if (jointData.type === b2Joint.e_gearJoint) {
              gears.push([ jointDef, joints.length ]);
              joints.push(null);
            } else {
              var joint = world.CreateJoint(jointDef);
              joints.push(joint);
            }
          }
          for (i = 0; i < gears.length; ++i) {
            gears[i][0].joint1 = joints[gears[i][0].joint1];
            gears[i][0].joint2 = joints[gears[i][0].joint2];
            joint = world.CreateJoint(gears[i][0]);
            joints[gears[i][1]] = joint;
          }
        }
      };
      var b2RUBELoader = (function() {
        function parseVector(obj) {
          return new b2Vec2(obj && obj.x || 0, obj && obj.y || 0);
        }
        function parseVectorArray(obj) {
          var vals = new Array(obj.x.length);
          for (var i = 0; i < vals.length; ++i) vals[i] = new b2Vec2(obj.x[i], obj.y[i]);
          return vals;
        }
        function parseProperty(obj, instance) {
          var name = obj.name;
          var val;
          if ("undefined" !== typeof obj["int"]) val = obj["int"]; else if ("undefined" !== typeof obj["float"]) val = obj["float"]; else if ("undefined" !== typeof obj["string"]) val = obj["string"]; else if ("undefined" !== typeof obj["bool"]) val = obj["bool"]; else {
            if ("undefined" === typeof obj.vec2) throw new Error("unknown property type");
            val = parseVector(obj.vec2);
          }
          if (instance.hasOwnProperty(name)) throw new Error("custom property possibly overwriting an existing one");
          instance[name] = val;
        }
        function parseFixture(obj, body) {
          var def = new b2FixtureDef();
          def.density = obj.density || 0;
          def.filter.categoryBits = "undefined" === typeof obj["filter-categoryBits"] ? 1 : obj["filter-categoryBits"];
          def.filter.maskBits = "undefined" === typeof obj["filter-maskBits"] ? 65535 : obj["filter-maskBits"];
          def.filter.groupIndex = "undefined" === typeof obj["filter-groupIndex"] ? 0 : obj["filter-groupIndex"];
          def.friction = obj.friction || 0;
          def.restitution = obj.restitution || 0;
          def.isSensor = obj.sensor || 0;
          var shape;
          if ("undefined" !== typeof obj.circle) {
            shape = new b2CircleShape();
            shape.m_p = parseVector(obj.circle.center);
            shape.m_radius = obj.circle.radius || 0;
          } else if ("undefined" !== typeof obj.polygon) {
            var vertices = parseVectorArray(obj.polygon.vertices);
            shape = new b2PolygonShape();
            shape.Set(vertices, vertices.length);
          } else {
            if ("undefined" === typeof obj.chain) throw new Error("unknown shape type");
            var vertices = parseVectorArray(obj.chain.vertices);
            shape = new b2ChainShape();
            shape.m_count = vertices.length;
            shape.m_vertices = vertices;
            (shape.m_hasNextVertex = obj.chain.hasNextVertex) && (shape.m_nextVertex = parseVector(obj.chain.nextVertex));
            (shape.m_hasPrevVertex = obj.chain.hasPrevVertex) && (shape.m_prevVertex = parseVector(obj.chain.prevVertex));
          }
          def.shape = shape;
          var fixture = body.CreateFixture(def);
          fixture.name = obj.name;
          if (obj.customProperties) for (var i = 0; i < obj.customProperties.length; ++i) parseProperty(obj, fixture);
        }
        function parseBody(obj, world) {
          var def = new b2BodyDef();
          def.type = obj.type || b2Body.b2_staticBody;
          def.angle = obj.angle || 0;
          def.angularDamping = obj.angularDamping || 0;
          def.angularVelocity = obj.angularVelocity || 0;
          def.awake = obj.awake || false;
          def.bullet = obj.bullet || false;
          def.fixedRotation = obj.fixedRotation || false;
          def.linearDamping = obj.linearDamping || false;
          def.linearVelocity = parseVector(obj.linearVelocity);
          def.gravityScale = "undefined" !== typeof obj.gravityScale ? obj.gravityScale : 1;
          var md = new b2MassData();
          md.mass = obj["massData-mass"] || 0;
          md.center = parseVector(obj["massData-center"]);
          md.I = obj["massData-I"] || 0;
          def.position = parseVector(obj.position);
          var body = world.CreateBody(def);
          body.name = obj.name;
          body.SetMassData(md);
          if (obj.fixture) for (var i = 0; i < obj.fixture.length; ++i) parseFixture(obj.fixture[i], body);
          if (obj.customProperties) for (i = 0; i < obj.customProperties.length; ++i) parseProperty(obj, body);
          return body;
        }
        var jointsList = {
          revolute: b2RevoluteJointDef,
          distance: b2DistanceJointDef,
          prismatic: b2PrismaticJointDef,
          wheel: b2WheelJointDef,
          rope: b2RopeJointDef,
          motor: b2MotorJointDef,
          weld: b2WeldJointDef,
          friction: b2FrictionJointDef
        };
        function parseJoint(obj, world, bodies) {
          if (!jointsList[obj.type]) throw new Error("unknown joint type");
          var jd = new jointsList[obj.type]();
          switch (jd.type) {
           case b2Joint.e_revoluteJoint:
            jd.localAnchorA = parseVector(obj.anchorA);
            jd.localAnchorB = parseVector(obj.anchorB);
            jd.enableLimit = obj.enableLimit || false;
            jd.enableMotor = obj.enableMotor || false;
            jd.lowerAngle = obj.lowerLimit || 0;
            jd.maxMotorTorque = obj.maxMotorTorque || 0;
            jd.motorSpeed = obj.motorSpeed || 0;
            jd.referenceAngle = obj.refAngle || 0;
            jd.upperAngle = obj.upperLimit || 0;
            break;

           case b2Joint.e_distanceJoint:
            jd.localAnchorA = parseVector(obj.anchorA);
            jd.localAnchorB = parseVector(obj.anchorB);
            jd.dampingRatio = obj.dampingRatio || 0;
            jd.frequencyHz = obj.frequency || 0;
            jd.length = obj.length || 0;
            break;

           case b2Joint.e_prismaticJoint:
            jd.localAnchorA = parseVector(obj.anchorA);
            jd.localAnchorB = parseVector(obj.anchorB);
            jd.enableLimit = obj.enableLimit || false;
            jd.enableMotor = obj.enableMotor || false;
            jd.localAxisA = parseVector(obj.localAxisA);
            jd.lowerTranslation = obj.lowerLimit || 0;
            jd.maxMotorForce = obj.maxMotorForce || 0;
            jd.motorSpeed = obj.motorSpeed || 0;
            jd.referenceAngle = obj.refAngle || 0;
            jd.upperTranslation = obj.upperLimit || 0;
            break;

           case b2Joint.e_wheelJoint:
            jd.localAnchorA = parseVector(obj.anchorA);
            jd.localAnchorB = parseVector(obj.anchorB);
            jd.enableMotor = obj.enableMotor || false;
            jd.localAxisA = parseVector(obj.localAxisA);
            jd.maxMotorTorque = obj.maxMotorTorque || 0;
            jd.motorSpeed = obj.motorSpeed || 0;
            jd.dampingRatio = obj.springDampingRatio || 0;
            jd.frequencyHz = obj.springFrequency || 0;
            break;

           case b2Joint.e_ropeJoint:
            jd.localAnchorA = parseVector(obj.anchorA);
            jd.localAnchorB = parseVector(obj.anchorB);
            jd.maxLength = obj.maxLength || 0;
            break;

           case b2Joint.e_motorJoint:
            jd.linearOffset = parseVector(obj.anchorA);
            jd.angularOffset = obj.refAngle || 0;
            jd.maxForce = obj.maxForce || 0;
            jd.maxTorque = obj.maxTorque || 0;
            jd.correctionFactor = obj.correctionFactor || 0;
            break;

           case b2Joint.e_weldJoint:
            jd.localAnchorA = parseVector(obj.anchorA);
            jd.localAnchorB = parseVector(obj.anchorB);
            jd.referenceAngle = obj.refAngle || 0;
            jd.dampingRatio = obj.dampingRatio || 0;
            jd.frequencyHz = obj.frequencyHz || 0;
            break;

           case b2Joint.e_frictionJoint:
            jd.localAnchorA = parseVector(obj.anchorA);
            jd.localAnchorB = parseVector(obj.anchorB);
            jd.maxForce = obj.maxForce || 0;
            jd.maxTorque = obj.maxTorque || 0;
            break;

           default:
            throw new Error("wat?");
          }
          jd.bodyA = bodies[obj.bodyA || 0];
          jd.bodyB = bodies[obj.bodyB || 0];
          jd.collideConnected = obj.collideConnected || false;
          var joint = world.CreateJoint(jd);
          joint.name = obj.name;
          if (obj.customProperties) for (var i = 0; i < obj.customProperties.length; ++i) parseProperty(obj, joint);
          return joint;
        }
        function b2RubeParameters() {
          this.world = null;
          this.positionIterations = 0;
          this.velocityIterations = 0;
          this.stepsPerSecond = 0;
          this.fixtures = {};
          this.bodies = {};
          this.joints = {};
          Object.seal(this);
        }
        function parseWorld(obj, world) {
          var params = new b2RubeParameters();
          params.world = world = world || new b2World(new b2Vec2(0, 0));
          params.positionIterations = obj.positionIterations || 0;
          params.velocityIterations = obj.velocityIterations || 0;
          params.stepsPerSecond = obj.stepsPerSecond || 0;
          obj.gravity && world.SetGravity(parseVector(obj.gravity));
          world.SetAllowSleeping(obj.allowSleep || false);
          world.SetAutoClearForces(obj.autoClearForces || false);
          world.SetWarmStarting(obj.warmStarting || false);
          world.SetContinuousPhysics(obj.continuousPhysics || false);
          world.SetSubStepping(obj.subStepping || false);
          var bodies = [];
          var bl = obj.body;
          if (bl) for (var i = 0; i < bl.length; ++i) {
            var body = parseBody(bl[i], world);
            bodies.push(body);
            for (var f = body.GetFixtureList(); f; f = f.GetNext()) {
              params.fixtures[f.name] || (params.fixtures[f.name] = []);
              params.fixtures[f.name].push(f);
            }
            params.bodies[body.name] || (params.bodies[body.name] = []);
            params.bodies[body.name].push(body);
          }
          var joints = [];
          var jl = obj.joint;
          if (jl) for (i = 0; i < jl.length; ++i) {
            var joint = parseJoint(jl[i], world, bodies);
            joints.push(joint);
            params.joints[joint.name] || (params.joints[joint.name] = []);
            params.joints[joint.name].push(joint);
          }
          return params;
        }
        return {
          parseWorld: parseWorld
        };
      })();
      var mappings = [ {
        trimmed: "version",
        name: "b2_version",
        def: b2_version
      }, {
        trimmed: "Vec2",
        name: "b2Vec2",
        def: b2Vec2
      }, {
        trimmed: "Vec3",
        name: "b2Vec3",
        def: b2Vec3
      }, {
        trimmed: "Mat22",
        name: "b2Mat22",
        def: b2Mat22
      }, {
        trimmed: "Mat33",
        name: "b2Mat33",
        def: b2Mat33
      }, {
        trimmed: "Rot",
        name: "b2Rot",
        def: b2Rot
      }, {
        trimmed: "Transform",
        name: "b2Transform",
        def: b2Transform
      }, {
        trimmed: "Sweep",
        name: "b2Sweep",
        def: b2Sweep
      }, {
        trimmed: "Dot_v2_v2",
        name: "b2Dot_v2_v2",
        def: b2Dot_v2_v2
      }, {
        trimmed: "Cross_v2_v2",
        name: "b2Cross_v2_v2",
        def: b2Cross_v2_v2
      }, {
        trimmed: "Cross_v2_f",
        name: "b2Cross_v2_f",
        def: b2Cross_v2_f
      }, {
        trimmed: "Cross_f_v2",
        name: "b2Cross_f_v2",
        def: b2Cross_f_v2
      }, {
        trimmed: "Mul_m22_v2",
        name: "b2Mul_m22_v2",
        def: b2Mul_m22_v2
      }, {
        trimmed: "MulT_m22_v2",
        name: "b2MulT_m22_v2",
        def: b2MulT_m22_v2
      }, {
        trimmed: "Distance",
        name: "b2Distance",
        def: b2Distance
      }, {
        trimmed: "DistanceSquared",
        name: "b2DistanceSquared",
        def: b2DistanceSquared
      }, {
        trimmed: "Dot_v3_v3",
        name: "b2Dot_v3_v3",
        def: b2Dot_v3_v3
      }, {
        trimmed: "Cross_v3_v3",
        name: "b2Cross_v3_v3",
        def: b2Cross_v3_v3
      }, {
        trimmed: "Mul_m22_m22",
        name: "b2Mul_m22_m22",
        def: b2Mul_m22_m22
      }, {
        trimmed: "MulT_m22_m22",
        name: "b2MulT_m22_m22",
        def: b2MulT_m22_m22
      }, {
        trimmed: "Mul_m33_v3",
        name: "b2Mul_m33_v3",
        def: b2Mul_m33_v3
      }, {
        trimmed: "Mul22_m33_v2",
        name: "b2Mul22_m33_v2",
        def: b2Mul22_m33_v2
      }, {
        trimmed: "Mul_r_r",
        name: "b2Mul_r_r",
        def: b2Mul_r_r
      }, {
        trimmed: "MulT_r_r",
        name: "b2MulT_r_r",
        def: b2MulT_r_r
      }, {
        trimmed: "Mul_r_v2",
        name: "b2Mul_r_v2",
        def: b2Mul_r_v2
      }, {
        trimmed: "MulT_r_v2",
        name: "b2MulT_r_v2",
        def: b2MulT_r_v2
      }, {
        trimmed: "Mul_t_v2",
        name: "b2Mul_t_v2",
        def: b2Mul_t_v2
      }, {
        trimmed: "Min_v2",
        name: "b2Min_v2",
        def: b2Min_v2
      }, {
        trimmed: "Max_v2",
        name: "b2Max_v2",
        def: b2Max_v2
      }, {
        trimmed: "Clamp",
        name: "b2Clamp",
        def: b2Clamp
      }, {
        trimmed: "MulT_t_v2",
        name: "b2MulT_t_v2",
        def: b2MulT_t_v2
      }, {
        trimmed: "Mul_t_t",
        name: "b2Mul_t_t",
        def: b2Mul_t_t
      }, {
        trimmed: "MulT_t_t",
        name: "b2MulT_t_t",
        def: b2MulT_t_t
      }, {
        trimmed: "Clamp_v2",
        name: "b2Clamp_v2",
        def: b2Clamp_v2
      }, {
        trimmed: "NextPowerOfTwo",
        name: "b2NextPowerOfTwo",
        def: b2NextPowerOfTwo
      }, {
        trimmed: "Abs_v2",
        name: "b2Abs_v2",
        def: b2Abs_v2
      }, {
        trimmed: "Abs_m22",
        name: "b2Abs_m22",
        def: b2Abs_m22
      }, {
        trimmed: "IsPowerOfTwo",
        name: "b2IsPowerOfTwo",
        def: b2IsPowerOfTwo
      }, {
        trimmed: "RandomFloat",
        name: "b2RandomFloat",
        def: b2RandomFloat
      }, {
        trimmed: "Timer",
        name: "b2Timer",
        def: b2Timer
      }, {
        trimmed: "Color",
        name: "b2Color",
        def: b2Color
      }, {
        trimmed: "Draw",
        name: "b2Draw",
        def: b2Draw
      }, {
        trimmed: "ContactID",
        name: "b2ContactID",
        def: b2ContactID
      }, {
        trimmed: "ManifoldPoint",
        name: "b2ManifoldPoint",
        def: b2ManifoldPoint
      }, {
        trimmed: "Manifold",
        name: "b2Manifold",
        def: b2Manifold
      }, {
        trimmed: "WorldManifold",
        name: "b2WorldManifold",
        def: b2WorldManifold
      }, {
        trimmed: "GetPointStates",
        name: "b2GetPointStates",
        def: b2GetPointStates
      }, {
        trimmed: "ClipVertex",
        name: "b2ClipVertex",
        def: b2ClipVertex
      }, {
        trimmed: "RayCastInput",
        name: "b2RayCastInput",
        def: b2RayCastInput
      }, {
        trimmed: "RayCastOutput",
        name: "b2RayCastOutput",
        def: b2RayCastOutput
      }, {
        trimmed: "AABB",
        name: "b2AABB",
        def: b2AABB
      }, {
        trimmed: "CollideCircles",
        name: "b2CollideCircles",
        def: b2CollideCircles
      }, {
        trimmed: "CollidePolygonAndCircle",
        name: "b2CollidePolygonAndCircle",
        def: b2CollidePolygonAndCircle
      }, {
        trimmed: "FindMaxSeparation",
        name: "b2FindMaxSeparation",
        def: b2FindMaxSeparation
      }, {
        trimmed: "FindIncidentEdge",
        name: "b2FindIncidentEdge",
        def: b2FindIncidentEdge
      }, {
        trimmed: "CollidePolygons",
        name: "b2CollidePolygons",
        def: b2CollidePolygons
      }, {
        trimmed: "CollideEdgeAndCircle",
        name: "b2CollideEdgeAndCircle",
        def: b2CollideEdgeAndCircle
      }, {
        trimmed: "EPAxis",
        name: "b2EPAxis",
        def: b2EPAxis
      }, {
        trimmed: "TempPolygon",
        name: "b2TempPolygon",
        def: b2TempPolygon
      }, {
        trimmed: "ReferenceFace",
        name: "b2ReferenceFace",
        def: b2ReferenceFace
      }, {
        trimmed: "EPCollider",
        name: "b2EPCollider",
        def: b2EPCollider
      }, {
        trimmed: "CollideEdgeAndPolygon",
        name: "b2CollideEdgeAndPolygon",
        def: b2CollideEdgeAndPolygon
      }, {
        trimmed: "ClipSegmentToLine",
        name: "b2ClipSegmentToLine",
        def: b2ClipSegmentToLine
      }, {
        trimmed: "TestShapeOverlap",
        name: "b2TestShapeOverlap",
        def: b2TestShapeOverlap
      }, {
        trimmed: "TestOverlap",
        name: "b2TestOverlap",
        def: b2TestOverlap
      }, {
        trimmed: "Shape",
        name: "b2Shape",
        def: b2Shape
      }, {
        trimmed: "CircleShape",
        name: "b2CircleShape",
        def: b2CircleShape
      }, {
        trimmed: "EdgeShape",
        name: "b2EdgeShape",
        def: b2EdgeShape
      }, {
        trimmed: "ChainShape",
        name: "b2ChainShape",
        def: b2ChainShape
      }, {
        trimmed: "PolygonShape",
        name: "b2PolygonShape",
        def: b2PolygonShape
      }, {
        trimmed: "Pair",
        name: "b2Pair",
        def: b2Pair
      }, {
        trimmed: "PairLessThan",
        name: "b2PairLessThan",
        def: b2PairLessThan
      }, {
        trimmed: "BroadPhase",
        name: "b2BroadPhase",
        def: b2BroadPhase
      }, {
        trimmed: "DistanceProxy",
        name: "b2DistanceProxy",
        def: b2DistanceProxy
      }, {
        trimmed: "SimplexCache",
        name: "b2SimplexCache",
        def: b2SimplexCache
      }, {
        trimmed: "DistanceInput",
        name: "b2DistanceInput",
        def: b2DistanceInput
      }, {
        trimmed: "DistanceOutput",
        name: "b2DistanceOutput",
        def: b2DistanceOutput
      }, {
        trimmed: "SimplexVertex",
        name: "b2SimplexVertex",
        def: b2SimplexVertex
      }, {
        trimmed: "Simplex",
        name: "b2Simplex",
        def: b2Simplex
      }, {
        trimmed: "DistanceFunc",
        name: "b2DistanceFunc",
        def: b2DistanceFunc
      }, {
        trimmed: "TreeNode",
        name: "b2TreeNode",
        def: b2TreeNode
      }, {
        trimmed: "DynamicTree",
        name: "b2DynamicTree",
        def: b2DynamicTree
      }, {
        trimmed: "TOIInput",
        name: "b2TOIInput",
        def: b2TOIInput
      }, {
        trimmed: "TOIOutput",
        name: "b2TOIOutput",
        def: b2TOIOutput
      }, {
        trimmed: "SeparationFunction",
        name: "b2SeparationFunction",
        def: b2SeparationFunction
      }, {
        trimmed: "TimeOfImpact",
        name: "b2TimeOfImpact",
        def: b2TimeOfImpact
      }, {
        trimmed: "BodyDef",
        name: "b2BodyDef",
        def: b2BodyDef
      }, {
        trimmed: "Body",
        name: "b2Body",
        def: b2Body
      }, {
        trimmed: "Filter",
        name: "b2Filter",
        def: b2Filter
      }, {
        trimmed: "FixtureDef",
        name: "b2FixtureDef",
        def: b2FixtureDef
      }, {
        trimmed: "Fixture",
        name: "b2Fixture",
        def: b2Fixture
      }, {
        trimmed: "DestructionListener",
        name: "b2DestructionListener",
        def: b2DestructionListener
      }, {
        trimmed: "ContactFilter",
        name: "b2ContactFilter",
        def: b2ContactFilter
      }, {
        trimmed: "ContactImpulse",
        name: "b2ContactImpulse",
        def: b2ContactImpulse
      }, {
        trimmed: "ContactListener",
        name: "b2ContactListener",
        def: b2ContactListener
      }, {
        trimmed: "QueryCallback",
        name: "b2QueryCallback",
        def: b2QueryCallback
      }, {
        trimmed: "RayCastCallback",
        name: "b2RayCastCallback",
        def: b2RayCastCallback
      }, {
        trimmed: "TimeStep",
        name: "b2TimeStep",
        def: b2TimeStep
      }, {
        trimmed: "Position",
        name: "b2Position",
        def: b2Position
      }, {
        trimmed: "Velocity",
        name: "b2Velocity",
        def: b2Velocity
      }, {
        trimmed: "SolverData",
        name: "b2SolverData",
        def: b2SolverData
      }, {
        trimmed: "World",
        name: "b2World",
        def: b2World
      }, {
        trimmed: "MixFriction",
        name: "b2MixFriction",
        def: b2MixFriction
      }, {
        trimmed: "MixRestitution",
        name: "b2MixRestitution",
        def: b2MixRestitution
      }, {
        trimmed: "ContactRegister",
        name: "b2ContactRegister",
        def: b2ContactRegister
      }, {
        trimmed: "ContactEdge",
        name: "b2ContactEdge",
        def: b2ContactEdge
      }, {
        trimmed: "Contact",
        name: "b2Contact",
        def: b2Contact
      }, {
        trimmed: "CircleContact",
        name: "b2CircleContact",
        def: b2CircleContact
      }, {
        trimmed: "PolygonContact",
        name: "b2PolygonContact",
        def: b2PolygonContact
      }, {
        trimmed: "ChainAndCircleContact",
        name: "b2ChainAndCircleContact",
        def: b2ChainAndCircleContact
      }, {
        trimmed: "ChainAndPolygonContact",
        name: "b2ChainAndPolygonContact",
        def: b2ChainAndPolygonContact
      }, {
        trimmed: "EdgeAndCircleContact",
        name: "b2EdgeAndCircleContact",
        def: b2EdgeAndCircleContact
      }, {
        trimmed: "EdgeAndPolygonContact",
        name: "b2EdgeAndPolygonContact",
        def: b2EdgeAndPolygonContact
      }, {
        trimmed: "PolygonAndCircleContact",
        name: "b2PolygonAndCircleContact",
        def: b2PolygonAndCircleContact
      }, {
        trimmed: "defaultFilter",
        name: "b2_defaultFilter",
        def: b2_defaultFilter
      }, {
        trimmed: "defaultListener",
        name: "b2_defaultListener",
        def: b2_defaultListener
      }, {
        trimmed: "ContactManager",
        name: "b2ContactManager",
        def: b2ContactManager
      }, {
        trimmed: "VelocityConstraintPoint",
        name: "b2VelocityConstraintPoint",
        def: b2VelocityConstraintPoint
      }, {
        trimmed: "ContactPositionConstraint",
        name: "b2ContactPositionConstraint",
        def: b2ContactPositionConstraint
      }, {
        trimmed: "ContactVelocityConstraint",
        name: "b2ContactVelocityConstraint",
        def: b2ContactVelocityConstraint
      }, {
        trimmed: "PositionSolverManifold",
        name: "b2PositionSolverManifold",
        def: b2PositionSolverManifold
      }, {
        trimmed: "ContactSolverDef",
        name: "b2ContactSolverDef",
        def: b2ContactSolverDef
      }, {
        trimmed: "ContactSolver",
        name: "b2ContactSolver",
        def: b2ContactSolver
      }, {
        trimmed: "Island",
        name: "b2Island",
        def: b2Island
      }, {
        trimmed: "Jacobian",
        name: "b2Jacobian",
        def: b2Jacobian
      }, {
        trimmed: "JointEdge",
        name: "b2JointEdge",
        def: b2JointEdge
      }, {
        trimmed: "JointDef",
        name: "b2JointDef",
        def: b2JointDef
      }, {
        trimmed: "Joint",
        name: "b2Joint",
        def: b2Joint
      }, {
        trimmed: "RevoluteJointDef",
        name: "b2RevoluteJointDef",
        def: b2RevoluteJointDef
      }, {
        trimmed: "RevoluteJoint",
        name: "b2RevoluteJoint",
        def: b2RevoluteJoint
      }, {
        trimmed: "MouseJointDef",
        name: "b2MouseJointDef",
        def: b2MouseJointDef
      }, {
        trimmed: "MouseJoint",
        name: "b2MouseJoint",
        def: b2MouseJoint
      }, {
        trimmed: "DistanceJointDef",
        name: "b2DistanceJointDef",
        def: b2DistanceJointDef
      }, {
        trimmed: "DistanceJoint",
        name: "b2DistanceJoint",
        def: b2DistanceJoint
      }, {
        trimmed: "PrismaticJointDef",
        name: "b2PrismaticJointDef",
        def: b2PrismaticJointDef
      }, {
        trimmed: "PrismaticJoint",
        name: "b2PrismaticJoint",
        def: b2PrismaticJoint
      }, {
        trimmed: "FrictionJointDef",
        name: "b2FrictionJointDef",
        def: b2FrictionJointDef
      }, {
        trimmed: "FrictionJoint",
        name: "b2FrictionJoint",
        def: b2FrictionJoint
      }, {
        trimmed: "WeldJointDef",
        name: "b2WeldJointDef",
        def: b2WeldJointDef
      }, {
        trimmed: "WeldJoint",
        name: "b2WeldJoint",
        def: b2WeldJoint
      }, {
        trimmed: "WheelJointDef",
        name: "b2WheelJointDef",
        def: b2WheelJointDef
      }, {
        trimmed: "WheelJoint",
        name: "b2WheelJoint",
        def: b2WheelJoint
      }, {
        trimmed: "GearJointDef",
        name: "b2GearJointDef",
        def: b2GearJointDef
      }, {
        trimmed: "GearJoint",
        name: "b2GearJoint",
        def: b2GearJoint
      }, {
        trimmed: "MotorJointDef",
        name: "b2MotorJointDef",
        def: b2MotorJointDef
      }, {
        trimmed: "MotorJoint",
        name: "b2MotorJoint",
        def: b2MotorJoint
      }, {
        trimmed: "PulleyJointDef",
        name: "b2PulleyJointDef",
        def: b2PulleyJointDef
      }, {
        trimmed: "PulleyJoint",
        name: "b2PulleyJoint",
        def: b2PulleyJoint
      }, {
        trimmed: "RopeJointDef",
        name: "b2RopeJointDef",
        def: b2RopeJointDef
      }, {
        trimmed: "RopeJoint",
        name: "b2RopeJoint",
        def: b2RopeJoint
      }, {
        trimmed: "RopeDef",
        name: "b2RopeDef",
        def: b2RopeDef
      }, {
        trimmed: "Rope",
        name: "b2Rope",
        def: b2Rope
      }, {
        trimmed: "maxManifoldPoints",
        name: "b2_maxManifoldPoints",
        def: b2_maxManifoldPoints
      }, {
        trimmed: "maxPolygonVertices",
        name: "b2_maxPolygonVertices",
        def: b2_maxPolygonVertices
      }, {
        trimmed: "aabbExtension",
        name: "b2_aabbExtension",
        def: b2_aabbExtension
      }, {
        trimmed: "aabbMultiplier",
        name: "b2_aabbMultiplier",
        def: b2_aabbMultiplier
      }, {
        trimmed: "linearSlop",
        name: "b2_linearSlop",
        def: b2_linearSlop
      }, {
        trimmed: "angularSlop",
        name: "b2_angularSlop",
        def: b2_angularSlop
      }, {
        trimmed: "polygonRadius",
        name: "b2_polygonRadius",
        def: b2_polygonRadius
      }, {
        trimmed: "maxSubSteps",
        name: "b2_maxSubSteps",
        def: b2_maxSubSteps
      }, {
        trimmed: "maxTOIContacts",
        name: "b2_maxTOIContacts",
        def: b2_maxTOIContacts
      }, {
        trimmed: "velocityThreshold",
        name: "b2_velocityThreshold",
        def: b2_velocityThreshold
      }, {
        trimmed: "maxLinearCorrection",
        name: "b2_maxLinearCorrection",
        def: b2_maxLinearCorrection
      }, {
        trimmed: "maxAngularCorrection",
        name: "b2_maxAngularCorrection",
        def: b2_maxAngularCorrection
      }, {
        trimmed: "maxTranslation",
        name: "b2_maxTranslation",
        def: b2_maxTranslation
      }, {
        trimmed: "maxTranslationSquared",
        name: "b2_maxTranslationSquared",
        def: b2_maxTranslationSquared
      }, {
        trimmed: "maxRotation",
        name: "b2_maxRotation",
        def: b2_maxRotation
      }, {
        trimmed: "maxRotationSquared",
        name: "b2_maxRotationSquared",
        def: b2_maxRotationSquared
      }, {
        trimmed: "baumgarte",
        name: "b2_baumgarte",
        def: b2_baumgarte
      }, {
        trimmed: "toiBaugarte",
        name: "b2_toiBaugarte",
        def: b2_toiBaugarte
      }, {
        trimmed: "timeToSleep",
        name: "b2_timeToSleep",
        def: b2_timeToSleep
      }, {
        trimmed: "linearSleepTolerance",
        name: "b2_linearSleepTolerance",
        def: b2_linearSleepTolerance
      }, {
        trimmed: "angularSleepTolerance",
        name: "b2_angularSleepTolerance",
        def: b2_angularSleepTolerance
      }, {
        trimmed: "epsilon",
        name: "b2_epsilon",
        def: b2_epsilon
      }, {
        trimmed: "JsonSerializer",
        name: "b2JsonSerializer",
        def: b2JsonSerializer
      }, {
        trimmed: "RUBELoader",
        name: "b2RUBELoader",
        def: b2RUBELoader
      }, {
        trimmed: "Profiler",
        name: "b2Profiler",
        def: b2Profiler
      } ];
      if ("undefined" !== typeof b2_compatibility && "undefined" !== typeof window) for (var i = 0; i < mappings.length; ++i) window[mappings[i].name] = mappings[i].def; else {
        var b2 = {};
        for (var i = 0; i < mappings.length; ++i) b2[mappings[i].trimmed] = mappings[i].def;
        "undefined" !== typeof module ? module.exports = b2 : window["b2"] = b2;
      }
    })();
  }), {} ],
  291: [ (function(require, module, exports) {
    var _global = "undefined" === typeof window ? global : window;
    cc = _global.cc || {};
    _cc = _global._cc || {};
    require("./predefine");
    require("./CCDebugger");
    require("./polyfill/string");
    require("./polyfill/misc");
    require("./polyfill/array");
    true;
    require("./polyfill/typescript");
    require("./cocos2d/core/predefine");
    true;
    require("./CCBoot");
    require("./cocos2d");
    require("./extends");
    false;
    false;
    module.exports = cc;
  }), {
    "./CCBoot": 1,
    "./CCDebugger": 2,
    "./cocos2d": 251,
    "./cocos2d/core/predefine": 180,
    "./extends": 271,
    "./jsb/jsb-loader.js": 292,
    "./package": void 0,
    "./polyfill/array": 293,
    "./polyfill/misc": 294,
    "./polyfill/string": 295,
    "./polyfill/typescript": 296,
    "./predefine": 297
  } ],
  292: [ (function(require, module, exports) {
    "use strict";
    require("../cocos2d/core/load-pipeline");
    function empty(item, callback) {
      return null;
    }
    function downloadScript(item, callback) {
      require(item.url);
      return null;
    }
    function downloadAudio(item, callback) {
      var loadByDeserializedAsset = item._owner instanceof cc.AudioClip;
      if (loadByDeserializedAsset) return item.url;
      var audioClip = new cc.AudioClip();
      audioClip._setRawAsset(item.rawUrl, false);
      audioClip._nativeAsset = item.url;
      return audioClip;
    }
    function downloadImage(item, callback) {
      var img = new Image();
      img.src = item.url;
      img.onload = function(info) {
        callback(null, img);
      };
    }
    cc.loader.addDownloadHandlers({
      js: downloadScript,
      jsc: downloadScript,
      png: downloadImage,
      jpg: downloadImage,
      bmp: downloadImage,
      jpeg: downloadImage,
      gif: downloadImage,
      ico: downloadImage,
      tiff: downloadImage,
      webp: downloadImage,
      image: downloadImage,
      mp3: downloadAudio,
      ogg: downloadAudio,
      wav: downloadAudio,
      mp4: downloadAudio,
      m4a: downloadAudio,
      font: empty,
      eot: empty,
      ttf: empty,
      woff: empty,
      svg: empty,
      ttc: empty
    });
  }), {
    "../cocos2d/core/load-pipeline": 116
  } ],
  293: [ (function(require, module, exports) {
    Array.isArray || (Array.isArray = function(arg) {
      return "[object Array]" === Object.prototype.toString.call(arg);
    });
  }), {} ],
  294: [ (function(require, module, exports) {
    Math.sign || (Math.sign = function(x) {
      x = +x;
      if (0 === x || isNaN(x)) return x;
      return x > 0 ? 1 : -1;
    });
    Number.isInteger || (Number.isInteger = function(value) {
      return "number" === typeof value && isFinite(value) && Math.floor(value) === value;
    });
    if (false, !console.time) {
      var Timer = window.performance || Date;
      var _timerTable = Object.create(null);
      console.time = function(label) {
        _timerTable[label] = Timer.now();
      };
      console.timeEnd = function(label) {
        var startTime = _timerTable[label];
        var duration = Timer.now() - startTime;
        console.log(label + ": " + duration + "ms");
      };
    }
  }), {} ],
  295: [ (function(require, module, exports) {
    String.prototype.startsWith || (String.prototype.startsWith = function(searchString, position) {
      position = position || 0;
      return this.lastIndexOf(searchString, position) === position;
    });
    String.prototype.endsWith || (String.prototype.endsWith = function(searchString, position) {
      ("undefined" === typeof position || position > this.length) && (position = this.length);
      position -= searchString.length;
      var lastIndex = this.indexOf(searchString, position);
      return -1 !== lastIndex && lastIndex === position;
    });
  }), {} ],
  296: [ (function(require, module, exports) {
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
    };
    window.__extends = function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    window.__assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
      }
      return t;
    };
    window.__rest = function(s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" === typeof Object.getOwnPropertySymbols) for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && (t[p[i]] = s[p[i]]);
      return t;
    };
    window.__decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    window.__param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    window.__metadata = function(metadataKey, metadataValue) {
      if ("object" === typeof Reflect && "function" === typeof Reflect.metadata) return Reflect.metadata(metadataKey, metadataValue);
    };
    window.__awaiter = function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : new P(function(resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    window.__generator = function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = y[2 & op[0] ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 0, t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    window.__exportStar = function(m, exports) {
      for (var p in m) exports.hasOwnProperty(p) || (exports[p] = m[p]);
    };
    window.__values = function(o) {
      var m = "function" === typeof Symbol && o[Symbol.iterator], i = 0;
      if (m) return m.call(o);
      return {
        next: function() {
          o && i >= o.length && (o = void 0);
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
    };
    window.__read = function(o, n) {
      var m = "function" === typeof Symbol && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((void 0 === n || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          r && !r.done && (m = i["return"]) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    window.__spread = function() {
      for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    window.__await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    window.__asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        g[n] && (i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([ n, v, a, b ]) > 1 || resume(n, v);
          });
        });
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        (f(v), q.shift(), q.length) && resume(q[0][0], q[0][1]);
      }
    };
    window.__asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", (function(e) {
        throw e;
      })), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        o[n] && (i[n] = function(v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: "return" === n
          } : f ? f(v) : v;
        });
      }
    };
    window.__asyncValues = function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator];
      return m ? m.call(o) : "function" === typeof __values ? __values(o) : o[Symbol.iterator]();
    };
  }), {} ],
  297: [ (function(require, module, exports) {
    var _global = "undefined" === typeof window ? global : window;
    function defineMacro(name, defaultValue) {
      "undefined" === typeof _global[name] && (_global[name] = defaultValue);
    }
    function defined(name) {
      return "object" === typeof _global[name];
    }
    defineMacro("CC_TEST", defined("tap") || defined("QUnit"));
    defineMacro("CC_EDITOR", defined("Editor") && defined("process") && "electron" in process.versions);
    defineMacro("CC_PREVIEW", true);
    defineMacro("CC_DEV", true);
    defineMacro("CC_DEBUG", true);
    defineMacro("CC_JSB", defined("jsb"));
    defineMacro("CC_BUILD", false);
    defineMacro("CC_WECHATGAME", defined("wx") && wx.getSystemInfoSync);
    defineMacro("CC_QQPLAY", defined("bk"));
    false;
    defineMacro("CC_SUPPORT_JIT", !(false, false));
    false;
    var engineVersion = "2.0.0-preview.4";
    _global["CocosEngine"] = cc.ENGINE_VERSION = engineVersion;
  }), {} ]
}, {}, [ 291 ]);
//# sourceMappingURL=cocos2d-js.js.8c9a8.map